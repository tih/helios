#                      Template.con
#
# This file was last updated on $Date: 1993/09/29 14:04:38 $
#
# This file is a template for producing host.con files for use with
# Helios-C40.  Under normal circumstances the board specific versions
# of the host.con file should be used, rather than this file.  You
# should only use this file if:
#
#   a. You do not have a board specific version of the host.con file.
#   b. Your board specific version does not work, and you cannot fix it.
#   c. You want to customise the behaviour of Helios beyond the scope
#      of the board specific host.con files.
#
# This file attempts to describe all of the options available in a
# host.con file.  Some options apply to all C40 boards, some are
# specific to a single board or group of boards.  All options come in
# one of two forms.  They consist either of a word on its own, or a word
# followed by a equals sign, followed by a value.  A word on its own
# enables a feature, but if the word is missing or commented out
# then the feature is disabled.
# 
# Comments start with a hash character ( # ) and extend to the end of
# the line.  Comments are ignored by the parser.  Comments may contain
# the hash character inside of themselves.  If a comment does not
# start at the beginning of a line then the text from the beginning of
# the line up to (but not including) the hash character is parsed by
# the I/O server.  Options inside a comment are ignored.  You are
# currently reading a comment.  
#
# Option names are a sequence of alphabetic and underscore ( _ )
# characters.  They do not contain white space.  When the I/O server
# is searching for an option in the host.con file it performs a case
# insensitive search.  If an option occurs more than once in the
# host.con file then the first occurrence of the option will be used. 
# The following are all the same option:
#
#     hello_world
#     Hello_World
#     HELLO_WORLD
#     hElLo_woRLD
#
# If an option takes a value then it must be followed by an equals
# sign and then the value.  There can be white space between the option
# name and the equals sign and between the equals sign and the value,
# but this not compulsory.  The following are all the same:
#
#     the_answer = 42
#     The_Answer= 42
#     the_Answer     	=	42
#     thE_answeR	=42
#
# All non-C40 specific options are described in the book: "The Helios
# Parallel Operating System" in chapter 8.  The comments below are
# intended as a guide, but for definitive explanations consult this
# book.   The I/O server has built in default values for all options,
# so that if an option is not specified in the host.con file, the
# default value will be used.
#


#                 Compulsory Options
#
# The following options must always be found in a host.con file
#

target_processor = C40

# The target_processor defines the type of processor that the I/O
# server will attempt to boot.  Normally this will be a TMS320C40, but
# if you have purchased the Helios operating system for another
# processor, (for example the Transputer), then you might want to
# change this value. 
#

host = AT

# The host defines the type of machine upon which the I/O server is
# running.  Typically this option will have a value of AT for MS-DOS
# based host machines and SUN or i486V4 for UNIX based hosts.
#

box = TIM40

# The box option defines the C40 hardware that the I/O server will
# attempt to boot.  This option is being slowly extended as the number
# of C40 boards supported by Helios is increased.  Currently the
# following boards are supported:
#
# TIM40       For most C40 TIM-40 standard boards.  Including the
#             HEPC2 and TDMB409 using the their slow, byte wide port
#             interfaces. 
#
# HEPC2       The Hunt Engineering HEPC2 board, using its high
#             performance FIFO interface.  For this board you must
#             also set the hepc2_fifo_base option.
#
# TDB416      The Transtech / A. G. Electronics TDB416 board.
#
# DSP1        The Hema DSP1 board.  You will also need to change the
#             bootfile, c40_disable_halfduplex, and c40_pseudo_idrom
#             options, and create an idrom configuration. 
#
# TDMB409     The Transtech TDMB409 board.  Very similar to the HEPC2
#             board,  You will also need to set the tdmb40x_fifo_base
#             option. 
#
# QPCV1       The LSI QPC/C40 board, first revision.
# QPCV2       The LSI QPC/C40 board, second revision.
#	      You should also set the qpc_slabase, qpc_module and
#             bootlink options. 
#
# megalinkc40 The SANG MEGA-Link C40 board.  You must also set the
#             bootlink option.
#
# B008        The Transtech TTM60 C40 Tram fitted to a B008 board.
#
# SPIRIT40    The Sonitech Spirit40 board.  You will also need to
#             change the bootfile, c40_disable_cache, c40_use_pseudo_idrom,
#             c40_disable_halfduplex, bootlink, shared memory and
#             system_image options, and you will have to create an
#             idrom configuration. 
# 
# VC40        The Ariel VC40 board.  You will also need to change the
#             bootfile, system_image, bootlink, shared memory, and
#             c40_disable_halfduplex options, and you will have to
#             create an idrom configuration.
# 
# HEV40       The Hunt Engineering VME board.
#
# HESB40      The Hunt Engineering SBUS board.
#
# remote      This is a special value indicating that the I/O server
#             is connecting to a C40 board on another computer via the
#             help of the hydra program.  If this option is specified
#             then the 'family_name', 'socket_name' and 'hydra_host'
#             options should be specified as well.  [UNIX only].
#

helios_directory = \helios

# The helios_directory option tells the I/O server where the root of
# the Helios directory tree is located on the host's file system.  The
# directory specified here will appear as /helios to users of the Helios
# operating system.  (This option makes it is possible to run the I/O
# server from a directory other than the directory where Helios has
# been installed.)  The pathname specified by this option must be
# understandable to the host's operating system.  So for example under
# MS-DOS this option could take values such as:
#
#    helios_directory = d:\helios\c40
#    helios_directory = y:\helios.new
#
# whereas under UNIX this option could take values such as:
#
#    helios_directory = /usr/helios
#    helios_directory = /usr/local/os/Helios
#

system_image = ~\lib\nucleus

# The system_image option specifies where the Helios nucleus is
# located.  The Helios nucleus is normally located in the lib
# directory of the Helios directory tree, (although occasionally for
# debugging purposes it can be located elsewhere).  A tilde character
# ( ~ ) at the start of the pathname is replaced by the value for the
# helios_directory option.  The following options are the same:
#
#    helios_directory = c:\helios
#
#    system_image = ~\lib\nucleus
#    system_image = c:\helios\lib\nucleus
#
# This option should normally only be changed if you are using a C40
# board which has a shared memory interface to the host computer, rather
# than a link based interface.  In such circumstances the following
# variations should be used:
#
#    helios_directory = ~\lib\nucleus.sml    # for the Sonitech Spirit40
#    helios_directory = ~/lib/nucleus.sml    # for the Ariel VC40 
#

bootfile = ~\lib\c40boot.i

# The bootfile option specifies the name of the file containing the
# code necessary to boot the C40.  This option is very similar to the
# system_image option above.  Normally this option only needs to be
# changed if the C40 board being booted has a special start up sequence.
# In such circumstances the following variations should be used:
#
#    bootfile = ~\lib\c40hboot.i	# for the Hema DSP1
#    bootfile = ~\lib\c40sboot.i	# for the Sonitech Spirit40
#    bootfile = ~/lib/c40aboot.i	# for the Ariel VC40
#


#                 Supplementary Options
#
# The following options can be changed if necessary, although the
# values set here are usually correct.
#

Server_windows

# The server_windows option enables the I/O server's windowing system.
# This is a text based windowing system, not a graphical one.  It
# allows programs to have their own text "window" that looks just like
# an ordinary ANSI terminal.  Users can switch between these windows
# using the "hot keys" (ALT-F1 and ALT-F2 under MS-DOS).  The windows do
# not overlap.  Under MS-DOS there can only only be one window on
# the screen at any one time, and the hot key switches between
# displaying each of these windows.  Under UNIX the same applies
# unless the user has SunView available, in which case each window is
# implemented as a SunView terminal widget.  The only reason for not
# enabling this option is if the user wants to run their own window
# server which is normally only the case if the C40 is capable of
# running its own graphical windowing system.  
#

# server_windows_nopop

# The server_windows_nopop option specifies what should happen when a
# debugging message is received by the I/O server.  (Debugging messages
# are generated by the Helios nucleus, or by programs using the
# IOdebug() function.)  The I/O server maintains a special window in its
# windowing system for these debugging messages.  If the
# server_windows_nopop option is DISABLED, and if debugging messages
# are going to be written to this window, (see the logging_destination
# option below) then the I/O server will automatically switch to
# displaying this window whenever a debugging message is generated.
# If the option is ENABLED, then the debugging messages will still be
# written to the debugging window, (assuming the logging_destination
# option allows them to), but the window will remain where it is and
# will not be automatically displayed on the screen.  This option only
# applies to the MSDOS based version of the I/O server.  The WINDOWS
# based version does not use it, because there multiple windows can
# overlap each other.
#

logging_destination = screen

# The logging_destination option tells the I/O server where debugging
# messages should be sent.  (These messages can be generated by the
# nucleus, or by calls to the IOdebug() function).  There are two
# possible destinations for the debugging messages; the I/O server's
# debugging window, and the I/O server's log file, (see the logfile
# option below).  This option can take one of three possible values:
#
#     screen		# send debugging messages to debugging window only
#     file		# send debugging messages to the log file only
#     both		# send debugging messages to both the log file
#                       # and the debugging window
#

logfile = logbook

# The logfile option specifies the name of the file created by the I/O
# server when it is told to direct debugging messages to a file, (see
# the logging_destination option above).  Helios users can access this
# service by the name /logger.  The default name for the file is
# logbook. 
#

# root_processor = /00

# The root_processor option specifies the name of the C40 booted by
# the I/O server.  This name is important if the Helios networking
# software is going to be used, as the name of the booted processor,
# (known as the root processor), must be specified in the resource map
# used to initialise the networking software.  By default the I/O server
# calls the root processor /00.
#

# io_processor = /IO

# The io_processor option specifies the name of the host computer
# running the I/O server, as seen by programs running under Helios.
# This name is important if the Helios networking software is going to
# be used, as the name of the host computer (known as the IO
# processor), must be specified in the resource map used to initialise
# the networking software.  By default the I/O server calls the IO
# processor /IO. 
#

# no_helios

# The no_helios option is used to prevent the I/O server from creating 
# a /helios service.  All Helios networks must have exactly one
# /helios service, so if the I/O server is going to connect to an  
# already running Helios network, then no /helios service is needed.
#

# enable_link

# The enable_link option tells the I/O server that it should not
# attempt to boot the C40 that is attached to the host computer, rather
# it should just enable the link connection between the two processors,
# and then behave as if the C40 had already been booted.  This option is
# used to connect the I/O server into an already running Helios network.
#

# Xsupport

# The Xsupport option enables the /mouse and /keyboard services of the
# I/O server.  These services are intended to support a graphical
# windowing system that needs access to raw keyboard and mouse events.
# This option is not implemented on UNIX based versions of the I/O
# server. 
#

# mouse_resolution = 1

# The mouse_resolution option specifies how far the PC mouse can move
# before the I/O server reports the movement to the /mouse service, (see
# the Xsupport option above).  Mouse movement is measured in terms of
# mickies, an abstract unit defined as "320 detectable events per inch".
# The exact value of a micky will depend upon the mouse and driver
# installed on the PC, although typically it will be at least one
# three-hundredth of an inch.  Movement in the X and Y directions are
# considered to be separate, so that if the mouse_resolution option is
# set at 4, then the mouse must move at least 4 mickies in either the X
# or Y directions (or both), before a message is sent to the /mouse
# service.  When the message is sent, it will include the distance moved
# in both the X and Y directions, even if one of them has had no
# movement at all.  Mickies are a signed quantity.  A positive X micky
# indicates a movement towards the right, a negative X micky indicates a
# movement towards the left.  A positive Y micky indicates a movement
# towards the bottom of the screen, a negative Y micky indicates a
# movement towards the top of the screen.  The mouse_resolution option,
# however, is an absolute quantity, so that if it were to have a value
# of 4, then a message would be sent if the mouse had moved in either
# the X or Y directions by plus or minus 4 mickies.  (If the mouse were
# to move by +3 mickies, then back to where it started, then to -3
# mickies, and then back to where it started, NO message would be sent).
# The default value is 1.
#

# mouse_divisor = 1

# The mouse_divisor option species by how much the mickies being
# reported to the /mouse server should be divided.  (See the Xsupport
# and mouse_resolution options above).  When an message is sent to the
# /mouse service it includes the distance moved by the mouse in the X
# and Y directions, in terms of mickies.  So for example, if the
# mouse_resolution option were set at 4, a message sent to the /mouse
# service might typically have the values +4 X mickies, -2 Y mickies.
# (It is quite possible for larger values to be reported as well.  If
# the mouse is moved very quickly, then the events reported can easily
# reach the tens or even hundreds of mickies.)  The mouse_divisor
# option, reduces the size of the movements reported to the /mouse
# service.  So, if for example the mouse_divisor option was set at 2,
# then the actual message, as described above, that would be sent to the
# /mouse service would be +2 X, -1 Y.  The values are rounded towards 0.
# The default value for this option is 1.
#

# StreamTimeout = 1800000

# The StreamTimeout option specifies the maximum duration of the
# timeouts, in microseconds, of the co-routines handling stream
# connections between the I/O server and the C40.  The default value 
# is 1800000 which is 30 minutes.
#

message_limit = 64000

# The message_limit option controls the maximum amount of data that
# can be placed in a single message to or from the I/O server.  This
# option is here in order to allow the I/O server to work on hosts
# where there is a shortage of memory, and hence the size of the
# buffer used by the I/O server to hold a message has to be reduced.
# For efficiency, however, this value should be as large as possible.
# The minimum value is 1000, the maximum value is 64000, the default
# value is 2000.
#


#		PC Specific Options
#
# The following options only apply to the I/O server running under
# MS-DOS on an IBM PC or clone.

# Unix_fileio

# The Unix_fileio option enables a special feature of the Helios C
# library that translates carriage-return line-feed pairs into just
# line-feeds.  This option only works on text files that are read and
# written using the C library routines fread() and fwrite().  If the
# option is ENABLED then any fread() calls that encounters the
# carriage-return line-feed pair will translate this to just a single
# line-feed character, any control-Z characters will be interpreted as
# end-of-file.   All calls to fwrite(), however will remain
# untranslated; (that is any write of a line-feed character will NOT be
# translated into a carriage-return line-feed pair).  If the option is
# DISABLED, then any calls to fread() will remain untranslated, whilst
# calls to fwrite() WILL translate line-feed characters into
# carriage-return line-feed pairs.
#
# This option is intended primarily for MS-DOS users who want to be
# able to transfer their text files to and from UNIX systems
# without having to worry about the differences between UNIX and MS-DOS
# text files.
#

# coroutine_stack = 1500

# The coroutine_stack option tells the I/O server how big the
# execution stacks for its co-routines should be, in bytes.  By default
# these routines have a stack size of 4096, but if the I/O server is
# running out of memory on the PC, then this option can be used to
# reduce the stack size, and hence save memory.

floppies = ab

# The floppies option tells the I/O server if either or both of a: and
# b: are actually present as floppy disk drives on the PC.  If a floppy
# disk drive is not present, then it should not be specified in this
# option.  For example if b: is not present as a floppy disk drive
# then this option should read :
#
#     floppies = a
#
# For each floppy disk drive specified by this option the I/O server
# will create a corresponding service under Helios.  For the a: drive
# this would be called /a, and for the b: drive the service would be
# called /b.  The other reason for using this option is to prevent the
# I/O server from creating a service, even though the floppy disk drive
# is present.  This is most useful in conjunction with the rawdisk_drive
# option below.
#

# rawdisk_drive = d

# The rawdisk_drive option tells the I/O server which disk drive
# (floppy or hard) can be used for the Helios filing system.  This
# system is quite different from the MS-DOS filing system, and so this
# option should only be used for a drive where no precious, MS-DOS
# formatted data is kept.
#

# ethernet

# The ethernet option is used to enable the I/O server's ethernet
# service.  This option allows programs under Helios to access an
# ethernet packet driver running on the PC.  This packet driver must
# understand the Clarkson conventions for ethernet packet drivers.  This
# option must be enabled if the Helios products Ethernet I or Network
# Services are going to be used.
#

no_clock

# The no_clock option disables the I/O server's clock service.  This
# service is used to access the PC's battery backed real time clock.
# If the service is disabled, then a small amount of memory is saved.
#

no_pc

# The no_pc option disables the I/O server's /pc service.  This
# service allows programs running under Helios to send messages to a
# TSR program that was run on the host computer before the I/O server 
# started.  The I/O server invokes the software interrupt 0x60, and
# uses this to pass messages between the Helios program and the TSR
# program.  Normally this service is not required, and so disabling it
# saves memory in the I/O server.
#

no_centronics

# The no_centronics option disables the I/O server's /centronics
# service.  This service, if enabled, allows Helios programs to access
# the centronics ports on the PC.  If the PC has no centronics ports
# then the service is disabled automatically.
#

# default_centronics = lpt2

# The default_centronics option specifies which of the centronics
# ports should be used as the default centronics port.  This option only
# applies if the centronics service is enabled in the I/O server, (see
# the no_centronics option above).  If it is enabled then the
# /centronics service will contain entries such as 'lpt1' and 'lpt2'
# as well as 'default', which is just a convenient alias for one of the
# other entries.
#

# rs232_ports = 1, 2, 4

# The rs232_ports option specifies which ports should appear in the
# /rs232 service provided by the I/O server.  If this option is disabled
# then the I/O server will not create a /rs232 service.  If it is
# enabled, then the option indicates which com ports on the PC have
# rs232 hardware support.
#

# default_rs232 = com2

# The default_rs232 option specifies which entry in the /rs232 service
# should be aliases to the default entry in that service.  The rs232
# service (enabled by the rs232_ports option above) will contain an
# entry for each rs232 port available, plus a default entry, which is
# just a convenient alias for one of the other ports.
#

# com3_base = 0x300

# The com3_base option tells the I/O server where the COM3: port is
# located in the PC's address map.  The I/O server assumes that COM1: is
# at 0x3f8 and COM2: is at 0x2f8, but it is unable to make any guesses
# about the location of any other com ports.  There is one option for
# each com port port 3 through 7 :
#
#     com3_base = 0x???
#     com4_base = 0x???
#     com5_base = 0x???
#     com6_base = 0x???
#     com7_base = 0x???
#

# rs232_interrupt = 1

# The rs232_interrupt option tells the I/O server which PC interrupts
# it should use for handling the com ports.  Normally the PC will take
# over both interrupts 0x0B and 0x0C.  If however this option is
# specified and it has the value 1 then the I/O server will only take
# over interrupt 0x0C (corresponding to COM1:), and if the option has
# the value 2 then the I/O server will only take over interrupt 0x0B
# (corresponding to COM2:).
#

# default_printer = lpt2

# The default_printer option specifies which port on the PC should be
# used as the default entry in the /printer service provided by the I/O
# server.  The service usually has several entries, such as lpt1 lpt2,
# com1, com2, as well as the default entry.  The default entry is just
# a convenient alias for one of the other entries.  The printer service
# consists of all the entries in the centronics service and all the
# entries in the rs232 service.
#

# no_t

# The SUN PC-NFS package creates a special directory called T: which
# does not work with the Helios I/O server.  In order to avoid problems
# when using SUN PC-NFS and Helios, the no_t option should be used.
#
# In fact this option can be extended to any drive on the PC.  So for
# excample if you do not want the I/O server to allow Helios to access
# the d: drive you can add the option:
# 
#    no_d
#
# In particular this can help with CD-ROM drives, which the I/O server
# does not cope with very well.
#


#                UNIX Specific Options
#
# The following options only apply to the UNIX versions of the I/O
# server.
#

# family_name = AF_UNIX

# The family_name specifies in which domain to create the socket that
# is going to be used to connect to the hydra program.  This option is
# only necessary if the box option (see above) has been set to remote.
# Possible values are AF_UNIX, (which creates a socket in the UNIX
# domain, and so the hydra program must be running on the same machine
# as the I/O server), or AF_INET, (which creates a socket in the
# internet domain, and so the hydra program can be running on any
# machine connected to the I/O server's machine via ethernet).  The
# default value is AF_UNIX.
#

# socket_name = hydra.skt

# The socket_name option specifies the name of the socket to be
# contacted.  This name must be the same as the name installed by the
# hydra program.  This option only applies if the family_name option
# (see above) is set to AF_UNIX.  The default value is hydra.dft.
# (If the family_name option is set to AF_INET, then the I/O server
# will attempt to contact a TCP service called "hydra").
#

# hydra_host =

# The hydra_host option is used to specify the name of the remote host 
# machine that is running the hydra program.  This option only applies
# if the family_name option (see above) has been set to # AF_INET).
# There is no default value for this option. 
#

# connection_retries = 5

# The connection_retries option is used to specify the number of times
# that the I/O server should attempt to contact the hydra program.  The
# default value is 5.  This option applies to both internet and UNIX
# domain connections to the hydra program.
#

# site = 0

# The site option specifies to which site on the C40 hardware the I/O
# server should attempt to connect.  Under UNIX it is possible to have
# multiple connections to C40 hardware; (this is not possible under
# MS-DOS, because it is a single-tasking operating system).  Hence if
# the C40 hardware has been designed to allow multiple connections, it
# may be necessary to specify which connection to use by running the I/O
# server.  One I/O server is run per connection to the C40.  If the site
# option is not specified then the I/O server will use the first free
# site that it can find.  Sites are numbered from 0.
#

# internet

# The internet option tells the I/O server that it should provide a
# /internet service which allows programs running under Helios (such as
# X or ftp) to access the ethernet hardware on the host computer.  This
# option is necessary if the Helios products Ethernet I and Networking
# Services are to be used.
#

# serverwindow = serverwinxv

# The serverwindow option tells the I/O server the name of the program
# to be run in order to provide a windowing service.  This option only
# applies if the server_windows option has been enabled (see above).
# Normally the I/O server is able to work out for itself which program
# to be run.
#

# escape_sequence = @\E[S

# The escape_sequence option tells the I/O server which key sequence
# is used to introduce a "hot key".  When the "hot key" is pressed the
# I/O server will interpret the next key to be pressed as special key
# indicating that the I/O server should perform some action.  These
# special keys can be one of the following :
#
#    1   -> switch to next window
#    2   -> switch to previous window
#    3   -> refresh current window
#    8   -> report I/O server status
#    9   -> terminate I/O server
#    0   -> reboot I/O server
#    a   -> toggle debugging option: ALL
#    b   -> toggle debugging option: BOOT
#    .
#    .
#    z   -> reconfigure I/O server from host.con file
#
# The string specified by the escape_sequence option can either be a
# termcap entry for the terminal type under which the I/O server is
# currently running, (for example k1 for function key 1), or it can be
# an exact sequence of key strokes.  In this case the string must be
# started by the at symbol (@).  Inside this string certain sequence of
# characters produce special effects :
#
#    \E   -> The escape character (0x1B)
#    ^A   -> Control A (0x01)
#    ^B   -> Control B (0x02)
#     .
#     .
#    ^Z   -> Control Z (0x1F)
#    \123 -> The octal number 0123 (hex 0x53)
#    \n   -> Line feed (0x0A)
#    \r   -> Carriage return (0x0D)
#    \t   -> Tab       (0x09)
#    \b   -> Backspace (0x08)
#    \f   -> Form feed (0x0C)
#    \\   -> Backslash (0x5C)
#    \^   -> Caret     (0x5E)
#

# switch_forwards_key = k1

# The switch_forwards_key option specifies a key sequence that
# performs the equivalent to "hot key" 1, (see the escape_sequence
# option above).  This option uses the same syntax as the
# escape_sequence option, and is intended to provide a fast, one key
# press method of activating the 'switch to next window' hot key
# feature. 
#

# switch_backwards_key = k2

# The switch_backwards_key option specifies a key sequence that
# performs the equivalent to "hot key" 2, (see the escape_sequence
# option above).  This option uses the same syntax as the
# escape_sequence option, and is intended to provide a fast, one key
# press method of activating the 'switch to previous window' hot key
# feature. 
#

# status_key = k8

# The status_key option specifies a key sequence that performs the
# equivalent to "hot key" 8, (see the escape_sequence option above).
# This option uses the same syntax as the escape_sequence option, and
# is intended to provide a fast, one key press method of activating
# the 'show I/O server status' hot key feature. 
#

# exit_key = k9

# The exit_key option specifies a key sequence that performs the
# equivalent to "hot key" 9, (see the escape_sequence option above).
# This option uses the same syntax as the escape_sequence option, and
# is intended to provide a fast, one key press method of activating
# the 'terminate I/O server' hot key feature. 
#

# reboot_key = k10

# The reboot_key option specifies a key sequence that performs the
# equivalent to "hot key" 0, (see the escape_sequence option above).
# This option uses the same syntax as the escape_sequence option, and
# is intended to provide a fast, one key press method of activating
# the 'reboot I/O server' hot key feature. 
#

# refresh_key = k3

# The refresh_key option specifies a key sequence that performs the
# equivalent to "hot key" 3, (see the escape_sequence option above).
# This option uses the same syntax as the escape_sequence option, and
# is intended to provide a fast, one key press method of activating
# the 'redisplay current window' hot key feature. 
#



#                C40 Specific Options
#
# The following options apply specifically to C40's, not to any other
# hardware.
#

# c40_disable_cache

# The c40_disable_cache option is used to disable the C40's
# instruction cache.  This option is necessary because there is a bug
# in all versions of the C40 silicon, up to and including TMS 2.3.
# (For later versions of the silicon check with TI).  This bug only
# manifests itself if the External Memory Ready pin on the C40 is
# being used, (normally only the case if shared memory is being used),
# and at least two out of the three possible address buses (global,
# local, internal) are being used.  Under these circumstances memory
# fetches can fail, causing Helios to crash.  This problem applies to
# the Sonitech Spirit40 and Ariel VC40 boards.
#

# c40_disable_halfduplex

# The c40_disable_halfduplex option is used to disable Helios' half
# duplex protocol on the links.  This option is only necessary if the
# I/O server communicates with the C40 via a single, real link.  For
# boards which used a shared memory interface, (such as the Sonitech
# Spirit40) or boards which use two links to communicate with the I/O
# server, (such as the Hema DSP1), this option should be uncommented,
# as this will increase the communication speed between the I/O server
# and the C40.
#

# c40_load_nucleus_local_s0

# The c40_load_nucleus_local_s0 is ONE of a set of FOUR options that
# specifies where the Helios nucleus should be placed in the C40's
# address map.  The C40 has two address buses, (local and global), each
# of which can control two separate banks of memory (strobes 0 and 1).
# (The C40 also has some on-chip memory, but you can ignore this -
# Helios will never load its nucleus into on-chip RAM).  This option
# specifies that the nucleus should be loaded into memory on the local
# bus, strobe 0.  The other three options are :
#
#     c40_load_nucleus_local_s1
#     c40_load_nucleus_global_s0
#     c40_load_nucleus_global_s1
#
# which respectively load the nucleus into memory on
#
#     local  bus, strobe 1
#     global bus, strobe 0
#     global bus, strobe 1
#
# In the absence of any of these options, Helios will try to load the
# nucleus into the memory on strobe 0 of the local bus.  The nucleus
# will always be placed into the bottom of the memory on whichever bus
# and strobe is specified, and the Helios code loader will then try to
# put programs (and libraries) into the same memory area, (at different
# addresses!)  At most ONE of these four options should be enabled, (if
# more than one is enabled, then the first one in the file will be
# used).  If memory exists on both the local and global bus, then Helios
# will always place data on the local bus, and so a large increase in
# performance can be gained by placing the code on the global bus.
#


#                  IDROM Options
#
# The TIM-40 specification defines a standard format ROM that contains
# data that characterises a C40 system.  Helios uses this to automatically
# configure itself to the target system.  If your C40 board doesn't implement
# an IDROM, don't despair, the I/O server can send a pseudo IDROM so that
# Helios can configure itself to the target system.  Alternatively if
# your C40 board does specify an IDROM, but you don't want to use it,
# you can override the contents.  Full details on the IDROM can be
# found in section 6 of the TIM-40 specification, available from Texas
# Instruments. 
#
 
# c40_use_pseudo_rom

# The c40_use_pseudo_idrom option tells the I/O server to create a
# fake IDROM image and send this to the Helios nucleus.  This option
# will only work if the C40 hardware does not have an IDROM on the
# board. 
#

# c40_replace_idrom

# The c40_replace_idrom option tells Helios to reset the config line
# and swap out the true IDROM.  Instead the I/O server constructs a fake
# IDROM image and sends it to the Helios nucleus.  This option will
# only work if the C40 hardware already has an IDROM.
#

# c40_idrom_cpu_id = 0

# The c40_idrom_cpu_id specifies the type of CPU.  A value of 0 (the
# default) indicates the CPU is a TMS320C40.  The full list of values
# is currently : 
#
#    0   -> TMS320C40   
#    1   -> TMS320C30
#    2   -> TMS320C31
#    3   -> TMS320C32
#    4   -> TMS34010
#    5   -> TMS34020
#
# (Note: Of the above list of processors, Helios will only work on the
# TMS320C40). 
#

# c40_idrom_cpu_clk = 49

# The c40_idrom_cpu_clk option specifies the clock speed of the CPU.
# If this option is not specified then a default value of 49 is used.
# The value can be any number between 1 and 256 although the following
# values are the most common :
#
#    39   -> 50 MHz
#    49   -> 40 MHz
#    59   -> 33 MHz
#

# c40_idrom_man_id = 0

# The c40_idrom_man_id option specifies the manufacturer's unique
# identifier.  This is a 16-bit value.  This value is not actually used
# by Helios.
#

# c40_idrom_model_no = 0

# The c40_idrom_model_no option sets the manufacturer's module number.
# This is a 16-bit value.  This value is not actually used by Helios.
#

# c40_idrom_rev_lvl = 0

# The c40_idrom_rev_lvl option sets the manufacturer's revision level.
# This is an 8-bit value.  This value is not actually used by Helios.
#

# c40_idrom_lbase0 = 0x00300000

# The c40_idrom_lbase0 option specifies where the memory attached to
# strobe 0 of the local bus starts in the C40's address memory.  This
# address is a machine address, not a C address.  Memory is assumed to
# start at this address and ascend upwards through memory.  A value of
# 0xffffffff indicates that there is no memory on strobe 0 of the local
# bus.  The default value, if this option is not specified, is
# 0x00300000.
#

# c40_idrom_lbase1 = 0xffffffff

# The c40_idrom_lbase1 option specifies where the memory attached to
# strobe 1 of the local bus starts in the C40's address memory.  This
# address is a machine address, not a C address.  Memory is assumed to
# start at this address and ascend upwards through memory.  A value of
# 0xffffffff indicates that there is no memory on strobe 1 of the local
# bus.  The default value, if this option is not specified, is
# 0xffffffff.
#

# c40_idrom_gbase0 = 0x80000000

# The c40_idrom_gbase0 option specifies where the memory attached to
# strobe 0 of the global bus starts in the C40's address memory.  This
# address is a machine address, not a C address.  Memory is assumed to
# start at this address and ascend upwards through memory.  A value of
# 0xffffffff indicates that there is no memory on strobe 0 of the global
# bus.  The default value, if this option is not specified, is
# 0x80000000.
#

# c40_idrom_gbase1 = 0xffffffff

# The c40_idrom_gbase1 option specifies where the memory attached to
# strobe 1 of the global bus starts in the C40's address memory.  This
# address is a machine address, not a C address.  Memory is assumed to
# start at this address and ascend upwards through memory.  A value of
# 0xffffffff indicates that there is no memory on strobe 1 of the global
# bus.  The default value, if this option is not specified, is
# 0xffffffff.
#

# c40_idrom_lsize0 = 0x100000

# The c40_idrom_lsize0 option specifies the amount (in 32 bit words)
# of memory on strobe 0 of the local bus.  A value of 0x100000 indicates
# 4 megabytes (one megaword) of memory.  The default value is 0x100000.
# Any of the c40_idrom_l/gsize0/1 options can give a size of 0 to force
# automatic memory sizing. Automatic sizing will only work if their base
# is set correctly (i.e. not 0xffffffff).
#

# c40_idrom_lsize1 = 0

# The c40_idrom_lsize1 option specifies the amount (in 32 bit words)
# of memory on strobe 1 of the local bus.  A value of 0x100000 indicates
# 4 megabytes (one megaword) of memory.  The default value is 0.
#

# c40_idrom_gsize0 = 0x100000

# The c40_idrom_gsize0 option specifies the amount (in 32 bit words)
# of memory on strobe 0 of the global bus.  A value of 0x100000 indicates
# 4 megabytes (one megaword) of memory.  The default value is 0x100000.
#

# c40_idrom_gsize1 = 0

# The c40_idrom_gsize1 option specifies the amount (in 32 bit words)
# of memory on strobe 1 of the global bus.  A value of 0x100000 indicates
# 4 megabytes (one megaword) of memory.  The default value is 0.
#

# c40_idrom_fsize = 0x800

# The c40_idrom_fsize option specifies the amount (in 32 bit words) of
# memory available as "fast" memory.  Normally this would just be the
# on-chip RAM, but if 0 wait state SRAM has been placed in the address
# map, directly after the on-chip RAM, then this memory can be used as
# "fast" memory as well.  (Make sure that this memory is not included
# as part of the memory on strobe 0 of the local bus!)  The default
# value is 0x800 which is just the on-chip RAM.
#

# c40_idrom_wait_l0 = 2

# The c40_idrom_wait_l0 option specifies how long it takes to read a
# word from the memory on strobe 0 of the local bus.  This value is in
# terms of CPU cycles.  0 wait state memory takes 1 cycle.  If the time
# is indeterminate (because the memory is shared, or because there are
# multiple banks of memory on the same strobe), then the value 0xF
# should be used.  This option only refers to fetches within a page.
# For fetches outside of the current page the c40_idrom_pwait_l0
# option should be used.  The default value is 2. 
#

# c40_idrom_wait_l1 = 2

# The c40_idrom_wait_l1 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word within the current page of memory on strobe 1 of the
# local bus.  The default value is 2.
#

# c40_idrom_wait_g0 = 2

# The c40_idrom_wait_g0 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word within the current page of memory on strobe 0 of the
# global bus.  The default value is 2.
#

# c40_idrom_wait_g1 = 2

# The c40_idrom_wait_g1 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word within the current page of memory on strobe 1 of the
# global bus.  The default value is 2.
#

# c40_idrom_pwait_l0 = 5

# The c40_idrom_pwait_l0 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word outside of the current page of memory on strobe 0 of the
# local bus.  The default value is 5.  For SRAM this value will be the
# same as the value for c40_idrom_wait_l0.
#

# c40_idrom_pwait_l1 = 5

# The c40_idrom_pwait_l1 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word outside of the current page of memory on strobe 1 of the
# local bus.  The default value is 5.  For SRAM this value will be the
# same as the value for c40_idrom_wait_l1.
#

# c40_idrom_pwait_g0 = 5

# The c40_idrom_pwait_g0 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word outside of the current page of memory on strobe 0 of the
# global bus.  The default value is 5.  For SRAM this value will be the
# same as the value for c40_idrom_wait_g0.
#

# c40_idrom_pwait_g1 = 5

# The c40_idrom_pwait_g1 option is the same as the c40_idrom_wait_l0
# option (see above) except that it specifies how many cycles it takes
# to read a word outside of the current page of memory on strobe 1 of the
# global bus.  The default value is 5.  For SRAM this value will be the
# same as the value for c40_idrom_wait_g1.
#

# c40_idrom_timer0_period = 0x2710

# The c40_idrom_timer0_period option specifies the value that should
# be loaded into the C40's timer 0 in order for it to generate 1 ms
# ticks.  The values for various different processor speeds are as
# follows :
#
#    0x203A    -> 33 MHz
#    0x2710    -> 40 MHz    (the default value)
#    0x30D4    -> 50 MHz
#    0x411A    -> 60 MHz
#

# c40_idrom_timer0_ctrl = 0x2c2

# The c40_idrom_timer0_ctrl option specifies the value to be placed
# into the control register of the C40's timer 0.  Normally this value
# is such that the timer runs in pulse mode from the C40's internal
# clock, and external timer pin is left alone.  The default value is
# 0x2c2.  The meaning of the bits in control register are described in
# table 9-10 on page 9-48 of the TMS320C4x User's Guide, available from
# Texas Instruments.
#

# c40_idrom_timer1_period = 0x80

# The c40_idrom_timer1_period option is used to specify the value
# loaded into the C40's timer 1 period register.  This timer is not used
# by Helios, although some pieces of hardware may use this timer to
# control DRAM refresh.  The default value is 0x80.
#

# c40_idrom_timer1_ctrl = 0

# The c40_idrom_timer1_ctrl option is used to specify the value to be
# placed into the C40's timer 1 control register.  The default value is
# 0.  The control register is described in table 9-10 on page 9-48 of
# the TMS320C4x User's Guide, available from Texas Instruments.
#

# c40_idrom_lbcr = 0x3e39fff0

# The c40_idrom_lbcr option is used to specify the value to be placed
# into the C40's local bus control register.   This register is
# described in table 7-3 on page 7-8 of the TMS320C4x User's Guide,
# available from Texas Instruments.  The default value is 0x3e39fff0.
#

# c40_idrom_gbcr = 0x3e39fff0

# The c40_idrom_gbcr option is used to specify the value to be placed
# into the C40's global bus control register.   This register is
# described in table 7-3 on page 7-8 of the TMS320C4x User's Guide,
# available from Texas Instruments.  The default value is 0x3e39fff0.
#


#               Board Specific Options
#
# These options are specific to one or more manufacturer's board.
#

link_base = 0x150

# The link_base option is used to specify where, in the PC's address
# map, the link used to communicate with the C40 appears.  This option
# needs to be set for the following boards :
#
#    Hunt Engineering HEPC2
#    Hema DSP1
#    Sonitech Spirit40
#    Transtech TDB416
#    Transtech TDMB409
#    Transtech TTM60
#    LSI QPC/C40 versions 1 and 2
#    Sang MEGA-Link C40
#

# bootlink = 3

# The bootlink specifies which link on the C40 connects to the I/O
# server.  This applies even to C40's which use a shared memory
# interface to the host computer, as Helios implements this as a seventh
# link.  If no value is specified then a default value of 3 is used by
# the I/O server.  This option needs to be set for the following boards :
#
#    bootlink = 6			# for the Sonitech Spirit40
#    bootlink = 6			# for the Ariel VC40
#    bootlink = 1                       # for the LSI QPC boards
#    bootlink = 0                       # for the SANG Mega-Link board
#

# hepc2_fifo_base = 0xd0000

# The hepc2_fifo_base option is used to specify where, in the PC's
# address map, the fast FIFO connection to the C40 appears.  This option
# needs to be set for the following boards :
#
#    Hunt Engineering HEPC2
#

# tdmb40x_fifo_base = 0xd000

# The tdmb40x_fifo_base option is used to specify where, in the PC's
# address map, the fast FIFO connection to the C40 appears.  This option
# needs to be set for the following boards :
#
#    Transtech TDMB409
#

# qpc_slabase = 0x280

# The qpc_slabase option spciefies where the communication link with
# the C40 should appear in the PC's memory map.  This is a software
# controllable feature of the LSI QPC/C40 board.  The default value is
# 0x280.  This option should be set for the following boards : 
# 
#     LSI QPC/C40 version 1
#     LSI QPC/C40 version 2
#

# qpc_module = primary

# The qpc_module option specifies to which site on the QPC motherboard
# the link adapter should be connected.  There are four TIM sites on a
# QPC motherboard, and the software can connect the I/O server to only
# on of them.  (Naturally each of the four TIM sites can communicate
# with each other, so that a network of C40s can be formed).  This
# option can take one of four values: primary (the default), secondary,
# tertiary or quaternary.  This option must be set for the following
# boards :
# 
#       LSI QPC/C40 boards, version 1
#       LSI QPC/C40 boards, version 2
#

# c40_sml_g0

# The c40_sml_g0 option specifies that the communication link to the
# host processor should use the shared memory on the C40's global bus,
# strobe 0.  This is the default value.  The alternative option is :
#
#    c40_sml_g1
#
# which specifies that the shared memory attached to strobe 1 of the
# global bus should be used.  This option (in either form) is only
# necessary for C40 boards which have a shared memory interface to the
# host computer.  Hence this option should only be set for the
# following boards : 
#
#    Sonitech Spirit40
#    Ariel VC40
#
# It is possible to use the shared memory on either strobe both as a
# communication link and to hold the Helios nucleus.  The nucleus is
# always loaded at the start of the area controlled by the strobe,
# whilst the communication link is always placed at the end of the
# memory controlled by the strobe.
#

# c40_sml_size = 32

# The c40_sml_size option specifies the amount of shared memory, in
# kilobytes, that should be used be used for the communication link to
# the host computer.  This memory will be subtracted from the memory
# available on whichever strobe is being used for the communication
# link, (see the c40_sml_g0 option above).  The remaining memory is
# available to the rest of Helios.  This option only applies to boards
# which use a shared memory interface to the host computer, such as : 
#
#    Sonitech Spirit40
#    Ariel VC40
#

# c40_root_proc = 0

# The c40_root_proc option specifies which processor on the Spirit40
# board should be used as the root processor.  The Spirit40 board has
# one bank of shared memory which is common to both processors and the
# host computer, and so either processor can be selected as the root
# processor.  The processors are numbered 0 and 1, and by default
# processor 0 will be used.  This option needs to be set for :
#
#    Sonitech Spirit40
#

#
# end of template.con
#
