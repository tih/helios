--{{{ Comments

;
; vectlib.a - Assembly language implementation of a simple vector library
;
; Copyright (c) 1992 - 1994 by Perihelion Software Ltd.
;   All Rights Reserved
;
; Author: Nick Clifton
;
; $Id: vectlib.a,v 1.6 1994/01/11 16:53:12 nickc Exp $
;
;

--}}}
--{{{ includes
_include 'c40.m
_include 'basic.m
_include 'module.m

--}}}

	StartModule vectlib -1 1

--{{{ Functions

--
-- Vector manipulation libray
--
-- This library has been written for speed.  As a result
-- it will not work with vectors of only one element.  In
-- addition, none of the routines validate their arguments.
--

--{{{ VfAdd

Function VfAdd
--
--	void VfAdd( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	           R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfadd_loop					-- repeat block of code
	   LSH3	       -2,                 R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                 R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   ADDF3     *++R_ATMP(R_BASE), *++R_ADDR1(R_BASE), R_A1	-- add first elements of arrays	   
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,             *R_ATMP++(1)			-- store reult of previous addition
vfadd_loop:
	 ADDF3        *+R_ATMP(0),      *++R_ADDR1(1),      R_A1	-- compute next sum
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,             *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfAdd
--

--}}}
--{{{ VfSub

Function VfSub
--
--	void VfSub( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	            R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfsub_loop					-- repeat block of code
	   LSH3	       -2,                  R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                  R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   SUBF3     *++R_ADDR1(R_BASE), *++R_ATMP(R_BASE), R_A1	-- subtract first elements of arrays
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,              *R_ATMP++(1)			-- store reult of previous addition
vfsub_loop:
	 SUBF3     *++R_ADDR1(1),       *+R_ATMP(0),      R_A1	-- compute next difference
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,              *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfSub
--

--}}}
--{{{ VfMul

Function VfMul
--
--	void VfMul( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	            R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfmul_loop					-- repeat block of code
	   LSH3	       -2,                  R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                  R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   MPYF3     *++R_ADDR1(R_BASE), *++R_ATMP(R_BASE), R_A1	-- multiply first elements of arrays
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,              *R_ATMP++(1)			-- store reult of previous addition
vfmul_loop:
	 MPYF3     *++R_ADDR1(1),       *+R_ATMP(0),      R_A1	-- compute next product
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,              *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfMul
--

--}}}
--{{{ VfDiv

Function VfDiv
--
--	void VfDiv( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	RPTBD	   vfdiv_loop
	   LSH3	  -2,			R_A3,		R_ADDR1
	   ADDI	   R_BASE,		R_ATMP
	   LDF	*++R_ADDR1(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,	       *R_ATMP,	R_A2
	 RND	   R_A2
vfdiv_loop:
	 STF	   R_A2,	       *R_ATMP++(1)
	 || LDF	*++R_ADDR1(1),		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	BuD	   R_LR
	   MPYF3   R_FT1,	       *R_ATMP,	R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP++(1)
--
-- end of VfDiv
--

--}}}
--{{{ VdAdd

Function VdAdd
--
--	void VdAdd( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD          vdadd_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 ADDF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdadd_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   ADDF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdAdd
--

--}}}
--{{{ VdSub

Function VdSub
--
--	void VdSub( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD         vdsub_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 SUBF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdsub_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   SUBF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdSub
--

--}}}
--{{{ VdMul

Function VdMul
--
--	void VdMul( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD         vdmul_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 MPYF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdmul_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   MPYF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdMul
--

--}}}
--{{{ VdDiv

Function VdDiv
--
--	void VdDiv( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	      2, 		R_A1,		RC
	LSH3	     -2,		R_A2,		R_ATMP
	RPTBD	      vddiv_loop
	   LSH3	     -2,		R_A3,		R_ADDR1
	   LDF	   *++R_ADDR1(R_BASE),	R_A3
	   || LDF  *++R_ATMP(R_BASE),	R_A1
	   LDI	   *++R_ADDR1(1),	R_A3
	   || LDI   *+R_ATMP(1),	R_A1
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF	   R_FT1,		R_A1

	 STF	   R_A1,	       *R_ATMP++(1)
	 STI	   R_A1,	       *R_ATMP++(1)
	 LDF	*++R_ADDR1(1),		R_A3
	 || LDF	  *R_ATMP,		R_A1
vddiv_loop:
	 LDI	*++R_ADDR1(1),		R_A3
	 || LDI	 *+R_ATMP(1),		R_A1
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	BuD	   R_LR
	   MPYF    R_FT1,	       	R_A1
	   STF	   R_A1,	       *R_ATMP++(1)
	   STI	   R_A1,	       *R_ATMP++(1)
--
-- end of VdDiv
--

--}}}
--{{{ VfAddScalar

Function VfAddScalar
--
--	void VfAddScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vfadds_loop
	   LSH3	    -2,		     R_A4,	R_ATMP
	   ADDF3  *++R_ATMP(R_BASE), R_A1,	R_A2
	   LDI	     R_ATMP,		        R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfadds_loop:
	 ADDF3  *++R_ATMP(1),	     R_A1,	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfAddScalar
--

--}}}
--{{{ VfSubScalar

Function VfSubScalar
--
--	void VfSubScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,		RC
	RPTBD        vfsubs_loop
	   LSH3	    -2,		     R_A4,		R_ATMP
	   SUBF3     R_A1,	  *++R_ATMP(R_BASE),	R_A2
	   LDI	     R_ATMP,				R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfsubs_loop:
	 SUBF3     R_A1,	  *++R_ATMP(1),	   	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfSubScalar
--

--}}}
--{{{ VfMulScalar

Function VfMulScalar
--
--	void VfMulScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,		RC
	RPTBD        vfmuls_loop
	   LSH3	    -2,		     R_A4,		R_ATMP
	   MPYF3     R_A1,	  *++R_ATMP(R_BASE),	R_A2
	   LDI	     R_ATMP,				R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfmuls_loop:
	 MPYF3       R_A1,	  *++R_ATMP(1),	   	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfMulScalar
--

--}}}
--{{{ VfDivScalar

Function VfDivScalar
--
--	void VfDivScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the floating point argument
--
	LSH3	     -2,	    R_A4,		R_ATMP
	STI	      R_A1,	*\--R_USP(1)
	SUBI3	      2,	    R_A3,		RC
	LDF	     *R_USP++(1),   R_A1
	LDI	      R_A2,	    R_A1
	RCPF	      R_A1,	    R_FT1
	MPYF3	      R_A1,	    R_FT1,		R_FT2
	SUBRF	      2.0,	    R_FT2
	MPYF	      R_FT2,	    R_FT1
	MPYF3	      R_A1,	    R_FT1,		R_FT2
	SUBRF         2.0,	    R_FT2
	RPTBD	      vfdivs_loop
	   MPYF	      R_FT2,	    R_FT1
	   MPYF3      R_FT1,	 *++R_ATMP(R_BASE),	R_A1
	   LDI	      R_ATMP,	    R_ADDR1
	 RND	      R_A1
vfdivs_loop:
	 STF	      R_A1,	   *R_ATMP++(1)
	 || MPYF3  *++R_ADDR1(1),   R_FT1,		R_A1
	BuD	      R_LR
	   RND	      R_A1
	   STF	      R_A1,	   *R_ATMP++(1)
	   NOP
--
-- end of VfDivScalar
--

--}}}
--{{{ VfRecScalar

Function VfRecScalar
--
--	void VfRecScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	floating point argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	RPTBD	   vfrecs_loop
	   LSH3	  -2,			R_A4,		R_ATMP
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,		R_A1,		R_A2
	 RND	   R_A2
	 STF	   R_A2,	       *R_ATMP++(1)
vfrecs_loop:
	 LDF	  *R_ATMP,		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP++(1)
--
-- end of VfRecScalar
--

--}}}
--{{{ VdAddScalar

Function VdAddScalar
--
--	void VdAddScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdadds_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 ADDF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdadds_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   ADDF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdAddScalar
--

--}}}
--{{{ VdSubScalar

Function VdSubScalar
--
--	void VdSubScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdsubs_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 SUBF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdsubs_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   SUBF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdSubScalar
--

--}}}
--{{{ VdMulScalar

Function VdMulScalar
--
--	void VdMulScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdmuls_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 MPYF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdmuls_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   MPYF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdMulScalar
--

--}}}
--{{{ VdDivScalar

Function VdDivScalar
--
--	void VdDiv( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the double precision argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      1.0,	       R_FT2
	MPYF	      R_FT1,	       R_FT2
	ADDF	      R_FT2,	       R_FT1

	LDF	   *++R_ATMP(R_BASE),  R_A3
	RPTBD	      vddivs_loop
	   LDI	      R_ATMP,	       R_ADDR1
	   LDI	   *++R_ATMP(1),       R_A3
	   MPYF3      R_FT1,	       R_A3,		R_A1
	 STF	      R_A1,	      *R_ADDR1++(1)
	 || LDF	   *++R_ATMP(1),       R_A3
	 STI	      R_A1,	      *R_ADDR1++(1)
	 || LDI	   *++R_ATMP(1),       R_A3
vddivs_loop:
	 MPYF3	      R_A3,            R_FT1,		R_A1
	BuD	      R_LR
	   STF	      R_A1,	      *R_ADDR1++(1)
	   STI	      R_A1,	      *R_ADDR1++(1)
	   NOP
--
-- end of VdDivScalar
--

--}}}
--{{{ VdRecScalar

Function VdRecScalar
--
--	void VdRecScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	double precision argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LSH3	  -2,			R_A4,		R_ATMP
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdrecs_loop
	   LDI	   R_ATMP,		R_ADDR1
	   LDI	   R_A2,		R_A1
	   LDI	*++R_ATMP(1),		R_A3
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF3	   R_FT1,		R_A1,		R_A2
	 STF	   R_A2,	       *R_ADDR1++(1)
	 || LDF	*++R_ATMP(1),		R_A3
vdrecs_loop:
	 STI	   R_A2,	       *R_ADDR1++(1)
	 || LDI	*++R_ATMP(1),		R_A3
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   STF	   R_A2,	       *R_ADDR1++(1)
	   STI	   R_A2,	       *R_ADDR1++(1)
--
-- end of VdRecScalar
--

--}}}
--{{{ VfCopy

Function VfCopy
--
--	void VfCopy( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	     -2,		R_A2,	R_ATMP
	SUBI3	      2,		R_A1,	RC
	RPTBD	      vfcopy_loop
	   LSH3	     -2,		R_A3,	R_ADDR1
	   LDF	   *++R_ADDR1(R_BASE),	R_A1
	   ADDI	      R_BASE,		R_ATMP
vfcopy_loop:
	 STF	      R_A1,	       *R_ATMP++(1)
	 || LDF    *++R_ADDR1(1),	R_A1
	STF	      R_A1,	       *R_ATMP++(1)
	Bu	      R_LR
--
-- end of VfCopy
--

--}}}
--{{{ VdCopy

Function VdCopy
--
--	void VdCopy( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--
-- Corrupts
--	ST
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH	      1,		R_A1
	LSH3	     -2,		R_A2,	R_ATMP
	SUBI3	      2,		R_A1,	RC
	RPTBD	      vdcopy_loop
	   LSH3	     -2,		R_A3,	R_ADDR1
	   LDI	   *++R_ADDR1(R_BASE),	R_A1
	   ADDI	      R_BASE,		R_ATMP
vdcopy_loop:
	 STI	      R_A1,	       *R_ATMP++(1)
	 || LDI    *++R_ADDR1(1),	R_A1
	STI	      R_A1,	       *R_ATMP++(1)
	Bu	      R_LR
--
-- end of VdCopy
--

--}}}
--{{{ VfFill

Function VfFill
--
--	void VfFill( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the floating point argument
--
	SUBI3	     2,		     R_A3,	RC
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	RPTBD        vffill_loop
	   LDI	     R_A2,	     R_A1
	   RND	     R_A1
	   STF       R_A1,	  *++R_ATMP(R_BASE)
vffill_loop:
	 STF	     R_A1,	  *++R_ATMP(1)
	Bu	     R_LR
--
-- end of VfFill
--

--}}}
--{{{ VdFill

Function VdFill
--
--	void VdFill( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the double precision argument
--
	SUBI3	     2,		     R_A3,	RC
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	RPTBD        vdfill_loop
	   LDI	     R_A2,	     R_A1
	   STF       R_A1,	  *++R_ATMP(R_BASE)
	   STI       R_A1,	  *++R_ATMP(1)
	 STF	     R_A1,	  *++R_ATMP(1)
vdfill_loop:
	 STI	     R_A1,	  *++R_ATMP(1)
	Bu	     R_LR
--
-- end of VdFill
--

--}}}
--{{{ VfMax

Function VfMax
--
--	uword VfMax( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfmax_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 CMPF3	   R_A2,	     *++R_ATMP(1)
	 LDIgt	   R_A3,		R_A1
vfmax_loop:
	 LDFgt	  *R_ATMP,		R_A2
	Bu	   R_LR 
--
-- end of VfMax
--

--}}}
--{{{ VdMax

Function VdMax
--
--	uword VdMax( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Corrupts
--	ST
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	RPTBD	   vdmax_loop
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vdmax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdMax
--

--}}}
--{{{ VfMin

Function VfMin
--
--	uword VfMin( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfmin_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 CMPF3	   R_A2,             *++R_ATMP(1)
	 LDIlt	   R_A3,		R_A1
vfmin_loop:
	 LDFlt	  *R_ATMP,		R_A2
	Bu	   R_LR 
--
-- end of VfMin
--

--}}}
--{{{ VdMin

Function VdMin
--
--	uword VdMin( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	RPTBD	   vdmin_loop
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vdmin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdMin
--

--}}}
--{{{ VfAmax

Function VfAmax
--
--	uword VfAmax( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfamax_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   ABSF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 ABSF	*++R_ATMP(1),		R_FT1
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vfamax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VfAmax
--

--}}}
--{{{ VdAmax

Function VdAmax
--
--	uword VdAmax( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	LDI	   0,			R_A3
	RPTBD	   vdamax_loop
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	   ABSF    R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ABSF	   R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vdamax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdAmax
--

--}}}
--{{{ VfAmin

Function VfAmin
--
--	uword VfAmin( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfamin_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   ABSF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 ABSF	*++R_ATMP(1),		R_FT1
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vfamin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VfAmin
--

--}}}
--{{{ VdAmin

Function VdAmin
--
--	uword VdAmin( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	LDI	   0,			R_A3
	RPTBD	   vdamin_loop
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	   ABSF    R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ABSF	   R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vdamin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdAmin
--

--}}}
--{{{ VfDot

Function VfDot
--
--	float VfDot( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	SUBI	     2,			R_A1,			RC
	   LSH3	    -2,			R_A2,			R_ATMP
	RPTBD        vfdot_loop
	   LSH3	    -2,			R_A3,			R_ADDR1
	   LDF	     0.0,		R_A3
	   MPYF3  *++R_ATMP(R_BASE), *++R_ADDR1(R_BASE),	R_A2
vfdot_loop:
	 MPYF3	  *++R_ATMP(1),	     *++R_ADDR1(1),		R_A2
	 || ADDF3    R_A3,	        R_A2,			R_A3
	BuD	     R_LR
	   ADDF3     R_A2,		R_A3,			R_A1
	   RND	     R_A1
	   NOP
--
-- end of VfDot
--

--}}}
--{{{ VdDot

Function VdDot
--
--	double VdDot( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		R_A2,	R_ATMP
	LSH3	     -2,		R_A3,	R_ADDR1
	SUBI	      2,		R_A1,	RC
	RPTBD         vddot_loop
	   LDF	   *++R_ATMP(R_BASE),	R_A2
	   || LDF  *++R_ADDR1(R_BASE),	R_A3
	   LDF	      0.0,		R_A1
	   LDI	   *++R_ATMP(1),	R_A2
	   || LDI  *++R_ADDR1(1),	R_A3
	 MPYF	      R_A2,		R_A3
	 ADDF	      R_A3,		R_A1
	 LDF	   *++R_ATMP(1),	R_A2
	 || LDF	   *++R_ADDR1(1),	R_A3
vddot_loop:
	 LDI	   *++R_ATMP(1),	R_A2
	 || LDI	   *++R_ADDR1(1),	R_A3
	BuD	      R_LR
	   MPYF	      R_A2,		R_A3
	   ADDF	      R_A3,		R_A1
	   NOP
--
-- end of VdDot
--

--}}}
--{{{ VfSum

Function VfSum
--
--	float VfSum( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vfsum_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   NOP
	   LDF	*++R_ATMP(R_BASE),	R_A1
vfsum_loop:
	 ADDF	*++R_ATMP(1),		R_A1
	RND	   R_A1
	Bu	   R_LR
--
-- end of VfSum
--

--}}}
--{{{ VdSum

Function VdSum
--
--	double VdSum( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Corrupts
--	ST
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vdsum_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   LDF	*++R_ATMP(R_BASE),	R_A1
	   LDI	*++R_ATMP(1),		R_A1
	 LDF	*++R_ATMP(1),		R_A2
	 LDI	*++R_ATMP(1),		R_A2
vdsum_loop:
	 ADDF	   R_A2,		R_A1
	Bu	   R_LR
--
-- end of VdSum
--

--}}}
--{{{ VfProd

Function VfProd
--
--	float VfProd( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vfprod_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   NOP
	   LDF	*++R_ATMP(R_BASE),	R_A1
vfprod_loop:
	 MPYF	*++R_ATMP(1),		R_A1
	RND	   R_A1
	Bu	   R_LR
--
-- end of VfProd
--

--}}}
--{{{ VdProd

Function VdProd
--
--	double VdProd( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vdprod_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   LDF	*++R_ATMP(R_BASE),	R_A1
	   LDI	*++R_ATMP(1),		R_A1
	 LDF	*++R_ATMP(1),		R_A2
	 LDI	*++R_ATMP(1),		R_A2
vdprod_loop:
	 MPYF	   R_A2,		R_A1
	Bu	   R_LR
--
-- end of VdProd
--

--}}}
--{{{ VfMulAdd

Function VfMulAdd
--
--	void VfMulAdd( float value, uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in arrays 'x' and 'y'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the floating point argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(0),	R_ADDR1
	RPTBD	     vfmuladd_loop
	   LDI	     R_A2,		R_A1
	   MPYF3  *++R_ADDR1(R_BASE),	R_A1,		R_A2
	   ADDF	  *++R_ATMP(R_BASE),	R_A2
	 RND	     R_A2
	 STF	     R_A2,	       *R_ATMP++(1)
	 || MPYF3 *++R_ADDR1(1),	R_A1,		R_A2
vfmuladd_loop:
	 ADDF	    *R_ATMP,		R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	       *R_ATMP
	   NOP
--
-- end of VfMulAdd
--

--}}}
--{{{ VdMulAdd

Function VdMulAdd
--
--	void VdMulAdd( double value, uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in arrays 'x' and 'y'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(0),	R_ADDR1
	LDI	     R_A2,		R_A1
	RPTBD	     vdmuladd_loop
	   LDF	  *++R_ADDR1(R_BASE),	R_A2
	   || LDF *++R_ATMP(R_BASE),	R_A3
	   LDI	  *++R_ADDR1(1),	R_A2
	   || LDI  *+R_ATMP(1),		R_A3
	   MPYF      R_A1,		R_A2
	 ADDF	     R_A3,	        R_A2
	 STF	     R_A2,	       *R_ATMP++(1)
	 STI	     R_A2,	       *R_ATMP++(1)
	 LDF	  *++R_ADDR1(1),	R_A2
	 || LDF     *R_ATMP,		R_A3
	 LDI	  *++R_ADDR1(1),	R_A2
	 || LDI    *+R_ATMP(1),		R_A3
vdmuladd_loop:
	 MPYF        R_A1,		R_A2
	BuD	     R_LR
	   ADDF	     R_A3,		R_A2
	   STF	     R_A2,	       *R_ATMP++(1)
	   STI	     R_A2,	       *R_ATMP
--
-- end of VdMulAdd
--

--}}}
--{{{ VfsAdd

Function VfsAdd
--
--	void VfsAdd( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	ADDF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfsadd_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 ADDF  *++R_ADDR1(R_USE),     R_A2
vfsadd_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsAdd
--

--}}}
--{{{ VfsSub

Function VfsSub
--
--	void VfsSub( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	SUBF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfssub_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 SUBF  *++R_ADDR1(R_USE),     R_A2
vfssub_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsSub
--

--}}}
--{{{ VfsMul

Function VfsMul
--
--	void VfsMul( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	MPYF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfsmul_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 MPYF  *++R_ADDR1(R_USE),     R_A2
vfsmul_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsMul
--

--}}}
--{{{ VfsDiv

Function VfsDiv
--
--	void VfsDiv( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LDI	  *R_USP,		R_USE
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	RPTBD	   vfsdiv_loop
	   LDF	*++R_ADDR1(R_BASE),	R_A4
	   LDI	   R_BASE,		R_ADDR2
	   LDI	   R_A3,		R_BASE
	 RCPF	   R_A4,		R_FT1
	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,	       *R_ATMP,	R_A2
	 RND	   R_A2
vfsdiv_loop:
	 STF	   R_A2,	       *R_ATMP++(R_BASE)
	 || LDF	*++R_ADDR1(R_USE),	R_A4
	RCPF	   R_A4,		R_FT1
	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3      R_FT1,	       *R_ATMP,		R_A2
	RND	   R_A2
	BuD	   R_LR
	   STF	   R_A2,	       *R_ATMP
	   LDI	   R_T1,	        R_USE
	   LDI	   R_ADDR2,		R_BASE
--
-- end of VfsDiv
--

--}}}
--{{{ VdsAdd

Function VdsAdd
--
--	void VdsAdd( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdsadd_loop
	   ADDF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdsadd_loop:
	 ADDF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsAdd
--

--}}}
--{{{ VdsSub

Function VdsSub
--
--	void VdsSub( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdssub_loop
	   SUBF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdssub_loop:
	 SUBF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsSub
--

--}}}
--{{{ VdsMul

Function VdsMul
--
--	void VdsMul( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdsmul_loop
	   MPYF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdsmul_loop:
	 MPYF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsMul
--

--}}}
--{{{ VdsDiv

Function VdsDiv
--
--	void VdsDiv( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (double)
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LSH3	   1,		      *+R_USP(0),	R_USE
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	LDF	*++R_ADDR1(R_BASE),	R_A4
	RPTBD	   vdsdiv_loop
	   LDI	   R_BASE,		R_ADDR2
	   LDI	 *+R_ADDR1(1),		R_A4
	   LSH3	   1,			R_A3,		R_BASE
	 RCPF	   R_A4,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 LDF	  *R_ATMP,		R_A2
	 LDI	 *+R_ATMP(1),		R_A2

	 MPYF	   R_FT1,	       	R_A2

	 STI	   R_A2,	      *+R_ATMP(1)
	 STF	   R_A2,	       *R_ATMP++(R_BASE)
	 || LDF	*++R_ADDR1(R_USE),	R_A4
vdsdiv_loop:
	 LDI	 *+R_ADDR1(1),		R_A4
	RCPF	   R_A4,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	LDF	  *R_ATMP,		R_A2
	LDI	 *+R_ATMP(1),		R_A2

	MPYF       R_FT1,	       	R_A2
	STF	   R_A2,	       *R_ATMP
	BuD	   R_LR
	   STI	   R_A2,	      *+R_ATMP(1)
	   LDI	   R_T1,	        R_USE
	   LDI	   R_ADDR2,		R_BASE
--
-- end of VdsDiv
--

--}}}
--{{{ VfsAddScalar

Function VfsAddScalar
--
--	void VfsAddScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfsadds_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   ADDF3  *++R_ATMP(R_BASE),	R_A1,		R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfsadds_loop:
	 ADDF3    *++R_ATMP(R_USE),     R_A1,		R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsAddScalar
--

--}}}
--{{{ VfsSubScalar

Function VfsSubScalar
--
--	void VfsSubScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfssubs_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   SUBF3     R_A1,	     *++R_ATMP(R_BASE),	R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfssubs_loop:
	 SUBF3       R_A1,	     *++R_ATMP(R_USE),  R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsSubScalar
--

--}}}
--{{{ VfsMulScalar

Function VfsMulScalar
--
--	void VfsMulScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfsmuls_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   MPYF3  *++R_ATMP(R_BASE),	R_A1,		R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfsmuls_loop:
	 MPYF3    *++R_ATMP(R_USE),     R_A1,		R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsMulScalar
--

--}}}
--{{{ VfsDivScalar

Function VfsDivScalar
--
--	void VfsDivScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP   distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the floating point argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	LDI	      R_USE,	       R_T1
	LDI	     *R_USP,	       R_USE
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	RPTBD	      vfsdivs_loop
	   MPYF	      R_FT2,	       R_FT1
	   MPYF3      R_FT1,	    *++R_ATMP(R_BASE),	R_A1
	   LDI	      R_ATMP,	       R_ADDR1
	 RND	      R_A1
vfsdivs_loop:
	 STF	      R_A1,	      *R_ATMP++(R_USE)
	 || MPYF3  *++R_ADDR1(R_USE),  R_FT1,		R_A1
	BuD	      R_LR
	   RND	      R_A1
	   STF	      R_A1,	      *R_ATMP
	   LDI	      R_T1,	       R_USE
--
-- end of VfsDivScalar
--

--}}}
--{{{ VfsRecScalar

Function VfsRecScalar
--
--	void VfsRecScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	floating point argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LDI	   R_USE,		R_T1
	LDI	  *R_USP,		R_USE
	RPTBD	   vfsrecs_loop
	   LSH3	  -2,			R_A4,		R_ATMP
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,		R_A1,		R_A2
	 RND	   R_A2
	 STF	   R_A2,	       *R_ATMP++(R_USE)
vfsrecs_loop:
	 LDF	  *R_ATMP,		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	LDI	   R_T1,		R_USE
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP
--
-- end of VfsRecScalar
--

--}}}
--{{{ VdsAddScalar

Function VdsAddScalar
--
--	void VdsAddScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdsadds_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   ADDF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdsadds_loop:
	 ADDF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsAddScalar
--

--}}}
--{{{ VdsSubScalar

Function VdsSubScalar
--
--	void VdsSubScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdssubs_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   SUBF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdssubs_loop:
	 SUBF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsSubScalar
--

--}}}
--{{{ VdsMulScalar

Function VdsMulScalar
--
--	void VdsMulScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdsmuls_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   MPYF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdsmuls_loop:
	 MPYF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsMulScalar
--

--}}}
--{{{ VdsDivScalar

Function VdsDivScalar
--
--	void VdsDivScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP   distance between elements of 'x' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the double precision argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	LDI	      R_USE,	       R_T1
	LSH3	      1,	     *+R_USP(0),	R_USE
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      1.0,	       R_FT2
	MPYF	      R_FT1,	       R_FT2
	ADDF	      R_FT2,	       R_FT1

	LDF	   *++R_ATMP(R_BASE),  R_A1
	RPTBD	      vdsdivs_loop
	   LDI	    *+R_ATMP(1),       R_A1
	   MPYF       R_FT1,	       R_A1
	   LDI	      R_ATMP,	       R_ADDR1
	 STI	      R_A1,	     *+R_ATMP(1)
	 STF	      R_A1,	      *R_ATMP++(R_USE)
	 || LDF	   *++R_ADDR1(R_USE),  R_A2
	 LDI	    *+R_ADDR1(1),      R_A2
vdsdivs_loop:
	 MPYF3	      R_FT1,	       R_A2,		R_A1
	BuD	      R_LR
	   STF	      R_A1,	      *R_ATMP
	   STI	      R_A1,	     *+R_ATMP(1)
	   LDI	      R_T1,	       R_USE
--
-- end of VdsDivScalar
--

--}}}
--{{{ VdsRecScalar

Function VdsRecScalar
--
--	void VdsRecScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	double precision argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LDI	   R_USE,		R_T1
	LSH3	   1,		      *+R_USP(0),	R_USE
	LSH3	  -2,			R_A4,		R_ATMP
	RPTBD	   vdsrecs_loop
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   R_ATMP,		R_ADDR1
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF3	   R_FT1,		R_A1,		R_A2
	 STI	   R_A2,	      *+R_ATMP(1)
	 STF	   R_A2,	       *R_ATMP++(R_USE)
	 || LDF	*++R_ADDR1(R_USE),	R_A3
vdsrecs_loop:
	 LDI	 *+R_ADDR1(1),		R_A3
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	LDI	   R_T1,		R_USE
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   STF	   R_A2,	       *R_ATMP
	   STI	   R_A2,	      *+R_ATMP(1)
--
-- end of VdsRecScalar
--

--}}}
--{{{ VfsCopy

Function VfsCopy
--
--	void VfsCopy( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	LDF	*++R_ADDR1(R_BASE),	R_A2
	STI	   R_BASE,	    *\--R_USP(1)
	SUBI3	   2,		    	R_A1,		RC
	RPTBD	   vfscopy_loop
	   STI	   R_USE,	    *\--R_USP(1)
	   LDI	   R_A3,	    	R_BASE
	   LDI	 *+R_USP(2),		R_USE
vfscopy_loop:
	 LDF	*++R_ADDR1(R_USE),	R_A2
	 || STF	   R_A2,	       *R_ATMP++(R_BASE)
	BuD	   R_LR
           STF	   R_A2,	       *R_ATMP
	   LDI	  *R_USP++(1),	        R_USE
	   LDI	  *R_USP++(1),		R_BASE
--
-- end of VfsCopy
--

--}}}
--{{{ VdsCopy

Function VdsCopy
--
--	void VdsCopy( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LSH3	  -2,			R_A4,		R_ADDR1
	LDI	*++R_ADDR1(R_BASE),	R_A2
	STI	   R_A2,	     *++R_ATMP(R_BASE)
	|| LDI	 *+R_ADDR1(1),		R_A4
	STI	   R_BASE,	    *\--R_USP(1)
	SUBI3	   2,		    	R_A1,		RC
	RPTBD	   vdscopy_loop
	   STI	   R_USE,	    *\--R_USP(1)
	   LSH3	   1,		        R_A3,	    	R_BASE
	   LSH3	   1,		      *+R_USP(2),	R_USE
	 STI	   R_A4,	      *+R_ATMP(1)
	 || LDI	*++R_ADDR1(R_USE),      R_A2
vdscopy_loop:
	 STI	   R_A2,	     *++R_ATMP(R_BASE)
	 || LDI	 *+R_ADDR1(1),		R_A4
	BuD	   R_LR
           STI	   R_A4,	      *+R_ATMP(1)
	   LDI	  *R_USP++(1),	        R_USE
	   LDI	  *R_USP++(1),		R_BASE
--
-- end of VdsCopy
--

--}}}
--{{{ VfsFill

Function VfsFill
--
--	void VfsFill( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the floating point argument
--
	STI	  R_A1,	    *\--R_USP(1)
	LDF	 *R_USP++(1),	R_A1
	LDI	  R_A2,		R_A1
	RND	  R_A1
	LSH3	 -2,		R_A4,	R_ATMP
	SUBI3	  2,		R_A3,	RC
	RPTBD	  vfsfill_loop
	   STF	  R_A1,      *++R_ATMP(R_BASE)
	   STI	  R_USE,    *\--R_USP(1)
	   LDI	*+R_USP(1),	R_USE
vfsfill_loop:
	 STF	  R_A1,	     *++R_ATMP(R_USE)
	LDI	 *R_USP++(1),	R_USE
	Bu	  R_LR
--
-- end of VfsFill
--

--}}}
--{{{ VdsFill

Function VdsFill
--
--	void VdsFill( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the double precision argument
--
	STI	  R_A1,	    *\--R_USP(1)
	LDF	 *R_USP++(1),	R_A1
	LSH3	 -2,		R_A4,	R_ATMP
	LDI	  R_A2,		R_A1
	SUBI3	  2,		R_A3,	RC
	STF	  R_A1,      *++R_ATMP(R_BASE)
	RPTBD	  vdsfill_loop
	   STI	  R_A1,       *+R_ATMP(1)
	   STI	  R_USE,    *\--R_USP(1)
	   LSH3	  1,          *+R_USP(1),	R_USE
	 STF	  R_A1,	     *++R_ATMP(R_USE)
vdsfill_loop:
	 STI	  R_A1,	      *+R_ATMP(1)
	LDI	 *R_USP++(1),	R_USE
	Bu	  R_LR
--
-- end of VdsFill
--

--}}}
--{{{ VfsMax

Function VfsMax
--
--	uword VfsMax( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsmax_loop
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vfsmax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsMax
--

--}}}
--{{{ VdsMax

Function VdsMax
--
--	uword VdsMax( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdsmax_loop
	   LDI	   0,			R_A2
	   LDI	 *+R_ATMP(1),		R_A3
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vdsmax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsMax
--

--}}}
--{{{ VfsMin

Function VfsMin
--
--	uword VfsMin( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsmin_loop
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vfsmin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsMin
--

--}}}
--{{{ VdsMin

Function VdsMin
--
--	uword VdsMin( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdsmin_loop
	   LDI	   0,			R_A2
	   LDI	 *+R_ATMP(1),		R_A3
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vdsmin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsMin
--

--}}}
--{{{ VfsAmax

Function VfsAmax
--
--	uword VfsAmax( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsamax_loop
	   ABSF	*++R_ATMP(R_BASE),	R_A3	   
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 ABSF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vfsamax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsAmax
--

--}}}
--{{{ VdsAmax

Function VdsAmax
--
--	uword VdsAmax( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	LDI	   0,			R_A2
	RPTBD	   vdsamax_loop
	   LDI	   0,			R_A1
	   LDI	 *+R_ATMP(1),		R_A3
	   ABSF	   R_A3
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ABSF	   R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vdsamax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsAmax
--

--}}}
--{{{ VfsAmin

Function VfsAmin
--
--	uword VfsAmin( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsamin_loop
	   ABSF	*++R_ATMP(R_BASE),	R_A3	   
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 ABSF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vfsamin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsAmin
--

--}}}
--{{{ VdsAmin

Function VdsAmin
--
--	uword VdsAmin( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	LDI	   0,			R_A2
	RPTBD	   vdsamin_loop
	   LDI	   0,			R_A1
	   LDI	 *+R_ATMP(1),		R_A3
	   ABSF	   R_A3
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ABSF	   R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vdsamin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsAmin
--

--}}}
--{{{ VfsDot

Function VfsDot
--
--	float VfDot( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		  R_A2,			R_ATMP
	LSH3	     -2,		  R_A4,			R_ADDR1
	MPYF3	   *++R_ATMP(R_BASE),  *++R_ADDR1(R_BASE),	R_A2
	STI	      R_USE,	      *\--R_USP(1)
	SUBI3	      2,		  R_A1,			RC	
	LDF	      0.0,		  R_A4
	RPTBD	      vfsdot_loop
	   STI	      R_BASE,	      *\--R_USP(1)
	   LDI	      R_A3,		  R_BASE
	   LDI	    *+R_USP(2),		  R_USE
vfsdot_loop:
	 MPYF3	   *++R_ATMP(R_BASE),  *++R_ADDR1(R_USE),	R_A2
	 || ADDF3     R_A2,		  R_A4,			R_A4
	ADDF3	      R_A2,		  R_A4,			R_A1
	BuD	      R_LR
	   RND	      R_A1
	   LDI	     *R_USP++(1),	  R_BASE
	   LDI	     *R_USP++(1),	  R_USE
--
-- end of VfsDot
--

--}}}
--{{{ VdsDot

Function VdsDot
--
--	double VdDot( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (double)
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		  R_A2,			R_ATMP
	LSH3	     -2,		  R_A4,			R_ADDR1
	LDF	   *++R_ATMP(R_BASE),	  R_A2
	|| LDF	   *++R_ADDR1(R_BASE),	  R_A4
	SUBI3	      2,		  R_A1,			RC	
	STI	      R_USE,	      *\--R_USP(1)
	LDI	    *+R_ATMP(1),	  R_A2
	|| LDI	    *+R_ADDR1(1),	  R_A4
	MPYF3	      R_A4,		  R_A2,			R_A1
	RPTBD	      vdsdot_loop
	   STI	      R_BASE,	      *\--R_USP(1)
	   LSH3	      1,	          R_A3,			R_BASE
	   LSH3	      1,	        *+R_USP(2),		R_USE         
	 LDF	   *++R_ATMP(R_BASE),	  R_A2
	 || LDF	   *++R_ADDR1(R_USE),	  R_A4
	 LDI	    *+R_ATMP(1),	  R_A2
	 || LDI	    *+R_ADDR1(1),	  R_A4
	 MPYF	      R_A4,		  R_A2
vdsdot_loop:
	 ADDF	      R_A2,		  R_A1
	BuD	      R_LR
	   LDI	     *R_USP++(1),	  R_BASE
	   NOP
	   LDI	     *R_USP++(1),	  R_USE
--
-- end of VfsDot
--

--}}}
--{{{ VfsSum

Function VfsSum
--
--	float VfsSum( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x' 
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	RPTBD	   vfssum_loop
	   LDF	*++R_ATMP(R_BASE), R_A1
	   LDI	   R_USE,	   R_A2
	   LDI	   R_A3,	   R_USE
vfssum_loop:
	 ADDF	*++R_ATMP(R_USE),  R_A1
	BuD	   R_LR
	   RND	   R_A1
	   LDI	   R_A2,	   R_USE
	   NOP
--
-- end of VfsSum
--

--}}}
--{{{ VdsSum

Function VdsSum
--
--	double VdsSum( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	LDF	*++R_ATMP(R_BASE), R_A1
	RPTBD	   vdssum_loop
	   LDI	 *+R_ATMP(1),      R_A1
	   LDI	   R_USE,	   R_A2
	   LSH3	   1,		   R_A3,	R_USE
	 LDF	*++R_ATMP(R_USE),  R_A3
	 LDI	 *+R_ATMP(1),      R_A3
vdssum_loop:
	 ADDF	   R_A3,	   R_A1
	LDI	   R_A2,	   R_USE
	Bu	   R_LR
--
-- end of VdsSum
--

--}}}
--{{{ VfsProd

Function VfsProd
--
--	float VfsProd( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	RPTBD	   vfsprod_loop
	   LDF	*++R_ATMP(R_BASE), R_A1
	   LDI	   R_USE,	   R_A2
	   LDI	   R_A3,	   R_USE
vfsprod_loop:
	 MPYF	*++R_ATMP(R_USE),  R_A1
	BuD	   R_LR
	   RND	   R_A1
	   LDI	   R_A2,	   R_USE
	   NOP
--
-- end of VfsProd
--

--}}}
--{{{ VdsProd

Function VdsProd
--
--	double VdsProd( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	LDF	*++R_ATMP(R_BASE), R_A1
	RPTBD	   vdsprod_loop
	   LDI	 *+R_ATMP(1),      R_A1
	   LDI	   R_USE,	   R_A2
	   LSH3	   1,		   R_A3,	R_USE
	 LDF	*++R_ATMP(R_USE),  R_A3
	 LDI	 *+R_ATMP(1),      R_A3
vdsprod_loop:
	 MPYF	   R_A3,	   R_A1
	LDI	   R_A2,	   R_USE
	Bu	   R_LR
--
-- end of VdsProd
--

--}}}
--{{{ VfsMulAdd

Function VfsMulAdd
--
--	void VfsMulAdd( float value, uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	 most  significant 32 bits of FP number
--	R_A2	 least significant 32 bits of FP number
--	R_A3	 number of elements in arrays 'x' and 'y'
--	R_A4	 byte offset of start of floating point array 'x'
--     *R_USP    distance between elements of 'x' in sizeof (float) units
--    *+R_USP(1) byte offset of start of floating point array 'y'
--    *+R_USP(2) distance between elements of 'y' in sizeof (float) units
--	R_LR	 return address
--	R_BASE	 base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the floating point argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(1),	R_ADDR1
	LDI	     R_A2,		R_A1
	LDI	     R_USE,		R_T1
	MPYF3     *++R_ADDR1(R_BASE),	R_A1,		R_A2
	ADDF	  *++R_ATMP(R_BASE),	R_A2
	RPTBD	     vfsmuladd_loop
	   LDI	   *+R_USP(2),		R_USE
	   LDI	     R_BASE,		R_ADDR2
	   LDI	    *R_USP,		R_BASE
	 RND	     R_A2
	 STF	     R_A2,	       *R_ATMP++(R_BASE)
	 || MPYF3 *++R_ADDR1(R_USE),	R_A1,		R_A2
vfsmuladd_loop:
	 ADDF	    *R_ATMP,		R_A2
        LDI	     R_ADDR2,		R_BASE
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	       *R_ATMP
	   LDI	     R_T1,	        R_USE
--
-- end of VfsMulAdd
--

--}}}
--{{{ VdsMulAdd

Function VdsMulAdd
--
--	void VdsMulAdd( double value, uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	  most  significant 32 bits of FP number
--	R_A2	  least significant 32 bits of FP number
--	R_A3	  number of elements in arrays 'x' and 'y'
--	R_A4	  byte offset of start of double precision array 'x'
--     *R_USP     distance between elements of 'x' in sizeof (double) units
--    *+R_USP(1)  byte offset of start of double precision array 'y'
--    *+R_USP(2)  distance between elements of 'y' in sizeof (double) units
--	R_LR	  return address
--	R_BASE	  base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(1),	R_ADDR1
	LDI	     R_A2,		R_A1
	LDF	  *++R_ADDR1(R_BASE),	R_A2
	|| LDF    *++R_ATMP(R_BASE),	R_A3
	LDI	     R_BASE,		R_ADDR2
	LDI	     R_USE,		R_T1
	LSH3	     1,		      *+R_USP(0),	R_BASE
	RPTBD	     vdsmuladd_loop
	   LSH3	     1,		      *+R_USP(2),	R_USE
	   LDI	   *+R_ADDR1(1),	R_A2
	   || LDI  *+R_ATMP(1),		R_A3
	   MPYF      R_A1,		R_A2
	 ADDF	     R_A3,	        R_A2
	 STI	     R_A2,	      *+R_ATMP(1)
	 STF	     R_A2,	       *R_ATMP++(R_BASE)
	 LDF	  *++R_ADDR1(R_USE),	R_A2
	 || LDF     *R_ATMP,		R_A3
	 LDI	   *+R_ADDR1(1),	R_A2
	 || LDI    *+R_ATMP(1),		R_A3
vdsmuladd_loop:
	 MPYF        R_A1,		R_A2
	ADDF	     R_A3,		R_A2
	STI	     R_A2,	      *+R_ATMP(1)
	BuD	     R_LR
	   STF	     R_A2,	       *R_ATMP
	   LDI	     R_ADDR2,	        R_BASE
	   LDI	     R_T1,		R_USE
--
-- end of VdMulAdd
--

--}}}

--}}}
--{{{ Initialisation

init
	Bu	R_LR

--}}}

        EndModule

