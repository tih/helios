


libInterViews(3I)   UNIX Programmer's Manual    libInterViews(3I)



NAME
     libInterViews - base InterViews library

SYNOPSIS
     #include <InterViews/_c_l_a_s_s.h>
     CC ... -lInterViews -lX -lm

DESCRIPTION
     InterViews is a collection of C++ classes  for  implementing
     user   interfaces.   All  interactive  objects  are  derived
     directly or indirectly from the Interactor class.  All  com-
     posite   interactive   objects   are   derived  directly  or
     indirectly from the Scene class,  which  itself  is  derived
     from Interactor. Subclasses include Box(3I) and Glue(3I) for
     tiling  interactors,  Tray(3I)   for   overlapping/aligning,
     Frame(3I)  for  decorating a single interactor, Deck(3I) for
     paging through a list  of  interactors  (one  visible  at  a
     time),  Viewport(3I)  for  scrolling/panning around a larger
     interactor, Scroller(3I) for a simple scrollbar,  Panner(3I)
     for  2-D scrolling and zooming, and Menu(3I) for simple pop-
     up menus.  An instance of the World(3I) subclass is used  to
     map interactors onto a display.

     A number of classes are provided for graphics input and out-
     put.    These   include   Canvas(3I)  for  display  regions;
     Painter(3I) for drawing  operations;  Brush(3I),  Color(3I),
     Font(3I),  and  Pattern(3I) for controlling graphics charac-
     teristics; Cursor(3I) for the screen appearance of a  point-
     ing  device;  Event(3I) for input events, and Sensor(3I) for
     expressing  interest  in   a   set   of   possible   events;
     Rubberband(3I)  objects  for interactive dragging and place-
     ment.

     The basic InterViews library  includes  the  above  classes.
     The  _l_i_b_g_r_a_p_h_i_c(3I)  library  provides  an additional set of
     classes for defining structured graphics and storing graphi-
     cal  objects  in  files.   The  _l_i_b_t_e_x_t(3I) library provides
     classes for manipulating structured  and  unstructured  text
     objects.

     All InterViews header files include  the  following  defini-
     tions from ``<InterViews/defs.h>'':

     typedef int Coord;
          Display coordinates are represented uniformly as 32-bit
          integers;  however, the units depend on context because
          of the possibility of coordinate  transformations  (see
          Painter(3I)).   The  predefined  variables  cm, inches,
          pixels, and points  should  be  used  as  units  if  no
          transformations        are        present        (e.g.,
          ``Coord x = 3*inches'').   This  convention  makes  the
          coordinate  values  independent  of  screen resolution.



Printed 4/10/90           31 July 1988                          1






libInterViews(3I)   UNIX Programmer's Manual    libInterViews(3I)



          The variables inch  and  point  are  also  provided  as
          synonyms for inches and points, respectively.

     typedef enum { true = 1, false = 0 } boolean;

     typedef enum {
          TopLeft, TopCenter, TopRight
          CenterLeft, Center, CenterRight
          BottomLeft, BottomCenter, BottomRight
          Left, Right, Top, Bottom
     } Alignment;

     #define nil 0

     int min(int, int), int max(int, int)
          Return the minimum and maximum of two integers, respec-
          tively.

     int round(double)
          Return the integer closest to its argument.

SEE ALSO
     libgraphic(3I), libtext(3I)
































Printed 4/10/90           31 July 1988                          2






Adjuster(3I)        UNIX Programmer's Manual         Adjuster(3I)



NAME
     Adjuster - button-like interactors for incremental scrolling
     and zooming

SYNOPSIS
     #include <InterViews/adjuster.h>

DESCRIPTION
     Adjuster  objects   manipulate   a   perspective   using   a
     pushbutton-like  interface.  Adjusters also provide an auto-
     repeat capability.  Depressing and holding  down  any  mouse
     button  on  an  adjuster  for  a specified time causes it to
     repeatedly perform  its  operation.   The  auto-repeat  ter-
     minates when the button is released.

     Predefined subclasses of Adjuster include Zoomer and  Mover.
     Zoomers  adjust  the  perspective's  _c_u_r_w_i_d_t_h  and _c_u_r_h_e_i_g_h_t
     members to suggest magnification.  The user clicks on a zoo-
     mer  to  magnify  or  reduce  the contents of the interactor
     through  its  perspective.   The  Enlarger  zoomer  subclass
     halves  the  perspective values while the Reducer class dou-
     bles them. Movers provide an  incremental  movement  of  the
     perspective in one of four directions; left, right, down, or
     up.  The user clicks on a mover to move the perspective.

PUBLIC OPERATIONS
     Adjuster(Interactor*, Bitmap*, int = NO_AUTOREPEAT)
          Adjuster constructors take a pointer to the  interactor
          whose perspective will be adjusted, a pointer to a bit-
          map defining the adjuster's appearance, and a delay (in
          tenths  of a second) after which auto-repeat will begin
          once the adjuster is ``pressed''.

     virtual void Highlight()
     virtual void UnHighlight()
          These functions define how the  adjuster  draws  itself
          when  it  is pressed.  The adjuster is highlighted when
          it is pressed with any mouse button  and  unhighlighted
          when  the button is released.  The default is to invert
          the bitmap when highlighted.

PROTECTED OPERATIONS
     virtual void AdjustView(Event&)
          This function defines  how  the  adjuster  adjusts  the
          interactor's  perspective.   It  is  called  after  the
          adjuster is pressed and released, or repeatedly  during
          auto-repeat.   Derived  classes  should  redefine  this
          function to implement the desired behavior.

DERIVED CLASSES
     Enlarger(Interactor*)
     Reducer(Interactor*)



Printed 4/10/90          15 January 1988                        1






Adjuster(3I)        UNIX Programmer's Manual         Adjuster(3I)



          Enlargers and reducers adjust an interactor's  perspec-
          tive  to enlarge and reduce the visible area by factors
          of one half and two, respectively.  This suggests to an
          interactor  to  enlarge  or  reduce its contents. Auto-
          repeat is disabled on these adjusters.

     LeftMover(Interactor*, int delay = NO_AUTOREPEAT)
     RightMover(Interactor*, int delay = NO_AUTOREPEAT)
     DownMover(Interactor*, int delay = NO_AUTOREPEAT)
     UpMover(Interactor*, int delay = NO_AUTOREPEAT)
          These subclasses of Mover adjust the current origin  of
          the  interactor's  perspective  by  an  amount  in  the
          corresponding direction.  If  the  shift  key  is  down
          while  the  mover is pressed, the amount corresponds to
          the perspective's _l_x or _l_y member variables; otherwise,
          the _s_x or _s_y values are used.

SEE ALSO
     Bitmap(3I), Interactor(3I), Perspective(3I)




































Printed 4/10/90          15 January 1988                        2






Banner(3I)          UNIX Programmer's Manual           Banner(3I)



NAME
     Banner - one line title bar

SYNOPSIS
     #include <InterViews/banner.h>

DESCRIPTION
     A banner is an interactor that draws a one  line  title  bar
     with  optional left-justified, centered, and right-justified
     headings.  The member variable _h_i_g_h_l_i_g_h_t can be set to cause
     drawing  to  be performed with the foreground and background
     colors reversed.

     The natural size of a banner depends  on  the  size  of  its
     headings.   Banners are infinitely stretchable horizontally,
     but fixed size vertically.

PUBLIC OPERATIONS
     Banner(char* left, char* middle, char* right)
          The _l_e_f_t string  will  be  left-justified,  the  _m_i_d_d_l_e
          string  centered,  and  _r_i_g_h_t string right-justified in
          the banner.  A header can be omitted by passing  a  nil
          string.

     void Update()
          The strings can be set through the  _l_e_f_t,  _m_i_d_d_l_e,  and
          _r_i_g_h_t member variables.  The Update operation should be
          called after one or more of the strings is changed.

SEE ALSO
     Interactor(3I)
























Printed 4/10/90           15 June 1987                          1






Bitmap(3I)          UNIX Programmer's Manual           Bitmap(3I)



NAME
     Bitmap - bit mapped data

SYNOPSIS
     #include <InterViews/bitmap.h>

DESCRIPTION
     A _B_i_t_m_a_p is a two-dimensional array of boolean values.  Bit-
     maps  can  be used in Painter operations or to define window
     manager icons for top-level  Interactors.   Bitmaps  can  be
     constructed  from  data  contained in a file, from data sup-
     plied by the application program, or from a font  character.
     Operations  include  geometric  transformations,  common bit
     transformations,   and   individual    bit    manipulations.
     Geometric  transformations and painting operations are rela-
     tive to an _o_r_i_g_i_n.

PUBLIC OPERATIONS
     Bitmap(const char* filename)
          Create a bitmap from the named file.  The  file  format
          is that produced by the X bitmap(3X) program.  The bit-
          map origin will be the _h_o_t _s_p_o_t specified by  the  file
          or  the lower left corner if the file does not define a
          hot spot.

     Bitmap(void* data, int width, int height, int x0 = 0, int y0 = 0)
          Create a bitmap from the data specified.  The data for-
          mat is the same as that  of  a  bitmap(3X)  file.   The
          coordinates  _x_0  and _y_0 specify the bitmap origin.  The
          data is transferred into an internal format, so  subse-
          quent  changes  in either the passed data or the bitmap
          will not affect the other.  Passing a  nil  pointer  to
          _d_a_t_a  is equivalent to passing an array with all values
          set to _f_a_l_s_e.

     Bitmap(Font* font, int character)
          Create a bitmap from the given character of  the  font.
          The  bitmap  width  and  height will reflect the actual
          size of the character glyph and will not usually  equal
          the  width and height of the character cell as reported
          by operations on the Font.  The bitmap origin is set to
          the character origin.

     Bitmap(Bitmap*)
          Create a copy of the given bitmap.

     int Left()
     int Right()
     int Top()
     int Bottom()
     int Width()
     int Height()



Printed 4/10/90           24 April 1989                         1






Bitmap(3I)          UNIX Programmer's Manual           Bitmap(3I)



          These operations return the size and bounds of the bit-
          map.

     void Transform(Transformer)
     void Scale(float x, float y)
     void Rotate(float angle)
          Transform the bitmap in place.  _S_c_a_l_e and  _R_o_t_a_t_e  pro-
          vide  convenient  interfaces to common transformations.
          Transformations are relative to the bitmap origin.

     void FlipHorizontal()
     void FlipVertical()
     void Rotate90()
     void Rotate180()
     void Rotate270()
     void Invert()
          Perform an operation on the bitmap data.   _F_l_i_p_H_o_r_i_z_o_n_-
          _t_a_l  and _F_l_i_p_V_e_r_t_i_c_a_l reflect the data about its verti-
          cal or  horizontal  center  respectively.   The  _R_o_t_a_t_e
          functions  move  the data in a counter-clockwise direc-
          tion about the bitmap center.  _I_n_v_e_r_t toggles each  bit
          in  the  bitmap.   In  each  case, the bitmap origin is
          unchanged.

     boolean Peek(int x, int y)
     void Poke(boolean bit, int x, int y)
     boolean Contains(int x, int y)
          Operations for reading and writing individual  bits  in
          the  bitmap.   If  the  specified  coordinates  are not
          within the bitmap  bounds,  _C_o_n_t_a_i_n_s  and  _P_e_e_k  return
          false, and _P_o_k_e has no effect.

SEE ALSO
     Painter(3I), Transformer(3I)





















Printed 4/10/90           24 April 1989                         2






Border(3I)          UNIX Programmer's Manual           Border(3I)



NAME
     Border, HBorder, VBorder - visual separators

SYNOPSIS
     #include <InterViews/border.h>

DESCRIPTION
     Border is the base class for interactors that simply display
     a  line  of  a  given  thickness,  usually to separate other
     interactors in a scene.  HBorder objects have a fixed height
     and  are infinitely stretchable and shrinkable horizontally.
     VBorder objects  have  a  fixed  width  and  are  infinitely
     stretchable and shrinkable vertically.

PUBLIC OPERATIONS
     HBorder(int thickness = 1)
     VBorder(int thickness = 1)
          Construct a border with a given thickness  (default  is
          one pixel).

SEE ALSO
     Interactor(3I)

































Printed 4/10/90           15 June 1987                          1






Box(3I)             UNIX Programmer's Manual              Box(3I)



NAME
     Box, HBox, VBox - tile interactors in a box

SYNOPSIS
     #include <InterViews/box.h>

DESCRIPTION
     A box is a scene of interactors that are tiled  side-by-side
     in  the  available  space.   Interactors are placed left-to-
     right in a horizontal box, and top-to-bottom in  a  vertical
     box.

     A box will try to stretch or shrink the  interactors  inside
     it to fit the available space.  The natural size of a box is
     the sum of its elements along the major axis, and  the  max-
     imum along its minor axis.  A box's stretchability (shrinka-
     bility) is the sum of its elements along its major axis  and
     the minimum of its elements along its minor axis.

PUBLIC OPERATIONS
     HBox(...)
     VBox(...)
          Create a new box.  Zero to  seven  interactors  may  be
          passed  as arguments; the interactors are inserted into
          the box.

     void Align(Alignment)
          Set the alignment mode that the box uses to place  ele-
          ments  along the minor axis.  The default alignment for
          an hbox is _B_o_t_t_o_m; other choices are  _T_o_p  and  _C_e_n_t_e_r.
          The default alignment for a vbox is _L_e_f_t; other choices
          are _R_i_g_h_t and _C_e_n_t_e_r.

     void Insert(Interactor*)
          Append an interactor to the box.  Components of an hbox
          (vbox) will appear left-to-right (top-to-bottom) in the
          order in which they are inserted.

     void Change(Interactor*)
          Notify the box that the given  interactor's  shape  has
          changed.   If  change propagation is true, the box will
          modify its own shape to reflect the change  and  notify
          its  parent.   Regardless  of propagation, the box will
          recompute the positions of  the  component  interactors
          and update any that have changed.

     void Remove(Interactor*)
          Take an element of out a box.  Remove  does  not  cause
          any  immediate  change  to  the other components in the
          box; the Change operation must be called after  one  or
          more Removes to update the component positions.




Printed 4/10/90           15 June 1987                          1






Box(3I)             UNIX Programmer's Manual              Box(3I)



SEE ALSO
     Glue(3I), Interactor(3I), Scene(3I), Shape(3I)





















































Printed 4/10/90           15 June 1987                          2






Brush(3I)           UNIX Programmer's Manual            Brush(3I)



NAME
     Brush - line style and width for a painter

SYNOPSIS
     #include <InterViews/brush.h>

DESCRIPTION
     A Brush defines the thickness and pattern for drawing lines.
     The  global  variable  ``single'' is for drawing solid lines
     that are one pixel wide.

PUBLIC OPERATIONS
     Brush(int linestyle, int width = 1)
          Define a brush with a given 32-bit pattern  and  width.
          Wide brushes are not particularly portable to different
          graphics  systems;  therefore  filled   rectangles   or
          polygons  should be used where possible.  A brush width
          of 0 means to use a fast, possibly device-dependent one
          pixel wide line-drawing algorithm.

     int Width()
          Return the brush's width in pixels.

SEE ALSO
     Painter(3I)






























Printed 4/10/90           15 June 1987                          1






Button(3I)          UNIX Programmer's Manual           Button(3I)



NAME
     ButtonState, Button,  TextButton,  PushButton,  RadioButton,
     CheckBox - interactive buttons

SYNOPSIS
     #include <InterViews/button.h>

DESCRIPTION
     Button is a class of interactors that can set the value of a
     piece of state.  ButtonState is a class of objects that con-
     tain a value and a list of buttons that can set  its  value.
     A value is either an integer or an arbitrary pointer.

     TextButton is a subclass of Button that  has  an  associated
     text  label  to  be  displayed inside or to the right of the
     button.  PushButton, RadioButton,  and  CheckBox  are  subc-
     lasses  of  TextButton  that provide particular displays for
     buttons.  Each kind  of  button  will  display  itself  dif-
     ferently  for  each of the five possible cases: ``enabled'',
     when the button is listening to  input,  ``disabled'',  when
     the  button  is not listening, ``chosen'', when the button's
     value is equal to its button state's value, ``hit'', when  a
     button  that  is  not chosen first receives a DownEvent, and
     ``same-hit'', when  a  button  that  is  chosen  receives  a
     DownEvent.

     When a button receives a DownEvent,  it  calls  the  virtual
     Refresh()  to update its display.  It then reads input wait-
     ing for an UpEvent.  If the  UpEvent  coordinates  are  also
     within  the  button, then it calls the virtual Press().  The
     default Press operation sets the associated state's value to
     the button's value.

     A button can have a list of attached buttons.  When a button
     is not chosen its attached buttons are ``disabled'', meaning
     they ignore all input events.

BUTTONSTATE OPERATIONS
     ButtonState()
     ButtonState(int)
     ButtonState(void*)
          Define a button state optionally with an initial value.

     void Attach(Button*)
          Add a button to  the  list  associated  with  a  button
          state.   The  button  will  be notified when the button
          state's value is modified.

     void Detach(Button*)
          Remove a button from the list associated with a  button
          state.




Printed 4/10/90           15 June 1987                          1






Button(3I)          UNIX Programmer's Manual           Button(3I)



     void GetValue(int&)
     void GetValue(void*&)
          Get the value of a button.

     void SetValue(int)
     void SetValue(void*)
          Set the value of a button state and notify all the but-
          tons associated with the state.

     void operator=(ButtonState&)
          Copy the value of one button  state  to  another.   The
          button  list associated with the source button state is
          not copied.

BUTTON OPERATIONS
     void PushButton(const char* text, ButtonState* s, int v)
     void PushButton(const char* text, ButtonState* s, void* v)
          Construct a button  with  _t_e_x_t  in  the  center  and  a
          polygon  on the outside.  The polygon is like a rectan-
          gle, but with rounded corners.  When chosen, the entire
          button  is  drawn with foreground and background colors
          reversed.

     void RadioButton(const char* text, ButtonState* s, int v)
     void RadioButton(const char* text, ButtonState* s, void* v)
          Construct a button with a circle on the left  and  _t_e_x_t
          on  the  right.   When  hit,  a  second circle is drawn
          inside the first.  When  chosen,  a  filled  circle  is
          drawn inside the outer circle.

     void CheckBox(const char* text, ButtonState* s, int on, int off)
off)
     void  CheckBox(const  char* text, ButtonState* s, void* on, void*
          Construct  a  button  with  a rectangle on the left and
          _t_e_x_t on the right.  When hit,  a  second  rectangle  is
          drawn  inside  the  first.   When  chosen, two diagonal
          lines are drawn connecting the opposite corners of  the
          rectangle.   When a checkbox is pressed the first time,
          it sets _s to _o_f_f if the value is _o_n and sets  _s  to  _o_n
          otherwise.   Subsequent  presses swap the values of the
          checkbox and _s.

     void Attach(Button*)
          Add to this button's list of associated buttons.  These
          buttons  are enabled when the button is chosen and dis-
          abled when it is not chosen.

     void Detach(Button*)
          Remove a button from this button's list  of  associated
          buttons.

     void Disable()



Printed 4/10/90           15 June 1987                          2






Button(3I)          UNIX Programmer's Manual           Button(3I)



          Stop listening to input events.  Disabled  buttons  are
          typically  ``grayed out'' by drawing a half-filled rec-
          tangle in the background.

     void Enable()
          Start listening to input events.

     void Choose()
          Make the button as chosen, enabling any associated but-
          tons.

     void Handle(Event&)
          If the event  type  is  DownEvent  and  the  button  is
          enabled,  call Refresh and read events until an UpEvent
          occurs.  If the button is the target  of  the  UpEvent,
          then call Press.

     virtual void Press()
          Take  the  appropriate  action  for  the  button  being
          pressed.  The default is to set the associated state to
          the button's value, which will trigger all related but-
          tons to update their display.

     virtual void Refresh()
          Update the button display.

     void SetDimensions(int width, int height)
          Specify the natural size of the  button.   The  default
          size  is a function of the size of the text.  This rou-
          tine is obsolete; use Interactor::Reshape instead.

     void UnChoose()
          Mark the button as not chosen, disabling any associated
          buttons.

SEE ALSO
     Event(3I), Interactor(3I)


















Printed 4/10/90           15 June 1987                          3






Canvas(3I)          UNIX Programmer's Manual           Canvas(3I)



NAME
     Canvas - region for graphics output

SYNOPSIS
     #include <InterViews/canvas.h>

DESCRIPTION
     A canvas is an area for graphics output associated  with  an
     interactor.   Most  interactors  do  not need to perform any
     operations on a canvas; they simply  pass  a  canvas  as  an
     argument  to  graphics  operations.  In this case, it is not
     necessary to include ``canvas.h''.

PUBLIC OPERATIONS
     Canvas(int width, int height)
          Create an offscreen canvas  with  the  given  size  and
          height.

     void Clip(Coord, Coord, Coord, Coord)
          Clip drawing to the canvas to the given rectangle.

     void ClipOn()
     void ClipOff()
          Temporarily turn use of a canvas' clipping rectangle on
          or off.

     int Height()
          Return the height of a canvas in pixels.

     boolean IsClipped()
          Return  whether  output  to  the  canvas  is  currently
          clipped.

     void NoClip()
          Delete the clipping rectangle for with a canvas.

     void SetBackground(Color*)
          Associate a background color with the canvas.

     CanvasStatus Status()
          Return the current status of a canvas, which is one  of
          CanvasMapped  (assigned  an  area on the display), Can-
          vasUnmapped (not assigned an area), and CanvasOffscreen
          (assigned an area in offscreen memory).

     int Width()
          Return the width of a canvas in pixels.

SEE ALSO
     Interactor(3I), Painter(3I)





Printed 4/10/90           15 June 1987                          1






ChiefDeputy(3I)     UNIX Programmer's Manual      ChiefDeputy(3I)



NAME
     ChiefDeputy - buffer communication with remote object space

SYNOPSIS
     #include <InterViews/chief.h>

DESCRIPTION
     A chief deputy mutiplexes communication with a remote object
     space across a single connection.

PUBLIC OPERATIONS
     ChiefDeputy(Connection*)
          Construct a chief deputy that sends messages  over  the
          given connection.

     ObjectTag Tag()
          The tag for a chief deputy corresponds  to  the  remote
          object space itself, whose tag is by convention zero.

     Connection* GetServer()
          Return the connection associated with the remote object
          space.

     void Alloc(void*& dst, ObjectTag, int op, int len)
          Allocate a message in the buffer.

     int PackString(const char*, void* msg)
     int PackString(const char*, int len, void* msg)
          Put a string or substring into a message  buffer.   The
          buffer area is assumed to have already been allocated.

     void Msg(ObjectTag, int op)
     void StringMsg(ObjectTag, int op, const char*)
     void IntegerMsg(ObjectTag, int op, int val)
          Short-hand for allocating a message and storing  fields
          in  the cases where a message has no parameters, a sin-
          gle string parameter, or a single integer parameter.

     void Sync()
          Force all messages to be  sent  to  the  remote  object
          space.

     int ReadReply(void* reply, int len)
     void GetReply(void* reply, int len)
     void GetString(const char*& str, int len)
          Read a reply from the object space, first flushing  any
          messages  in  the buffer.  ReadReply returns the actual
          size of the reply from the object space.  GetReply will
          abort if the size is not the size requested.  GetString
          will first read the size  of  a  string  and  then  the
          string itself.




Printed 4/10/90            29 May 1989                          1






ChiefDeputy(3I)     UNIX Programmer's Manual      ChiefDeputy(3I)



SEE ALSO
     ChiefDeputy(3i), ObjectSpace(3i)





















































Printed 4/10/90            29 May 1989                          2






Color(3I)           UNIX Programmer's Manual            Color(3I)



NAME
     Color - colors for a painter

SYNOPSIS
     #include <InterViews/color.h>

DESCRIPTION
     A Color defines a mix of rgb (red, green, and blue) intensi-
     ties.  The global variables ``black'' and ``white'' point to
     predefined colors of zero and full intensity output, respec-
     tively.  Note that the displayed intensities of a color will
     depend on the characteristics of the workstation.

PUBLIC OPERATIONS
     Color(const char* name)
          Construct a  color  with  intensities  associated  with
          _n_a_m_e.

     Color(int red, int green, int blue)
          Construct a color with the specified  red,  green,  and
          blue  intensities.  Zero represents no intensity; 65535
          represents full intensity.

     Color(int entry)
          Construct a color with intensities  associated  with  a
          color map entry.

     void Intensities(int& red, int& green, int& blue)
          Get the intensities used to create the color.

     void DisplayIntensities(int& red, int& green, int& blue)
          Get the intensities used to display the color.

     int PixelValue()
          Return the color's index in its color map.

     boolean Valid()
          Return whether the color is meaningful.  This call  can
          be  used after Color(name) to see if the name is recog-
          nized as a color.

SEE ALSO
     Painter(3I)












Printed 4/10/90           15 June 1987                          1






Connection(3I)      UNIX Programmer's Manual       Connection(3I)



NAME
     Connection - interprocess communication

SYNOPSIS
     #include <InterViews/connection.h>

DESCRIPTION
     Connection provides a simple interface to interprocess  com-
     munication.   A  general  connection  can  be  made  between
     processes on the same or different machines.  A  local  con-
     nection  can  only  be  made  between  processes on the same
     machine.

PUBLIC OPERATIONS
     Connection()
     ~Connection()
          Construct a connection, initially not  associated  with
          any process.

     Connection(int)
          Construct a connection associated with the  given  Unix
          file descriptor.

     void CreateService(const char* host, int port)
     void CreateLocalService(const char*)
          Create  a  connection  and  bind  it  to  a  particular
          address.   In  the general case, the address is defined
          by the host name and  Internet  port  number.   In  the
          local case, a string name is used.

     boolean OpenService(const char* host, int port)
     boolean OpenLocalService(const char*)
          Establish a connection with  another  process.   It  is
          assumed  the  process  has already created the service.
          If no connection can be made, the open functions return
          false.

     Connection* AcceptClient()
          Create  a  new  connection  for  communicating  with  a
          client.  AcceptClient is called by servers that receive
          input on a general service connection.

     int Pending()
          Return the number of bytes waiting to be  read  from  a
          connection.

     int Read(void* buf, int n)
          Read up to _n bytes from the connection into _b_u_f  Return
          the actual number of bytes read.

     int Write(const void* buf, int n)
          Write _n bytes from _b_u_f to the connection.   Return  the



Printed 4/10/90            29 May 1989                          1






Connection(3I)      UNIX Programmer's Manual       Connection(3I)



          actual number of bytes written.

     int WritePad(const void* buf, int n, int pad)
          Write _p_a_d bytes to the connection.  The first  _n  bytes
          are  from  _b_u_f,  any  remaining  are  zero.  Return the
          actual number of bytes written.

     int Descriptor()
          Return the file descriptor associated with the  connec-
          tion.

     void Close()
          Close the connection.  Subsequent operations,  such  as
          Read and Write, will return an error code of -1.









































Printed 4/10/90            29 May 1989                          2






Cursor(3I)          UNIX Programmer's Manual           Cursor(3I)



NAME
     Cursor - pointing device image

SYNOPSIS
     #include <InterViews/cursor.h>

DESCRIPTION
     A cursor specifies the image that tracks a pointing device's
     position.   Cursors  are  defined by two bitmaps and a ``hot
     spot''.  A mask bitmap specifies  which  pixels  are  to  be
     drawn,  and  a  pattern bitmap specifies which pixels are in
     foreground color and which in  background  color.   The  hot
     spot  specifies the location of the pointing device relative
     to the cursor's lower-left corner.  A number of common  cur-
     sors  are  predefined  and can be referenced by global vari-
     ables declared in the include file.  These include ``arrow''
     (pointing  to upper left), ``ltextcursor'' (an `I' text cur-
     sor with hot spot on the left), ``rtextcursor'' (hot spot on
     the right), ``lowerleft'' (an `L'), ``lowerright'' (mirrored
     `L'),  ``upperleft''   (upside-down   `L'),   ``upperright''
     (upside-down  and mirrored `L'), ``crosshairs'', and ``hour-
     glass''.

PUBLIC OPERATIONS
     typedef int CursorPattern[cursorHeight];

Color* f, Color* b)
     Cursor(short x, short y, CursorPattern pat,  CursorPattern  mask,
          Create  a  cursor with the given data and a hot spot at
          (_x, _y).  Ones in _p_a_t specify  pixels  which  should  be
          displayed  in  the foreground color _f and zeros specify
          pixels which should be in the background color _b.  Ones
          in  _m_a_s_k  specify  which pixels should be visible.  The
          first pattern element defines the topmost row  of  pix-
          els,  and  the  least  significant  bit of each element
          defines the rightmost column.

     Cursor(Bitmap* pat, Bitmap* mask, Color* f, Color* b)
          Create a cursor from the given bitmaps.  The  hot  spot
          is set to the origin of the _p_a_t bitmap.

     Cursor(Font*, int pat, int mask, Color* f, Color* b)
          Create a cursor from font glyphs.  _P_a_t and _m_a_s_k are the
          font characters to use as the pattern and mask bitmaps,
          respectively.  The hot spot is  set  to  the  character
          origin.

     Cursor(int id, Color* f, Color* b)
          Create a ``standard''  cursor  using  a  window  system
          specific  identifier.  Particular values of _i_d are usu-
          ally defined in an include file.  For example, standard
          X11 cursors are defined in the file <X11/cursorfont.h>.



Printed 4/10/90           15 June 1987                          1






Deck(3I)            UNIX Programmer's Manual             Deck(3I)



NAME
     Deck - a stack of interactors on top of each other

SYNOPSIS
     #include <InterViews/deck.h>

DESCRIPTION
     A deck is a scene containing interactors that are  conceptu-
     ally  stacked  on top of each other.  Only one interactor is
     visible at a time.  A deck is useful to implement ``paging''
     through  a  document,  or  where only one of several similar
     components should be visible at a time, as  in  applications
     using   alternate  tool  pallets  or  menus  with  alternate
     entries.

     A deck will try to stretch or shrink the visible  interactor
     to  fill the total space.  The natural size of a deck is the
     maximum of its components.

     A deck uses its _p_e_r_s_p_e_c_t_i_v_e to specify  which  component  is
     visible.   The components are numbered in the order in which
     they are inserted into  the  deck,  starting  with  one.   A
     scroller  or other interactor which operates on the perspec-
     tive can be used to allow a user to specify the component to
     view.  Either horizontal or vertical scrolling can be used.

PUBLIC OPERATIONS
     Deck()
          Construct a new deck.

     void Insert(Interactor*)
          Add an interactor to the deck.

     void Change(Interactor*)
          Notify the deck that an interactor's shape has changed.
          If propagation is on, the deck recomputes its own shape
          and notifies its parent.

     void Remove(Interactor*)
          Take an interactor out of a deck.

     void Flip(int count = 1)
     void FlipTo(int position)
     void Top()
     void Bottom()
          Perform operations on the perspective  to  specify  the
          component  to view.  Flip specifies the component rela-
          tive to the current component.   A  positive  value  of
          _c_o_u_n_t specifies a component nearer to the ``bottom'' of
          the deck (the components inserted last), and a negative
          value  specifies  a  component  nearer  to the ``top''.
          FlipTo specifies a component by its  absolute  position



Printed 4/10/90         13 December 1987                        1






Deck(3I)            UNIX Programmer's Manual             Deck(3I)



          in  the deck.  A positive value of _p_o_s_i_t_i_o_n specifies a
          position from the top, starting at 1.  A negative value
          specifies  a  position from the bottom, starting at -1.
          Top  and  Bottom  are  equivalent  to   FlipTo(1)   and
          FlipTo(-1) respectively.

SEE ALSO
     Interactor(3I), Scene(3I), Shape(3I)















































Printed 4/10/90         13 December 1987                        2






Deputy(3I)          UNIX Programmer's Manual           Deputy(3I)



NAME
     Deputy - pack and send remote messages

SYNOPSIS
     #include <InterViews/deputy.h>

DESCRIPTION
     A deputy object performs operations on  remote  objects.   A
     caller  performs a local call on the deputy, which packs the
     parameters into a message.  Deputies place the message  into
     a  buffer managed by a ChiefDeputy(3i), which then take care
     of sending the message to the remote space.

PUBLIC OPERATIONS
     Deputy()
     Deputy(ChiefDeputy*)
          Construct a deputy,  optionally  specifying  the  chief
          deputy  that will manage the message buffer.  The chief
          deputy is accessible through a protected member _c_h_i_e_f.

     void Sync()
          Force all messages to be  sent  to  the  remote  object
          space.   Without  doing  a  Sync, messages are buffered
          locally to reduce message-passing overhead.

     ObjectTag Tag()
          Return a tag to use in messages to identify the  remote
          object.   Because  the client defines the tag, a deputy
          uses its address (this pointer) as its tag.

     Connection* GetServer()
          Return  the  connection  associated  with  the   remote
          object.

SEE ALSO
     ChiefDeputy(3i), ObjectSpace(3i)



















Printed 4/10/90            29 May 1989                          1






Dialog(3I)          UNIX Programmer's Manual           Dialog(3I)



NAME
     Dialog - popup dialog interactor

SYNOPSIS
     #include <InterViews/dialog.h>

DESCRIPTION
     A dialog is an interactor that handles input  for  a  dialog
     box.   The dialog layout is specified by a separate interac-
     tor passed to the dialog constructor.  The dialog  completes
     when  the  value  of an associated button state becomes non-
     zero.  This button state is typically set  by  one  or  more
     buttons in the component interactor.

PUBLIC OPERATIONS
     Dialog(ButtonState*, Interactor*, Alignment = Center)
          Construct a new dialog with the given button state  and
          interactor.   The alignment is used by the Popup opera-
          tion.

     virtual boolean Accept()
          Set the dialog button state to zero  and  loop  reading
          events until the button state's value becomes non-zero.
          Each event is passed to is target's  Handle  operation.
          Return true if the value is one, false otherwise.

     virtual boolean Popup(Event&, boolean placed = true)
          Insert the dialog into the world  associated  with  the
          given  event.   If  _p_l_a_c_e_d  is  true,  align the dialog
          around the event's (_x, _y) coordinate.   Otherwise,  the
          dialog  is  inserted  without  specifying  a  position.
          Popup then calls the Accept operation and  returns  its
          value.

SEE ALSO
     Button(3I), Interactor(3I), World(3I)



















Printed 4/10/90          11 August 1988                         1






Event(3I)           UNIX Programmer's Manual            Event(3I)



NAME
     Event - input events

SYNOPSIS
     #include <InterViews/event.h>

DESCRIPTION
     Events represent user input.  The _t_a_r_g_e_t field of  an  event
     indicates  the interactor whose current sensor is interested
     in the event.  For keyboard and button events, the _t_i_m_e_s_t_a_m_p
     field indicates when the event occured and the (_x, _y) fields
     contain the coordinates of the input pointing  device  rela-
     tive  to  the target interactor.  The _e_v_e_n_t_T_y_p_e field speci-
     fies what kind of event occurred.  The  following  types  of
     events are possible:

     MotionEvent
          The position of the pointing device changed.

     DownEvent
     UpEvent
          The _b_u_t_t_o_n field identifies a button that  was  pressed
          or released.  The constants LEFTMOUSE, MIDDLEMOUSE, and
          RIGHTMOUSE identify up to three buttons on the pointing
          device.   The fields _l_e_f_t_m_o_u_s_e, _m_i_d_d_l_e_m_o_u_s_e, and _r_i_g_h_t_-
          _m_o_u_s_e are _t_r_u_e if the corresponding button is currently
          down as well (so chording can be handled).

     KeyEvent
          A key is pressed.  Since many keyboards do not  support
          up  events  for  arbitrary  keys; no event is generated
          when the key is released.  The  _b_u_t_t_o_n  field  contains
          the  key  code.  The _k_e_y_s_t_r_i_n_g field points to a string
          of length _l_e_n that represents the ASCII mapping of  the
          key.   The  fields  _c_o_n_t_r_o_l, _m_e_t_a, _s_h_i_f_t, and _s_h_i_f_t_l_o_c_k
          are _t_r_u_e if the corresponding key is currently down.

     OnEvent
     OffEvent
          The pointing device enters or leaves the canvas associ-
          ated with the target interactor.

     ChannelEvent
          Data is available on the file descriptors identified in
          the  _c_h_a_n_n_e_l  field.  The field is a bitset, with bit 0
          set if data is ready on file descriptor 0, bit 1 set if
          data ready on file descriptor 1, etc.

     TimerEvent
          The time  limit  defined  by  the  sensor  has  expired
          without any input events occurring.




Printed 4/10/90         11 December 1987                        1






Event(3I)           UNIX Programmer's Manual            Event(3I)



PUBLIC OPERATIONS
     void GetAbsolute(Coord& x, Coord& y)
     void GetAbsolute(World*&, Coord& x, Coord& y)
          GetAbsolute computes the event coordinates relative  to
          the root scene and optionally assigns a pointer to that
          root scene.

SEE ALSO
     Sensor(3I), World(3I)














































Printed 4/10/90         11 December 1987                        2






Font(3I)            UNIX Programmer's Manual             Font(3I)



NAME
     Font - text font for a painter

SYNOPSIS
     #include <InterViews/font.h>

DESCRIPTION
     A font defines  the  representation  of  characters  on  the
     screen.   The global variable ``stdfont'' is a small, fixed-
     width font that Painter(3I) operations use by default.

PUBLIC OPERATIONS
     Font(const char* str)
     Font(const char* str, int length)
          Construct a font named by  the  given  string  or  sub-
          string.

     int Baseline()
          Return the font's baseline in pixels.

     boolean FixedWidth()
          Return whether the font contains  fixed  width  charac-
          ters.

     int Height()
          Return the font's height in pixels.

     int Index(const char* string, int offset, boolean between)
between)
     int Index(const  char*  string,  int  len,  int  offset,  boolean
          Return  the index in a string or substring of the char-
          acter that would be _o_f_f_s_e_t pixels from the left if  the
          string  were displayed.  If _b_e_t_w_e_e_n is _f_a_l_s_e, the index
          of the character that contains _o_f_f_s_e_t is returned; oth-
          erwise   the  index  of  the  character  following  the
          between-character  space  that  is  nearest  _o_f_f_s_e_t  is
          returned.  In either case a negative offset will return
          an index of zero and an offset beyond the  end  of  the
          string  or  substring will return an index equal to the
          length of the string.

     int Width(const char* string)
     int Width(const char* string, int len)
          Return the width in pixels that the string or substring
          would have if it were displayed in this font.

     boolean Valid()
          Return whether the font is meaningful.

SEE ALSO
     Painter(3I)




Printed 4/10/90           1 August 1988                         1






Frame(3I)           UNIX Programmer's Manual            Frame(3I)



NAME
     Frame, TitleFrame, BorderFrame, ShadowFrame,  MarginFrame  -
     surrounding interactor

SYNOPSIS
     #include <InterViews/frame.h>

DESCRIPTION
     A frame  is  a  monoscene  subclass  that  outlines  another
     interactor.   A title frame provides a banner in addition to
     the outline and highlights the banner when  the  frame  con-
     tains  the  input  focus.   A border frame draws the outline
     using a solid pattern when it contains the input  focus  and
     using  a  gray  pattern  otherwise.  A shadow frame draws an
     outline with a drop shadow.  A margin  frame  surrounds  its
     component with horizontal and vertical glue.

PUBLIC OPERATIONS
     Frame(Interactor*, int width = 1)
          Construct a frame.  If the given interactor is not nil,
          it  is  inserted  as  the frame's component.  The frame
          extends _w_i_d_t_h pixels outside of the interactor.

     TitleFrame(Banner*, Interactor*, int width = 1)
          Construct a title frame with the given banner.

     BorderFrame(Interactor*, int width = 1)
          Construct a border frame.

     ShadowFrame(Interactor*, int h = 1, int v = 1)
          Construct a shadow frame.   The  _h  and  _v  ShadowFrame
          parameters  specify  the  width  of  the horizontal and
          vertical shadows, respectively.   Positive  values  for
          these  parameters  specify shadows falling to the right
          and below the interactor, respectively; negative values
          specify shadows falling to the left and above.

     MarginFrame(Interactor* = nil, int margin = 0)
     MarginFrame(Interactor*, int margin, int shrink, int stretch)
     MarginFrame(Interactor*, int hmargin, int vmargin)
vshr, int vstr)
     MarginFrame(Interactor*, int hm, int hshr, int hstr, int vm,  int
          Construct  a  margin frame.  The first constructor puts
          rigid, fixed-sized glue around the component, while the
          second  surrounds it with fixed-sized glue of the given
          shrinkability and stretchability.  Independent horizon-
          tal  and  vertical  margins are set with the third con-
          structor.  The last constructor allows full  specifica-
          tion of the margin frame's horizontal and vertical mar-
          gins, shrinkabilities, and stretchabilities.

     virtual void HandleInput(Event&)



Printed 4/10/90           15 June 1987                          1






Frame(3I)           UNIX Programmer's Manual            Frame(3I)



          A frame listens for OnEvent and OffEvent to detect when
          it  has  input  focus.   When  an  OnEvent is received,
          Frame::Handle calls Highlight(true); when  an  OffEvent
          is  received, it calls Highlight(false).  For any other
          event, it calls HandleInput.   Frame::HandleInput  does
          nothing.

     virtual void Highlight(boolean)
          The base class Highlight operation does nothing.

PROTECTED OPERATIONS
     Frame(Interactor*, int, int, int, int)
          This constructor is used by  subclasses  to  explicitly
          set  the  widths  of  each  line  in  the outline.  The
          integers specify the width of the left, bottom,  right,
          and top lines, respectively.

SEE ALSO
     Banner(3I), Event(3I), Glue(3I), Scene(3I)




































Printed 4/10/90           15 June 1987                          2






Glue(3I)            UNIX Programmer's Manual             Glue(3I)



NAME
     Glue, HGlue, VGlue - open space between interactors

SYNOPSIS
     #include <InterViews/glue.h>

DESCRIPTION
     A glue object is  an  interactor  that  is  used  to  define
     variable-size space between interactors in boxes.  The HGlue
     subclass is for space in a horizontal box; VGlue  for  space
     in  a  vertical  box.   Along  its  minor axis (vertical for
     HGlue, horizontal for VGlue), glue has  a  natural  size  of
     zero and infinite stretchability.

PUBLIC OPERATIONS
     HGlue(int natural = 0, int stretch = hfil)
     VGlue(int natural = 0, int stretch = vfil)
          Construct glue of a minimum  size.   The  glue  can  be
          stretched arbitrarily, but cannot shrink.

     HGlue(int natural, int shrink, int stretch)
     VGlue(int natural, int shrink, int stretch)
          Construct glue with a given natural  size,  shrinkabil-
          ity,  and  stretchability.   If  _s_h_r_i_n_k  is larger than
          _n_a_t_u_r_a_l  the  glue  potentially  can  have   ``negative
          size'', meaning interactors will overlap in a box.

SEE ALSO
     Box(3I), Interactor(3I), Shape(3I)


























Printed 4/10/90           15 June 1987                          1






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



NAME
     Interactor - base class for interactive objects

SYNOPSIS
     #include <InterViews/interactor.h>

DESCRIPTION
     Interactor is the base class for  all  interactive  objects.
     Every  interactor  has  a _s_h_a_p_e member variable that defines
     the desired characteristics of  screen  space  in  terms  of
     size,  shrinkability,  and stretchability.  This information
     is used to allocate display space for the interactor and the
     interactor's  _c_a_n_v_a_s  member  variable  is set to the actual
     space obtained.  The lower left  corner  of  the  canvas  is
     addressed by (0, 0); the upper right by the member variables
     (_x_m_a_x, _y_m_a_x).

     The _i_n_p_u_t member variable is the normal sensor  for  reading
     events.   The _o_u_t_p_u_t member variable is the standard painter
     for performing graphics operations.   Interactors  generally
     should  not  set  _o_u_t_p_u_t;  it  will either be inherited (and
     shared) from the interactor's parent or set by user customi-
     zation attributes.

     An interactor may optionally define the  _p_e_r_s_p_e_c_t_i_v_e  member
     variable  to  represent  the  portion of total area that the
     interactor is displaying.  Perspectives allow interactors to
     coordinate  with  other interactors, such as scrollers, that
     want to control the display area.

     An interactor also may specify  certain  characteristics  of
     the  interactor's canvas, such as whether it is read-only or
     read/write, whether its contents should be  saved  when  not
     visible.   Top-level  interactors  may specify an associated
     string name and icon.   Interactors  also  may  specify  the
     visual  format and interpretation of the input pointing dev-
     ice (e.g., mouse cursor) when it is inside the  interactor's
     canvas.

     To be mapped to some portion of the display,  an  interactor
     must  have  been  inserted  into a scene, called its _p_a_r_e_n_t.
     The interactor will be mapped when  its  parent  is  mapped.
     The  root  scene for the display is an instance of World(3I)
     and is always mapped.

CONSTRUCTORS
     Interactor()
          Construct an interactor.  The _i_n_p_u_t sensor  and  _o_u_t_p_u_t
          painters are initialized to _n_i_l.

     Interactor(const char* name)
          Construct an  interactor  associated  with  the  string



Printed 4/10/90            3 Apr 1989                           1






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



          _n_a_m_e.   The string is used to customize the behavior of
          the interactor according to user preferences.  Behavior
          can  also  be customized on a per-class basis using the
          subclass name.  Although not explicitly documented,  an
          instance  of  any object inheriting from interactor may
          be constructed with an additional  argument  (appearing
          first)  containing  the string name.  For example, both
          ``HGlue(natural,  stretch)''  and   ``HGlue("somename",
          natural, stretch)'' are valid.

     ~Interactor()
          The base  destructor  automatically  deletes  the  base
          fields, including _s_h_a_p_e, _c_a_n_v_a_s, _i_n_p_u_t, and _o_u_t_p_u_t.

CONFIGURATION
     void Align(Alignment, int w, int h, Coord& l, Coord& b)
          Return the coordinates at  which  an  object  with  the
          given  width  and  height will have the given alignment
          within the interactor's canvas.

     void SetClassName(const char*)
     const char* GetClassName()
     void SetInstance(const char*)
     const char* GetInstance()
          Set/get the class or instance name for  an  interactor.
          The names are used to determine user style preferences.
          SetClassName and SetInstance can only be  performed  by
          subclasses.

     void Config(Scene* s)
          Configure this interactor and its descendants according
          to  user preferences.  The scene _s is assumed to be the
          interactor's parent and is used  to  inherit  attribute
          values.   This operation need not be called explicitly;
          it is called automatically when  the  ancestors  of  an
          interactor  become  known (e.g., when the interactor or
          an ancestor is inserted into a world).

     Configuration involves a traversal of the interactor hierar-
     chy.   For  each  interactor  in  the  hierarchy, the _o_u_t_p_u_t
     painter is either inherited from its parent or  copied  from
     its  parent  if  there  are user preferences specific to the
     interactor for painter attributes such as colors, font,  and
     brush.    For   example,  suppose  the  user  preference  is
     ``A*B*font:9x15''   and   the   interactor   hierarchy    is
     ``A.B.C.D''  (each ``.'' representing a nesting level in the
     hierarchy).  Interactors A and B will share the same  output
     painter,  C  will  copy  B's  output  and change the font to
     ``9x15'', and D will share C's output.

     After assigning the output painter,  configuration  is  per-
     formed  recursively  on any children interactors.  The final



Printed 4/10/90            3 Apr 1989                           2






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



     step at each node in the traversal is to  call  the  virtual
     Reconfig operation.

     virtual void Reconfig()
          Perform any  configuration  specific  to  a  particular
          interactor.   This  operation  should minimally compute
          the interactor's shape based on the shape of its  chil-
          dren  and/or  the characteristics of its output painter
          (e.g., font).  It can also  retrieve  user  preferences
          specific  to  this  interactor's class or instance name
          using GetAttribute.

     const char* GetAttribute(const char*)
          Retrieve the value of a user preference with the  given
          name.    GetAttribute   searches   through  the  global
          PropertySheet(3I) looking for the most  specific  match
          to  the  current context.  If called from Reconfig, the
          context contains this interactor's class  and  instance
          names  as  well  as  those of all ancestors.  If called
          outside the configuration  traversal,  the  context  is
          only  the  top-level  class and instance (World's const
          char* argument and the application's name).

     virtual void Reshape(Shape&)
     Shape* GetShape()
          Set/get the shape of an interactor.   Reshape  is  a  a
          suggestion  that an interactor's shape should change to
          the  given  one.   The  default  operation   sets   the
          interactor's   shape   to   the  new  shape  and  calls
          Scene::Change on the  interactor's  parent.   Suggested
          shape  information  may  be  lost when an interactor is
          configured; thus, it is best to avoid use  of  Reshape.
          The  same affect can usually be achieved by putting the
          interactor in a box along with a  particular  shape  of
          glue.

     void SetCursor(Cursor*)
     Cursor* GetCursor()
          Set/get the cursor that  will  be  displayed  when  the
          pointing  device is inside the interactor's canvas.  If
          the interactor does not explicitly set its  cursor,  it
          will use its parent's cursor.  GetCursor returns nil in
          this case.

INTERACTOR HIERARCHY
     Scene* Parent()
          Return the interactor's parent or _n_i_l if the interactor
          has not been inserted into a scene.

     Scene* Root()
          Return the interactor's root ancestor  or  _n_i_l  if  the
          interactor has no parent.  Root effectively returns the



Printed 4/10/90            3 Apr 1989                           3






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



          world if an interactor is mapped but it can also return
          an  unmapped  scene if the root ancestor itself has not
          been inserted into the world.

     World* GetWorld()
          Return a pointer to the world the interactor  has  been
          inserted  into or _n_i_l if the interactor's root ancestor
          is not mapped.

     void GetRelative(Coord& x, Coord& y, Interactor* = nil)
          Map coordinates that are relative to this  interactor's
          canvas  to  be relative to another interactor's canvas.
          If the other interactor is _n_i_l,  then  the  coordinates
          are made relative to the world.

int&)
     virtual  void  GetComponents(Interactor**,  int,   Interactor**&,
          Construct  an array of pointers to the interactors con-
          tained within this interactor.  The  first  and  second
          parameters  specify  an  array  of  interactors that is
          already allocated.  This array is used if it  is  large
          enough,  otherwise  a  new array is allocated from free
          store.  The third  and  fourth  parameters  return  the
          which  array  was  used  and  the actual number of com-
          ponents.  This operation is only defined by scenes; the
          default operation sets the number of elements to zero.

OUTPUT
     virtual void Draw()
          Draw is used to display the contents of an  interactor,
          including  the  contents  of  any interior interactors.
          The      default       Draw       operation       calls
          Redraw(0, 0, _x_m_a_x, _y_m_a_x).   Interactors  usually  don't
          need to redefine  Draw  unless  they  contain  interior
          interactors   (i.e.,  scene  subclasses);  most  simple
          interactors redefine only Redraw.

     void Sync()
     void Flush()
          Sync waits until any pending operations have completed.
          Flush makes sure the local buffer of pending operations
          (if any) is sent to the display.   An  input  operation
          will  do  a Sync automatically if it would block; thus,
          applications generally need  not  call  Sync  or  Flush
          explicitly.

INPUT
     void Listen(Sensor*)
          When an interactor is mapped onto a display, its  input
          interest  is  determined  by  its _i_n_p_u_t sensor.  A dif-
          ferent sensor can be specified with the  Listen  opera-
          tion.  To switch back to _i_n_p_u_t, call Listen(_i_n_p_u_t).



Printed 4/10/90            3 Apr 1989                           4






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



     void Read(Event&)
          Each application has a single input  queue  of  events.
          Any interactor can use Read to take the next event from
          the queue.  Redraw and Resize operations may be  called
          as  a  side  effect of a Read (or any input operation).
          The _t_a_r_g_e_t field of the event specifies the  interactor
          for  which  the  event is intended, which is not neces-
          sarily the same as the interactor  that  performed  the
          Read.  The target is normally the interactor whose can-
          vas is under the pointing device.

     void UnRead(Event&)
          UnRead puts an event back on the input queue as  if  it
          had never been read.

     virtual void Handle(Event&)
          When an interactor wishes to pass an event  to  another
          interactor,  it  calls  the  other  interactor's Handle
          operation.  Thus, input flow control can be either pro-
          cedural with Read or event-driven with Handle.

     void Run()
          Run implements a simple  event  dispatching  loop.   It
          calls  Read  to get the next event and passes the event
          to the target interactor via  Handle.   The  loop  ter-
          minates if the Handle operation sets the event's target
          to nil.

     void QuitRunning(Event&)
          QuitRunning sets the event's target to nil.   A  Handle
          operation  can  call  it  to  make  Run  exit its event
          dispatching loop.

     boolean Check()
          Check determines  whether  an  event  of  interest  has
          occurred.

     void Poll(Event&)
          Poll sets an event to reflect the current input  state.
          Input  polling  can be wasteful of cycles and should be
          avoided if possible.

     int CheckQueue()
          CheckQueue returns the number  of  input  packets  that
          have  been  queued  within  the application.  The event
          queue manager always reads as much information as  pos-
          sible  from input; thus, a single Read might store many
          events in a local buffer.  Subsequent reads can  simply
          access the buffer.  This buffer can include out-of-band
          packets, such as those requiring a Redraw.  The  number
          returned  by CheckQueue does not correspond, therefore,
          to the actual number of input events.



Printed 4/10/90            3 Apr 1989                           5






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



VIEWS
     virtual void Adjust(Perspective&)
          Adjust suggests to an interactor that  its  perspective
          should  change to the given perspective; the interactor
          may choose to accept any part of  the  new  perspective
          and  must  ensure  that the parameter matches its (new)
          perspective before returning.  Adjust can  be  used  by
          another  interactor to scroll, pan, or zoom an interac-
          tor.

     Perspective* GetPerspective()
          GetPerspective returns the perspective associated  with
          an interactor or nil if the interactor has not assigned
          one.

     virtual void Update()
          Change the display to reflect some change in state that
          the interactor depends on.  This operation is used in a
          number of contexts.  One example is  in  managing  per-
          spectives.   If  an  interactor changes its perspective
          (e.g., the total of  size  of  what  it  is  displaying
          changes), it must notify its perspective, which in turn
          calls Update on the interactors that  access  the  per-
          spective (such as a scroller).

TOP-LEVEL INTERACTORS
     void SetName(const char*)
     const char* GetName()
          Set/get the name associated with the top-level interac-
          tor.   Window  managers  will display the name in title
          bars.  If no name is set explicitly, then the  name  of
          the  application will be assigned to top-level interac-
          tors.

     void SetGeometry(const char*)
     const char* GetGeometry()
          Set/get the geometry specification associated with  the
          top-level interactor.  This operation must be performed
          before an interactor is mapped.  See _W_o_r_l_d(_3_I) for more
          information  about geometry specifications.  The Inter-
          Views library automatically stores a  geometry  with  a
          top-level  interactor  if  a  resource  or command-line
          option sets a ``.geometry: value'' property  associated
          with  the interactor and automatically fetches it again
          to parse it before creating the interactor's canvas.

     void SetCanvasType(CanvasType)
     CanvasType GetCanvasType()
          Set/get the type of canvas desired for  an  interactor.
          This  operation  must be performed before an interactor
          is  mapped.   The  possible  canvas  types   are   Can-
          vasShapeOnly,  meaning the interactor performs no input



Printed 4/10/90            3 Apr 1989                           6






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



          or output (e.g., glue),  CanvasInputOnly,  meaning  the
          interactor performs no output, CanvasInputOutput, which
          is the default, CanvasSaveUnder,  which  suggests  that
          the interactor will be mapped for a short time (e.g., a
          popup menu) and that the information under  the  canvas
          should  be  saved,  CanvasSaveContents,  which suggests
          that Redraw calls are expensive and should  be  avoided
          by  caching  the  display,  and  CanvasSaveBoth,  which
          requests both CanvasSaveUnder and CanvasSaveContents.

     void SetInteractorType(InteractorType)
     void GetInteractorType(InteractorType)
          Set/get the type of interactor seen by window managers.
          This  operation  must be performed before an interactor
          is  mapped.   The   possible   interactor   types   are
          InteriorInteractor, which is the default, PopupInterac-
          tor, which gets inserted into  the  world  without  any
          interaction  with window managers, TransientInteractor,
          which suggests to window managers that they not ask the
          user  to place this interactor nor should they decorate
          it,  ToplevelInteractor,  which  suggests   to   window
          managers  that  they treat this interactor as part of a
          group of top-level interactors owned by the same appli-
          cation,   ApplicationInteractor,   which  tells  window
          managers this interactor is  the  application's  "main"
          interactor,  and IconInteractor, which tells the Inter-
          Views library to only create a canvas for this interac-
          tor,  not map it, when Insert is called.  Most applica-
          tions  call  one  of  the  World  methods  InsertPopup,
          InsertTransient,  InsertToplevel, InsertApplication, or
          InsertIcon rather than call SetInteractorType directly.

     void SetGroupLeader(Interactor*)
     Interactor* GetGroupLeader()
     void SetTransientFor(Interactor*)
     Interactor* GetTransientFor()
          Set/get additional information that  ToplevelInteractor
          and  TransientInteractor  interactors  need  to provide
          window managers with.   ToplevelInteractor  interactors
          need to tell window managers which top-level interactor
          is the leader of the interactor group they  belong  to.
          TransientInteractor  interactors  need  to  tell window
          managers which interactor they are transient on  behalf
          of,  such  as  a  popup  dialog box for an application.
          Most applications provide  the  additional  information
          when  they call one of the World methods InsertToplevel
          or InsertTransient rather than call  SetGroupLeader  or
          SetTransientFor directly.

     void SetIconBitmap(Bitmap*)
     Bitmap* GetIconBitmap()
          Set/get the bitmap that a  top-level  interactor  wants



Printed 4/10/90            3 Apr 1989                           7






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



          window  managers  to  display  when  they  iconify this
          interactor.  Most  window  managers  will  display  the
          specified  bitmap  although  some  may clip or tile the
          bitmap if it's not the size they expect.

     void SetIconMask(Bitmap*)
     Bitmap* GetIconMask()
          Set/get the bitmap that a  top-level  interactor  wants
          window managers to mask the bitmap set by SetIconBitmap
          with.  Some window managers will use the mask to create
          the appearance of irregularly shaped icons.

     void SetIconInteractor(Interactor*)
     Interactor* GetIconInteractor()
          Set/get the icon interactor that a top-level interactor
          wants  window  managers  to  map when they iconify this
          interactor.   The  InterViews   library   automatically
          creates  the  icon  interactor's  canvas  if necessary.
          Most window managers will map the icon interactor  when
          iconifying  this  interactor in preference to showing a
          bitmap even if a bitmap was set by SetIconBitmap.

     void SetIconGeometry(const char*)
     const char* GetIconGeometry()
          Set/get the geometry that a top-level interactor  wants
          to  give  its  icon  interactor  or the position that a
          top-level interactor wants window managers to give  its
          icon  bitmap.   The  InterViews  library  automatically
          stores an icon geometry with a top-level interactor  if
          a    resource    or   command-line   option   sets   an
          ``.iconGeometry: value'' property associated  with  the
          interactor  and automatically fetches it again to parse
          it before creating the icon interactor's canvas or set-
          ting  a  hint to tell window managers where to position
          the bitmap.

     void SetStartIconic(boolean)
     boolean GetStartIconic()
          Set/get a hint to  window  managers  that  they  should
          iconify  this  top-level interactor immediately when it
          starts up.  This operation must be performed before  an
          interactor is mapped.  The InterViews library automati-
          cally sets or clears this hint on a top-level  interac-
          tor  before  mapping  it  if a resource or command-line
          option sets an ``.iconic: on/off'' property  associated
          with the interactor.

     void Iconify()
     void DeIconify()
          Iconify (DeIconify) asks window managers to  unmap  the
          toplevel  interactor  (icon) and map the icon (interac-
          tor).



Printed 4/10/90            3 Apr 1989                           8






Interactor(3I)      UNIX Programmer's Manual       Interactor(3I)



INTERNAL OPERATIONS
     virtual void Redraw(Coord l, Coord b, Coord r, Coord t)
          The Redraw operation is called when some portion of the
          Interactor  needs  to be redrawn, presumably because it
          was previously obscured.  The Redraw  operation  should
          NOT redraw interior interactors; the Interviews library
          or the Draw operation will call their Redraw operations
          automatically.  The default Redraw operation does noth-
          ing.

Coord t[])
     virtual void RedrawList(int n, Coord l[], Coord b[],  Coord  r[],
          RedrawList notifies an interactor that several areas of
          its canvas need to be redrawn,  presumably  because  it
          was  raised  to the top of other canvases.  The default
          RedrawList operation redraws each area separately  with
          Redraw.

     virtual void Resize()
          Resize notifies an interactor that its canvas has  been
          created  or  modified.   Only scenes are typically con-
          cerned with Resize, as they must place their  component
          interactors  within  the  new  or  resized canvas.  The
          default Resize operation does nothing.

     virtual void Activate()
     virtual void Deactivate()
          Activate and Deactivate notify an interactor  that  its
          canvas  has  been  mapped  (unmapped), which occur when
          window managers  deiconify  (iconify)  the  interactor.
          Interactors  that  perform  a  lot  of  computation  or
          display a lot of  information  may  wish  to  save  cpu
          cycles  when  "deactivated."   The default Activate and
          Deactivate operations do nothing.

SEE ALSO
     Bitmap(3I),   Canvas(3I),   Painter(3I),    Perspective(3I),
     Scene(3I), Sensor(3I), Shape(3I), World(3I)

















Printed 4/10/90            3 Apr 1989                           9






Menu(3I)            UNIX Programmer's Manual             Menu(3I)



NAME
     Menu, HMenu, VMenu,  MenuItem,  TextItem  -  menu  and  item
     interactors

SYNOPSIS
     #include <InterViews/menu.h>

DESCRIPTION
     A menu is an interactor that displays a list  of  items  and
     selects  an  item based on the position of the pointing dev-
     ice.  Items in a menu are  arranged  vertically  in  a  box.
     HMenu is a subclass whose items are arranged horizontally.

     Each item in a menu is also an interactor.   MenuItem  is  a
     class  of  interactors  that  highlight  themselves when the
     pointing device enters their canvas, and  unhighlight  them-
     selves when the pointing device leaves their canvas.  A pub-
     lic _t_a_g field of MenuItem contains an integer that typically
     determines  the  item's associated operation.  TextItem is a
     subclass of MenuItem that displays a string of characters.

PUBLIC OPERATIONS
     Menu(boolean persistent = true)
     HMenu(boolean persistent = true)
          Construct a new menu.  If _p_e_r_s_i_s_t_e_n_t is true  the  menu
          will  remain  visible  when  the mouse leaves its area,
          otherwise the menu will disappear.   A  string  can  be
          passed  as the first argument to name the menu to allow
          the user to customize its appearance.

     Insert(MenuItem*)
          Add a new item to the menu.

     Change(MenuItem*)
          Notify the menu that an item's shape has changed.

     Remove(MenuItem*)
          Eliminate an item from the menu.

     void Compose()
          After all the items in a menu have been inserted,  Com-
          pose builds the box representation of the menu.

     void Popup(Event&, MenuItem*&)
          Insert the menu into the root scene centered around the
          coordinates  associated  with the event and read events
          until a button is released.   When  the  target  of  an
          event is a menu item, it is marked as the selected item
          and passed the event.  Events for other interactors are
          ignored.   The menu is removed from the root scene when
          the button is released.   The  interactor  argument  to
          Popup is set to the selected menu item or nil if none.



Printed 4/10/90           15 June 1987                          1






Menu(3I)            UNIX Programmer's Manual             Menu(3I)



     void GetSelection(MenuItem*&)
          GetSelection returns the currently selected item.

     void Handle(Event&)
          The Handle operation reads events  until  a  button  is
          released,  passing  the  events to the appropriate menu
          items.  Handle sets the currently selected menu item to
          the event's target.

     MenuItem(int = 0)
          Construct a new item with the given tag.

     TextItem(const char*, int = 0)
          Construct a text item with the  string  and  tag.   The
          string will be centered in the canvas.

SEE ALSO
     Interactor(3I)





































Printed 4/10/90           15 June 1987                          2






Message(3I)         UNIX Programmer's Manual          Message(3I)



NAME
     Message - interactor containing text

SYNOPSIS
     #include <InterViews/message.h>

DESCRIPTION
     A message is an interactor that contains  a  line  of  text.
     The  alignment  of the text with respect to the interactor's
     canvas can be specified in the constructor.

PUBLIC OPERATIONS
     Message(const char*, Alignment = Center)
          Construct a new message interactor with the given  text
          string and alignment.

SEE ALSO
     Interactor(3I)





































Printed 4/10/90           28 March 1988                         1






ObjectSpace(3I)     UNIX Programmer's Manual      ObjectSpace(3I)



NAME
     ObjectSpace - distributed objects

SYNOPSIS
     #include <InterViews/space.h>

DESCRIPTION
     ObjectSpace is a class  that  represents  a  tightly-coupled
     cluster  of  objects.   It is analogous to an address space,
     with objects instead of bytes  or  words.   The  ObjectSpace
     class allows remote access to objects through Unix IPC.

     An object space is a kind of  server  process.   It  runs  a
     top-level  loop  that  receives  messages  from other object
     spaces (processes) and  delivers  them  to  the  appropriate
     object.

     Clients connect to object spaces  through  the  name  server
     process  _s_p_a_c_e_m_a_n(1).  Object names have two parts: a string
     that identifies the object space and is known  to  spaceman,
     and a string that is resolved by the object space itself.

PUBLIC OPERATIONS
     ObjectSpace(const char*)
          Create a space and register it  under  the  given  name
          with the space manager.

     void StartServer(Connection* local, Connection* remote)
          Start listening to the  given  connections  for  object
          messages.   This  routine  is  not necessary in general
          because as the constructor will connect  to  the  space
          manager  and  establish connections on which to listen.
          However, some applications, such as the  space  manager
          itself, must specify the connections explicitly.

     void UsePath(const char* path)
          Tell the space manager to prepend the given  path  when
          searching for other known spaces.

     Connection* Find(const char* name, boolean wait = false)
          Ask the space manager to look for an object space  with
          the  given  name.   If  _w_a_i_t is true, then wait until a
          space is created with the given name if none  currently
          exists.   Find returns a connection to the named object
          space or _n_i_l is none is defined an _w_a_i_t was false.

     void Dispatch()
          Wait for a single message from a client and deliver  it
          to the target object.

     void Deliver(Connection*, ObjectTag, int op, void*, int len)
          Send an untyped message of a given length to  a  target



Printed 4/10/90            29 May 1989                          1






ObjectSpace(3I)     UNIX Programmer's Manual      ObjectSpace(3I)



          object by mapping the tag and calls Message on the tar-
          get object stub.

len)
     virtual void Message(Connection*, ObjectTag, int op,  void*,  int
          Handle  a message to the object space itself.  Messages
          with a zero tag in the target field are handled by  the
          object space.  These are used to find an object by name
          with a space, create a  new  instance  of  an  existing
          object, or destroy an object.  If an object is found or
          created, the tag specified  by  the  sender  should  be
          associated  with  the object for use in subsequent mes-
          sages.

     ObjectStub* Map(Connection*, ObjectTag)
          Translate a client's tag to  a  stub.   The  client  is
          identified by the connection.

     void AddChannel(int, ObjectStub*)
     void RemoveChannel(int)
          Add or remove an additional channel on which to receive
          data.   This  channel is treated as a stream instead of
          interpreting  packets  with  tags  identifying   target
          objects.   When  data  is  pending  on the channel, the
          object space calls ChannelReady on the stub.

     void Attach(int)
     void Detach(int)
          Start or stop listening to a channel added by  an  ear-
          lier call to AddChannel.

SEE ALSO
     spaceman(1), Connection(3i), ObjectStub(3i)
     Linton, M.A., ``Distributed Management of a  Software  Data-
     base'',   _I_E_E_E   _S_o_f_t_w_a_r_e,   Vol. 4,  No. 6,  November 1987,
     pp. 70-76.



















Printed 4/10/90            29 May 1989                          2






ObjectStub(3I)      UNIX Programmer's Manual       ObjectStub(3I)



NAME
     ObjectStub - unpack remote messages

SYNOPSIS
     #include <InterViews/stub.h>

DESCRIPTION
     An object stub interprets byte stream messages by  unpacking
     parameters  and calling the appropriate operation on another
     object.  Because object stubs are accessed by remote  object
     spaces, reference counts are used to determine when they can
     be deallocated.

PUBLIC OPERATIONS
     ObjectStub()
     ~ObjectStub()
          When an object stub is created, its reference count  is
          set  to  one.   When the stub is deleted, its reference
          count is decremented and it is only  destroyed  if  the
          count reaches zero.

     void Reference()
          Increment the reference count.

     boolean LastRef()
          Return true if the reference count is currently one.

len)
     virtual void Message(Connection*, ObjectTag, int op,  void*,  int
          Handle   a   message  for  the  object  that  the  stub
          represents.  The message  contains  a  connection  that
          specifies  the  sender,  a tag that is usually the stub
          itself, an opcode that is the method  selector,  and  a
          varying-length  array  of  bytes.   The default Message
          operation does nothing.

     virtual void ChannelReady(int channel)
          Handle data that is pending on the given channel.   The
          channel  is  uninterpreted  by the object space, so the
          stub must read and interpret the data.

     virtual ObjectStub* Clone()
          Create a copy of the object represented  by  the  stub.
          Remote clients create a new instance by first finding a
          prototype by name and then  copying  the  object  using
          Clone.

SEE ALSO
     ObjectSpace(3i)






Printed 4/10/90            29 May 1989                          1






Painter(3I)         UNIX Programmer's Manual          Painter(3I)



NAME
     Painter - graphics output

SYNOPSIS
     #include <InterViews/painter.h>

DESCRIPTION
     Painter is a class that provides ``immediate-mode'' graphics
     operations  for drawing on a canvas.  The state of a painter
     defines the graphics context for the drawing operations  and
     includes  a  brush, foreground and background colors, a fill
     pattern and mode, a text font, a text style, an output  ori-
     gin and current position, and a transformation matrix.

STATE OPERATIONS
     Painter(Painter* = stdpaint)
          Create a new painter and copy its state from the  given
          painter.

     void SetBrush(Brush*)
     Brush* GetBrush()
          Set or return the  painter's  brush.   Default  is  the
          predefined brush ``single''.

     void SetColors(Color* fg, Color* bg)
     Color* GetFgColor()
     Color* GetBgColor()
          Set or return the painter's colors.  If either argument
          to  SetColors  is  nil, then the corresponding color is
          not changed.  Defaults are ``black'' for foreground and
          ``white'' for background.

     void SetFont(Font*)
     Font* GetFont()
          Set or return the painter's text font.  Default is  the
          predefined font ``stdfont''.

     void SetStyle(int style)
     int GetStyle()
          Set or get the painter's text style.  A text style is a
          bit  vector  that  can be assembled from the predefined
          constants _P_l_a_i_n, _B_o_l_d_f_a_c_e,  _U_n_d_e_r_l_i_n_e_d,  and  _R_e_v_e_r_s_e_d.
          Default is Plain.

     void SetPattern(Pattern*)
     Pattern* GetPattern()
     void FillBg(boolean mode)
     boolean BgFilled()
          Set or return the painter's fill pattern and mode.   If
          the  mode  is  _t_r_u_e,  fill  operations  will set pixels
          corresponding to ones in the current  fill  pattern  to
          the  foreground color and pixels corresponding to zeros



Printed 4/10/90           15 June 1987                          1






Painter(3I)         UNIX Programmer's Manual          Painter(3I)



          to the background color.  If  _f_a_l_s_e,  then  only  fore-
          ground   pixels   will  be  set.   Default  pattern  is
          ``solid''; default mode is _t_r_u_e.

     void SetOrigin(int x0, int y0)
     void GetOrigin(int& x0, int& y0)
          Set or return the origin by which all  coordinates  are
          offset.  Default is (0, 0).

     void Translate(float dx, float dy)
     void Rotate(float angle)
     void Scale(float x, float y)
     void SetTransformer(Transformer*)
     Transformer* GetTransformer()
          Coordinates   passed   to   drawing   operations    are
          transformed  according  to the current origin, transla-
          tion (cumulative), rotation, and scale factor.   Inter-
          nally,  a  transformation  matrix is stored that can be
          directly set and accessed using SetTransformer and Get-
          Transformer.   The  default transformer is nil, meaning
          no transformations are performed.

     void SetPlaneMask(int mask)
          Set which bit planes are  affected  by  drawing  opera-
          tions.   If  the  Kth  bit of _m_a_s_k is set, then display
          operations will draw on plane K.

     void SetOverwrite(boolean)
          Set whether a painter is allowed to  write  in  subcan-
          vases.   If  true,  drawing  operations will be able to
          write over the canvases of component  interactors.   If
          false,  drawing  operations will be clipped by any sub-
          canvases.  The default is false.

     void Clip(Canvas*, Coord x1, Coord y1, Coord x2, Coord y2)
     void NoClip()
          Clip  restricts  output  operations  to  the  specified
          region  of  the canvas.  NoClip removes the restriction
          so that operations affect the entire canvas.  Only  one
          clipping region may be in effect at a time.

     void MoveTo(Coord x, Coord y)
          Set the current output position.  The  output  position
          is used and updated by Text and CurveTo.

DRAWING OPERATIONS
     void Curve(Canvas*, Coord x0, y0, x1, y1, x2, y2, x3, y3)
     void CurveTo(Canvas*, Coord x1, y1, x2, y2, x3, y3)
          Paint a Bezier curve on the canvas from the first point
          to the last point (but not going through the intermedi-
          ate control points).  The curve  will  lie  within  the
          polygon  formed  by  the four points.  CurveTo uses the



Printed 4/10/90           15 June 1987                          2






Painter(3I)         UNIX Programmer's Manual          Painter(3I)



          current position for the first point.

     void BSpline(Canvas*, Coord x[], y[], int n)
     void ClosedBSpline(Canvas*, Coord x[], y[], int n)
     void FillBSpline(Canvas*, Coord x[], y[], int n)
          Draw the B-spline defined by the  _n  control  vertices.
          If closed or filled, the last point is connected to the
          first point.

     void Circle(Canvas*, Coord x, y, int r)
     void FillCircle(Canvas*, Coord x, y, int radius)
          Draw a circle with center (_x, _y) and radius _r.

     void Ellipse(Canvas*, Coord x, y, int xr, int yr)
     void FillEllipse(Canvas*, Coord x, y, int xr, int yr)
          Draw an ellipse with center (_x, _y),  horizontal  radius
          _x_r, and vertical radius _y_r.

     void Line(Canvas*, Coord x1, y1, x2, y2)
     void MultiLine(Canvas*, Coord x[], y[], int n)
     void Polygon(Canvas*, Coord x[], y[], int n)
     void FillPolygon(Canvas*, Coord x[], y[], int n)
          Draw a path using the current brush  and  colors.   The
          Line  operation  draws  a  vector  between  two  points
          (inclusive); MultiLine draws a number of connected vec-
          tors;  Polygon  draws  a closed set of vectors; FillPo-
          lygon fills the area inside a polygon using the current
          fill pattern and colors.

     void Point(Canvas*, Coord x, y)
     void MultiPoint(Canvas*, Coord x[], y[], int n)
          Set a point or set of points to the current  foreground
          color.

     void Rect(Canvas*, Coord x1, y1, x2, y2)
     void FillRect(Canvas*, Coord x1, y1, x2, y2)
     void ClearRect(Canvas*, Coord x1, y1, x2, y2)
          Draw a rectangle  with  opposite  corners  specfied  by
          (_x_1, _y_1)  and  (_x_2, _y_2).   FillRect fills the rectangle
          using the current pattern and colors;  ClearRect  fills
          the rectangle with the background color.

     void Text(Canvas*, const char* str, Coord x, Coord y)
     void Text(Canvas*, const char* str, int n, Coord x, Coord y)
     void Text(Canvas*, const char* str)
     void Text(Canvas*, const char* str, int n)
          Draw a string or substring of text  using  the  current
          Font  and  text  style.  The (_x, _y) coordinates specify
          the lower-left corner of the bounding box of the  text.
          The  width  of  the  bounding  box  is the width of the
          string as reported by the  Font::Width  operation,  and
          the  height  of  the  bounding  box is the Font height.



Printed 4/10/90           15 June 1987                          3






Painter(3I)         UNIX Programmer's Manual          Painter(3I)



          Most fonts will result in  output  which  only  affects
          pixels  within the bounding box.  The current transfor-
          mation matrix is applied to both the positions and  the
          shapes  of characters drawn.  If the matrix specifies a
          transformation  involving  rotation  or  scaling,   the
          resulting  operation  may proceed much more slowly than
          normal.  If background fill mode is on, then the  char-
          acters  are  drawn  in  the foreground color, and other
          pixels within the bounding box are  set  to  the  back-
          ground color.  If background fill mode is off, only the
          foreground pixels  are  set.   If  no  coordinates  are
          specified,   then  the  current  position  (defined  by
          MoveTo) is used and updated to reflect the  lower-right
          corner of the bounding box.

mask = nil)
     void Stencil(Canvas*, Coord x, Coord y,  Bitmap*  image,  Bitmap*
          Paint  foreground and background colors through a sten-
          cil formed by positioning the image  and  mask  Bitmaps
          with  their  origins  at  the point (_x, _y).  Foreground
          color is painted where the  _i_m_a_g_e  Bitmap  has  a  true
          value  and background color where image is false.  How-
          ever, only pixels corresponding to a true value in  the
          mask  Bitmap are affected.  A nil _m_a_s_k is equivalent to
          a mask of the same size and shape as image and contain-
          ing all true values.  The current transformation matrix
          is applied to both the image and mask Bitmaps.  If  the
          matrix specifies a transformation involving rotation or
          scaling, the resulting operation may proceed much  more
          slowly than normal.

     void RasterRect(Canvas*, Coord x, Coord y, Raster*)
          Render the Raster with its  lower-left  corner  at  the
          position  (_x, _y).  The current transformation matrix is
          applied to the  Raster.   If  the  matrix  specifies  a
          transformation   involving  rotation  or  scaling,  the
          resulting operation may proceed much more  slowly  than
          normal.

     void Read(Canvas*, void*, Coord x1, y1, x2, y2)
     void Write(Canvas*, const void*, Coord x1, y1, x2, y2)
x0, y0)
     void Copy(Canvas* src, Coord x1, y1, x2, y2, Canvas*  dst,  Coord
          Read  copies  a  region of a canvas into memory.  Write
          copies data from memory to a region of a canvas.   Copy
          reads a region of one canvas and writes the data into a
          region of another canvas (or within a canvas if _s_r_c and
          _d_s_t  are  the  same).  The point (_x_0, _y_0) is the lower-
          left corner of the destination region.  Note that  _R_e_a_d
          and  _W_r_i_t_e  are  superceded by operations that use Ras-
          ters.




Printed 4/10/90           15 June 1987                          4






Painter(3I)         UNIX Programmer's Manual          Painter(3I)



SEE ALSO
     Bitmap(3I),  Brush(3I),  Canvas(3I),  Color(3I),   Font(3I),
     Pattern(3I), Raster(3I), Transformer(3I)




















































Printed 4/10/90           15 June 1987                          5






Panner(3I)          UNIX Programmer's Manual           Panner(3I)



NAME
     Panner - two-dimensional scrolling and zooming

SYNOPSIS
     #include <InterViews/panner.h>

DESCRIPTION
     A panner is an interactor that manipulates  the  perspective
     of  another  interactor to provide two-dimensional scrolling
     and zooming.  A panner is composed of a _s_l_i_d_e_r  and  several
     adjusters,  including  two  zoomers  and  four  movers.  The
     slider's position and size reflect the current origin, size,
     and  aspect ratio in the interactor's perspective.  Dragging
     the slider around with the mouse changes  the  perspective's
     _c_u_r_x and _c_u_r_y members.

PUBLIC OPERATIONS
     Panner(Interactor*, int size = 0)
          Create a panner for the  given  interactor,  optionally
          with  the  given width.  If the size is 0, a reasonable
          default  size  is  used.   The  panner's  aspect  ratio
          reflects that of the perspective.

     Slider(Interactor*)
     Slider::Handle(Event&)
     Slider::Reshape(Shape&)
     Slider::Update()
          A slider reflects and lets the user specify the visible
          portion  of the view.  A rectangle represents the visi-
          ble area, while the area surrounding it represents  the
          total area.  Clicking and holding down any mouse button
          on the rectangle allows you to drag it to  a  different
          position  within  the  total  area.   The perspective's
          current origin is shifted to reflect the  new  position
          when  the  button  is released.  Holding down the shift
          key while dragging the rectangle constrains its  motion
          horizontally  or vertically.  Clicking outside the rec-
          tangle moves it  in  the  corresponding  one  of  eight
          directions;  for  example, clicking to the right of the
          rectangle moves it to the right.   If  the  left  mouse
          button  is  used,  the  movement  increment  equals the
          perspective's _s_x or _s_y member  variables.   The  middle
          mouse  button  increments  by  _l_x  or _l_y, and the right
          mouse button centers the rectangle around  the  cursor.
          The  Reshape  call sets the width of the slider to that
          of the passed Shape and  calls  Change  on  the  parent
          interactor.   Update redisplays the slider to reflect a
          change in the interactor's perspective.

X DEFAULTS
     The ``syncScroll'' resource  specifies  whether  the  slider
     should   work   in  real-time  or  not.   When  synchronized



Printed 4/10/90          15 January 1988                        1






Panner(3I)          UNIX Programmer's Manual           Panner(3I)



     scrolling is employed the interactor  scrolls  synchronously
     as  the  slider  is  dragged; otherwise the slider's outline
     follows the mouse during dragging,  and  the  interactor  is
     scrolled  only  after  the  user  stops dragging the slider.
     Sliders  will  scroll  synchronously  if  their   syncScroll
     resource is set to ``on'' or ``true.''

SEE ALSO
     Adjuster(3I), Interactor(3I), Perspective(3I)














































Printed 4/10/90          15 January 1988                        2






Pattern(3I)         UNIX Programmer's Manual          Pattern(3I)



NAME
     Pattern - fill patterns for a painter

SYNOPSIS
     #include <InterViews/pattern.h>

DESCRIPTION
     A pattern defines how to fill areas during  graphics  opera-
     tions.   The  global variables ``solid'' and ``clear'' point
     to patterns for filling all or none of the pixels in a  par-
     ticular  area;  ``lightgray'',  ``gray'',  and  ``darkgray''
     point to  patterns  for  filling  one-eighth,  one-half,  or
     seven-eighths of the pixels in an area respectively.

PUBLIC OPERATIONS
     Pattern(int b[patternHeight])
          Construct a pattern from the array _b.  For each element
          of _b, the least significant _p_a_t_t_e_r_n_W_i_d_t_h bits are used.
          If a bit is one, then the foreground color will be used
          when  filling.  Otherwise, the background color will be
          used.  The first pattern element  defines  the  topmost
          row  of  pixels,  and the least significant bit of each
          element defines the rightmost column.

     Pattern(int i)
          Construct a pattern by interpreting the  least  signfi-
          cant 16 bits of _i as a 4x4 bitmap and replicating it to
          make a full _p_a_t_t_e_r_n_W_i_d_t_h by _p_a_t_t_e_r_n_H_e_i_g_h_t array.

     Pattern(Bitmap*)
          Construct a pattern from the bitmap.  If necessary, the
          bitmap  will  be  tiled  or truncated to satisfy window
          system requirements for fill pattern sizes.

SEE ALSO
     Painter(3I)



















Printed 4/10/90           15 June 1987                          1






Perspective(3I)     UNIX Programmer's Manual      Perspective(3I)



NAME
     Perspective - visible portion of an interactor

SYNOPSIS
     #include <InterViews/perspective.h>

DESCRIPTION
     A perspective object describes which part of an interactor's
     total  display  area  is visible in the interactor's canvas.
     The main use of perspectives is for scrolling, panning,  and
     zooming  interactors.   The member variables (_x_0, _y_0) define
     the origin of  the  interactor's  display  area;  _w_i_d_t_h  and
     _h_e_i_g_h_t  define  the  total  height  of the area.  The member
     variables (_c_u_r_x, _c_u_r_y) define the lower-left corner  of  the
     interactor's canvas relative to the total area; _c_u_r_w_i_d_t_h and
     _c_u_r_h_e_i_g_h_t define how much of the total area is displayed  in
     the canvas.

     The member variables _s_x, _s_y, _l_x, and _l_y  specify  small  and
     large  increments  in  each dimension.  These increments are
     used by a scroller to implement line and page scrolling.

PUBLIC OPERATIONS
     Perspective()
          Define a new perspective with all member variables ini-
          tialized to zero.

     void Attach(Interactor*)
          Add to the list of interactors that are  interested  in
          updates  to the perspective.  These interactors reflect
          the perspective visually;  examples  include  scrollers
          and sliders.

     void Detach(Interactor*)
          Remove an interactor from the list of those  interested
          in  updates.   This operation should be called from the
          interactor's destructor.

     void Init(Coord x0, Coord y0, Coord width, Coord height)
          Initialize the perspective display area.

     void Update()
          Notify all the interactors interested in  the  perspec-
          tive that it has changed.  The perspective's interactor
          should call Update after modifying its perspective.

SEE ALSO
     Adjuster(3I), Interactor(3I), Panner(3I), Scroller(3I)







Printed 4/10/90           15 June 1987                          1






PropertySheet(3I)   UNIX Programmer's Manual    PropertySheet(3I)



NAME
     PropertySheet - user-customizable attributes

SYNOPSIS
     #include <InterViews/propsheet.h>

DESCRIPTION
     A property sheet is a tree of  directories  and  attributes.
     The  syntax  and semantics of property sheets is the same as
     the X Toolkit defines for resources, though the  terminology
     here is slightly different.

     An attribute is defined by a string name, string value,  and
     optional  string type descriptor.  A property directory con-
     tains a list of attributes, a list of subdirectories, a list
     of  ``default''  attributes,  and a list of ``default'' sub-
     directories.  Any of the lists  can  be  empty.   InterViews
     uses  a  global property sheet called ``properties'' to cus-
     tomize the appearance and behavior of interactive objects.

PUBLIC OPERATIONS
     PropertySheet()
          Construct a property sheet.  The initial sheet contains
          a single root directory with no attributes.

     ~PropertySheet()
          Free all storage associated with the property sheet.

     boolean Load(const char* filename)
          Read a set of attributes from  the  given  file.   Each
          attribute  is defined on a separate line, with its path
          from  the  root  fully-qualified.   A  ``.''  separates
          directories,  a  ``*'' separates a default, and a ``:''
          separate the path from the value.  Thus, ``A.B*C.D:this
          is a test'' defines an attribute D with value ``this is
          a test''.  The path to D starts at the  property  sheet
          root,  followed  by a subdirectory named A, a subdirec-
          tory named B, and a default subdirectory named C.

     If any of the directories are not present, Load will  create
     them.   If  an  attribute  is  already  defined,  Load  will
     overwrite its value with the new value.

nil)
     void Put(const char* path, const char* value, const char* type  =
          Add an attribute to the property sheet explicitly.

     boolean Get(PropertyDef&)
          Find an attribute.  PropertyDef is a structure contain-
          ing a name, type descriptor, and value.  To make lookup
          fast in the cases where the name can be processed ahead
          of  time,  the name is an index into a StringTable(3I).



Printed 4/10/90          15 August 1988                         1






PropertySheet(3I)   UNIX Programmer's Manual    PropertySheet(3I)



          The search looks in  each  directory  on  the  property
          directory  stack in order.  Get searches the top direc-
          tory for an attribute and all other directories  for  a
          default attribute.

     boolean GetLocal(PropDir*, PropertyDef&)
          Find an attribute that is local to  a  particular  pro-
          perty directory.

     PropDir* Find(PropertyName)
          Find the property  directory  that  matches  the  given
          directory  name.  The search looks in each directory on
          the property directory stack in order.  If no directory
          can be found with the given name, Find returns _n_i_l.

     void Push(PropDir*, boolean sibling)
          Add a property directory to the stack.  If  sibling  is
          true, then Get will search both the top and next to top
          stack elements for an attribute.

     void Pop()
          Remove the top of the property directory stack.

     PropDir* Root()
          Return the root directory of the property sheet.

SEE ALSO
     Interactor(3I), StringTable(3I)



























Printed 4/10/90          15 August 1988                         2






Raster(3I)          UNIX Programmer's Manual           Raster(3I)



NAME
     Raster - simple rasterized image data

SYNOPSIS
     #include <InterViews/raster.h>

DESCRIPTION
     A _R_a_s_t_e_r is a two-dimensional array of Colors  that  can  be
     rendered by a Painter.  Rasters can be constructed from data
     supplied by the application program or from a  region  of  a
     Canvas.   The  only  operations currently defined on rasters
     are for accessing individual raster cells.

PUBLIC OPERATIONS
     Raster(Color** data, int width, int height)
          Create a raster from the data specified.  The  data  is
          formatted  as  a  two-dimensional matrix of pointers to
          Colors, organized in  row-major  order.   The  data  is
          transferred  into  an  internal  format,  so subsequent
          changes in either the passed data or  the  raster  will
          not   affect   the  other.   Passing  nil  to  _d_a_t_a  is
          equivalent to passing an array with all cells  contain-
          ing a pointer to the predefined Color _w_h_i_t_e.

     Raster(Canvas*, Coord x0, Coord y0, int width, int height)
          Create a raster from the current contents of  the  Can-
          vas.   The coordinates _x_0 and _y_0 specify the lower left
          corner of the region of the Canvas to use.

     Raster(Raster*)
          Create a copy of the given raster.

     int Width()
     int Height()
          These operations return the size of the raster.

     Color* Peek(int x, int y)
     void Poke(Color*, int x, int y)
     boolean Contains(int x, int y)
          Operations for reading and writing individual cells  in
          the  raster.   If  the  specified  coordinates  are not
          within the raster bounds, _C_o_n_t_a_i_n_s returns false,  _P_e_e_k
          returns nil, and _P_o_k_e has no effect.

SEE ALSO
     Painter(3I), Transformer(3I)









Printed 4/10/90           24 April 1989                         1






Regexp(3I)          UNIX Programmer's Manual           Regexp(3I)



NAME
     Regexp - regular expression searching

SYNOPSIS
     #include <InterViews/regexp.h>

DESCRIPTION
     A Regexp  encapsulates  a  regular  expression  pattern  and
     defines  operations  for  searching and matching the pattern
     against a string.  The syntax of the regular expression pat-
     tern  is  the  same  as  that for ed(1).  Information can be
     obtained about the most recent match of the regular  expres-
     sion (and its sub-expressions).

PUBLIC OPERATIONS
     Regexp(const char* pattern)
     Regexp(const char* pattern, int length)
          Construct a new Regexp for _p_a_t_t_e_r_n.

     int Match(const char* text, int length, int index)
          Attempt a match against  _t_e_x_t  (of  length  _l_e_n_g_t_h)  at
          position  _i_n_d_e_x.  The return value is the length of the
          matching string, or a  negative  number  if  the  match
          failed.

     int Search(const char* text, int length, int index, int range)
          Search  for  a  match  in  the  string  _t_e_x_t (of length
          _l_e_n_g_t_h).  Matches are attempted starting  at  positions
          between  _i_n_d_e_x and _i_n_d_e_x plus _r_a_n_g_e.  If _r_a_n_g_e is posi-
          tive the first match after _i_n_d_e_x is reported.  If _r_a_n_g_e
          is  negative  the first match before _i_n_d_e_x is reported.
          The return value is the index of the starting  position
          of the match, or a negative number if there is no match
          in the specified range.

     int BeginningOfMatch(int subexp)
     int EndOfMatch(int subexp)
          Return information about the  most  recent  match.   If
          _s_u_b_e_x_p  is  zero (the default), information is reported
          for the complete regular expression.  Other  values  of
          _s_u_b_e_x_p  refer  to  sub-expressions in the pattern.  For
          example, if _s_u_b_e_x_p is 2, information  is  returned  for
          the  sub-expression  specified by the second pair of \(
          and \) delimiters in the pattern.

SEE ALSO
     ed(1)








Printed 4/10/90            23 May 1989                          1






ReqErr(3I)          UNIX Programmer's Manual           ReqErr(3I)



NAME
     ReqErr - handle request errors

SYNOPSIS
     #include <InterViews/reqerr.h>

DESCRIPTION
     Some requests to the window server may  generate  an  error.
     For  example,  if  a  window  is destroyed while it is being
     repositioned interactively, the request to place the  window
     in  the  new  position  will fail.  Normally, errors cause a
     process to terminate.  The ReqErr class is  used  to  handle
     errors  within  an  application.  The base class defines the
     attributes associated with each error, including  a  _m_e_s_s_a_g_e
     string  describing  the  error, an integer _r_e_q_u_e_s_t code that
     specifies the kind of call that generated the error,  and  a
     _i_d object that was the target of the request.  When an error
     occurs, the attributes of the current  request  handler  are
     assigned and the handler's Error operation is called.

PUBLIC OPERATIONS
     ReqErr* Install()
          Use this error handler for subsequent errors and return
          the previous error handler.

     virtual void Error()
          Handle a detected error.  The default handler is a nop.

SEE ALSO
     Interactor(3I)

























Printed 4/10/90           15 June 1987                          1






Resource(3I)        UNIX Programmer's Manual         Resource(3I)



NAME
     Resource - InterViews shared object

SYNOPSIS
     #include <InterViews/resource.h>

DESCRIPTION
     Resource is a class that provides a simple form of reference
     counting for shared objects.  Every resource has a reference
     count that is initially set to one and  must  be  explicitly
     incremented through a call to Reference.  When a resource is
     deleted, the reference count is  decremented  and  if  still
     non-zero the object is not actually destroyed.

PUBLIC OPERATIONS
     Resource()
          Create a new resource object with reference count one.

     ~Resource()
          Decrement the reference count and  destroy  the  object
          only if the count is now zero.

     void Reference()
          Increment the resource's reference count.

     boolean LastRef()
          Check if the resource  only  has  a  single  reference.
          This  operation  is  useful in a subclass destructor to
          decide whether to destroy components of an object.


























Printed 4/10/90           15 June 1987                          1






Rubband(3I)         UNIX Programmer's Manual          Rubband(3I)



NAME
     Rubband - rubberbanding graphical objects

SYNOPSIS
     #include <InterViews/rubband.h>
     #include <InterViews/rubline.h>
     #include <InterViews/rubrect.h>
     #include <InterViews/rubcurve.h>

DESCRIPTION
     Rubband is the base class for a set of classes that  provide
     graphical  feedback to a user when performing an interactive
     operation such as sizing a rectangle.  A  rubberband  varies
     in  appearance as its ``tracking'' point changes.  A rubber-
     band is NOT an interactor itself, but is used by an interac-
     tor.   The  rubberband constructors therefore must be passed
     the painter and canvas to use for drawing.

PUBLIC OPERATIONS
offy = 0)
     RubberLine(Painter*, Canvas*, Coord fx, fy, mx,  my,  offx  =  0,
          A  rubber  line  stretches to follow the tracking point
          while its other endpoint stays tied down.

offy = 0)
     RubberAxis(Painter*, Canvas*, Coord fx, fy, mx,  my,  offx  =  0,
          A  rubber  axis stretches either horizontally or verti-
          cally to follow the tracking point while its other end-
          point  stays tied down.  One endpoint stays fixed while
          the other moves along either the horizontal or vertical
          axis, whichever is closer to the tracking point.

offx = 0, offy = 0)
     SlidingLine(Painter*, Canvas*, Coord x0, y0, x1,  y1,  rfx,  rfy,
          A  sliding  line  slides  around  without  changing its
          length or angle as the tracking point  moves  around  a
          reference point.

offx = 0, offy = 0)
     RotatingLine(Painter*, Canvas*, Coord x0, y0, x1, y1,  rfx,  rfy,
          A  rotating  line  rotates around (_c_x, _c_y) based on the
          angle between the radius from  (_c_x, _c_y)  to  (_r_f_x, _r_f_y)
          and the radius from (_c_x, _c_y) to the tracking point.

offy = 0)
     RubberRect(Painter*, Canvas*, Coord fx, fy, mx,  my,  offx  =  0,
          A  rubber  rectangle  stretches  to  follow the tacking
          point while its opposite corner stays tied down.

offx = 0, offy = 0)
     SlidingRect(Painter*, Canvas*, Coord x1, y1, x2,  y2,  rfx,  rfy,
          A  sliding  rectangle  slides around the screen without



Printed 4/10/90           15 June 1987                          1






Rubband(3I)         UNIX Programmer's Manual          Rubband(3I)



          changing its side or orientation as the tracking  point
          moves around a reference point.

= 0, offy = 0)
     ScalingRect(Painter*, Canvas*, Coord x1, y1, x2, y2, cx, cy, offx
          A  scaling  rectangle scales equally in both dimensions
          about (_c_x, _c_y) to keep one edge intersecting the track-
          ing point.

rfx, rfy, offx = 0, offy = 0)
     RotatingRect(Painter*, Canvas*, Coord x1, y1,  x2,  y2,  cx,  cy,
          A  rotating  rectangle  rotates about (_c_x, _c_y) based on
          the radius from (_c_x, _c_y) to (_r_f_x, _r_f_y) and  the  radius
          from (_c_x, _c_y) to the tracking point.

Coord offx = 0, offy = 0)
     StretchingRect(Painter*, Canvas*, Coord x1, y1, x2, y2, Side  ts,
          A  stretching  rectangle's  tracking  side  follows the
          tracking point while the  opposite  side  stays  fixed.
          The _s_i_d_e can be one of _L_e_f_t_S_i_d_e, _R_i_g_h_t_S_i_d_e, _B_o_t_t_o_m_S_i_d_e,
          or _T_o_p_S_i_d_e.

offy = 0)
     RubberCircle(Painter*, Canvas*, Coord cx, cy, rx, ry, offx  =  0,
          A  rubber  circle's radius varies with the magnitude of
          the tracking point's distance from (_c_x, _c_y).

offy = 0)
     RubberEllipse(Painter*, Canvas*, Coord cx, cy, rx, ry, offx =  0,
          A  rubber  ellipse's horizontal and vertical radii vary
          with the magnitude of  the  tracking  point's  distance
          from (_c_x, _c_y).

offx = 0, offy = 0)
     RubberSpline(Painter*, Canvas*, Coord x[], y[], int n, pt,  Coord
Coord offx = 0, offy = 0)
     RubberClosedSpline(Painter*,  Canvas*, Coord x[], y[], int n, pt,
          A rubber spline is the section of a B-spline defined by
          _n control points that  changes  shape  as  the  control
          point indexed by _p_t is set to the tracking point.

Coord offx = 0, offy = 0)
     RubberHandles(Painter*, Canvas*, Coord x[], y[], int n, pt, size,
          A rubber handles object is a set of filled squares cen-
          tered about each point in the list.  The point index by
          _p_t follows the tracking point.

Coord rfx, rfy, offx = 0, offy = 0)
     SlidingPointList(Painter*, Canvas*, Coord x[], y[],  int  n,  pt,
          A  sliding  point list slides around the screen without
          changing its appearance as  the  tracking  point  moves
          around a reference point.



Printed 4/10/90           15 June 1987                          2






Rubband(3I)         UNIX Programmer's Manual          Rubband(3I)



Coord rfx, rfy, offx = 0, offy = 0)
     SlidingLineList(Painter*, Canvas*, Coord x[],  y[],  int  n,  pt,
          A  sliding  line  list slides around the screen without
          changing the appearance of its connected lines  as  the
          tracking point moves around (_r_f_x, _r_f_y).

     virtual void Draw()
     void Redraw()
     virtual void Erase()
          Explicitly draw,  redraw,  and  erase  the  rubberband.
          Multiple  calls  to  Draw  without an intervening Erase
          will only draw the rubberband once.  Redraw forces  the
          rubberband to be drawn.  Since rubberbands are drawn in
          XOR mode, Redraw will erase the rubberband every  other
          time  it  is  called.  These functions are used only on
          occasion, for example,  when  part  of  the  screen  is
          erased  while a rubberband is visible.  The Track func-
          tion  is  normally  used  to  draw  the  rubberband  in
          response to mouse input.

     virtual void Track(Coord x, Coord y)
          Erase the rubberband and redraw it using the new track-
          ing point.

     void GetOriginal(Coord& x1, Coord& y2, Coord& x2, Coord& y2)
     void GetCurrent(Coord& x1, Coord& y2, Coord& x2, Coord& y2)
          GetOriginal obtains the original points  specified  for
          the  rubberband.  GetCurrent obtains the current points
          based on the most recent call to Track.  The meaning of
          the  points  depends  on  the  kind of rubberband.  For
          lines, the points are the  endpoints;  for  rectangles,
          the  points  are opposite corners; for curves, (_x_1, _y_1)
          is the center and _x_2 and _y_2 are the radii.

     virtual void SetPainter(Painter*)
     Painter* GetPainter()
          Explicitly set and get the painter used by the  rubber-
          band. By default, rubberbands use a copy of the painter
          passed to their constructor.  The user  can  specify  a
          particular  painter  to use by passing a nil painter to
          the constructor and later  calling  SetPainter.   _N._B.:
          the rubberband may alter the painter specified via Set-
          Painter.

     virtual void SetCanvas(Canvas*)
     Canvas* GetCanvas()
          Explicitly set and get the canvas used by  the  rubber-
          band.

SEE ALSO
     Canvas(2I), Painter(2I)




Printed 4/10/90           15 June 1987                          3






Scene(3I)           UNIX Programmer's Manual            Scene(3I)



NAME
     Scene, MonoScene - composite interactors

SYNOPSIS
     #include <InterViews/scene.h>

DESCRIPTION
     Scene is the base class for all interactors that are defined
     in  terms  of  one  or  more instances of other interactors.
     MonoScene is a subclass for scenes  that  contain  a  single
     instance.   A monoscene's shape is copied from its component
     and the component's canvas is given the same size and  loca-
     tion as the monoscene's canvas.

     When a scene is deleted, it should delete all its  component
     interactors.   A monoscene deletes its existing component if
     a new component is inserted.

PUBLIC OPERATIONS
     void Insert(Interactor*)
Left)
     void Insert(Interactor*, Coord x, Coord y,  Alignment  =  Bottom-
     virtual Interactor* Wrap(Interactor*)
Shape*)
     virtual void DoInsert(Interactor*, boolean, Coord& x,  Coord&  y,
          Add an interactor to the scene, optionally aligned with
          respect to a specific position relative to  the  lower-
          left  corner  of  the scene.  Valid alignment types are
          TopLeft, TopCenter, TopRight, CenterLeft, Center,  Cen-
          terRight,  BottomLeft, BottomCenter, BottomRight, Left,
          Right, Top, Bottom, HorizCenter, and  VertCenter.   The
          scene  uses  the  interactor's desired shape, if it has
          non-zero width, to size the interactor.  The base scene
          class  always calls Wrap and DoInsert from Insert; thus
          subclasses only implement DoInsert (and  Wrap  if  they
          want to wrap additional interactors around the inserted
          interactor) and users only call Insert.  In the case of
          a  monoscene,  the  current interior interactor, if not
          nil, is deleted and replaced by the  given  interactor.
          If  an  interactor  is  inserted  into  a scene that is
          already mapped, the interactor and its descendants will
          be configured before DoInsert is called.

     void Propagate(boolean)
     void Change(Interactor*)
     virtual void DoChange(Interactor*, Shape*)
          Change notifies a scene that  a  given  interactor  has
          changed its desired shape.  If the propagate flag asso-
          ciated  with  the  scene  is  true,  Change  will  call
          DoChange  and  then Change(this) on the scene's parent.
          If the propagate flag is false, Resize will  be  called
          instead.  The propagate flag is true by default and can



Printed 4/10/90            7 Mar 1989                           1






Scene(3I)           UNIX Programmer's Manual            Scene(3I)



          be set with the Propagate operation.

     void Move(Interactor*, Coord x, Coord y, Alignment = BottomLeft)
     virtual void DoMove(Interactor*, Coord& x, Coord& y)
          Request that an interactor be moved to the given  coor-
          dinates  using the given alignment.  As with Insert and
          Change,  users  call  Move  and  subclasses   implement
          DoMove.

     void Remove(Interactor*)
     virtual void DoRemove(Interactor*)
          Remove an interactor from a scene.  Users  call  Remove
          and subclasses implement DoRemove.

     void Lower(Interactor*)
     virtual void DoLower(Interactor*)
          Put the interactor's canvas below  all  others  in  the
          scene,  potentially obscuring it.  Users call Lower and
          subclasses implement DoLower.

     void Raise(Interactor*)
     virtual void DoRaise(Interactor*)
          Put the interactor's canvas above  all  others  in  the
          scene,  making  it fully visible.  Users call Raise and
          subclasses implement DoRaise.

PROTECTED OPERATIONS
     Scene()
     MonoScene()
          Construct a new scene or monoscene.  Scenes and  monos-
          cenes  are  abstract  classes;  thus,  the constructors
          should only be called implicitly by subclass  construc-
          tors.

boolean = true)
     void Place(Interactor*, Coord x1, Coord y1, Coord x2,  Coord  y2,
          Assign  an  interactor's canvas to be a given region of
          the scene's canvas.  Unless the optional sixth  parame-
          ter  is  false,  the interactor will be mapped.  If the
          interactor is already assigned the given  position  and
          size,  then  this  operation will have no effect.  This
          optimization means that a scene can place  all  of  its
          elements  in  response  to a Change and be assured that
          only those elements that have really  changed  will  be
          redrawn.

     void Map(Interactor*, boolean = true)
          Make the interactor visible on the display if and  when
          the  scene  is  visible.   Unless  the  optional second
          parameter is false, the interactor will  be  raised  to
          the top of the scene.




Printed 4/10/90            7 Mar 1989                           2






Scene(3I)           UNIX Programmer's Manual            Scene(3I)



     void Unmap(Interactor*)
          Make the interactor not be visible on  the  display  if
          and when the scene is visible.

     void UserPlace(Interactor*, int w, int h)
          Let the  user  interact  with  the  window  manager  to
          specify  the size and location of the interactor's can-
          vas, whose default width and height must also  be  sup-
          plied by the program.

SEE ALSO
     Canvas(3I), Interactor(3I), Shape(3I)











































Printed 4/10/90            7 Mar 1989                           3






Scroller(3I)        UNIX Programmer's Manual         Scroller(3I)



NAME
     Scroller, HScroller, VScroller - scrolling an interactor

SYNOPSIS
     #include <InterViews/scroller.h>

DESCRIPTION
     A scroller is an interactor that manipulates the perspective
     of another interactor.  It contains a bar whose position and
     size reflect the current origin and size in the interactor's
     perspective.   VScroller  is  a  class for defining vertical
     scrollers, HScroller for horizontal scrollers.

PUBLIC OPERATIONS
     HScroller(Interactor*, int size = 0)
     VScroller(Interactor*, int size = 0)
          Create a scroller of a given size (height  for  a  hor-
          izontal  scroller,  width  for a vertical scroller).  A
          zero size means to use the default size.

     virtual void Handle(Event&)
          The left button shifts the perspective's current origin
          down, the right button shifts the origin up, the middle
          button rubberbands the scroll bar until the  button  is
          released and then moves the origin to reflect the rela-
          tive position of the bar in the scroller.  The scroller
          calls  Adjust  on the interactor to update the perspec-
          tive.  The left  and  right  buttons  shift  a  smaller
          amount if the shift key is down.

     virtual void Update()
          Redisplay the scroller  to  reflect  a  change  in  the
          interactor's perspective.

X DEFAULTS
     The ``syncScroll'' resource specifies whether  the  scroller
     should  work  in real-time or not.  When synchronized scrol-
     ling is employed the interactor scrolls synchronously as the
     scroller's  bar is dragged; otherwise the bar's outline fol-
     lows the  mouse  during  dragging,  and  the  interactor  is
     scrolled  only  after  the  user  stops  dragging  the  bar.
     Scrollers will  scroll  synchronously  if  their  syncScroll
     resource  is  set  to  ``on''  or ``true.'' The state of the
     syncScroll attribute can be toggled temporarily  by  holding
     down the ``control'' key while the scroller is manipulated.

SEE ALSO
     Interactor(3I), Perspective(3I)







Printed 4/10/90           15 June 1987                          1






Sensor(3I)          UNIX Programmer's Manual           Sensor(3I)



NAME
     Sensor - input interest for interactors

SYNOPSIS
     #include <InterViews/sensor.h>

DESCRIPTION
     A sensor  specifies  a  set  of  interesting  input  events.
     Several  sensors  are  predefined  as global variables.  The
     sensor ``allEvents'' is interested in all user input  events
     (excludes  ChannelEvent and TimerEvent); ``noEvents'' is not
     interested in any events; ``updownEvents'' is interested  in
     UpEvents  and  DownEvents; and ``onoffEvents'' is interested
     in OnEvents and OffEvents.

PUBLIC OPERATIONS
     Sensor()
          Create a new sensor  that  is  not  interested  in  any
          events.

     Sensor(Sensor*)
          Create a sensor whose interests are  the  same  as  the
          given sensor.

     void Catch(EventType)
     void CatchButton(EventType, int)
     void CatchChannel(int)
     void CatchTimer(int sec, int usec)
          Express interest in an event.  CatchButton can be  used
          for  keys as well as buttons, though it is necessary to
          know the key code.  Not all types of events make  sense
          for     all     the     operations;     for    example,
          Catch(ChannelEvent) is not meaningful.   Such  requests
          are silently ignored.

     void Ignore(EventType)
     void IgnoreButton(EventType, int)
     void IgnoreChannel(int)
          Remove interest in an event.  Ignore means no  interest
          in    any   events   of   a   particular   kind;   thus
          Ignore(DownEvent) means pressing any  button  will  not
          generate an event.

     void CatchRemote()
     void IgnoreRemote()
          Express or remove interest in access to  the  structure
          of  an  interactor's  canvas.  Only a world view should
          use these operations, as such access is reported  using
          the WorldView::InsertRemote and WorldView::ChangeRemote
          operations.





Printed 4/10/90         11 December 1987                        1






Sensor(3I)          UNIX Programmer's Manual           Sensor(3I)



SEE ALSO
     Interactor(3I), World(3I), WorldView(3I)





















































Printed 4/10/90         11 December 1987                        2






Shape(3I)           UNIX Programmer's Manual            Shape(3I)



NAME
     Shape - what shape a canvas should have

SYNOPSIS
     #include <InterViews/shape.h>

DESCRIPTION
     A shape specifies the desired characteristics of  a  canvas.
     An  interactor should set the fields of its shape when it is
     reconfigured and should call Change on its parent if any  of
     these fields change.

     The dimensions of a shape are defined by a ``natural'' size,
     a stretch amount, and a shrink amount.  The _w_i_d_t_h and _h_e_i_g_h_t
     fields indicate the desired sizes.  The _h_s_t_r_e_t_c_h,  _v_s_t_r_e_t_c_h,
     _h_s_h_r_i_n_k,  _v_s_h_r_i_n_k  fields  define how flexible these desired
     sizes are.  For example, an interactor may  have  a  natural
     size  of  100, but can adequately handle any size between 50
     and 200.  The stretchability for this case would be 100  and
     the shrinkability 50.

     The  constants  _h_f_i_l  and  _v_f_i_l  are  provided  to  indicate
     ``infinite''  stretching or shrinking.  They are represented
     as very large numbers and manipulated exactly  the  same  as
     other stretch and shrink parameters.

     The _a_s_p_e_c_t field specifies  the  desired  aspect  ratio.   A
     value of zero means any aspect is acceptable.

     The _h_u_n_i_t_s and _v_u_n_i_t_s fields indicate that the canvas dimen-
     sions should be multiples of some values.

PUBLIC OPERATIONS
     Shape()
          Construct a new shape with undefined natural  size  and
          infinite   stretchability  and  shrinkability  in  both
          directions.

     boolean Defined()
     boolean Undefined()
          Test if the shape's natural size is defined or not.

     void Rect(int width, int height)
     void Square(int side)
          Short-hand for setting the  dimensions  of  the  shape.
          Square sets both dimensions to _s_i_d_e and sets the aspect
          ratio to one.

     void Rigid(int hshrink, int hstretch, int vshrink, int vstretch)
     void Rigid()
          Set the stretchability and shrinkability fields of  the
          shape.   If  no arguments are specified, the fields are



Printed 4/10/90           15 June 1987                          1






Shape(3I)           UNIX Programmer's Manual            Shape(3I)



          set to zero.

     void SetUndefined()
          Reset the shape's natural size to be undefined.

SEE ALSO
     Interactor(3I), Scene(3I)
















































Printed 4/10/90           15 June 1987                          2






StringEditor(3I)    UNIX Programmer's Manual     StringEditor(3I)



NAME
     StringEditor - single line interactive string editor

SYNOPSIS
     #include <InterViews/stringeditor.h>

DESCRIPTION
     StringEditor is an interactor  that  provides  a  convenient
     mouse-based  interactive  editor  for  text  strings.  It is
     suitable for incorporation into  other  components  such  as
     dialog  boxes.  Clicking inside the StringEditor (or calling
     the Edit function) initiates an edit.   Subsequent  keyboard
     events,  which  need  not  be  inside  the StringEditor, are
     interpreted as editing operations on  the  text.   Typing  a
     carriage  return  or  clicking  outside  the StringEdit ter-
     minates the edit.   StringEditor  works  with  either  fixed
     width or proportionally spaced fonts.

EDITING MODEL
     Text is selected with the mouse or  with  the  keyboard.   A
     single  click  selects a new insertion point between charac-
     ters.  Dragging across the text selects a range  of  charac-
     ters.   A  set  of  control characters is mapped into common
     editing operations.  A character not specifically associated
     with commands is inserted in place of the the current selec-
     tion, the replaced text is lost, and the  selection  becomes
     an  insertion  point following the inserted character.  Com-
     mands currently defined include the following.

     CharacterLeft (^B)
     CharacterRight (^F)
     BeginningOfText (^A)
     EndOfText (^E)
          Move the selection one character position to  the  left
          or right, or to the beginning or end of the text.

     Erase (^H, DEL)
     Delete (^D)
          Delete the text  of  the  current  selection.   If  the
          selection  is  an  insertion point, delete the previous
          character  (Erase)  or  the  next  character   (Delete)
          instead.

     SelectAll (^U)
     SelectWord (^W)
          Select the entire text, or extend the selection to  the
          left  by  one whole word.  These commands enable common
          editing operations to be performed  without  using  the
          mouse.   For  example,  to replace the previous word in
          the text, do a SelectWord and type the new text.

     Accept (CR)



Printed 4/10/90            23 May 1989                          1






StringEditor(3I)    UNIX Programmer's Manual     StringEditor(3I)



     Cancel (^G)
          Finish the edit.

PUBLIC OPERATIONS
sample)
     StringEditor(ButtonState*, int accept, int  cancel,  const  char*
          Create a new StringEditor object.  The ButtonState will
          be used to communicate the  result  of  editing  opera-
          tions.  If an edit is terminated by an Accept, the But-
          tonState will be set to _a_c_c_e_p_t.  If the  edit  is  ter-
          minated  by Cancel, the ButtonState will be set to _c_a_n_-
          _c_e_l.  The shape of the new object  is  calculated  from
          the length of the sample string.

     void Message(const char* text)
          Set the contents of the edit buffer to _t_e_x_t.

     void Select(int point)
     void Select(int left, int right)
          Select an insertion point or a  subrange  of  the  edit
          buffer.

     void Edit()
     void Edit(const char* text, int left, int right)
          Initiate an edit.  Specifying a  string  and  selection
          range  is  short  hand  for  first  calling Message and
          Select with the corresponding parameters.

     const char* Text()
          Return the current value of the edit buffer.  Note that
          this  buffer is owned by the StringEditor, and that its
          contents are subject to change.   It  is  the  caller's
          responsibility  to copy the string if the value will be
          needed in the long term.

     Handle(Event&)
          Handle the  event,  and  read  and  process  subsequent
          events until an Accept or Cancel command is executed or
          a down click occurs outside the StringEditor's bounds.

PROTECTED OPERATIONS
     virtual boolean HandleChar(char)
     void InsertText(const char* text, int length)
          Subclasses of StringEditor can perform additional  pro-
          cessing  on  the  edit buffer.  For instance, an editor
          for file names might do file  name  completion,  or  an
          editor  for  numeric  input might check the validity of
          the string as it is entered.   Derived  classes  should
          redefine  the  virtual function HandleChar as required.
          HandleChar should return true to indicate that the edit
          is  completed,  or  false otherwise.  InsertText can be
          used to insert text into the edit buffer, replacing any



Printed 4/10/90            23 May 1989                          2






StringEditor(3I)    UNIX Programmer's Manual     StringEditor(3I)



          currently selected text.

SEE ALSO
     Interactor(2I), Button(3I)



















































Printed 4/10/90            23 May 1989                          3






StringPool(3I)      UNIX Programmer's Manual       StringPool(3I)



NAME
     StringPool - store strings in large chunks

SYNOPSIS
     #include <InterViews/strpool.h>

DESCRIPTION
     A string pool is an area  for  character  storage.   Because
     strings in a pool cannot be independently deallocated, it is
     generally faster to allocate them than to use _n_e_w in C++  or
     _m_a_l_l_o_c in C.

PUBLIC OPERATIONS
     StringPool(int size = 800)
          Construct a string pool.  The size is used to  allocate
          contiguous  blocks  of storage.  When one block is con-
          sumed, another block is allocated  from  the  operating
          system.   The  default  block  size will fit in a small
          page (1024-byte).

     ~StringPool()
          Free the storage associated with the string pool.

     char* Append(const char*, int)
          Add a string of a given length to a pool.  Append  does
          not  add  a  null  to terminate strings in the pool; if
          desired, null-termination must be performed  explicitly
          by the caller.

SEE ALSO
     malloc(3)
























Printed 4/10/90          15 August 1988                         1






StringTable(3I)     UNIX Programmer's Manual      StringTable(3I)



NAME
     StringTable - map strings to unique pointers

SYNOPSIS
     #include <InterViews/strtable.h>

DESCRIPTION
     A string table is an index for character strings.  The table
     maps  strings  or  substrings  to  a  unique pointer to type
     StringId.  The table guarantees that the  same  string  will
     always  be mapped to the same pointer; thus, one can quickly
     compare if two strings are equal by comparing their  precom-
     puted  pointers.   String tables use a static StringPool(3I)
     to manage the storage of the characters.

PUBLIC OPERATIONS
     StringTable(int size)
          Construct a string table of the given size.   The  size
          will  be  rounded  up  to the next power of two so that
          indexing the table does not require division (just take
          the  bitwise-and  of the string's hash value and (size-
          1)).

     ~StringTable()
          Free storage associated with the string table.

     StringId* Id(const char*)
     StringId* Id(const char*, int)
          Convert a string (null-terminated) or substring (expli-
          cit  length)  to  a  StringId.  If the string cannot be
          found, it will be  entered  into  the  table.   In  any
          event,  the  pointer  to the string table entry for the
          string is returned.

     void Remove(const char*)
     void Remove(const char*, int)
          Delete a string from the table.   This  operation  will
          not  release  any  character  storage, only the storage
          associated with table entry.

     const char* StringId::Str()
          Return the string associated with a StringId.

SEE ALSO
     StringPool(3I)










Printed 4/10/90          15 August 1988                         1






Subject(3I)         UNIX Programmer's Manual          Subject(3I)



NAME
     Subject - object with interactive views

SYNOPSIS
     #include <InterViews/subject.h>

DESCRIPTION
     A subject is an object that has one or more  views  that  it
     wishes to notify when it changes.

PUBLIC OPERATIONS
     virtual void Attach(Interactor*)
     virtual void Detach(Interactor*)
          Add or remove an interactor from the subject's list  of
          views.

     virtual void Notify()
          Call Update on all the views attached to  the  subject.
          Update is a virtual function defined on interactors.

     void DeleteViews()
          Delete all the views attached to a subject.

SEE ALSO
     Interactor(3I)






























Printed 4/10/90           29 June 1989                          1






Table(3I)           UNIX Programmer's Manual            Table(3I)



NAME
     Table - associative store for single-word objects

SYNOPSIS
     #include <InterViews/table.h>

DESCRIPTION
     A table is an index where the key and data are both  single-
     word  objects  (either  integers  or  pointers).   The types
     TableKey and TableValue are arbitrary pointers (void*);  all
     the   operations   below  are  also  provided  for  integer,
     unsigned, long, and unsigned long keys.

PUBLIC OPERATIONS
     Table(int size)
          Construct a table of the given size.  The size will  be
          rounded  up  to  the next power of two so that indexing
          the table does not  require  division  (just  take  the
          bitwise-and of the key and (size-1)).

     ~Table()
          Free storage associated with the table.

     void Insert(TableKey key, TableValue value)
          Add (_k_e_y, _v_a_l_u_e) pair to the table.   Insert  does  not
          prevent a key from being entered in the table more than
          once.

     boolean Find(TableValue& value, TableKey key)
          If _k_e_y has been inserted into the table, set  _v_a_l_u_e  to
          the  associated  value  and return true.  Otherwise, do
          not modify _v_a_l_u_e and return false.  In the presence  of
          duplicate  keys,  Find  gets the most recently inserted
          value.

     void Remove(TableKey key)
          Delete _k_e_y from the table.  If _k_e_y appears in the table
          more  than  once,  the  most recently inserted entry is
          removed.
















Printed 4/10/90          15 August 1988                         1






TextBuffer(3I)      UNIX Programmer's Manual       TextBuffer(3I)



NAME
     TextBuffer - operations on unstructured text

SYNOPSIS
     #include <InterViews/textbuffer.h>

DESCRIPTION
     TextBuffer defines common editing, searching, and text move-
     ment  operations  on  a  buffer  of unstructured text.  Text
     positions are specified by an index into the buffer and log-
     ically  refer to positions between characters.  For example,
     the position referred to by the index _0 is before the  first
     character in the text.  Indices can be compared for equality
     or ordering, but they should not be used to directly  access
     the  buffer  because  TextBuffer might rearrange the text to
     improve the efficiency of some operations.

PUBLIC OPERATIONS
     TextBuffer(char* buffer, int length, int size)
     ~TextBuffer()
          Create or  destroy  an  instance  of  TextBuffer.   All
          operations  on  the  text contained in _b_u_f_f_e_r should be
          performed through TextBuffer functions.   The  text  is
          assumed to be of length _l_e_n_g_t_h, and the total available
          buffer size is _s_i_z_e.

     int Search(Regexp* regexp, int index, int range, int stop)
     int ForwardSearch(Regexp* regexp, int index)
     int BackwardSearch(Regexp* regexp, int index)
          Search for a match with the regular expression  _r_e_g_e_x_p,
          beginning  at position _i_n_d_e_x.  Search searches the part
          of the buffer specified by _r_a_n_g_e and _s_t_o_p  and  returns
          the  index of the beginning of the matched text.  Posi-
          tive values of  _r_a_n_g_e  specify  forward  searches,  and
          negative  values  specify backward searches.  In either
          case, the matched text will not extend beyond the posi-
          tion given by _s_t_o_p.  ForwardSearch searches for matches
          from _i_n_d_e_x to the end of the text and returns the index
          of  the end of the match.  BackwardSearch searches from
          _i_n_d_e_x to the start of the text and returns the index of
          the beginning of the match.  All three functions return
          a negative number if there was no match.

     int Match(Regexp* regexp, int index, int stop)
     boolean ForwardMatch(Regexp* regexp, int index)
     boolean BackwardMatch(Regexp* regexp, int index)
          Attempt to match the regular expression _r_e_g_e_x_p  at  the
          position _i_n_d_e_x.  Match returns the length of the match-
          ing string, or a negative number if there was no match.
          Matching  will not succeed beyond the position given by
          _s_t_o_p.  ForwardMatch looks for a match  that  begins  at
          _i_n_d_e_x.   BackwardMatch  looks  for a match that ends at



Printed 4/10/90            23 May 1989                          1






TextBuffer(3I)      UNIX Programmer's Manual       TextBuffer(3I)



          _i_n_d_e_x.

     int Insert(int index, const char* string, int count)
     int Delete(int index, int count)
     int Copy(int index, char* buffer, int count)
          Edit the text in  the  buffer.   Insert  inserts  count
          characters  from  _s_t_r_i_n_g  at  the  position  _i_n_d_e_x.  It
          returns the actual number of characters inserted, which
          might be less than count if there is insufficient space
          in the buffer.  Delete deletes  _c_o_u_n_t  characters  from
          the  buffer.  A positive _c_o_u_n_t deletes characters after
          _i_n_d_e_x, and a negative value  deletes  character  before
          _i_n_d_e_x.   Delete returns the actual number of characters
          deleted, which might be less than  _c_o_u_n_t  if  index  is
          near the beginning or the end of the text.  Copy copies
          _c_o_u_n_t characters into _b_u_f_f_e_r.  A positive _c_o_u_n_t  copies
          characters  after  _i_n_d_e_x  and  a  negative _c_o_u_n_t copies
          characters before  _i_n_d_e_x.   Count  returns  the  actual
          number  of  characters  copied.   It  is  the  caller's
          responsibility to ensure that  _b_u_f_f_e_r  contains  suffi-
          cient space for the copied text.

     int Height()
     int Width()
     int Length()
          Return information about the text.  Height returns  the
          number  of  lines in the text, Width returns the number
          of characters in the longest line, and  Length  returns
          the total number of characters.

     const char* Text()
     const char* Text(int index)
     const char* Text(int index1, int index2)
     char Char (int index)
          Access the contents of  the  text.   Char  returns  the
          character  immediately following _i_n_d_e_x.  The three Text
          calls return pointers to character strings representing
          the  text.  They make various guarantees about the for-
          mat of the returned string.  With no  parameters,  Text
          returns  a pointer to a string that contains the entire
          text of the buffer.  With a single parameter the string
          contains at least the text from _i_n_d_e_x to the end of the
          line.  With two parameters, the  returned  string  con-
          tains  at least the text between _i_n_d_e_x_1 and _i_n_d_e_x_2.  In
          any case, the returned string should be considered tem-
          porary and its contents subject to change.  To maximize
          efficiency, you should prefer the more restricted forms
          of Text.

     int LineIndex(int line)
     int LinesBetween(int index1, int index2)
     int LineNumber(int index)



Printed 4/10/90            23 May 1989                          2






TextBuffer(3I)      UNIX Programmer's Manual       TextBuffer(3I)



     int LineOffset (int index)
          Map between text indices and line and offset positions.
          LineIndex  returns  the  index of the beginning of line
          _l_i_n_e.  LineNumber returns the number of the  line  that
          contains _i_n_d_e_x.  LineOffset returns the offset of _i_n_d_e_x
          from the beginning  of  its  containing  line.   Lines-
          Between  returns  the difference between the numbers of
          the lines containings _i_n_d_e_x_1 and _i_n_d_e_x_2; a return value
          of  zero  indicates  that  _i_n_d_e_x_1 and _i_n_d_e_x_2 are on the
          same line, and a positive value indicates that the line
          containing  _i_n_d_e_x_2 is after the line containing _i_n_d_e_x_1.
          Lines are numbered starting from zero.

     int PreviousCharacter(int index)
     int NextCharacter(int index)
          Return the index  immediately  following  or  preceding
          _i_n_d_e_x.   The  returned value is never before the begin-
          ning or after the end of the text.

     boolean IsBeginningOfText(int index)
     int BeginningOfText()
     boolean IsEndOfText(int index)
     int EndOfText()
          Return the index of the beginning or end of  the  text,
          or  query  whether  _i_n_d_e_x is at the beginning or end of
          the text.

     boolean IsBeginningOfLine(int index)
     int BeginningOfLine(int index)
     int BeginningOfNextLine(int index)
     boolean IsEndOfLine(int index)
     int EndOfLine(int index)
     int EndOfPreviousLine(int index)
          Return information about the line structure of the text
          around _i_n_d_e_x.  BeginningOfLine returns the index of the
          beginning of the line containing  _i_n_d_e_x.   BeginningOf-
          NextLine returns the index of the beginning of the next
          line that begins after _i_n_d_e_x.   EndOfLine  returns  the
          index  of the end of the line containing _i_n_d_e_x.  EndOf-
          PreviousLine returns the index of the end of  the  last
          line  that  ends before _i_n_d_e_x.  The beginning of a line
          is logically immediately after a newline character, and
          the  end  of  a  line is logically immediately before a
          newline character.  The beginning and end of  the  text
          are considered to be the beginning and end of the first
          and last lines, respectively.

     boolean IsBeginningOfWord(int index)
     int BeginningOfWord(int index)
     int BeginningOfNextWord(int index)
     boolean IsEndOfWord(int index)
     int EndOfWord(int index)



Printed 4/10/90            23 May 1989                          3






TextBuffer(3I)      UNIX Programmer's Manual       TextBuffer(3I)



     int EndOfPreviousWord(int index)
          Return information about the word structure of the text
          around _i_n_d_e_x.  BeginningOfWord returns the index of the
          beginning of the word containing  _i_n_d_e_x.   BeginningOf-
          NextWord  return the index of the beginning of the nest
          word that begins after _i_n_d_e_x.   EndOfWord  returns  the
          index  of  the  end  of  the  word that contains _i_n_d_e_x.
          EndOfPreviousWord returns the index of the end  of  the
          last word that ends before _i_n_d_e_x.  A word is defined as
          a sequence of alpha-numeric characters.  The  beginning
          and  end of the text are considered to be the beginning
          and end of the first and last words, respectively.

SEE ALSO
     Regexp(3I)








































Printed 4/10/90            23 May 1989                          4






TextDisplay(3I)     UNIX Programmer's Manual      TextDisplay(3I)



NAME
     TextDisplay - unstructured text display

SYNOPSIS
     #include <InterViews/textdisplay.h>

DESCRIPTION
     A TextDisplay manages and displays  an  array  of  lines  of
     text.   Operations  are provided to insert and delete lines,
     to insert and delete text within a line, and to  scroll  the
     display.   TextDisplays  are  typically  used  to  implement
     interactors that require non-trivial display of unstructured
     text.

     The array is addressed by a line number and  an  index  into
     the  line.   Text  can  be  inserted or deleted at arbitrary
     positions.  The display is automatically  updated  following
     modifications to the text or when scrolling.  Each character
     in the array has an associated text style.   Operations  are
     provided  to apply, add, or remove font styles to a range of
     the text.  TextDisplay can be used with both  constant-width
     and proportionally-spaced fonts and with arbitrary geometric
     transformations.

PUBLIC OPERATIONS
     TextDisplay()
     ~TextDisplay()
          Create or destroy a TextDisplay.

lineheight, int tabwidth)
     void Resize(Coord xmin, Coord ymin, Coord xmax, Coord  ymax,  int
          Specify  dimension  information for the display.  Lines
          of text  that  fall  completely  inside  the  specified
          region  will  be  displayed with baselines separated by
          _l_i_n_e_h_e_i_g_h_t.  TextDisplay  will  not  draw  outside  the
          specified  region.   Tab  characters  in  the text will
          cause the  following  character  to  be  positioned  an
          integral multiple of _t_a_b_w_i_d_t_h from the beginning of the
          line.

right, Coord top)
     void Redraw(Painter*, Canvas*, Coord left,  Coord  bottom,  Coord
          Redraw  a  region  of  the  display using the specified
          Painter and Canvas.  The Painter  specifies  the  font,
          colors,  and  transformation  to  use  when drawing the
          text.

     void Scroll(int line, Coord x, Coord y)
          Scroll the display so that line _l_i_n_e is positioned with
          its lower-left corner at (_x, _y).  There are no restric-
          tions on the arguments: it is possible  to  scroll  the
          display so that no lines are visible.



Printed 4/10/90            23 May 1989                          1






TextDisplay(3I)     UNIX Programmer's Manual      TextDisplay(3I)



     void InsertLinesAfter(int line, int count)
     void InsertLinesBefore(int line, int count)
     void DeleteLinesAfter(int line, int count)
     void DeleteLinesBefore(int line, int count)
          Insert or delete whole lines of text.  Line _l_i_n_e is not
          affected by the operation.  Other lines will move up or
          down to accommodate the changes.  Newly inserted  lines
          are  blank.   The  specified  line need not refer to an
          existing line.

     void InsertText(int line, int index, const char*, int count)
     void DeleteText(int line, int index, int count)
     void ReplaceText(int line, const char*, int count)
          Modify the  text  within  line  _l_i_n_e.   InsertText  and
          DeleteText  will  cause the following characters on the
          line to move to accommodate the  changes.   ReplaceText
          replaces the entire text of the line.  If the specified
          line is non-existent, a new line will be created.

style)
     void Style(int line1, int index1,  int  line2,  int  index2,  int
style)
     void  AddStyle(int  line1, int index1, int line2, int index2, int
int style)
     void  RemoveStyle(int  line1,  int index1, int line2, int index2,
          Modify  the  styling of a range of text. Style replaces
          any existing style; AddStyle adds style _s_t_y_l_e in  addi-
          tion  to any existing styles; RemoveStyle removes style
          _s_t_y_l_e without affecting other existing styles.   Styles
          are  specified  as  any  combination  of  the constants
          Plain, Boldface, Underlined, and Reversed.

     void CaretStyle(int style)
     void Caret(int line, int index)
          Control the shape and position of a caret.  Valid caret
          styles are currently NoCaret and BarCaret.  TextDisplay
          does not automatically adjust the position of the caret
          following insertions and deletions.

     int LineNumber(Coord y)
     int LineIndex(int line, Coord x)
          Map x and y display coordinates  into  line  and  index
          text coordinates.  LineNumber returns the number of the
          line that contains the specified vertical  position  _y.
          LineIndex  returns  the  index into line _l_i_n_e that best
          corresponds to the specified horizontal position _x.

     Coord Base(int line)
     Coord Top(int line)
     Coord Left(int line, int index)
     Coord Right(int line, int index)
          Map line and  index  text  coordinates  into  x  and  y



Printed 4/10/90            23 May 1989                          2






TextDisplay(3I)     UNIX Programmer's Manual      TextDisplay(3I)



          display coordinates.  The return values define a bound-
          ing box for the character specified by _l_i_n_e and _i_n_d_e_x.

SEE ALSO
     Painter(2I), Canvas(2I)


















































Printed 4/10/90            23 May 1989                          3






TextEditor(3I)      UNIX Programmer's Manual       TextEditor(3I)



NAME
     TextEditor - basic unstructured text editing

SYNOPSIS
     #include <InterViews/texteditor.h>

DESCRIPTION
     A TextEditor is an interactor that provides  an  interactive
     interface for simple text editing of a TextBuffer.  TextEdi-
     tor uses an editing model based on a single  current  selec-
     tion.   Editing operations operate on the text in the selec-
     tion, alter the position or size of the selection, or scroll
     the  display  to  view  other parts of the text.  TextEditor
     interprets a perspective for interactive scrolling  using  a
     scroller.

PUBLIC OPERATIONS
     TextEditor(int rows, int cols, int tabsize, int highlight)
     ~TextEditor()
          Create or  destroy  an  instance  of  TextEditor.   The
          natural  size  of a TextEditor is specified by _r_o_w_s and
          _c_o_l_u_m_n_s.  The TextEditor will be tall enough to display
          _r_o_w_s  lines of text in the current font, and it will be
          wide  enough  to  display  _c_o_l_u_m_n_s   characters.    For
          proportionally-spaced fonts, the width of the character
          'n' is taken to be representative.  Tab  characters  in
          the text are expanded to multiples of _t_a_b_s_i_z_e character
          widths.  The current  selection  highlighted  with  the
          text style _h_i_g_h_l_i_g_h_t.

     void Edit(TextBuffer*)
          Specify the text buffer to edit.  A text buffer must be
          specified before the TextEditor is displayed.

     int Dot()
     int Mark()
          The current selection is bounded by  two  indices  into
          the  text  buffer.   By  convention  these  indices are
          called dot and mark.  Dot is the position at which text
          will  be inserted and deleted.  Mark locates the end of
          the selection that moves as the selection is  modified.
          When  the  selection is empty (an insertion point), dot
          and mark are equal.

     void InsertText(const char* string, int count)
     void DeleteText(int count)
     void DeleteSelection()
          Edit the text buffer at the current selection.  Insert-
          Text  inserts  count  characters from string after dot.
          The selection becomes an insertion point following  the
          newly  inserted text.  DeleteText deletes count charac-
          ters at dot.  If  count  is  positive,  the  characters



Printed 4/10/90            24 May 1989                          1






TextEditor(3I)      UNIX Programmer's Manual       TextEditor(3I)



          following  dot  are  deleted;  if count is negative the
          characters  before  dot  are  deleted.   The  selection
          becomes  an insertion point in the place of the deleted
          text.  DeleteSelection deletes the text between dot and
          mark, changing the selection to an insertion point.

     void BackwardCharacter(int count)
     void ForwardCharacter(int count)
     void BackwardLine(int count)
     void ForwardLine(int count)
     void BackwardWord(int count)
     void ForwardWord(int count)
     void BackwardPage(int count)
     void ForwardPage(int count)
          Move the current selection forward or backward  by  the
          specified  number  of the specified units.  The default
          movement is one  unit.   The  selection  is  not  moved
          before the beginning of after the end of the text.

     void BeginningOfLine()
     void EndOfLine()
     void BeginningOfWord()
     void EndOfWord()
     void BeginningOfSelection()
     void EndOfSelection()
     void BeginningOfText()
     void EndOfText()
          Move the current selection forwards or backwards to the
          specified feature of the text.

     void ScrollToSelection()
     void ScrollToView(Coord x, Coord y)
     void ScrollBy(Coord dx, Coord dy)
          Scroll  the  display.   ScrollToSelection  scrolls  the
          display  so  that  dot  will  be  visible.   If  dot is
          currently visible, no scrolling takes place.  ScrollTo-
          View  scrolls the display so that the text currently at
          the position (_x, _y) will be visible.  If the  specified
          point  is  currently visible, no scrolling takes place.
          ScrollBy specifies an amount by  which  to  scroll  the
          display.   Positive  values  scroll the display upwards
          and to the right.  In each case, the final position  of
          the  display is limited so that some text will be visi-
          ble.

     void Select(int dot)
     void Select(int dot, int mark)
     void SelectMore(int mark)
     void SelectAll()
          Modify the current selection in terms of text  indices.
          With a single parameter, Select moves both dot and mark
          to the specified index.  With two parameters,  dot  and



Printed 4/10/90            24 May 1989                          2






TextEditor(3I)      UNIX Programmer's Manual       TextEditor(3I)



          mark   can  be  controlled  independently.   SelectMore
          leaves dot unchanged and moves  mark.   SelectAll  sets
          dot to the end of the text and mark to the beginning.

     int Locate(Coord x, Coord y)
          Return the text index most closely matching  the  point
          (_x, _y).

SEE ALSO
     Interactor(2I), TextBuffer(3I)













































Printed 4/10/90            24 May 1989                          3






Transformer(3I)     UNIX Programmer's Manual      Transformer(3I)



NAME
     Transformer - transformation matrix for Painter

SYNOPSIS
     #include <InterViews/transformer.h>

DESCRIPTION
     A transformer object is a transformation matrix for  use  in
     translating coordinates.  Most users will not need to access
     a transformer directly; the _P_a_i_n_t_e_r(3I) operations  will  be
     sufficient.

PUBLIC OPERATIONS
     Transformer(Transformer* = nil)
          Create a copy of the given transformer.   The  identity
          transformer is returned by default.

a20, float a21)
     Transformer(float a00, float a01, float  a10,  float  a11,  float
          Create a matrix with the given values.

float& a20, float& a21)
     void GetEntries(float& a00, float& a01, float& a10,  float&  a11,
          Get the transformer's matrix entries.

     void Rotate(float angle)
          Modify  the  matrix  to  rotate  coordinates  by  _a_n_g_l_e
          degrees.

     boolean Rotated()
     boolean Rotated90()
          Rotated returns _t_r_u_e if coordinates  would  be  rotated
          when  transformed.   Rotated90 returns _t_r_u_e only if the
          angle of rotation is 90 degrees.

     void Scale(float sx, float sy)
          Modify the matrix to multiply coordinates by _s_x and _s_y.

     boolean Scaled()
     boolean Stretched()
          Scaled returns _t_r_u_e  if  coordinates  are  scaled  when
          transformed.   Stretched returns _t_r_u_e if the scaling is
          not the same in both dimensions.

     void Translate(float dx, float dy)
          Add (_d_x, _d_y) to coordinates after  multiplying  by  the
          matrix.

     boolean Translated()
          Return  _t_r_u_e  if  coordinates   are   translated   when
          transformed.




Printed 4/10/90           15 June 1987                          1






Transformer(3I)     UNIX Programmer's Manual      Transformer(3I)



     void Transform(Coord& x, Coord& y)
     void Transform(Coord x, Coord y, Coord& tx, Coord& ty)
     void Transform(float x, float y, float& tx, float& ty)
     void TransformList(Coord x[], Coord y[], int n)
ty[])
     void TransformList(Coord x[], Coord y[], int n, Coord tx[], Coord
          Transform   a   point   or  set  of  points  using  the
          transformer's matrix.

     void InvTransform(Coord& tx, Coord& ty)
     void InvTransform(Coord tx, Coord ty, Coord& x, Coord& y)
     void InvTransform(float tx, float ty, float& x, float& y)
     void InvTransformList(Coord tx[], Coord ty[], int n)
Coord y[])
     void InvTransformList(Coord tx[], Coord ty[], int n,  Coord  x[],
          Perform  a  reverse transformation on a point or set of
          points.

     void Premultiply(Transformer*)
     void Postmultiply(Transformer*)
          Multiply in place the transformer's matrix by the given
          transformer's matrix.

SEE ALSO
     Painter(2I)






























Printed 4/10/90           15 June 1987                          2






Tray(3I)            UNIX Programmer's Manual             Tray(3I)



NAME
     Tray - compose interactors  into  arbitrary  or  constrained
     layouts

SYNOPSIS
     #include <InterViews/tray.h>

DESCRIPTION
     A tray is a scene of interactors that overlap, tile, or have
     other constraints on their alignment relative to each other.
     One of the interactors in a tray can serve as  a  background
     for the other interactors.

     Constraints on the layout of interactors are made by  _a_l_i_g_n_-
     _i_n_g  interactors to each other.  Two interactors are aligned
     by specifying which edges coincide.  For example, the  lower
     left  corner  of  one interactor may be aligned to the upper
     right of another.  TGlue objects can be  used  to  introduce
     transparent  space between aligned interactors.  TGlue has a
     natural  size,  shrinkability,  and  stretchability  (though
     TGlue objects are _n_o_t interactors).  Trays stretch or shrink
     the TGlue along with the aligned interactors to satisfy  the
     alignment constraints.

     The tray adopts the shape of the  background  interactor  if
     there  is  one;  otherwise,  the tray's shape depends on the
     shapes of its components and  potentially  on  their  align-
     ments.   By  default, a tray without a background takes on a
     width and height equal to the  largest  of  the  widths  and
     heights  of  its  components.  However, alignments involving
     the tray can in effect override this default.

     For example, if the left and right  sides  of  a  particular
     component  are  aligned  to the tray's left and right sides,
     respectively, then the tray's sides are constrained to coin-
     cide  with  the component's sides.  Thus the tray will adopt
     the  width,   horizontal   shrinkability,   and   horizontal
     stretchability  of  that  component.   Another  example:  To
     ensure that a tray circumscribes a collection  of  (mutually
     aligned) components, align the outer edges of the components
     on the periphery of the collection to the outer edges of the
     tray,  thereby  constraining the tray to assume the shape of
     the collection.

TGLUE PUBLIC OPERATIONS
vfil);
     TGlue(int w = 0, int h = 0, int hstretch = hfil, int  vstretch  =
          Define  TGlue of a minimum size.  The TGlue can stretch
          from the given size but cannot shrink.

vstretch);
     TGlue(int, int, int  hshrink,  int  hstretch,  int  vshrink,  int



Printed 4/10/90         8 September 1988                        1






Tray(3I)            UNIX Programmer's Manual             Tray(3I)



          Define  general  TGlue with a given natural size (width
          and height), shrinkability, and stretchability.

TRAY PUBLIC OPERATIONS
     Tray(Interactor* background = nil)
          Create a new tray, optionally having an interactor as a
          background.

     void Align(Alignment, Interactor*, TGlue* = nil)
= nil)
     void Align(Alignment, Interactor*, Alignment, Interactor*, TGlue*
          Align  an  interactor  to  another interactor (the tray
          itself by default), optionally with TGlue between them.
          Align  operations  insert  interactors into the tray if
          they have not been inserted already.

     void Align(Alignment, Interactor*, ..., Interactor* = nil)
          Apply an alignment  to  a  set  of  interactors.   This
          operation  is shorthand for aligning the interactors to
          each other explicitly.  For  example,  Align(Left,  i1,
          i2,  i3,  i4)  aligns  the left sides of interactors i1
          through i4.  Two to seven interactors can be aligned at
          once.

     void HBox(Interactor*, ..., Interactor* = nil)
     void VBox(Interactor*, ..., Interactor* = nil)
          The  HBox  and  VBox  operations  align  the  specified
          interactors  such that they tile left-to-right and top-
          to-bottom, respectively.  These operations align in one
          dimension  only.   Two  to  seven  interactors  can  be
          aligned at once.  If the first (last) component is  the
          tray  or  the  background interactor, then the leftmost
          (rightmost) component will be  aligned  with  the  left
          (right) side of the tray.

     void Insert(Interactor*)
          Insert an interactor into the tray  without  an  align-
          ment.   The  interactor  will  appear in the lower left
          corner of the tray.

     void Change(Interactor*)
          Notify the tray that the given interactor's  shape  has
          changed.   The  tray  will  recompute the layout of its
          component interactors to satisfy  any  alignments.   If
          the  tray  does not contain a background, then a change
          in the shape of one  of  its  components  may  in  turn
          change  the tray's shape. If the tray has a background,
          then the tray's shape will change only if the shape  of
          the background changes.

     void Remove(Interactor*)
          Take an interactor out of  a  tray  and  eliminate  any



Printed 4/10/90         8 September 1988                        2






Tray(3I)            UNIX Programmer's Manual             Tray(3I)



          alignments that have been made to it.

SEE ALSO
     Interactor(3I), Scene(3I), Shape(3I)



















































Printed 4/10/90         8 September 1988                        3






Viewport(3I)        UNIX Programmer's Manual         Viewport(3I)



NAME
     Viewport - scrollable view

SYNOPSIS
     #include <InterViews/viewport.h>

DESCRIPTION
     Viewport is a subclass of MonoScene that allocates its  com-
     ponent  exactly  as  much space as it wants (determined from
     its shape).  This space will be clipped  to  the  viewport's
     size  and the viewport maintains a perspective to adjust the
     portion of the component that is actually displayed.  If the
     component  is  smaller  than the viewport's canvas, then the
     viewport background will be filled with a  light  gray  pat-
     tern.

PUBLIC OPERATIONS
     Viewport(Interactor* = nil, Alignment = Center)
          Construct a new viewport.  If  the  interactor  is  not
          nil,  it  is inserted as the viewport's component.  The
          second parameter  determines  where  the  component  is
          placed relative to the viewport.

     Insert(Interactor*)
          Set the component interactor.

     void Change(Interactor*)
          A viewport does not propagate changes.   Thus,  if  the
          component's  shape  changes the viewport simply resizes
          the component according to the new shape.

     void Remove(Interactor*)
          Take out the component interactor.

     virtual void Adjust(Perspective&)
          Change the viewport's perspective  to  the  given  one.
          This  operation will cause the desired area of the com-
          ponent to be drawn.

     void AdjustTo(float px, float py, float zx, float zy)
     void AdjustBy(float dpx, float dpy, float dzx, float dzy)
     void ScrollTo(float px, float py)
     void ScrollXTo(float px)
     void ScrollYTo(float py)
     void ScrollBy(float dpx, float dpy)
     void ScrollXBy(float dpx)
     void ScrollYBy(float dpy)
     void ZoomTo(float zx, float zy)
     void ZoomXTo(float zx)
     void ZoomYTo(float zy)
     void ZoomBy(float dzx, float dzy)
     void ZoomXBy(float dzx)



Printed 4/10/90         10 February 1988                        1






Viewport(3I)        UNIX Programmer's Manual         Viewport(3I)



     void ZoomYBy(float dzy)
          Short-hand operations for explicit manipulation of  the
          viewport's perspective.

     float XPos()
     float YPos()
     float XMag()
     float YMag()
          Short-hand for retrieving information about the current
          perspective.

SEE ALSO
     Perspective(3I), Scene(3I), Shape(3I)










































Printed 4/10/90         10 February 1988                        2






World(3I)           UNIX Programmer's Manual            World(3I)



NAME
     World - root scene for a display

SYNOPSIS
     #include <InterViews/world.h>

DESCRIPTION
     A world is an application's  root  scene  for  a  particular
     display.   The world must be created before any other Inter-
     Views objects are created.  Scene operations such as Insert,
     Raise,  and  Lower can be used to affect the display.  Thus,
     an interactor is placed as a top-level window on the  screen
     by inserting it into the world.

PUBLIC OPERATIONS
     World(const char* classname, int& argc, char* argv[])
          Construct the world object for  a  display.   Top-level
          interactors  that have not called SetClassName will use
          the world's class name when looking up  default  attri-
          butes.   Top-level  interactors  that  have  not called
          SetInstance will use the  world's  instance  name  when
          looking up attributes.  The world's instance name comes
          from the -name option if it was  given;  otherwise  the
          instance  name  comes  from  the  environment  variable
          RESOURCE_NAME if it is nonnil.  If the name  has  still
          not  been defined, then argv[0] with all leading direc-
          tories stripped is used.  The following  arguments  are
          interpreted automatically and are removed from _a_r_g_v:

          -background    next argument sets the background color
          -bg            same as -background
          -display       next argument specifies the target workstation display
          -foreground    next argument sets the foreground color
          -fg            same as -foreground
          -fn            same as -font
          -font          next argument sets the text font
          -geometry      next argument sets the first top-level interactor's position and size
          -iconic        starts up the first top-level interactor in iconic form
          -name          next argument sets the instance name of all top-level interactors
                         that don't have their own instance names
          -reverse       swaps default foreground and background colors
          -rv            same as -reverse
          -title         next argument sets the first top-level interactor's title bar name
          -xrm           next argument sets an ``attribute: value'' property
     The geometry specification has the form  ``=WxH+XOFF+YOFF''.
     A   negative   XOFF  (YOFF)  specifies  the  offset  of  the
     interactor's right (bottom) edge  from  the  right  (bottom)
     side of the screen.  The constructor sets _a_r_g_c to the number
     of uninterpreted arguments that remain.

     World(const char*, OptionDesc*, int&, char*[])
          Construct a world as  above,  but  using  an  array  of



Printed 4/10/90            7 Mar 1989                           1






World(3I)           UNIX Programmer's Manual            World(3I)



          option descriptors to parse application-specific attri-
          butes.  OptionDesc contains four fields: a _n_a_m_e used on
          the  command  line,  a _p_a_t_h specifying the attribute, a
          _s_t_y_l_e specifying where the  value  is,  and  a  default
          _v_a_l_u_e.   Valid  styles are _O_p_t_i_o_n_P_r_o_p_e_r_t_y_N_e_x_t (use next
          argument as  an  attribute:value  pair,  not  just  the
          value),  _O_p_t_i_o_n_V_a_l_u_e_N_e_x_t  (use next argument as value),
          _O_p_t_i_o_n_V_a_l_u_e_I_m_p_l_i_c_i_t  (use   default   value),   _O_p_t_i_o_n_-
          _V_a_l_u_e_I_s_A_r_g   (use   argument  as  value),  and  _O_p_t_i_o_n_-
          _V_a_l_u_e_A_f_t_e_r (use remainder of argument as value).

     World(const char*, PropertyData*, OptionDesc*, int&, char*[])
          Construct a world as above and specify a set of initial
          attribute values.  PropertyData contains  three  string
          fields: a _p_a_t_h specifying the attribute, a _v_a_l_u_e speci-
          fying the value, and a _t_y_p_e specifying the  type  name.
          Attributes  are  entered  in the following order: first
          any application defaults (specified by the PropertyData
          array),     then     user    defaults    (usually    in
          $HOME/.Xdefaults),  and  then  command-line  arguments.
          Thus,  command-line  arguments  override user defaults,
          and both override application defaults.

     World(const char* instance = nil, const char* display = nil)
          Construct the world  object  for  a  specific  display.
          This  constructor  is  for  backward  compatibility and
          should no longer be used.  Since the application cannot
          get its instance name for looking up resources from the
          command  line,  the  first  parameter   specifies   the
          instance  name  to  use rather than the class name.  If
          _d_i_s_p_l_a_y is omitted, then the DISPLAY environment  vari-
          able  is  used  to  connect  to  the appropriate window
          server.  The format of the string  is  ``hostname:N.S''
          where  N  is  the  display  number  and S is the screen
          number (S is optional).

     void InsertPopup(Interactor*)
tomLeft)
     void InsertPopup(Interactor*, Coord x, Coord y, Alignment =  Bot-
          Insert  a  popup  interactor into the world, optionally
          aligned with respect to a specific position relative to
          the  lower-left  corner  of  the  screen,  without  any
          interaction whatsoever with window managers.   A  popup
          interactor inserted without a specific position will be
          centered on the screen, since the  user  cannot  use  a
          window manager's help to place the interactor.

     void InsertTransient(Interactor*, Interactor*)
Coord y, Alignment = BottomLeft)
     void InsertTransient(Interactor*,  Interactor*  owner,  Coord  x,
          Insert  a transient interactor into the world on behalf
          of another interactor, optionally aligned with  respect



Printed 4/10/90            7 Mar 1989                           2






World(3I)           UNIX Programmer's Manual            World(3I)



          to  a  specific  position  relative  to  the lower-left
          corner of the screen.  Most window  managers  will  not
          decorate  the  transient  interactor or ask the user to
          place it.  Some window  managers  may  also  unmap  the
          transient interactor when its _o_w_n_e_r interactor is icon-
          ized.

     void InsertToplevel(Interactor*, Interactor*)
Coord y, Alignment = BottomLeft)
     void  InsertToplevel(Interactor*,  Interactor*  group,  Coord  x,
          Insert a toplevel interactor into the world, optionally
          aligned with respect to a specific position relative to
          the  lower-left  corner  of the screen.  A nonnil _g_r_o_u_p
          informs window managers that this  toplevel  interactor
          is  part  of  a  group  of  toplevel interactors led by
          _g_r_o_u_p.  Some window managers  may  unmap  the  toplevel
          interactor when its ``leader'' interactor is iconized.

     void InsertApplication(Interactor*)
BottomLeft)
     void InsertApplication(Interactor*, Coord x, Coord y, Alignment =
          Insert   an  application  interactor  into  the  world,
          optionally aligned with respect to a specific  position
          relative  to the lower-left corner of the screen.  Win-
          dow and session managers will consider  an  application
          interactor  to be the program's main top-level interac-
          tor.

     void InsertIcon(Interactor*)
tomLeft)
     void InsertIcon(Interactor*, Coord x, Coord y, Alignment  =  Bot-
          Insert  an  icon  interactor into the world, optionally
          aligned with respect to a specific position relative to
          the lower-left corner of the screen, but do not make it
          visible (``map'' it).  Another top level interactor may
          call   Interactor::SetIconInteractor   to  tell  window
          managers to use this interactor for its icon.  InsertI-
          con is called automatically when a top level interactor
          is inserted if the interactor has an icon and the  icon
          has not yet been inserted into the world.

     int Width()
     int Height()
          Return the width and height in pixels of the screen.

     int NPlanes()
          Return the number of  user-accessible  bit  planes  the
          workstation display has.

     int NButtons()
          Return the number of buttons on the input pointing dev-
          ice associated with the world.



Printed 4/10/90            7 Mar 1989                           3






World(3I)           UNIX Programmer's Manual            World(3I)



     int PixelSize()
          Return the natural size in bits for storing a pixel.

w, int& h)
     unsigned ParseGeometry(const char* spec, Coord& x, Coord& y, int&
          Interpret  a geometry specification (e.g., =80x24+1+1),
          returning a bit mask that identifies which fields  were
          specified.

     void SetHint(const char*)
          Provide window system specific information.   See  next
          section.

     void RingBell(int vol)
          Ring the workstation bell with a volume equal to a per-
          centage  of the possible range, with 0 the quietest and
          100 the loudest.

     void SetKeyClick(int vol)
          Set the volume of the audible keyclick equal to a  per-
          centage  of the possible range, with 0 the quietest and
          100 the loudest.

     void SetAutoRepeat(boolean on)
          Turn on or off autorepeat for the keyboard.

     void SetFeedback(int threshold, int scale)
          Set the amount of  magnification  to  give  the  user's
          movements  with  the pointing device.  The _t_h_r_e_s_h_o_l_d is
          the minimum distance after which to scale the  movement
          and  the  _s_c_a_l_e  is  the factor by which to magnify the
          movement.

     void SetCurrent()
          Set the current world.  Some routines use global  state
          associated  with  a  world  object.   Creating  a world
          automatically sets the state to that of the new world.

     int Fileno()
          Return the file descriptor of  the  connection  to  the
          window server.

WINDOW SYSTEM HINTS
     The performance of some InterViews library functions depends
     heavily on the characteristics of the underlying window sys-
     tem.  Window system hints provide a way for  the  programmer
     or  user  to  provide  information  to  maximize performace.
     There is usually no  need  to  provide  hints:  the  default
     behavior  is appropriate for most installations.  By conven-
     tion, a hint consists of a name and a value, separated by  a
     colon.   Meaningful  names  and  values  are implementation-
     specific.   Non-meaningful   hints   are   simply   ignored.



Printed 4/10/90            7 Mar 1989                           4






World(3I)           UNIX Programmer's Manual            World(3I)



     Currently defined hints include:

     RubberbandPixel
          The value is a hexadecimal number which is used to con-
          trol  the drawing of rubber bands.  On many window sys-
          tems, rubber bands are drawn in XOR mode so  that  they
          can easily be erased without damaging underlying screen
          contents.  On a color workstation, the resulting  color
          depends  on the screen contents and the XOR mask pixel.
          The mask should be chosed to maximize the visibility of
          the  rubber band,  but the best value may depend on the
          workstation color rendering model and on how an  appli-
          cation uses colors.

     TransformFonts
          The value is one of ``off'', ``on'', or ``cache''.   On
          many  window  systems,  drawing  text  which  has  been
          rotated  or  scaled  is  much   slower   than   drawing
          untransformed  text.  This hint suggests a strategy for
          optimizing text transformations.  ``Off'' suggests that
          fonts  should not be transformed.  This usually results
          in text drawn with the origins of the characters at the
          correct  positions  but  with  untransformed  character
          glyphs.  ``On''  suggests  that  the  character  glyphs
          should be transformed.  ``Cache'' further suggests that
          transformed glyphs be cached to speed  up  future  text
          operations  that  might require the same glyph.  Cached
          glyphs  consume  both  application  and  window  system
          resources but are drawn much faster.

     Window system hints can be specified  through  the  function
     _W_o_r_l_d::_S_e_t_H_i_n_t or as application attributes.  _S_e_t_H_i_n_t allows
     an application to specify hints dynamically.   For  example,
     an  application that uses transformed text might temporarily
     disable font transformations to speed up drawing of a  rough
     draft  and  re-enable transformations to show the final ver-
     sion.  Attributes allow users to control the default  values
     of hints from their user preference files or from the appli-
     cation command line.  Attribute names are derived  from  the
     corresponding  hint  names by appending the string ``Hint''.
     For example, the RubberbandPixel hint can be set through the
     ``RubberbandPixelHint'' attribute.

SEE ALSO
     Interactor(3I), Scene(3I)










Printed 4/10/90            7 Mar 1989                           5






WorldView(3I)       UNIX Programmer's Manual        WorldView(3I)



NAME
     WorldView - manipulate root scene

SYNOPSIS
     #include <InterViews/worldview.h>

DESCRIPTION
     WorldView is a class for writing window managers that  mani-
     pulate  a  root scene.  The operations manipulate objects of
     type RemoteInteractor, which are interactors that exist in a
     different address space than the window manager.  Typically,
     a subclass of WorldView is defined that handles input events
     according to a particular window manager style.

PUBLIC OPERATIONS
     WorldView(World*, Sensor*, Painter*)
          Define a worldview interactor associated with  a  given
          world,  and pass the sensor and painter to the interac-
          tor constructor.

     RemoteInteractor Find(Coord x, Coord y)
          Return the interactor under the given (absolute)  coor-
          dinates.

     RemoteInteractor Choose(Cursor*, boolean waitforup = true)
          Interactively choose an interactor by changing the cur-
          sor  to  the  given  one and waiting for a button to be
          pressed.  If _w_a_i_t_f_o_r_u_p is true,  then  wait  until  the
          button is released before returning.

     virtual void InsertRemote(RemoteInteractor)
          Handle a  request  from  an  application  (process)  to
          insert  an interactor into the root scene.  The default
          operation is a nop.

top, int w, int h
     virtual void  ChangeRemote(RemoteInteractor,  Coord  left,  Coord
          Handle  a  request  from  an  application  (process) to
          change an interactor's canvas to the specified position
          and size.  The default operation is simply to perform a
          Change operation with the given parameters.

     void Move(RemoteInteractor, Coord left, Coord top)
h)
     void Change(RemoteInteractor, Coord left, Coord top, int  w,  int
          The  Move operation sets the interactors position given
          the upper left corner.  Change both moves  and  resizes
          the interactor.

     void Raise(RemoteInteractor)
          Raise the interactor's canvas to be above all others on
          the screen.



Printed 4/10/90           15 June 1987                          1






WorldView(3I)       UNIX Programmer's Manual        WorldView(3I)



     void Lower(RemoteInteractor)
          Lower the interactor's canvas to be below all others on
          the screen.

     void Focus(RemoteInteractor)
          Set input focus to the interactor.  If nil  is  passed,
          the  input focus is based on the location of the point-
          ing device.

     RemoteInteractor GetFocus()
          Return the current interactor that has input focus  (or
          nil if none).

     void GetList(RemoteInteractor*&, int&)
          Return all the top-level interactors and a count of how
          many  there  are.   The space for the list is automati-
          cally allocated.

     void FreeList(RemoteInteractor*)
          Free the space allocated by a GetList call.

Coord& y2)
     void GetInfo(RemoteInteractor, Coord& x1, Coord& y1,  Coord&  x2,
          Get the current position of an interactor.

     RemoteInteractor GetIcon(RemoteInteractor)
          Gets the icon for the  specified  Interactor.   If  the
          argument  Interactor  is an icon, then GetIcon gets the
          original Interactor.

     void AssignIcon(RemoteInteractor i, RemoteInteractor icon)
          Associate _i_c_o_n as the icon interactor for _i.

     void UnassignIcon(RemoteInteractor)
          Remove the icon association for the given interactor.

     char* GetName(RemoteInteractor)
          Returns  the  name  of  the  Interactor  (as   set   by
          Scene::SetIcon(const char*)).

     RedrawAll()
          Force all the interactors on the screen to redraw them-
          selves.

PROTECTED OPERATIONS
     void GrabMouse(Cursor*)
     void UngrabMouse()
          Get or release control of the pointing  device.   Grab-
          Mouse  will wait until the device is available and then
          sets the cursor to the given cursor.

     boolean GrabButton(unsigned mask, Cursor*)



Printed 4/10/90           15 June 1987                          2






WorldView(3I)       UNIX Programmer's Manual        WorldView(3I)



     void UngrabButton(unsigned mask)
          Get or release control of a button or set  of  buttons.
          The  cursor  is used when the button is pressed.  Grab-
          Button returns _f_a_l_s_e if the button  is  not  available.
          The   button  mask  is  defined  by  the  constants  in
          ``<InterViews/Xlib.h>''.

     void Lock()
     void Unlock()
          Get or release exclusive access to the  server.   While
          locked, the server will ignore other clients.

     void ClearInput()
          Discard any pending input events.

     void MoveMouse(Coord x, Coord y)
          Set the pointing device position to  the  given  screen
          coordinates.

SEE ALSO
     Interactor(3I), Scene(3I)


































Printed 4/10/90           15 June 1987                          3


