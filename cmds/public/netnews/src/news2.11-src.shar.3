#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	src/funcs.c
#	src/funcs2.c
#	src/header.c
#	src/iextern.c
#	src/ifuncs.c
#	src/inews.c
#	src/logdir.c
#	src/ndir.c
#	src/pathinit.c
#	src/postnews.c
#	src/process.c
#	src/readnews.c
# This archive created: Wed Mar  1 10:57:36 1989
export PATH; PATH=/bin:$PATH
echo shar: extracting "'funcs.c'" '(17226 characters)'
if test -f 'funcs.c'
then
	echo shar: will not over-write existing file "'funcs.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'funcs.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * funcs - functions used by many programs
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)funcs.c	2.38	11/30/87";
	X#endif /* SCCSID */
	X
	X/*LINTLIBRARY*/
	X
	X#include "params.h"
	X#include <errno.h>
	X#if defined(USG) || defined(BSD4_2)
	X#include <fcntl.h>
	X#endif /* !v7 */
	X
	Xextern char *Progname;
	X
	X/*
	X * News group matching.
	X *
	X * nglist is a list of newsgroups.
	X * sublist is a list of subscriptions.
	X * sublist may have "meta newsgroups" in it.
	X * All fields are NGDELIM separated,
	X * and there is an NGDELIM at the end of each argument.
	X *
	X * Currently implemented glitches:
	X * sublist uses 'all' like shell uses '*', and '.' like shell '/'.
	X * If subscription X matches Y, it also matches Y.anything.
	X */
	Xngmatch(nglist, sublist)
	Xregister char *nglist, *sublist;
	X{
	X	register char *n, *s;
	X	register int rc;
	X
	X	rc = FALSE;
	X	for (n = nglist; *n != '\0' && rc == FALSE;) {
	X		for (s = sublist; *s != '\0';) {
	X			if (*s != NEGCHAR)
	X				rc = rc || ptrncmp(s, n);
	X			else
	X				rc = rc && !ptrncmp(s+1, n);
	X			while (*s++ != NGDELIM && *s != '\0')
	X				;
	X		}
	X		while (*n++ != NGDELIM && *n != '\0')
	X			;
	X	}
	X	return rc;
	X}
	X
	X/*
	X * Compare two newsgroups for equality.
	X * The first one may be a "meta" newsgroup.
	X */
	Xptrncmp(ng1, ng2)
	Xregister char *ng1, *ng2;
	X{
	X	while (*ng1 != NGDELIM && *ng1 != '\0') {
	X		if (ng1[0]=='a' && ng1[1]=='l' && ng1[2]=='l') {
	X			ng1 += 3;
	X			while (*ng2 != NGDELIM && *ng2 != '.' && *ng2 != '\0')
	X				if (ptrncmp(ng1, ng2++))
	X					return(TRUE);
	X			return ptrncmp(ng1, ng2);
	X		} else if (*ng1++ != *ng2++)
	X			return FALSE;
	X	}
	X	return *ng2 == '.' || *ng2 == NGDELIM || *ng2 == '\0';
	X}
	X
	X/*
	X * Exec the shell.
	X * This version resets uid, gid, and umask.
	X * Called with fsubr(ushell, s, NULL)
	X */
	X/* ARGSUSED */
	Xushell(s, dummy)
	Xchar *s, *dummy;
	X{
	X	(void) umask(savmask);
	X	(void) setgid(gid);
	X	(void) setuid(uid);
	X	xshell(s);
	X}
	X
	X/*
	X * Exec the shell.
	X */
	X
	X#ifdef lint
	Xchar	**environ;
	X#else /* !lint */
	Xextern char	**environ;
	X#endif /* !lint */
	X
	Xxshell(s)
	Xchar *s;
	X{
	X	char *env[100], **envp;
	X	char a[BUFLEN + 2];
	X	extern char filename[];
	X	/* set $A */
	X	(void) sprintf(a, "A=%s", filename);
	X	env[0] = a;
	X	for (envp = env + 1 ; *environ != NULL && envp < env + 98 ; environ++)
	X		if ((*environ)[0] != 'A' || (*environ)[1] != '=')
	X			*envp++ = *environ;
	X	*envp = NULL;
	X
	X	execle(SHELL, SHELL, "-c", s, (char *)0, env);
	X	xerror("No shell!");
	X}
	X
	X/*
	X * Fork and call a subroutine with two args.
	X * Return pid without waiting.
	X */
	Xfsubr(f, s1, s2)
	Xint (*f)();
	Xchar *s1, *s2;
	X{
	X	register int pid;
	X
	X	/* this may NOT be a vfork */
	X	while ((pid = fork()) == -1)
	X		sleep((unsigned)1);
	X	if (pid == 0) {
	X		(*f)(s1, s2);
	X		exit(0);
	X	}
	X	return pid;
	X}
	X
	X/*
	X * Wait on a child process.
	X */
	Xfwait(pid)
	Xregister int pid;
	X{
	X	register int w;
	X	int status;
	X	int (*onhup)(), (*onint)();
	X
	X	onint = signal(SIGINT, SIG_IGN);
	X	onhup = signal(SIGHUP, SIG_IGN);
	X	while ((w = wait(&status)) != pid && w != -1)
	X		;
	X	if (w == -1)
	X		status = -1;
	X	(void) signal(SIGINT, onint);
	X	(void) signal(SIGHUP, onhup);
	X	return status;
	X}
	X
	X/*
	X * Strip trailing newlines, blanks, and tabs from 's'.
	X * Return TRUE if newline was found, else FALSE.
	X */
	Xnstrip(s)
	Xregister char *s;
	X{
	X	register char *p;
	X	register int rc;
	X
	X	rc = FALSE;
	X	p = s;
	X	while (*p)
	X		if (*p++ == '\n')
	X			rc = TRUE;
	X	while (--p >= s && (*p == '\n' || *p == ' ' || *p == '\t'));
	X	*++p = '\0';
	X	return rc;
	X}
	X
	X/*
	X * Local open routine.
	X */
	XFILE *
	Xxfopen(name, fmode)
	Xregister char *name, *fmode;
	X{
	X	register FILE *fp;
	X	char	*fname;
	X	extern int errno;
	X
	X	if ((fp = fopen(name, fmode)) == NULL) {
	X#ifdef IHCC
	X		/*
	X		 * IHCC users only see the "filename" that was in trouble,
	X		 * not the whole path.  (for security!)
	X		 */
	X		fname = rindex(name, '/') + 1;
	X#else
	X		fname = name;
	X#endif
	X		xerror("Cannot open %s (%s): %s", fname, fmode, errmsg(errno));
	X	}
	X	/* kludge for setuid not being honored for root */
	X	if ((uid == 0) && (duid != 0) && ((*fmode == 'a') || (*fmode == 'w')))
	X		(void) chown(name, duid, dgid);
	X	return fp;
	X}
	X
	Xchar *
	Xerrmsg(code)
	Xint code;
	X{
	X	extern int sys_nerr;
	X	extern char *sys_errlist[];
	X	static char ebuf[6+5+1];
	X
	X	if (code > sys_nerr) {
	X		(void) sprintf(ebuf, "Error %d", code);
	X		return ebuf;
	X	} else
	X		return sys_errlist[code];
	X}
	X/* From UC Berkeley @(#)strcasecmp.c	1.3 (Berkeley) 8/3/87 */
	X
	X/*
	X * This array is designed for mapping upper and lower case letter
	X * together for a case independent comparison.  The mappings are
	X * based upon ascii character sequences.
	X */
	Xchar charmap[] = {
	X	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	X	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	X	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	X	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	X	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	X	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	X	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	X	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	X	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	X	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	X	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	X	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
	X	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
	X	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
	X	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
	X	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
	X	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
	X	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
	X	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
	X	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
	X	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	X	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
	X	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	X	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
	X};
	X
	Xstrcasecmp(s1, s2)
	Xregister char *s1, *s2;
	X{
	X	register char *cm = charmap;
	X
	X	while (cm[*s1] == cm[*s2++])
	X		if (*s1++ == '\0')
	X			return 0;
	X	return cm[*s1] - cm[*--s2];
	X}
	X
	Xstrncasecmp(s1, s2, n)
	Xregister char *s1, *s2;
	Xregister int n;
	X{
	X	register char *cm = charmap;
	X
	X	while (--n >= 0 && cm[*s1] == cm[*s2++])
	X		if (*s1++ == '\0')
	X			return 0;
	X	return n < 0 ? 0 : cm[*s1] - cm[*--s2];
	X}
	X
	Xprefix(full, pref)
	Xregister char *full, *pref;
	X{
	X	register char *cm = charmap;
	X
	X	while (*pref != '\0') {
	X		if (cm[*full++] != cm[*pref++])
	X			return FALSE;
	X	}
	X	return TRUE;
	X}
	X
	Xchar *
	Xdirname(ngname)
	Xchar *ngname;
	X{
	X	static char rbuf[BUFLEN];
	X	register char *p;
	X
	X	(void) sprintf(rbuf, "%s/%s", SPOOL, ngname);
	X
	X	for (p=rbuf+strlen(SPOOL); *p; p++)
	X		if (*p == '.')
	X			*p = '/';
	X	return rbuf;
	X}
	X
	X/*
	X * Return TRUE iff ngname is a valid newsgroup name
	X */
	Xvalidng(ngname)
	Xchar *ngname;
	X{
	X	register FILE *fp;
	X	register char *p, *q;
	X	char abuf[BUFLEN];
	X
	X	fp = xfopen(ACTIVE, "r");
	X	while(fgets(abuf, BUFLEN, fp) != NULL) {
	X		p = abuf;
	X		q = ngname;
	X		while (*p++ == *q++)
	X			;
	X		if (*--q == '\0' && *--p == ' ') {
	X			(void) fclose(fp);
	X			return TRUE;
	X		}
	X	}
	X	(void) fclose(fp);
	X	return FALSE;
	X}
	X
	X/* VARARGS1 */
	Xxerror(message, arg1, arg2, arg3)
	Xchar *message;
	Xlong arg1, arg2, arg3;
	X{
	X	char buffer[LBUFLEN];
	X
	X	fflush(stdout);
	X	(void) sprintf(buffer, message, arg1, arg2, arg3);
	X	logerr(buffer);
	X	xxit(1);
	X}
	X
	X/* VARARGS1 */
	Xlog(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)
	Xchar *fmt;
	Xlong a1, a2, a3, a4, a5, a6, a7, a8, a9;
	X{
	X	_dolog(0, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	X}
	X
	X/* VARARGS1 */
	Xlogerr(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)
	Xchar *fmt;
	Xlong a1, a2, a3, a4, a5, a6, a7, a8, a9;
	X{
	X	_dolog(1, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	X}
	X
	Xchar *lfsuffix[] = {
	X	"log",
	X	"errlog",
	X	NULL,
	X};
	X
	X/*
	X * Log the given message, with printf strings and parameters allowed,
	X * on the log file, if it can be written.  The date and an attempt at
	X * figuring out the remote system name are also logged.
	X */
	X/* VARARGS1 */
	X_dolog(which, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)
	Xchar *fmt;
	Xlong a1, a2, a3, a4, a5, a6, a7, a8, a9;
	X{
	X	FILE *logfile;
	X	register char *p, *logtime;
	X	int i;
	X	char logfname[BUFLEN];		/* the log file */
	X	char rmtsys[BUFLEN];
	X	char msg[LBUFLEN];
	X	time_t t;
	X
	X	(void) strcpy(rmtsys, header.path);
	X	p = index(rmtsys, '!');
	X	if (p == NULL)
	X		p = index(rmtsys, ':');
	X	if (p)
	X		*p = 0;
	X	else {
	X		p = rindex(rmtsys, '@');
	X		if (p)
	X			(void) strcpy(rmtsys, p+1);
	X		else
	X			(void) strcpy(rmtsys, "local");
	X	}
	X
	X	(void) time(&t);
	X	logtime = ctime(&t);
	X	logtime[16] = 0;
	X	logtime += 4;
	X
	X
	X	(void) sprintf(msg, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	X
	X	if (which)
	X		fprintf(stderr,"%s: %s\n", Progname, msg);
	X
	X	for (i=0; i<=which;i++) {
	X		(void) sprintf(logfname, "%s/%s", LIB, lfsuffix[i]);
	X
	X		if (access(logfname, 0) == 0 && (logfile = fopen(logfname, "a")) != NULL) {
	X#if defined(USG) || defined(BSD4_2)
	X			int flags;
	X			flags = fcntl(fileno(logfile), F_GETFL, 0);
	X			(void) fcntl(fileno(logfile), F_SETFL, flags|O_APPEND);
	X#else /* v7 */
	X			(void) lseek(fileno(logfile), 0L, 2);
	X#endif /* v7 */
	X			if (i)
	X				fprintf(logfile, "%s\t%s\t%s: %s\n", logtime,
	X					header.ident[0] ? header.ident : username, Progname, msg);
	X			else
	X				fprintf(logfile, "%s\t%s\t%s\n", logtime,
	X					rmtsys, msg);
	X			(void) fclose(logfile);
	X		}
	X	}
	X}
	X#ifdef VMS
	X
	X/*
	X * vmslink allows simulation of file linking under VMS.
	X */
	Xvmslink(infile,outfile)
	Xchar *infile, *outfile;
	X{
	X	FILE *fp;
	X
	X	if (access(outfile,0) == 0) {
	X		errno = EEXIST;
	X		return -1;
	X	}
	X
	X	fp = fopen(outfile, "w");
	X	if (fp == NULL) {
	X		errno = EACCES;
	X		return -1;
	X	}
	X
	X	(void) fprintf(fp, "%s", infile);
	X	(void) fclose(fp);
	X
	X	return 0;
	X}
	X
	X/*
	X * vmsdelete deletes all revisions of a file.  It attempts to
	X * appear as unlink(2) under conventional Unix in other respects.
	X */
	Xvmsdelete(file)
	Xchar *file;
	X{
	X	int i;
	X
	X	i = unlink(file);
	X	if (i != 0)
	X		return i;
	X
	X	i = errno;
	X	while (unlink(file) == 0)
	X		;
	X	errno = i;
	X
	X	return 0;
	X}
	X
	X/*
	X * Convert a Unix file to a VMS fixed record format file by
	X * executing the 'unixtovms' command.
	X */
	Xunixtovms(file)
	Xchar *file;
	X{
	X	char buf[BUFLEN];
	X	sprintf(buf, "exec /etc/unixtovms %s", file);
	X	return system(buf);
	X}
	X
	X/*
	X * Convert a VMS fixed record format file to a Unix file by
	X * executing the 'vmstounix' command.
	X */
	Xvmstounix(file)
	Xchar *file;
	X{
	X	char buf[BUFLEN];
	X	sprintf(buf,"exec /etc/vmstounix %s", file);
	X	return system(buf);
	X}
	X#endif /* VMS */
	X
	X#ifdef MKDIRSUB
	X/*
	X * make a directory. Also make sure that the directory is owned
	X * by the right userid
	X */
	Xmkdir(path, perm)
	Xchar *path;
	Xint perm;
	X{
	X	int pid, status;
	X#ifdef USG
	X	char parent[200];
	X	char *p;
	X	struct stat sbuf;
	X
	X	/*
	X	 * Make parent directory writable, because we will
	X	 * be creating a directory owned by the real user,
	X	 * rather than by news.
	X	 */
	X	(void) strcpy(parent, path);
	X	if (p = rindex(parent, '/')) {
	X		*p = '\0';
	X		if (stat(parent, &sbuf) == 0)
	X			(void) chmod(parent, 0777);
	X		else
	X			return -1;
	X	} else
	X		return -1;
	X#endif
	X
	X	if (pid=vfork()) {
	X		status = fwait(pid);
	X#if defined(USG) && !defined(CHEAP)
	X		if (pid=vfork())
	X			(void) fwait(pid);
	X		else {
	X			setgid(gid);
	X			setuid(uid);
	X			if (chown(path, duid, dgid) == 0)
	X				(void) chmod(path, perm&(~N_UMASK));
	X			_exit(0);
	X		}
	X#endif /* USG && !CHEAP */
	X	} else {
	X		(void) setgid(dgid);
	X		if (setuid(duid) < 0)
	X			(void) umask(0);
	X		else
	X			(void) umask(perm&N_UMASK);
	X		(void) execlp("mkdir", "mkdir", path, (char *)NULL);
	X		perror(path);
	X		_exit(1);
	X	}
	X#ifdef USG
	X	(void) chmod(parent, sbuf.st_mode); /* Restore mode of parent */
	X#endif
	X	return status;
	X}
	X#endif /* !BSD4_2 */
	X
	X#ifndef	RENAMESUB
	Xrename(from,to)
	Xregister char *from, *to;
	X{
	X	(void) unlink(to);
	X	if (link(from, to) < 0)
	X		return -1;
	X
	X	(void) unlink(from);
	X	return 0;
	X}
	X#endif /* !RENAMESUB */
	X
	X#ifndef USG
	Xchar *
	Xstrpbrk(str, chars)
	Xregister char *str, *chars;
	X{
	X	register char *cp;
	X
	X	do {
	X		cp = chars - 1;
	X		while (*++cp) {
	X			if (*str == *cp)
	X				return str;
	X		}
	X	} while (*str++);
	X	return NULL;
	X}
	X#endif /* !USG */
	X
	X#ifdef FASCIST
	X/*
	X *  This routine checks to see if the posting user is allowed to
	X *  post to the given newsgroup.  If the username is not in the file
	X *  $LIBDIR/authorized then the default in the symbol FASCIST is used.
	X *
	X *  Format of the call:
	X *     fascist(user, newgroups)
	X *
	X *  Returns:
	X *     FALSE, if authorized
	X *     TRUE, if not
	X *
	X *  Format of the file "authorized" is:
	X *    user:allowed groups  
	X *
	X *  Example:
	X *    root:net.all,mod.all
	X *    naughty_person:junk,net.politics
	X *    operator:!net.all,general,test,mod.unix
	X *
	X *  An open environment could have FASCIST set to "all"
	X *  and then individual entries could be made in the authorized file
	X *  to prevent certain individuals from posting to such a wide
	X *  area.
	X *
	X *  Note that a distribution of "all" does NOT mean to allow postings
	X *  only to local groups -- "all" includes "all.all".  
	X *  Use "all,!all.all" to get this behavior
	X *
	X *	Eugene Spafford		spaf@gatech	May 22, 1985
	X */
	X
	Xfascist(user, newsgroups)
	Xregister char *user, *newsgroups;
	X{
	X	FILE *facfd;
	X	char facuser[BUFLEN], facgroups[BUFLEN], factemp[BUFLEN];
	X	char *getgrplist();
	X	char *grplist = NULL;
	X	register char  *facptr;
	X
	X	/* First, open the necessary file...$LIBDIR/authorized and see if there
	X	 * is an entry for this user 
	X	 */
	X
	X	(void) strncpy(facgroups, FASCIST, BUFLEN);
	X	sprintf(factemp, "%s/%s", LIB, "authorized");
	X	facfd = fopen(factemp, "r");
	X	if (facfd != NULL) { /* If no such file, use global default only */
	X		while (fscanf(facfd, "%[^:]%s\n", facuser, factemp) != EOF) {
	X			if (feof(facfd))
	X				break;
	X			if (facuser[0] == '#') continue;
	X			if (factemp[0] != ':') continue;
	X			if (facuser[0] == '\\') {
	X				if (!grplist) grplist = getgrplist(user);
	X				facptr = facuser;
	X				facptr++;
	X				if (ngmatch(facptr, grplist)) {
	X					(void) strcat(facgroups, ",");
	X					(void) strcat(facgroups, factemp + 1);
	X					continue;
	X				}
	X			} else if (STRNCMP(facuser, user, BUFLEN) == 0) {
	X				(void) strcat(facgroups, ",");
	X				(void) strcat(facgroups, factemp + 1);
	X				break;
	X			}
	X		}
	X		fclose (facfd);
	X	}
	X#ifdef DEBUG
	X	fprintf(stderr, "facgroups = %s\n", facgroups);
	X	fprintf(stderr, "newsgroups = %s\n", newsgroups);
	X#endif /* DEBUG */
	X
	X	/* We step through the newsgroups being posted to and check each against
	X	 * the restriction list.  *ALL* posted groups must match the restriction
	X	 * list or we don't allow the posting.
	X	 */
	X
	X	while (*newsgroups != '\0') {
	X		facptr = factemp;
	X		while (*newsgroups != '\0' && *newsgroups != NGDELIM)
	X			*facptr++ = *newsgroups++;
	X		*facptr = '\0';
	X		if (*newsgroups == NGDELIM)
	X			newsgroups++;
	X
	X#ifdef DEBUG
	X		fprintf(stderr, "Checking newsgroup '%s'\n", factemp);
	X#endif
	X
	X		if (ngmatch(factemp, facgroups) == FALSE)
	X			return TRUE;
	X	}
	X
	X	/* must be okay -- return */
	X#ifdef DEBUG
	X	fprintf (stderr, "Newsgroups approved for this poster.\n");
	X#endif /* DEBUG */
	X	return FALSE;
	X}
	X#endif /* FASCIST */
	X
	X/*  This routine is meant to be called only once.  On a system with a
	X *  large /etc/group file, this routine is a HOG!!!!!  In order to save
	X *  ourselves from pain, this routine will look up groups for "user"
	X * the first time.  After that, it will always return the same results...
	X */
	X
	Xchar *
	Xgetgrplist(user)
	Xregister char *user;
	X{
	X	register struct group *gr;
	X	register struct passwd *pw;
	X	register char **cp;
	X	register int len;
	X	static int grpdone = FALSE;
	X	static char grplist[LBUFLEN];
	X
	X#ifdef DEBUG
	X	fprintf(stderr, "getgrplist entered...\n");
	X#endif /* DEBUG */
	X
	X	if (grpdone == FALSE) {
	X#ifdef DEBUG
	X		fprintf(stderr, "... actually reading /etc/group...\n");
	X#endif /* DEBUG */
	X		pw = getpwnam(user);
	X		setgrent();
	X		while (gr = getgrent()) {
	X			if (pw) if (pw->pw_gid == gr->gr_gid) {
	X				strcat(grplist, gr->gr_name);
	X				strcat(grplist, ",");
	X				continue;
	X			}	
	X			for (cp = gr->gr_mem; cp && *cp; cp++)
	X				if (STRCMP(*cp, user) == 0) {
	X					strcat(grplist, gr->gr_name);
	X					strcat(grplist, ",");
	X					break;
	X				}
	X		}
	X		if ((len = strlen(grplist))) grplist[len-1] = '\0';
	X		grpdone = TRUE;
	X	}
	X#ifdef DEBUG
	X	fprintf(stderr, "Group list - %s\n", grplist);
	X#endif /* DEBUG */
	X	return grplist;
	X}
SHAR_EOF
if test 17226 -ne "`wc -c < 'funcs.c'`"
then
	echo shar: error transmitting "'funcs.c'" '(should have been 17226 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'funcs2.c'" '(16805 characters)'
if test -f 'funcs2.c'
then
	echo shar: will not over-write existing file "'funcs2.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'funcs2.c'
	X/*
	X * This software is Copyright (c) 1985 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X *
	X * funcs2 - functions used by both inews and readnews.
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)funcs2.c	1.24	11/30/87";
	X#endif /* SCCSID */
	X
	X#include "params.h"
	X
	X#ifdef SunIII
	X#ifndef INTERNET
	X#define	INTERNET
	X#endif /* !INTERNET */
	X#endif /* SunIII */
	X
	X/*LINTLIBRARY*/
	X
	X/*
	X * Get user name and home directory.
	X */
	Xgetuser()
	X{
	X	static int flag = TRUE;
	X	register struct passwd *p;
	X
	X	if (flag) {
	X		if ((p = getpwuid(uid)) == NULL)
	X			xerror("Cannot get user's name");
	X		if ( username == NULL || username[0] == 0 ||
	X			STRCMP(username, "Unknown") == 0)
	X			username = AllocCpy(p->pw_name);
	X		userhome = AllocCpy(p->pw_dir);
	X		flag = FALSE;
	X	}
	X	(void) strcpy(header.path, username);
	X}
	X
	X/* no sys file on clients via nntp */
	X#ifndef SERVER
	Xstatic	FILE	*sysfile;
	X
	Xchar *fldget();
	X
	Xstatic int sfline;
	X
	X/*
	X * Open SUBFILE.
	X */
	Xs_openr()
	X{
	X	sysfile = xfopen(SUBFILE, "r");
	X	sfline = 0;
	X}
	X
	X/*
	X * Read SUBFILE.
	X */
	Xs_read(sp)
	Xregister struct srec *sp;
	X{
	X	register char *p;
	X	register int  c;
	X	char *e;
	X	int chop_spaces = 0;
	Xagain:
	X	p = bfr;
	X        /*
	X         * Read  the  SUBFILE  (/usr/lib/news/sys)  from   the   current
	X	 * position  to  the  first  unescaped newline.  If a newline is
	X	 * escaped with a backslash (\) continue reading but throw  away
	X	 * the backslash and newline; read the next line skipping spaces
	X	 * and tabs until the first non-space/tab character, then  start
	X	 * looking   for   a   newline   again.   Skipping  the  leading
	X	 * spaces/tabs after a escaped newline  keeps  the  news  groups
	X	 * together.  If  a  line  begins  with a newline, just skip it.
	X	 */
	X	for (e=p+LBUFLEN; p < e && (c=getc(sysfile)) != EOF; p++) {
	X		*p = c;
	X		if (c == '\n') {
	X			sfline++;
	X			if (p == bfr || p[-1] != '\\') {
	X				p[1] = '\0';
	X				break;
	X			} else {
	X				chop_spaces++;
	X				p -= 2;
	X			}
	X		} else if (chop_spaces) {
	X			if (c == '\t' || c == ' ')
	X				p--;
	X			else
	X				chop_spaces = 0;
	X		}
	X	}
	X	if (c == EOF) {
	X		return FALSE;
	X	}
	X	p = bfr;
	X	while (*p == ' ' || *p == '\t') /* skip leading white space */
	X		p++;
	X	if (*p == '\n')
	X		goto again;	     /* skip newlines */
	X	if (!nstrip(p))
	X		xerror("SUBFILE (%s) line %d too long.", SUBFILE, sfline);
	X	if (*p == '#')
	X		goto again;
	X	sp->s_xmit[0] = '\0';
	X	sp->s_flags[0] = '\0';
	X	sp->s_nosend = (char *)0;
	X
	X	p = fldget(sp->s_name, p);
	X	if (*p++ == '\0')
	X		xerror("Bad SUBFILE (%s) line %d.", SUBFILE, sfline);
	X	/*
	X	 * A sys file line reading "ME" means the name of the local system.
	X	 */
	X	if (STRCMP(sp->s_name, "ME") == 0)
	X		(void) strcpy(sp->s_name, LOCALPATHSYSNAME);
	X	e = index(sp->s_name, '/');
	X	if (e) {
	X		*e++ = '\0';
	X		sp->s_nosend = e;
	X	}
	X	p = fldget(sp->s_nbuf, p);
	X	lcase(sp->s_nbuf);
	X	if (*p++ == '\0')
	X		return TRUE;
	X
	X	p = fldget(sp->s_flags, p);
	X	if (*p++ == '\0')
	X		return TRUE;
	X
	X	(void) fldget(sp->s_xmit, p);
	X	return TRUE;
	X}
	X
	Xchar *
	Xfldget(q, p)
	Xregister char *q, *p;
	X{
	X	while (*p && *p != ':') {
	X		if (*p == '\\' && p[1]==':')
	X			p++;
	X		*q++ = *p++;
	X	}
	X	*q = '\0';
	X	return p;
	X}
	X
	X/*
	X * Find the SUBFILE record for a system.
	X */
	Xs_find(sp, system)
	Xregister struct srec *sp;
	Xchar *system;
	X{
	X	s_openr();
	X	while (s_read(sp))
	X		if (STRNCMP(system, sp->s_name, SNLN) == 0) {
	X			s_close();
	X			return TRUE;
	X		}
	X	s_close();
	X	return FALSE;
	X}
	X
	X/*
	X * Close sysfile.
	X */
	Xs_close()
	X{
	X	(void) fclose(sysfile);
	X}
	X#endif /* SERVER */
	X
	Xextern struct timeb Now;
	X
	Xtime_t
	Xcgtdate(datestr)
	Xchar *datestr;
	X{
	X	char	junk[40],month[40],day[30],tod[60],year[50];
	X	static time_t lasttime;
	X	static char lastdatestr[BUFLEN] = "";
	X
	X	if ( lastdatestr[0] && STRCMP(datestr, lastdatestr) == 0)
	X		return lasttime;
	X	lasttime = getdate(datestr, &Now);
	X	if (lasttime < 0) {
	X		logerr("Unparsable date \"%s\"", datestr);
	X		if (sscanf(datestr, "%s %s %s %s %s", junk, month, day, tod,
	X			year) == 5) {
	X			(void) sprintf(bfr, "%s %s, %s %s", month, day, year,
	X				tod);
	X			lasttime = getdate(bfr, &Now);
	X		}
	X		if (lasttime < 0) {
	X			datestr = "now"; /* better than nothing */
	X			lasttime = Now.time;
	X		}
	X	}
	X	strncpy(lastdatestr, datestr, BUFLEN);
	X	return lasttime;
	X}
	X
	Xlcase(s)
	Xregister char *s;
	X{
	X	register char *ptr;
	X
	X	for (ptr = s; *ptr; ptr++)
	X		if (isupper(*ptr))
	X			*ptr = tolower(*ptr);
	X}
	X
	X/*
	X * Return a compact representation of the person who posted the given
	X * message.  A sender or internet name will be used, otherwise
	X * the last part of the path is used preceded by an optional ".."
	X */
	Xchar *
	Xtailpath(hp)
	Xstruct hbuf *hp;
	X{
	X	char *p, *r;
	X	static char resultbuf[BUFLEN];
	X	char pathbuf[PATHLEN];
	X	char *malloc();
	X
	X	/*
	X	 * This only happens for articles posted by old news software
	X	 * in non-internet format.
	X	 */
	X	resultbuf[0] = '\0';
	X	(void) strncpy(pathbuf, hp->path, PATHLEN);
	X	p = index(pathbuf, ' ');
	X	if (p)
	X		*p = '\0';	/* Chop off trailing " (name)" */
	X	r = rindex(pathbuf, '!');
	X	if (r == 0) {
	X		r = pathbuf;
	X	} else {
	X		while (r > pathbuf && *--r != '!')
	X			;
	X		if (r > pathbuf) {
	X			r++;
	X			(void) strcpy(resultbuf, "..!");
	X		}
	X	}
	X	(void) strcat(resultbuf, r);
	X	return resultbuf;
	X}
	X
	X/*
	X * arpadate is like ctime(3) except that the time is returned in
	X * an acceptable ARPANET time format instead of ctime format.
	X */
	Xchar *
	Xarpadate(longtime)
	Xtime_t *longtime;
	X{
	X	register char *p, *q, *ud;
	X	register int i;
	X	static char b[40];
	X	extern struct tm *gmtime();
	X	extern char *asctime();
	X
	X	/*  Get current time. This will be used resolve the timezone. */
	X	ud = asctime(gmtime(longtime));
	X
	X	/*  Crack the UNIX date line in a singularly unoriginal way. */
	X	q = b;
	X
	X#ifdef notdef
	X/* until every site installs the fix to getdate.y, the day
	X   of the week can cause time warps */
	X	p = &ud[0];		/* Mon */
	X	*q++ = *p++;
	X	*q++ = *p++;
	X	*q++ = *p++;
	X	*q++ = ','; *q++ = ' ';
	X#endif
	X
	X	p = &ud[8];		/* 16 */
	X	if (*p == ' ')
	X		p++;
	X	else
	X		*q++ = *p++;
	X	*q++ = *p++; *q++ = ' ';
	X
	X	p = &ud[4];		/* Sep */
	X	*q++ = *p++; *q++ = *p++; *q++ = *p++; *q++ = ' ';
	X
	X	p = &ud[22];		/* 1979 */
	X	*q++ = *p++; *q++ = *p++; *q++ = ' ';
	X
	X	p = &ud[11];		/* 01:03:52 */
	X	for (i = 8; i > 0; i--)
	X		*q++ = *p++;
	X
	X	*q++ = ' ';
	X	*q++ = 'G';		/* GMT */
	X	*q++ = 'M';
	X	*q++ = 'T';
	X	*q = '\0';
	X
	X	return b;
	X}
	X
	Xchar *
	Xreplyname(hptr)
	Xstruct hbuf *hptr;
	X{
	X	register char *ptr;
	X	static char tbuf[PATHLEN];
	X
	X	ptr = hptr->path;
	X	if (PREFIX(ptr, PATHSYSNAME) &&
	X		index(NETCHRS, ptr[strlen(PATHSYSNAME)]))
	X		ptr = index(ptr, '!') + 1;
	X#ifdef INTERNET
	X	if (hptr->from[0])
	X		ptr = hptr->from;
	X	if (hptr->replyto[0])
	X		ptr = hptr->replyto;
	X#else /* !INTERNET */
	X	if (hptr->replyto[0] && !index(hptr->replyto, '@'))
	X		ptr = hptr->replyto;
	X#endif	/* !INTERNET */
	X	(void) strcpy(tbuf, ptr);
	X	ptr = index(tbuf, '(');
	X	if (ptr) {
	X		while (ptr[-1] == ' ')
	X			ptr--;
	X		*ptr = 0;
	X	}
	X#ifndef SERVER
	X#ifdef	SunIII
	X	if (ptr = rindex(tbuf, '.')) {
	X		if (prefix(++ptr, "OZ")) {
	X			/* some people only allow it in lower case ... */
	X			strcpy(ptr, "oz");
	X			return tbuf;
	X		}
	X		if (PREFIX(ptr, "UUCP") || PREFIX(ptr, "ARPA") ||
	X		    PREFIX(ptr, "DEC") || PREFIX(ptr, "CSNET")) {
	X			strcat(tbuf, "@munnari.oz");	/* via sun to munnari */
	X			return tbuf;
	X		}
	X	}
	X	/*
	X	 * must(?) have come from a uucp site, lets look see if path passes
	X	 * through munnari, and if so delete the fake uucp path after that.
	X	 */
	X	for (ptr = tbuf ;; ptr++) {
	X		if (PREFIX(ptr, "munnari!")) {
	X			strcpy(tbuf, ptr+8);
	X			break;
	X		}
	X		ptr = index(ptr, '!');
	X		if (ptr == (char *)0)
	X			break;
	X	}
	X	/*
	X	 * now, just send the address we have left to munnari, and
	X	 * hope that something sensible will be done with it there.
	X	 * (This works in more cases than you'd think ...)
	X	 */
	X	strcat(tbuf, "@munnari.oz");
	X#else /* !SunIII */
	X#ifndef INTERNET
	X	/*
	X	 * Play games stripping off multiple berknet
	X	 * addresses (a!b!c:d:e => a!b!d:e) here.
	X	 */
	X	for (ptr=tbuf; *ptr; ptr++) {
	X		register char *ptr2;
	X
	X		if (index(NETCHRS, *ptr) && *ptr == ':' &&
	X		    (ptr2=index(ptr+1, ':')))
	X			(void) strcpy(ptr, ptr2);
	X	}
	X#else	/* INTERNET */
	X	{
	X	char mbuf[BUFLEN], modadd[BUFLEN];
	X	FILE *mfd;
	X	/* Let's find a path to the backbone */
	X	sprintf(mbuf, "%s/mailpaths", LIB);
	X	mfd = xfopen(mbuf, "r");
	X	do {
	X		if (fgets(mbuf, sizeof mbuf, mfd) == NULL)
	X			xerror("Can't find internet in %s/mailpaths",
	X				LIB);
	X	} while (!PREFIX(mbuf, "internet"));
	X	if (sscanf(mbuf, "%*s %s", modadd) != 1)
	X		xerror("internet address corrupted");
	X	(void) fclose(mfd);
	X	(void)strcpy(mbuf, tbuf);
	X	/* If we are lucky, there is no ! or @ in the forward address */
	X	if (strpbrk(modadd, "!@") == NULL) {
	X		sprintf(tbuf, modadd, mbuf);
	X	} else {
	X		char *cp = index(mbuf, '@');
	X		if (index(modadd, '@') == NULL && cp) {
	X			/* we have to rearrange the address so no @ are in it */
	X			char atbuf[BUFLEN];
	X			*cp++ = '\0';
	X			sprintf(atbuf, "%s!%s", cp, mbuf);
	X			sprintf(tbuf, modadd, atbuf);
	X		} else if (cp) {
	X			/* some days you don't get lucky. presume the % hack */
	X			*cp = '%';
	X			sprintf(tbuf, modadd, mbuf);
	X		}
	X	}
	X	}
	X#endif /* INTERNET */
	X#endif /* !SunIII */
	X#endif /* !SERVER */
	X	return tbuf;
	X}
	X
	X
	X/*
	X * Given an article ID, find the line in the history file that mentions it.
	X * Return the text of the line, or NULL if not found.  A pointer to a
	X * static area is returned.
	X */
	Xchar *
	Xfindhist(artid)
	Xchar *artid;
	X{
	X	static char lbuf[256];
	X	char oidbuf[BUFSIZ];
	X	FILE *hfp;
	X	register char *p;
	X#ifdef SERVER
	X	char workspace[256];
	X	struct tm *tm;
	X	long clock;
	X#else /* !SERVER */
	X#ifdef DBM
	X	datum lhs, rhs;
	X	datum fetch();
	X	long fpos; /* We have to use an explicit variable to insure alignment */
	X#else /* !DBM */
	X	char *histfile();
	X#endif /* !DBM */
	X#endif /* !SERVER */
	X	/* Try to understand old artid's as well.  Assume .UUCP domain. */
	X	if (artid[0] != '<') {
	X		p = index(artid, '.');
	X		if (p)
	X			*p++ = '\0';
	X		(void) sprintf(oidbuf, "<%s@%s.UUCP>", p, artid);
	X		if (p)
	X			*--p = '.';
	X	} else
	X		(void) strcpy(oidbuf, artid);
	X#ifdef SERVER
	X	(void) sprintf(lbuf,"STAT %s",oidbuf);
	X	put_server(lbuf);
	X	(void) get_server(workspace,sizeof(workspace));
	X	if (*workspace != CHAR_OK)
	X		return NULL;
	X	(void) sprintf(lbuf,"XHDR xref %s",oidbuf);
	X	put_server(lbuf);
	X	(void) get_server(workspace,sizeof(workspace));	/* get response */
	X	if (*workspace != CHAR_OK)
	X		return NULL;		/* old style nntp */
	X	(void) get_server(workspace,sizeof(workspace)); /* get header line */
	X	sync_server();	/* get rid of the rest of it */
	X	p = index(workspace,' ');
	X	p++;
	X
	X	if (*p == '(') {	/* there is no xref line */
	X		long s,sm;
	X		FILE * af;
	X		char n[100], buf[100], *name;
	X		(void) sprintf(lbuf,"XHDR newsgroups %s",oidbuf);
	X		put_server(lbuf);
	X		(void) get_server(workspace,sizeof(workspace));
	X		if (*workspace != CHAR_OK)
	X			return NULL;
	X		(void) get_server(workspace,sizeof(workspace));
	X		sync_server();
	X		if ((name = index(workspace,' ')) == NULL)
	X			return NULL;
	X		name++;
	X		/* now we fetch the line from the active file */
	X		af = xfopen(ACTIVE, "r");
	X		while (fgets(buf, sizeof(buf), af) != NULL) {
	X			if (sscanf(buf, "%s %ld %ld", n, &s, &sm) == 3 &&
	X			     STRCMP(n, name) == 0) {
	X				break;
	X			}
	X		}
	X		(void) fclose(af);
	X		/* now we ask for a message ids in that newsgroup */
	X		if (set_group(name) == NULL)
	X			return NULL;
	X		(void) sprintf(lbuf, "XHDR message-id %d-%d", sm, s);
	X		put_server(lbuf);
	X		(void) get_server(workspace,sizeof(workspace));
	X		if (*workspace != CHAR_OK)
	X			return NULL;
	X		while (	get_server(workspace,sizeof(workspace)) >= 0) {
	X			if (*workspace == '.'  && strlen(workspace) == 1) 
	X				return NULL;
	X			if (strindex(workspace,oidbuf) > -1)
	X				break;
	X		}
	X		sync_server();
	X		*(index(workspace,' ')) = '\0';
	X		(void) sprintf(lbuf, "%s/%s", n, workspace);
	X		bzero(workspace,sizeof(workspace));
	X		strcpy(workspace, lbuf);
	X	} else {
	X		bzero(lbuf, sizeof(lbuf));
	X		strcpy(lbuf, p);
	X		while (*p != '\0' && (p = index(lbuf,':')) != NULL) {
	X			*p = '/';
	X			p++;
	X		}
	X		strcpy(workspace, lbuf);
	X	}
	X	p = &workspace[0];
	X	time(&clock);		
	X	tm = localtime(&clock);
	X#ifdef USG
	X	sprintf(lbuf, "%s\t%2.2d/%2.2d/%d %2.2d:%2.2d\t%s",
	X#else /* !USG */
	X	sprintf(lbuf, "%s\t%02d/%02d/%d %02d:%02d\t%s",
	X#endif /* !USG */
	X	oidbuf,tm->tm_mon,tm->tm_mday,tm->tm_year,tm->tm_hour,tm->tm_min,p);
	X	return lbuf;		/* not really the same, but close */
	X#else	/* !SERVER */
	X	lcase(oidbuf);
	X#ifdef DBM
	X	initdbm(ARTFILE);
	X	lhs.dptr = oidbuf;
	X	lhs.dsize = strlen(lhs.dptr) + 1;
	X	rhs = fetch(lhs);
	X	if (rhs.dptr == NULL)
	X		return NULL;
	X	hfp = xfopen(ARTFILE, "r");
	X	/* The bcopy is NECESSARY to insure alignment on some machines */
	X	bcopy(rhs.dptr, (char *)&fpos, sizeof (long));
	X	fseek(hfp, fpos, 0);
	X#else /* !DBM */
	X	hfp = xfopen(histfile(oidbuf), "r");
	X#endif /* !DBM */
	X	while (fgets(lbuf, BUFLEN, hfp) != NULL) {
	X		p = index(lbuf, '\t');
	X		if (p == NULL)
	X			p = index(lbuf, '\n');
	X		*p = 0;
	X		if (STRCMP(lbuf, artid) == 0 || STRCMP(lbuf, oidbuf) == 0) {
	X			(void) fclose(hfp);
	X			*p = '\t';
	X			*(lbuf + strlen(lbuf) - 1) = 0;	/* zap the \n */
	X			return lbuf;
	X		}
	X#ifdef DBM
	X		break;
	X#endif /* DBM */
	X	}
	X	(void) fclose(hfp);
	X	return NULL;
	X#endif	/* !SERVER */
	X}
	X
	X/*
	X * Hunt up the article "artid", and return the newsgroup/artnum
	X * where it can be found.
	X */
	Xchar *
	Xfindfname(artid)
	Xchar *artid;
	X{
	X	char *line, *p, *q;
	X	char *findhist();
	X	static char fname[BUFLEN];
	X
	X	line = findhist(artid);
	X	if (line) {
	X		/* Look for it stored as an article, where it should be */
	X		p = index(line, '\t');
	X		p = index(p+1, '\t');
	X		p++;
	X		if (*p) {
	X			q = index(p, ' ');
	X			if (q)
	X				*q = 0;
	X			(void) strcpy(fname, p);
	X			return fname;
	X		}
	X	}
	X	return NULL;
	X}
	X
	X/*
	X * Hunt up the article "artid", fopen it for read, and return a
	X * file descriptor to it.  We look everywhere we can think of.
	X */
	XFILE *
	Xhfopen(artid)
	Xchar *artid;
	X{
	X	char *p;
	X	char *findhist();
	X	FILE *rv = NULL;
	X	char fname[BUFLEN];
	X
	X	p = findfname(artid);
	X	if (p) {
	X#ifdef SERVER
	X	if ((rv = getartbyid(p)) != NULL) {
	X		strcpy(fname, article_name());
	X		(void) fclose(rv);
	X		rv = NULL;
	X	}
	X	else
	X		xerror("Cannot hfopen article %s", artid);
	X#else 	/* !SERVER */
	X		(void) strcpy(fname, dirname(p));
	X#endif	/* !SERVER */
	X		rv = fopen(fname, "r");	/* NOT xfopen! */
	X		if (rv == NULL)
	X			xerror("Cannot hfopen article %s", artid);
	X	}
	X#ifdef SERVER
	X	(void) unlink(fname);
	X#endif /* !SERVER */
	X	return rv;
	X}
	X#ifndef SERVER
	X# ifdef DBM
	X/*
	X** Avoid problems of multiple dbminit calls.
	X*/
	Xinitdbm(name)
	Xchar *name;
	X{
	X	static int called = 0;
	X
	X	if (called != 0)
	X		return;
	X	called = 1;
	X	(void) dbminit(name);
	X}
	X# endif /* DBM */
	X#endif	/* !SERVER */
	X
	X#ifndef BSD4_2
	X/*
	X * move n bytes from a to b
	X */
	Xbcopy(a, b, n)
	Xregister char *a, *b;
	Xregister n;
	X{
	X	while (--n >= 0)
	X		*b++ = *a++;
	X}
	X#endif
	X
	X#ifndef DBM
	X/*
	X** Generate the appropriate history subfile name
	X*/
	Xchar *
	Xhistfile(hline)
	Xchar *hline;
	X{
	X	char chr;	/* least significant digit of article number */
	X	static char subfile[BUFLEN];
	X
	X	chr = findhfdigit(hline);
	X	sprintf(subfile, "%s.d/%c", ARTFILE, chr);
	X	return subfile;
	X}
	X
	Xfindhfdigit(fn)
	Xchar *fn;
	X{
	X	register char *p;
	X	register int chr;
	X
	X	p = index(fn, '@');
	X	if (p != NULL && p > fn)
	X		chr = *(p - 1);
	X	else
	X		chr = '0';
	X	if (!isdigit(chr))
	X		chr = '0';
	X	return chr;
	X}
	X#endif /* !DBM */
	X
	X#ifdef VMS
	X/*
	X * These functions open an article with one level of indirection,
	X * to support symbolic links. xart_open exits if the open fails.
	X */
	XFILE *
	Xxart_open (filename,mode)
	Xchar *filename,*mode;
	X{
	X	FILE *fp = art_open (filename, mode);
	X	extern int errno;
	X	if (fp == NULL)
	X		xerror("Cannot open article %s (%s): %s\n",
	X			 filename, mode, errmsg(errno));
	X	return fp;
	X}
	X
	XFILE *
	Xart_open (filename,mode)
	Xchar *filename,*mode;
	X{
	X	char linkfile[BUFSIZ];
	X	FILE *fp;
	X
	X	if ((fp = fopen (filename, mode)) == NULL)
	X		return NULL;
	X	if (fgets (linkfile, BUFSIZ, fp) == NULL || linkfile[0] != '/') {
	X		rewind (fp);
	X		return fp;
	X	}
	X/* Chase the symbolic link. */
	X	(void) fclose (fp);
	X	if ((fp = fopen (linkfile, mode)) == NULL)
	X/* Clean up dangling link, if we have the power. Ignore error if we don't. */
	X		(void) unlink (filename);
	X	return fp;
	X}
	X#endif /* VMS */
	X
	X/*
	X * Generate the name of the person responsible for posting this article,
	X * in order to check that two articles were posted by the same person.
	X */
	Xchar *
	Xsenderof(hp)
	Xstruct hbuf *hp;
	X{
	X	register char *q, *tp;
	X	char *tailpath();
	X	static char senderbuf[BUFLEN];
	X
	X	if (hp->sender[0])
	X		tp = hp->sender;
	X	else if (hp->from[0])
	X		tp = hp->from;
	X	else
	X		tp = tailpath(hp);
	X
	X	(void) strncpy(senderbuf, tp, BUFLEN);
	X	/* Remove full name */
	X	q = index(senderbuf, ' ');
	X	if (q)
	X		*q = '\0';
	X
	X	return senderbuf;
	X}
SHAR_EOF
if test 16805 -ne "`wc -c < 'funcs2.c'`"
then
	echo shar: error transmitting "'funcs2.c'" '(should have been 16805 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'header.c'" '(16930 characters)'
if test -f 'header.c'
then
	echo shar: will not over-write existing file "'header.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'header.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * header.c - header functions plus some other goodies
	X */
	X/*LINTLIBRARY*/
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)header.c	2.49	10/7/87";
	X#endif /* SCCSID */
	X
	X#include <stdio.h>
	X#include "params.h"
	X#include "patchlevel.h"
	X
	Xchar *hfgets();
	X
	Xchar *news_version = NEWS_VERSION;
	X
	X/*
	X * Read header from file fp into *hp.  If wholething is FALSE,
	X * it's an incremental read, otherwise start from scratch.
	X * Return (FILE *) if header okay, else NULL.
	X */
	XFILE *
	Xhread(hp, fp, wholething)
	Xregister struct hbuf *hp;
	XFILE *fp;
	Xint wholething;
	X{
	X#ifndef GENERICPATH
	X	register int	len;
	X#endif /* GENERICPATH */
	X	register int	i;
	X#ifdef OLD
	X	char *p;
	X#endif /* OLD */
	X
	X	if (wholething) {
	X		for(i=0;i<NUNREC;i++)
	X			if (hp->unrec[i] != NULL)
	X				free(hp->unrec[i]);
	X			else
	X				break;
	X		bzero((char *)hp, sizeof (*hp));
	X		for (i=0;i<NUNREC;i++)
	X			hp->unrec[i] = NULL;
	X	}
	X
	X	/* Check that it's a B news style header. */
	X	if (hfgets(bfr, PATHLEN, fp) != NULL && isalpha(bfr[0])
	X	    && index(bfr, ':'))
	X		if (frmread(fp, hp))
	X			goto strip;
	X
	X	if (!nstrip(bfr+1))
	X		return NULL;
	X
	X	/* It's not.  Try A news (begins with PROTO). */
	X	if (bfr[0] != PROTO)
	X		return NULL;
	X#ifndef OLD
	X	logerr("Can not process A news format article without OLD defined");
	X#else /* OLD */
	X	/* Read in an A news format article. */
	X	p = index(bfr+1, '.');
	X	if (p == NULL) {
	X		(void) strcpy(hp->ident, bfr+1);
	X		return NULL;
	X	}
	X	*p++ = '\0';
	X	(void) sprintf(hp->ident, "<%s@%s%s>", p, bfr+1, ".UUCP");
	X
	X	/* Newsgroup List */
	X	if (hfgets(hp->nbuf, BUFLEN, fp) == NULL || !nstrip(hp->nbuf))
	X		return NULL;
	X	/* source path */
	X	if (hfgets(hp->path, PATHLEN, fp) == NULL || !nstrip(hp->path))
	X		return NULL;
	X	/* date */
	X	if (hfgets(hp->subdate, DATELEN, fp) == NULL || !nstrip(hp->subdate))
	X		return NULL;
	X	/* title */
	X	if (hfgets(hp->title, BUFLEN, fp) == NULL || !nstrip(hp->title))
	X		return NULL;
	X#endif /* OLD */
	X
	Xstrip:	/* strip off sys! from front of path. */
	X#ifndef GENERICPATH
	X	if (strncmp(PATHSYSNAME, hp->path, (len = strlen(PATHSYSNAME))) == 0
	X		&& index(NETCHRS, hp->path[len]))
	X		(void) strcpy(hp->path, &(hp->path[len+1]));
	X#endif /* GENERICPATH */
	X	lcase(hp->nbuf);
	X
	X	/* Intuit the From: line if only a path was given. */
	X	if (wholething) {
	X#ifdef OLD
	X		if (hp->from[0] == '\0')
	X			intuitfrom(hp);
	X		else
	X#endif /* OLD */
	X			fixfrom(hp);
	X	}
	X
	X	return fp;
	X}
	X
	X
	X/*
	X * Get header info from mail-format file.
	X * Return non-zero on success.
	X */
	X#define FROM 		1
	X#define NEWSGROUP 	2
	X#define TITLE 		3
	X#define SUBMIT		4
	X#define RECEIVE		5
	X#define EXPIRE		6
	X#define ARTICLEID	7
	X#define MESSAGEID	8
	X#define REPLYTO		9
	X#define FOLLOWID	10
	X#define CONTROL		11
	X#define SENDER		12
	X#define FOLLOWTO	13
	X#define PATH		14
	X#define POSTVERSION	15
	X#define RELAYVERSION	16
	X#define DISTRIBUTION	17
	X#define ORGANIZATION	18
	X#define NUMLINES	19
	X#define KEYWORDS	20
	X#define APPROVED	21
	X#define NFID		22
	X#define NFFROM		23
	X#define XREF		24
	X#define SUMMARY		25
	X#define XPATH		26
	X#define SUPERSEDES	27
	X#define OTHER		99
	X
	Xchar *malloc();
	X
	Xfrmread(fp, hp)
	Xregister FILE *fp;
	Xregister struct hbuf *hp;
	X{
	X	int	unreccnt = 0;
	X	register int	i;
	X
	X	i = type(bfr);
	X	do {
	X		switch (i) {
	X		case PATH:
	X			getfield(hp->path, sizeof(hp->path));
	X			break;
	X		case FROM:
	X			getfield(hp->from, sizeof(hp->from));
	X			break;
	X		case NEWSGROUP:
	X			getfield(hp->nbuf, sizeof(hp->nbuf));
	X			break;
	X		case TITLE:
	X			getfield(hp->title, sizeof(hp->title));
	X			break;
	X		case SUBMIT:
	X			getfield(hp->subdate, sizeof(hp->subdate));
	X			break;
	X		case EXPIRE:
	X			getfield(hp->expdate, sizeof(hp->expdate));
	X			break;
	X#ifdef OLD
	X		case ARTICLEID:
	X			/* Believe Message-ID in preference to Article-ID */
	X			if (hp->ident[0] == '\0') {
	X				register char *p;
	X				char msgb[NAMELEN];
	X				getfield(msgb, sizeof msgb);
	X				p = index(msgb, '.');
	X				if (p == NULL) {
	X					(void) strcpy(hp->ident, msgb);
	X				} else {
	X					*p++ = '\0';
	X					(void) sprintf(hp->ident, "<%s@%s%s>", p, msgb, ".UUCP");
	X				}
	X			}
	X			break;
	X#endif /* OLD */
	X		case MESSAGEID:
	X			getfield(hp->ident, sizeof(hp->ident));
	X			break;
	X		case REPLYTO:
	X			getfield(hp->replyto, sizeof(hp->replyto));
	X			break;
	X		case FOLLOWID:
	X			getfield(hp->followid, sizeof(hp->followid));
	X			break;
	X		case SENDER:
	X			getfield(hp->sender, sizeof(hp->sender));
	X			break;
	X		case FOLLOWTO:
	X			getfield(hp->followto, sizeof(hp->followto));
	X			break;
	X		case CONTROL:
	X			getfield(hp->ctlmsg, sizeof(hp->ctlmsg));
	X			break;
	X		case DISTRIBUTION:
	X			getfield(hp->distribution, sizeof(hp->distribution));
	X			if (strcmp(hp->distribution, "net") == 0
	X				|| strcmp(hp->distribution, "world") == 0)
	X				hp->distribution[0] = '\0';
	X			break;
	X		case ORGANIZATION:
	X			getfield(hp->organization, sizeof(hp->organization));
	X			break;
	X		case NUMLINES:
	X			getfield(hp->numlines, sizeof(hp->numlines));
	X			hp->intnumlines = atoi(hp->numlines);
	X			break;
	X		case KEYWORDS:
	X			getfield(hp->keywords, sizeof(hp->keywords));
	X			break;
	X		case APPROVED:
	X			getfield(hp->approved, sizeof(hp->approved));
	X			break;
	X		case NFID:
	X			getfield(hp->nf_id, sizeof(hp->nf_id));
	X			break;
	X		case NFFROM:
	X			getfield(hp->nf_from, sizeof(hp->nf_from));
	X			break;
	X		case SUPERSEDES:
	X			getfield(hp->supersedes, sizeof(hp->supersedes));
	X			break;
	X		/* discard these lines */
	X		case XREF:
	X		case XPATH:
	X		case RELAYVERSION:
	X		case POSTVERSION:
	X		case RECEIVE:
	X			break;
	X		case SUMMARY:
	X			getfield(hp->summary, sizeof(hp->summary));
	X			break;
	X		case OTHER:
	X			if (unreccnt < NUNREC) {
	X				if ((hp->unrec[unreccnt] = malloc((unsigned)(strlen(bfr) + 1))) != NULL ) {
	X					(void) strcpy(hp->unrec[unreccnt], bfr);
	X					(void) nstrip(hp->unrec[unreccnt]);
	X					unreccnt++;
	X				} else
	X					xerror("frmread: out of memory");
	X			}
	X			break;
	X		}
	X	} while ((i = type(hfgets(bfr, LBUFLEN, fp))) > 0);
	X
	X	if ((hp->from[0] || hp->path[0]) && hp->subdate[0] && hp->ident[0])
	X		return TRUE;
	X	return FALSE;
	X}
	X
	X#ifdef OLD
	X/*
	X * There was no From: line in the message (because it was generated by
	X * an old news program).  Guess what it should have been and create it.
	X */
	Xintuitfrom(hp)
	Xregister struct hbuf *hp;
	X{
	X	char *tp;
	X	char *user, *host;
	X	char *tailpath(), *rindex();
	X	char *at, *dot;
	X	char pathbuf[PATHLEN];
	X	char fullname[BUFLEN];
	X	extern char *mydomain();
	X
	X	tp = tailpath(hp);
	X	user = rindex(tp, '!');
	X	if (user == NULL)
	X		user = tp;
	X	else
	X		*user++ = '\0';
	X
	X	/* Check for an existing Internet address on the end. */
	X	at = index(user, '@');
	X	if (at) {
	X		dot = index(at, '.');
	X		if (dot) {
	X			(void) strcpy(hp->from, user);
	X			return;
	X		}
	X		/* @ signs are illegal except for the biggie, so */
	X		*at = '%';
	X	}
	X
	X	if (tp[0] == '.')
	X		host = index(tp, '!') + 1;
	X	else if (user == tp)
	X		host = FROMSYSNAME;
	X	else
	X		host = tp;
	X
	X	tp = index(host, '@');
	X	if (tp != NULL)
	X		*tp = 0;
	X	if (index(host, '.') != NULL)
	X		(void) sprintf(hp->from, "%s@%s%s", user, host, mydomain());
	X	else
	X		(void) sprintf(hp->from, "%s@%s", user, host);
	X
	X	skin(pathbuf, fullname, hp->path);	/* remove RFC822-style comments */
	X	if (fullname[0] != '\0') {
	X		strcat(hp->from, " (");
	X		(void) strcat(hp->from, fullname);
	X		strcat(hp->from, ")");
	X	}
	X	strcpy(hp->path, pathbuf);	/* and stick it back in */
	X}
	X#endif /* OLD */
	X
	X/*
	X * Canonicalize the "From:" line into the form
	X *
	X * From: <mail-address> (full-name)
	X *
	X * RFC822 doesn't require the comment to be at the end of the string
	X * like that.
	X */
	Xfixfrom(hp)
	Xregister struct hbuf *hp;
	X{
	X	char frombuf[PATHLEN];
	X	char fullname[BUFLEN];
	X
	X	skin(frombuf, fullname, hp->from);	/* remove RFC822-style comments */
	X	if (fullname[0] != '\0') {
	X		strcat(frombuf, " (");
	X		strcat(frombuf, fullname);
	X		strcat(frombuf, ")");
	X	}
	X	strcpy(hp->from, frombuf);	/* stick the canonicalized "from" back in */
	X}
	X
	Xskin(name, fullname, hfield)
	Xchar *name;
	Xchar *fullname;
	Xchar *hfield;
	X{
	X	register int c;
	X	register char *cp, *cp2;
	X	char *bufend;
	X	int gotlt, parenlev, lastsp;
	X	int seenfullname = FALSE;
	X
	X	*fullname = '\0';	/* no full name yet */
	X	if (strpbrk(hfield, "(< ") == NULL) {		/* include ',' ?? */
	X		strcpy(name, hfield);
	X		return;
	X	}
	X	gotlt = 0;
	X	parenlev = 0;
	X	lastsp = 0;
	X	bufend = name;
	X	for (cp = hfield, cp2 = bufend; c = *cp++; ) {
	X		switch (c) {
	X		case '(':
	X			/*
	X			 * Start of a "comment".
	X			 * Ignore it, or save it in "fullname" if we haven't
	X			 * seen a comment yet.
	X			 */
	X			parenlev++;
	X			while ((c = *cp) != 0) {
	X				cp++;
	X				switch (c) {
	X				case '\\':
	X					if ((c = *cp) == 0)
	X						goto outcm;
	X					cp++;
	X					break;
	X				case '(':
	X					parenlev++;
	X					break;
	X				case ')':
	X					parenlev--;
	X					if (parenlev == 0)
	X						goto outcm;
	X					break;
	X				}
	X				if (!seenfullname)
	X					*fullname++ = c;
	X			}
	X		outcm:
	X			parenlev = 0;
	X			lastsp = 0;
	X			if (!seenfullname) {
	X				*fullname = '\0';
	X				seenfullname = TRUE;	/* only extract first comment */
	X			}
	X			break;
	X
	X		case '"':
	X			/*
	X			 * Start of a "quoted-string".
	X			 * Copy it in its entirety.
	X			 */
	X			while ((c = *cp) != 0) {
	X				cp++;
	X				switch (c) {
	X				case '\\':
	X					if ((c = *cp) == 0)
	X						goto outqs;
	X					cp++;
	X					break;
	X				case '"':
	X					goto outqs;
	X				}
	X				*cp2++ = c;
	X			}
	X		outqs:
	X			lastsp = 0;
	X			break;
	X
	X		case ' ':
	X			if (cp[0] == 'a' && cp[1] == 't' && cp[2] == ' ')
	X				cp += 3, *cp2++ = '@';
	X			else
	X			if (cp[0] == '@' && cp[1] == ' ')
	X				cp += 2, *cp2++ = '@';
	X			else
	X				lastsp = 1;
	X			break;
	X
	X		case '<':
	X			if (!seenfullname) {
	X				*cp2 = '\0';
	X				strcpy(fullname, name);
	X				seenfullname = TRUE;
	X			}
	X			cp2 = bufend;
	X			gotlt++;
	X			lastsp = 0;
	X			break;
	X
	X		case '>':
	X			if (gotlt) {
	X				gotlt = 0;
	X				/*
	X				 * this doesn't seem reasonable, what about (,)
	X				 * or "," ??
	X				 */
	X				while (*cp != ',' && *cp != 0)
	X					cp++;
	X				if (*cp == 0 )
	X					goto done;
	X				*cp2++ = ',';
	X				*cp2++ = ' ';
	X				bufend = cp2;
	X				break;
	X			}
	X
	X			/* Fall into . . . */
	X
	X		default:
	X			if (lastsp) {
	X				lastsp = 0;
	X				*cp2++ = ' ';
	X			}
	X			*cp2++ = c;
	X			break;
	X		}
	X	}
	Xdone:
	X	*cp2 = 0;
	X}
	X
	X
	X#ifdef OLD
	Xchar *
	Xoident(ident)
	Xchar *ident;
	X{
	X	char lbuf[BUFLEN];
	X	static char oidbuf[BUFLEN];
	X	register char *p, *q;
	X
	X	(void) strcpy(lbuf, ident);
	X	p = index(lbuf, '@');
	X	if (p == NULL)
	X		return ident;
	X	*p++ = '\0';
	X	q = index(p, '.');
	X	if (q == NULL)
	X		q = index(p, '>');
	X	if (q)
	X		*q++ = '\0';
	X	p[SNLN] = '\0';
	X	(void) sprintf(oidbuf, "%s.%s", p, lbuf+1);
	X	return oidbuf;
	X}
	X#endif /* OLD */
	X
	X/*
	X * Get the given field of a header (char * parm) from bfr, but only
	X * if there's something actually there (after the colon).  Don't
	X * bother if we already have an entry for this field.
	X */
	Xgetfield(hpfield, size)
	Xchar	*hpfield;
	Xint	size;
	X{
	X	register char	*ptr;
	X
	X	if (hpfield[0])
	X		return;
	X	for (ptr = index(bfr, ':'); isspace(*++ptr); )
	X		;
	X	if (*ptr != '\0') {
	X		(void) strncpy(hpfield, ptr, size - 1);
	X		(void) nstrip(hpfield);
	X	}
	X}
	X
	X
	X#define its(type) (PREFIX(ptr, type))
	Xtype(ptr)
	Xregister char	*ptr;
	X{
	X	register char	*colon, *space;
	X
	X	if (ptr == NULL)
	X		return FALSE;
	X	if (its("From: "))
	X		if (index(ptr, '@') || !index(ptr, '!'))
	X			return FROM;
	X		else
	X			return PATH;
	X	if (its("Path: "))
	X		return PATH;
	X	if (its("Newsgroups: "))
	X		return NEWSGROUP;
	X	if (its("Subject: "))
	X		return TITLE;
	X	if (its("Date: "))
	X		return SUBMIT;
	X	if (its("Date-Received: "))
	X		return RECEIVE;
	X#ifdef OLD
	X	if (its("Title: "))
	X		return TITLE;
	X	if (its("Posted: "))
	X		return SUBMIT;
	X#endif /* OLD */
	X	if (its("Received: "))
	X		return RECEIVE;
	X	if (its("Expires: "))
	X		return EXPIRE;
	X	if (its("Article-I.D.: "))
	X		return ARTICLEID;
	X	if (its("Message-ID: "))
	X		return MESSAGEID;
	X	if (its("Reply-To: "))
	X		return REPLYTO;
	X	if (its("References: "))
	X		return FOLLOWID;
	X	if (its("Control: "))
	X		return CONTROL;
	X	if (its("Sender: "))
	X		return SENDER;
	X	if (its("Followup-To: "))
	X		return FOLLOWTO;
	X	if (its("Distribution: "))
	X		return DISTRIBUTION;
	X	if (its("Organization: "))
	X		return ORGANIZATION;
	X	if (its("Lines: "))
	X		return NUMLINES;
	X	if (its("Summary: "))
	X		return SUMMARY;
	X	if (its("Keywords: "))
	X		return KEYWORDS;
	X	if (its("Approved: "))
	X		return APPROVED;
	X	if (its("Nf-ID: "))
	X		return NFID;
	X	if (its("Nf-From: "))
	X		return NFFROM;
	X	if (its("Supersedes: "))
	X		return SUPERSEDES;
	X	if (its("Xref: "))
	X		return XREF;
	X	if (its("Xpath: "))
	X		return XPATH;
	X	if (its("Posting-Version: "))
	X		return POSTVERSION;
	X	if (its("Relay-Version: "))
	X		return RELAYVERSION;
	X	if (!isalpha(*ptr))
	X		return FALSE;
	X	colon = index(ptr, ':');
	X	space = index(ptr, ' ');
	X	if (!colon || space && space < colon)
	X		return FALSE;
	X	return OTHER;
	X}
	X
	X/*
	X * Write header at 'hp' on stream 'fp' in B+ format.  Include received date
	X * if wr is 1.  Leave off sysname if wr is 2.
	X */
	X#ifndef DOXREFS
	X/*ARGSUSED*/
	X#endif /* !DOXREFS */
	Xihwrite(hp, fp, wr)
	Xregister struct hbuf *hp;
	Xregister FILE *fp;
	Xint	wr;
	X{
	X	int iu;
	X	time_t t;
	X	time_t cgtdate();
	X
	X	/*
	X	 * We're being tricky with Path/From because of upward compatibility
	X	 * issues.  The new version considers From and Path to be separate.
	X	 * The old one thinks they both mean "Path" but only believes the
	X	 * first one it sees, so will ignore the second.
	X	 */
	X	if (PREFIX(hp->path, PATHSYSNAME) &&
	X		index(NETCHRS, hp->path[strlen(PATHSYSNAME)]))
	X		fprintf(fp, "Path: %s\n", hp->path);
	X	else
	X		fprintf(fp, "Path: %s!%s\n", PATHSYSNAME, hp->path);
	X	if (hp->from[0])
	X		fprintf(fp, "From: %s\n", hp->from);
	X
	X	fprintf(fp, "Newsgroups: %s\n", hp->nbuf);
	X	fprintf(fp, "Subject: %s\n", hp->title);
	X	if (*hp->summary)
	X		fprintf(fp, "Summary: %s\n", hp->summary);
	X	if (*hp->keywords)
	X		fprintf(fp, "Keywords: %s\n", hp->keywords);
	X	fprintf(fp, "Message-ID: %s\n", hp->ident);
	X	t = cgtdate(hp->subdate);
	X	fprintf(fp, "Date: %s\n", arpadate(&t));
	X#ifdef OLD
	X	fprintf(fp, "Article-I.D.: %s\n", oident(hp->ident));
	X	fprintf(fp, "Posted: %s", ctime(&t));
	X#endif /* OLD */
	X	if (*hp->expdate)
	X		fprintf(fp, "Expires: %s\n", hp->expdate);
	X	if (*hp->followid) {
	X		register char *dp, *cp;
	X
	X		dp = cp = hp->followid;
	X		while (*cp != '\0')
	X			if (*cp == '<' && *(cp + 1) == '>')
	X				cp += 2;
	X			else
	X				*dp++ = *cp++;
	X		*dp = '\0';
	X		if (*hp->followid)
	X			fprintf(fp, "References: %s\n", hp->followid);
	X	}
	X	if (*hp->ctlmsg)
	X		fprintf(fp, "Control: %s\n", hp->ctlmsg);
	X	if (*hp->sender)
	X		fprintf(fp, "Sender: %s\n", hp->sender);
	X	if (*hp->replyto)
	X		fprintf(fp, "Reply-To: %s\n", hp->replyto);
	X	if (*hp->followto)
	X		fprintf(fp, "Followup-To: %s\n", hp->followto);
	X	if (*hp->distribution)
	X		fprintf(fp, "Distribution: %s\n", hp->distribution);
	X	if (*hp->organization)
	X		fprintf(fp, "Organization: %s\n", hp->organization);
	X	if (*hp->numlines)
	X		fprintf(fp, "Lines: %s\n", hp->numlines);
	X	if (*hp->approved)
	X		fprintf(fp, "Approved: %s\n", hp->approved);
	X	if (*hp->nf_id)
	X		fprintf(fp, "Nf-ID: %s\n", hp->nf_id);
	X	if (*hp->nf_from)
	X		fprintf(fp, "Nf-From: %s\n", hp->nf_from);
	X	if (*hp->supersedes)
	X		fprintf(fp, "Supersedes: %s\n", hp->supersedes);
	X#ifdef DOXREFS
	X	if ( wr ==1 && *hp->xref)
	X		fprintf(fp, "Xref: %s\n", hp->xref);
	X#endif /* DOXREFS */
	X	for (iu = 0; iu < NUNREC; iu++) {
	X		if (hp->unrec[iu])
	X			fprintf(fp, "%s\n", &hp->unrec[iu][0]);
	X	}
	X	putc('\n', fp);
	X}
	X
	X
	X#ifndef BSD4_2
	X/*
	X * Set nc bytes, starting at cp, to zero.
	X */
	Xbzero(cp, nc)
	Xregister char	*cp;
	Xregister int	nc;
	X{
	X	if (nc > 0)
	X		do {
	X			*cp++ = 0;
	X		} while (--nc);
	X}
	X#endif /* !BSD4_2 */
	X
	X/*
	X * hfgets is like fgets, but deals with continuation lines.
	X * It also ensures that even if a line that is too long is
	X * received, the remainder of the line is thrown away
	X * instead of treated like a second line.
	X */
	Xchar *
	Xhfgets(buf, len, fp)
	Xchar *buf;
	Xint len;
	XFILE *fp;
	X{
	X	register int c;
	X	register int n = 0;
	X	register char *cp;
	X
	X	cp = buf;
	X	while (n < len && (c = getc(fp)) != EOF) {
	X		if (c == '\n')
	X			break;
	X		if (isprint(c) || c == '\b' || c == ' ' || c == '\t') {
	X			*cp++ = c;
	X			n++;
	X		}
	X	}
	X	if (c == EOF && cp == buf)
	X		return NULL;
	X	*cp = '\0';
	X
	X	if (c != '\n') {
	X		/* Line too long - part read didn't fit into a newline */
	X		while ((c = getc(fp)) != '\n' && c != EOF)
	X			;
	X	} else if (cp == buf) {
	X		/* Don't look for continuation of blank lines */
	X		*cp++ = '\n';
	X		*cp = '\0';
	X		return buf;
	X	}
	X
	X	while ((c = getc(fp)) == ' ' || c == '\t') {	/* for each cont line */
	X		/* Continuation line. */
	X		if ((n += 2) < len) {
	X			*cp++ = '\n';
	X			*cp++ = c;
	X		}
	X		while ((c = getc(fp)) != '\n' && c != EOF)
	X			if ((isprint(c) || c == '\b' || c == ' ' || c == '\t')
	X				&& n++ < len)
	X				*cp++ = c;
	X	}
	X	if (n >= len - 1)
	X		cp = buf + len - 2;
	X	*cp++ = '\n';
	X	*cp = '\0';
	X	if (c != EOF)
	X		(void) ungetc(c, fp); /* push back first char of next header */
	X	return buf;
	X}
SHAR_EOF
if test 16930 -ne "`wc -c < 'header.c'`"
then
	echo shar: error transmitting "'header.c'" '(should have been 16930 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'iextern.c'" '(1235 characters)'
if test -f 'iextern.c'
then
	echo shar: will not over-write existing file "'iextern.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'iextern.c'
	X/*
	X * iextern - external definitions for inews.
	X */
	X/*LINTLIBRARY*/
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)iextern.c	2.19	11/19/87";
	X#endif /* SCCSID */
	X
	X#include "iparams.h"
	X
	Xint	uid, gid;			/* real user/group I.D. */
	Xint	duid, dgid;			/* effective user/group I.D. */
	Xint	SigTrap;			/* set if signal trapped */
	Xint	savmask;			/* old umask */
	Xint	mode;				/* mode of news program */
	Xstruct hbuf header;			/* general-use header structure */
	Xchar	bfr[LBUFLEN];			/* general-use scratch area */
	Xchar	nbuf[LBUFLEN];			/* local newsgroup buffer */
	Xchar	filename[BUFLEN];		/* general-use file name */
	Xchar	not_here[SBUFLEN];		/* name of system not to xmit to */
	X
	X#ifndef ROOTID
	Xint	ROOTID;				/* special users id # */
	X#endif
	X
	Xchar	*DFLTNG = "general";		/* default newsgroup */
	XFILE	*infp;				/* input file-pointer */
	XFILE	*actfp;				/* active newsgroups file pointer */
	Xint	tty;				/* set if infp is a tty */
	Xchar	*PARTIAL = "dead.article";	/* place to save partial news */
	Xchar	*SHELL = "/bin/sh";		/* shell for inews to use	*/
	Xint	is_ctl;				/* true for a control message */
	Xchar	is_mod[NAMELEN];		/* contains newsgroup if moderated */
	Xint	is_mod_file_okay;		/* true if /usr/lib/news/moderators */
	X					/*  okays posting by the user */
SHAR_EOF
if test 1235 -ne "`wc -c < 'iextern.c'`"
then
	echo shar: error transmitting "'iextern.c'" '(should have been 1235 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ifuncs.c'" '(37308 characters)'
if test -f 'ifuncs.c'
then
	echo shar: will not over-write existing file "'ifuncs.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'ifuncs.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * ifuncs - functions used by inews.
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)ifuncs.c	2.69	12/1/87";
	X#endif /* SCCSID */
	X
	X#include "iparams.h"
	X
	Xextern long	localize();
	X
	X/*LINTLIBRARY*/
	X
	X/*
	X * Transmit this article to all interested systems.
	X */
	X
	X#ifdef u370
	Xstatic struct srec srec;
	X#endif /* u370 */
	X
	Xstatic struct hbuf h, hh;
	X
	X#ifdef MULTICAST
	X#define	MAXMCAST	20
	X#define	MAXMCS		10
	X
	Xstruct multicast {
	X	char mc_name[SBUFLEN];		/* "multi-cast" name */
	X	short mc_syscnt;
	X	char mc_tosys[MAXMCAST][SBUFLEN];
	X} mcast[MAXMCS];
	X
	Xstatic int mccount;
	X#endif /* MULTICAST */
	X
	Xlong lseek();
	X
	X#ifndef DBM
	Xchar *histfile();
	X#endif /* !DBM */
	X
	X#ifdef VMS
	X/*
	X * For VMS/Eunice there are no links: article was moved to firstbufname
	X * before broadcast is reached.  So we read it from there.
	X */
	Xextern char firstbufname[];
	X#endif
	X
	X#ifndef NFSCLIENT
	X#ifndef GENERICPATH
	X/*ARGSUSED*/
	X#endif /* !GENERICPATH */
	Xbroadcast(is_rnews)
	Xint is_rnews;
	X{
	X	register char *hptr;
	X	register char *sptr;
	X	register FILE *fp;
	X#ifndef u370
	X	struct srec srec;
	X#endif
	X	char sentbuf[LBUFLEN];
	X	int nsent = 0;
	X	char *sentsys;
	X#ifdef GENERICPATH
	X	int len;
	X#endif /* GENERICPATH */
	X
	X	/* h is a local copy of the header we can scribble on */
	X#ifdef VMS
	X	fp = xfopen (firstbufname, "r");
	X#else
	X	fp = xfopen(ARTICLE, "r");
	X#endif
	X	if (hread(&h, fp, TRUE) == NULL)
	X		xerror("Cannot reread article");
	X	(void) fclose(fp);
	X
	X	(void) strcpy(sentbuf, h.ident);
	X	(void) strcat(sentbuf, " sent to ");
	X	sentsys = index(sentbuf, '\0');
	X	nsent = 0;
	X	/* break path into list of systems. */
	X	hptr = h.path;
	X#ifdef GENERICPATH
	X	if (!is_rnews && 
	X		STRNCMP(PATHSYSNAME, h.path, (len = strlen(PATHSYSNAME))) == 0
	X		&& index(NETCHRS, h.path[len]))
	X		(void) strcpy(h.path, &(h.path[len+1]));
	X#endif /* GENERICPATH */
	X	sptr = hptr = h.path;
	X	while ((hptr=strpbrk(hptr, NETCHRS)) != NULL) {
	X		*hptr++ = '\0';
	X		sptr = hptr;
	X	}
	X	*sptr = '\0';
	X
	X#ifdef MULTICAST
	X	mccount = 0;
	X#endif /* MULTICAST */
	X
	X	/* loop once per system. */
	X	s_openr();
	X	while (s_read(&srec)) {
	X		char *dist = h.distribution;
	X		if (STRNCMP(srec.s_name, LOCALPATHSYSNAME, SNLN) == 0)
	X			continue;
	X		if (sptr = srec.s_nosend) {
	X			while (*sptr) {
	X				while (*sptr && *sptr != ',')
	X					sptr++;
	X				if (*sptr == ',')
	X					*sptr++ = '\0';
	X			}
	X			*++sptr = '\0';
	X		}
	X		hptr = h.path;
	X		while (*hptr != '\0') {
	X			if (STRNCMP(srec.s_name, hptr, SNLN) == 0)
	X				goto contin;
	X			if (sptr = srec.s_nosend) {
	X				while (*sptr != '\0') {
	X					if (STRNCMP(sptr, hptr, SNLN) == 0)
	X						goto contin;
	X					while (*sptr++)
	X						;
	X				}
	X			}
	X			while (*hptr++ != '\0')
	X				;
	X		}
	X		if (!ngmatch(h.nbuf, srec.s_nbuf))
	X			continue;
	X		if (*dist == '\0')
	X			dist = "world";
	X		if (!ngmatch(dist, srec.s_nbuf) && !ngmatch(srec.s_nbuf, dist))
	X			    continue;
	X
	X		if (nsent) {
	X			hptr = sentsys;
	X			while ((sptr = index(hptr, ',')) != NULL) {
	X				*sptr = '\0';
	X				if (STRCMP(hptr, srec.s_name) == 0) {
	X					*sptr = ',';
	X					goto contin;
	X				}
	X				*sptr++ = ',';
	X				for (hptr = sptr; isspace(*hptr); hptr++)
	X					;
	X			}
	X			if (STRCMP(hptr, srec.s_name) == 0)
	X				continue;
	X		}
	X		/* now we've found a system to send this article to */
	X#ifdef MULTICAST
	X		if (index(srec.s_flags, 'M')) {
	X			/* do a "multi-cast" transmit */
	X			register struct multicast *m;
	X
	X			if (strlen(srec.s_name) >= SBUFLEN ||
	X			    strlen(srec.s_xmit) >= SBUFLEN)
	X				xerror("system name too long for multicast");
	X			for (m = mcast; m < &mcast[mccount]; m++)
	X				if (STRCMP(srec.s_xmit, m->mc_name) == 0)
	X					break;
	X			if (m >= &mcast[MAXMCS])
	X				xerror("Too many multicasts");
	X			if (m == &mcast[mccount]) {
	X				mccount++;
	X				m->mc_syscnt = 0;
	X				strcpy(m->mc_name, srec.s_xmit);
	X			}
	X			if (m->mc_syscnt >= MAXMCAST)
	X				xerror("Too many systems for multicast");
	X			strcpy(m->mc_tosys[m->mc_syscnt++], srec.s_name);
	X		} else {
	X			register struct multicast *m;
	X			register char **yptr;
	X			char *sysptrs[MAXMCAST];
	X			int mc;
	X
	X			mc = 0;
	X			for (m = mcast; m < &mcast[mccount]; m++)
	X				if (STRCMP(m->mc_name, srec.s_name) == 0) {
	X					yptr = sysptrs;
	X					while (mc < m->mc_syscnt)
	X						*yptr++ = m->mc_tosys[mc++];
	X					break;
	X				}
	X#ifdef VMS
	X			if (!transmit(&srec, xfopen(firstbufname,"r"),
	X#else /* !VMS */
	X			if (!transmit(&srec, xfopen(ARTICLE,"r"),
	X#endif /* !VMS */
	X				(STRNCMP(h.nbuf, "to.", 3) != 0),
	X				sysptrs, mc))
	X				continue;
	X		}
	X#else /* !MULTICAST */
	X#ifdef VMS
	X		if (!transmit(&srec, xfopen(firstbufname, "r"),
	X#else /* !VMS */
	X		if (!transmit(&srec, xfopen(ARTICLE, "r"),
	X#endif /* !VMS */
	X			(STRNCMP(h.nbuf, "to.", 3) != 0),
	X			(char **) NULL, FALSE))
	X				continue;
	X#endif /* !MULTICAST */
	X		if (nsent)
	X			(void) strcat(sentbuf, ", ");
	X		(void) strcat(sentbuf, srec.s_name);
	X		nsent++;
	X	contin:;
	X	}
	X	if (nsent)
	X		log(sentbuf);
	X	s_close();
	X}
	X
	X/*
	X * Transmit file to system.
	X */
	X#define PROC 0004
	X#ifndef MULTICAST
	X/* ARGSUSED */
	X#endif /* !MULTICAST */
	Xtransmit(sp, ifp, maynotify, sysnames, mc)
	Xregister struct srec *sp;
	Xregister FILE *ifp;
	Xint maynotify;
	Xchar **sysnames;
	Xint mc;
	X{
	X	register FILE *ofp;
	X	register int c;
	X	register char *ptr;
	X	char TRANS[BUFLEN];
	X	char *argv[20];
	X	register int pid;
	X	extern char firstbufname[];
	X
	X/* A:	afmt: the other machine runs an A news, so we xmit in A format */
	X	int afmt = (index(sp->s_flags, 'A') != NULL);
	X/* B:	use B format (this is the default - don't use this letter elsewise). */
	X/* F:	append name to file */
	X	int appfile = (index(sp->s_flags, 'F') != NULL);
	X/* L:	local: don't send the article unless it was generated locally */
	X	int local = ((ptr = index(sp->s_flags, 'L')) != NULL);
	X/* H:	interpolate history line into command, use existing file */
	X	int history = (index(sp->s_flags, 'H') != NULL);
	X/* m:	moderated: only send if group is moderated */
	X	int sendifmoderated = (index(sp->s_flags, 'm') != NULL);
	X/* u:	unmoderated: only send if group is unmoderated */
	X	int sendifunmoderated = (index(sp->s_flags, 'u') != NULL);
	X/* M:	multi-cast: this is taken care of above, but don't reuse flag */
	X#ifdef MULTICAST
	X/* O:	multi-cast only, don't send article if not multicast hosts */
	X	int multisend = (index(sp->s_flags, 'O') != NULL);
	X#endif /* MULTICAST */
	X/* N:	notify: don't send the article, just tell him we have it */
	X	int notify = maynotify && (index(sp->s_flags, 'N') != NULL);
	X/* S:	noshell: don't fork a shell to execute the xmit command */
	X	int noshell = (index(sp->s_flags, 'S') != NULL);
	X/* U:	useexist: use the -c option to uux to use the existing copy */
	X	int useexist = (index(sp->s_flags, 'U') != NULL);
	X/* I:	append messageid to file. implies F flag */
	X	int appmsgid = maynotify && (index(sp->s_flags, 'I') != NULL);
	X
	X	if (notify)
	X		appfile = appmsgid = FALSE;
	X
	X	if (local && mode == PROC) {
	X		local = 0;
	X		while (isdigit(*++ptr))
	X			local = local * 10 + *ptr - '0';
	X		for (ptr = h.path; *ptr != '\0' && local >= 0; local--)
	X			while (*ptr++ != '\0')
	X				;
	X		if (local < 0) {
	X			(void) fclose(ifp);
	X			return FALSE;
	X		}
	X	}
	X
	X	/*
	X	** Do not transmit to system specified in -x flag.
	X	*/
	X	if (not_here[0] && STRCMP(not_here, sp->s_name) == 0) {
	X		(void) fclose(ifp);
	X		return FALSE;
	X	}
	X
	X#ifdef DEBUG
	X	printf("Transmitting to '%s'\n", sp->s_name);
	X#endif /* DEBUG */
	X
	X#ifdef MULTICAST
	X	if (multisend && mc == 0) {
	X		(void) fclose(ifp);
	X		return FALSE;
	X	}
	X#endif /* MULTICAST */
	X
	X	if ((sendifmoderated && is_mod[0] == '\0') ||
	X	    (sendifunmoderated && is_mod[0] != '\0')) {
	X		fclose(ifp);
	X		return FALSE;
	X	}
	X
	X	if (appmsgid || (!appfile && !useexist && !history)) {
	X		if (!hread(&hh, ifp, TRUE)) {
	X			logerr("Bad header, not transmitting %s re %s to %s",
	X				hh.ident, hh.title, sp->s_name);
	X			(void) fclose(ifp);
	X			return FALSE;
	X		}
	X		if (hh.nbuf[0] == '\0') {
	X			fprintf(stderr, "Article not subscribed to by %s\n", sp->s_name);
	X			(void) fclose(ifp);
	X			return FALSE;
	X		}
	X		(void) sprintf(TRANS, "%s/trXXXXXX", SPOOL);
	X	}
	X
	X	if (notify) {
	X		char oldid[50];
	X		(void) sprintf(hh.title, "ihave %s %s", hh.ident, PATHSYSNAME);
	X		(void) strcpy(hh.ctlmsg, hh.title);
	X		(void) strcpy(hh.numlines, "0");
	X		(void) sprintf(hh.nbuf, "to.%s.ctl", sp->s_name);
	X		(void) strcpy(oldid, hh.ident);
	X		getident(&hh);
	X		log("tell %s about %s, notif. id %s",
	X			sp->s_name, oldid, hh.ident);
	X	}
	X
	X	if (appfile || appmsgid) {
	X		if (firstbufname[0] == '\0') {
	X			extern char histline[];
	X			localize("junk");
	X			savehist(histline);
	X			xerror("No file name to xmit from");
	X		}
	X		if (sp->s_xmit[0] == '\0')
	X			sprintf(sp->s_xmit, "%s/%s%s", BATCHDIR, sp->s_name,
	X				appmsgid ? ".ihave" : "");
	X#ifdef LOGDIR
	X		(void) sprintf(TRANS, "%s/%s/%s", logdir(HOME), BATCHDIR, sp->s_xmit);
	X		ofp = fopen(TRANS, "a");
	X#else /* !LOGDIR */
	X		ofp = fopen(sp->s_xmit, "a");
	X#endif /* !LOGDIR */
	X		if (ofp == NULL)
	X			xerror("Cannot append to %s", sp->s_xmit);
	X		fprintf(ofp, "%s", appmsgid ? hh.ident : firstbufname);
	X#ifdef MULTICAST
	X		while (--mc >= 0)
	X			fprintf(ofp, " %s", *sysnames++);
	X#endif /* !MULTICAST */
	X		putc('\n', ofp);
	X		(void) fclose(ofp);
	X		(void) fclose(ifp);
	X		return TRUE;
	X	}
	X	else if (useexist) {
	X		if (firstbufname[0] == '\0')
	X			xerror("No file name to xmit from");
	X		if (*sp->s_xmit == '\0')
	X#ifdef UXMIT
	X			(void) sprintf(bfr, UXMIT, sp->s_name, firstbufname);
	X#else
	X			xerror("UXMIT not defined for U flag");
	X#endif
	X		else
	X#ifdef MULTICAST
	X			makeargs(bfr, sp->s_xmit, firstbufname, sysnames, mc);
	X#else
	X			(void) sprintf(bfr, sp->s_xmit, firstbufname);
	X#endif
	X		(void) fclose(ifp);
	X	} else if (history) {
	X		extern char histline[];
	X
	X		if (*sp->s_xmit == '\0')
	X			xerror("no xmit command with H flag");
	X#ifdef MULTICAST
	X		makeargs(bfr, sp->s_xmit, histline, sysnames, mc);
	X#else
	X		(void) sprintf(bfr, sp->s_xmit, histline);
	X#endif
	X	} else {
	X		MKTEMP(TRANS);
	X		ofp = xfopen(TRANS, "w");
	X		if (afmt) {
	X#ifdef OLD
	X			fprintf(ofp, "A%s\n%s\n%s!%s\n%s\n%s\n", oident(hh.ident), hh.nbuf, PATHSYSNAME,
	X				hh.path, hh.subdate, hh.title);
	X#else /* !OLD */
	X			logerr("Must have OLD defined to use A flag for xmit");
	X			return FALSE;
	X#endif /* !OLD */
	X		} else
	X			hwrite(&hh, ofp);
	X		if (!notify)
	X			while ((c = getc(ifp)) != EOF)
	X				putc(c, ofp);
	X		if (ferror(ofp))
	X			xerror("write failed on transmit");
	X		(void) fclose(ifp);
	X		(void) fclose(ofp);
	X		if (*sp->s_xmit == '\0')
	X			(void) sprintf(bfr, DFTXMIT, sp->s_name, TRANS);
	X		else
	X#ifdef MULTICAST
	X			makeargs(bfr, sp->s_xmit, TRANS, sysnames, mc);
	X#else /* !MULTICAST */
	X			(void) sprintf(bfr, sp->s_xmit, TRANS);
	X#endif /* !MULTICAST */
	X	}
	X
	X	/* At this point, the command to be executed is in bfr. */
	X	if (noshell) {
	X		if (pid = vfork())
	X			fwait(pid);
	X		else {
	X			(void) close(0);
	X			(void) open(TRANS, 0);
	X			ptr = bfr;
	X			for (pid = 0; pid < 19; pid++) {
	X				while (isspace(*ptr))
	X					*ptr++ = 0;
	X				argv[pid] = ptr;
	X				while (!isspace(*++ptr) && *ptr)
	X					;
	X				if (!*ptr)
	X					break;
	X			}
	X			argv[++pid] = 0;
	X			(void) setgid(gid);
	X			(void) setuid(uid);
	X			execvp(argv[0], argv);
	X			xerror("Can't execv %s", argv[0]);
	X		}
	X	} else {
	X		if (!history && sp->s_xmit[0] && !index(bfr, '<')) {
	X			char newcmd[LBUFLEN];
	X
	X			(void) sprintf(newcmd, "(%s) <%s", bfr,
	X			    useexist ? firstbufname : TRANS);
	X			system(newcmd);
	X		} else
	X			system(bfr);
	X	}
	X	if (!appfile && !useexist && !history)
	X		(void) unlink(TRANS);
	X	(void) fclose(ifp);
	X	return TRUE;
	X}
	X#endif /* !NFSCLIENT */
	X
	X#ifdef MULTICAST
	Xmakeargs(buf, cmd, arg2, sysargs, sac)
	Xchar *buf;
	Xchar *cmd;
	Xchar *arg2;
	Xregister char **sysargs;
	Xint sac;
	X{
	X	register char *p = cmd;
	X	register char *q;
	X	register ac = 0;
	X	register char *b = buf;
	X
	X	q = p;
	X	do {
	X		if (q = index(q, ' '))
	X			*q = '\0';
	X		if (index(p, '%')) {
	X			switch (++ac) {
	X			case 1:
	X				while (--sac >= 0) {
	X					sprintf(b, p, *sysargs++);
	X					b = index(b, '\0');
	X				}
	X				break;
	X			case 2:
	X				sprintf(b, p, arg2);
	X				b = index(b, '\0');
	X				break;
	X			default:
	X				if (q)
	X					*q = ' ';
	X				xerror("badly formed command: %s", cmd);
	X			}
	X		} else {
	X			strcpy(b, p);
	X			b = index(b, '\0');
	X		}
	X		if (q) {
	X			*q = ' ';
	X			p = q;
	X			while (isspace(*q))
	X				q++;
	X		}
	X	} while (q != NULL);
	X}
	X#endif /* MULTICAST */
	X
	X/*
	X * Return TRUE if we have seen this file before, else FALSE.
	X */
	Xhistory(hp)
	Xstruct hbuf *hp;
	X{
	X#ifdef DBM
	X	datum lhs, rhs;
	X	datum fetch();
	X#else /* !DBM */
	X	register FILE *hfp;
	X	register char *p;
	X#endif /* !DBM */
	X	char lcident[BUFLEN];
	X	extern char histline[];
	X
	X#ifdef DEBUG
	X	fprintf(stderr,"history(%s)\n", hp->ident);
	X#endif /* DEBUG */
	X	/*
	X	 * Make the article ID case insensitive.
	X	 */
	X	(void) strcpy(lcident, hp->ident);
	X	lcase(lcident);
	X
	X#ifndef NFSCLIENT
	X	idlock(lcident);
	X#ifdef DBM
	X	initdbm(ARTFILE);
	X	lhs.dptr = lcident;
	X	lhs.dsize = strlen(lhs.dptr) + 1;
	X	rhs = fetch(lhs);
	X	if (rhs.dptr) {
	X		idunlock();
	X		return(TRUE);
	X	}
	X#else /* !DBM */
	X	hfp = xfopen(histfile(lcident), "r");
	X	while (fgets(bfr, BUFLEN, hfp) != NULL) {
	X		p = index(bfr, '\t');
	X		if (p == NULL)
	X			p = index(bfr, '\n');
	X		if (p != NULL)	/* can happen if nulls in file */
	X			*p = 0;
	X		lcase(bfr);
	X
	X		if (STRCMP(bfr, lcident) == 0) {
	X			(void) fclose(hfp);
	X			idunlock();
	X#ifdef DEBUG
	X			fprintf(stderr,"history returns true\n");
	X#endif /* DEBUG */
	X			return TRUE;
	X		}
	X	}
	X	(void) fclose(hfp);
	X#endif /* !DBM */
	X#endif /* !NFSCLIENT */
	X	histline[0] = '\0';
	X	addhist(hp->ident);
	X	addhist("\t");
	X#ifndef NFSCLIENT
	X#ifdef DEBUG
	X	fprintf(stderr,"history returns false\n");
	X#endif
	X	return FALSE;
	X#else /* NFSCLIENT */
	X	return TRUE;
	X#endif /* NFSCLIENT */
	X}
	X
	Xchar histline[PATHLEN];
	X
	Xaddhist(msg)
	Xchar *msg;
	X{
	X	(void) strcat(histline, msg);
	X}
	X
	Xsavehist(hline)
	Xchar *hline;
	X{
	X	register FILE *hfp;
	X	register char *p;
	X#ifdef DBM
	X	long fpos;
	X#endif /* !DBM */
	X	char tmphline[PATHLEN];
	X
	X#ifndef DBM
	X	if (STRCMP((p = histfile(hline)), ARTFILE) != 0) {
	X	/* If the history subfile is accessible */
	X		if ((hfp = xfopen(p, "a")) != NULL ) { /* If we can append */
	X			fprintf(hfp, "%s\n", hline);   /* Append */
	X			(void) fclose(hfp);
	X		} else
	X			logerr("Unable to append to %s: %s", p, errmsg(errno));
	X	} else
	X#endif /* !DBM */
	X	{
	X	hfp = xfopen(ARTFILE, "a");
	X	(void) fseek(hfp, 0L, 2); /* Unisoft 5.1 doesn't seek to EOF on 'a' */
	X#ifdef DBM
	X	fpos = ftell(hfp);
	X#endif /* !DBM */
	X	fprintf(hfp, "%s\n", hline);
	X	(void) fclose(hfp);
	X	}
	X#ifdef DBM
	X	{
	X	datum lhs, rhs;
	X	/* We assume that history has already been called, calling dbminit. */
	X	strcpy(tmphline,hline);
	X	p = index(tmphline, '\t');
	X	if (p)
	X		*p = 0;
	X	lcase(tmphline);
	X	lhs.dptr = tmphline;
	X	lhs.dsize = strlen(lhs.dptr) + 1;
	X	rhs.dptr = (char *)&fpos;
	X	rhs.dsize = sizeof fpos;
	X	store(lhs, rhs);
	X	}
	X#endif /* DBM */
	X	idunlock();
	X}
	X
	X/*
	X * Save partial news.
	X */
	X/* ARGSUSED */
	Xnewssave(fd, dummy)
	XFILE *fd;
	Xchar *dummy;
	X{
	X	register FILE *tofd, *fromfd;
	X	char sfname[BUFLEN];
	X	register int c;
	X	time_t tim;
	X
	X	if (fd == NULL)
	X		fromfd = xfopen(INFILE, "r");
	X	else
	X		fromfd = fd;
	X	(void) umask(savmask);
	X	(void) setgid(gid);
	X	(void) setuid(uid);
	X
	X	(void) sprintf(sfname, "%s/%s", userhome, PARTIAL);
	X	if ((tofd = fopen(sfname, "a")) == NULL)
	X		xerror("Cannot save partial news in %s", sfname);
	X	(void) time(&tim);
	X	fprintf(tofd, "----- News saved at %s\n", arpadate(&tim));
	X	while ((c = getc(fromfd)) != EOF)
	X		putc(c, tofd);
	X	(void) fclose(fromfd);
	X	(void) fclose(tofd);
	X	printf("News saved in %s\n", sfname);
	X	xxit(1);
	X}
	X
	X/*
	X * Handle dates in header.
	X */
	X
	Xdates(hp)
	Xstruct hbuf *hp;
	X{
	X	time_t edt;
	X
	X	if (*hp->subdate) {
	X		if (cgtdate(hp->subdate) < 0) {
	X			error("Cannot parse submittal date '%s'", hp->subdate);
	X		}
	X	} else {
	X		(void) time(&edt);
	X		(void) strcpy(hp->subdate, arpadate(&edt));
	X	}
	X}
	X
	X#define LOCKSIZE	128
	Xchar lockname[LOCKSIZE];
	X
	Xidlock(str)
	Xchar *str;
	X{
	X	register int i;
	X	register char *cp, *scp;
	X	char tempname[LOCKSIZE];
	X	time_t now;
	X	struct stat sbuf;
	X	extern int errno;
	X#ifdef	VMS
	X	int fd;
	X/* The name here is because of the peculiar properties of version numbers
	X * in Eunice.  We eliminate any troublesome characters also.
	X */
	X	(void) sprintf(lockname, "/tmp/%.10s.l.1", str);
	X	for (cp = lockname; *cp; cp++)
	X		if (*cp == '/' || *cp == '[' || *cp == ']') *cp = '.';
	X	while ((fd = creat(lockname, 0444)) < 0) {
	X#else /* !VMS */
	X	(void) strcpy(tempname, "/tmp/LTMP.XXXXXX");
	X	MKTEMP(tempname);
	X	(void) strcpy(lockname, "/tmp/L");
	X	i = strlen(lockname);
	X	cp = &lockname[i];
	X	scp = str - 1;
	X	while (i++ < LOCKSIZE && *++scp != '\0')
	X		if (*scp == '/')	/* slash screws up the open */
	X			*cp++ = '.';
	X		else
	X			*cp++ = *scp;
	X	*cp = '\0';
	X#ifdef FOURTEENMAX
	X	lockname[5 /* /tmp/ */ + 14] = '\0';
	X#endif
	X	i = creat(tempname, 0666);
	X	if (i < 0)
	X		xerror("Cannot creat %s: errno %d", tempname, errno);
	X	(void) close(i);
	X	while (link(tempname, lockname)) {
	X#endif /* !VMS */
	X		(void) time(&now);
	X		if (stat(lockname, &sbuf) < 0)
	X			xerror("Directory permission problem in /tmp");
	X
	X		if (sbuf.st_mtime + 10*60 < now) {
	X			(void) unlink(lockname);
	X			logerr("Article %s locked up", str);
	X			break;
	X		}
	X		log("waiting on lock for %s", lockname);
	X		sleep((unsigned)60);
	X	}
	X#ifdef VMS
	X	(void) close(fd);
	X#endif
	X	(void) unlink(tempname);
	X}
	X
	Xidunlock()
	X{
	X	(void) unlink(lockname);
	X}
	X
	X/*
	X * Put a unique name into header.ident.
	X */
	Xgetident(hp)
	Xstruct hbuf *hp;
	X{
	X	long seqn;
	X	register FILE *fp;
	X	extern char *mydomain();
	X
	X	lock();
	X	fp = xfopen(SEQFILE, "r");
	X	(void) fgets(bfr, BUFLEN, fp);
	X	(void) fclose(fp);
	X	seqn = atol(bfr) + 1;
	X/*
	X * For Eunice, this breaks if SEQFILE is not in Unix format.
	X */
	X	fp = xfopen(SEQFILE, "r+w");
	X	fprintf(fp, "%ld\n", seqn);
	X	(void) fclose(fp);
	X	unlock();
	X	(void) sprintf(hp->ident, "<%ld@%s>", seqn, LOCALSYSNAME);
	X}
	X
	X/*
	X * Check that header.nbuf contains only valid newsgroup names;
	X * exit with error if not valid.
	X */
	Xngfcheck(user, isproc, is_mod_init)
	Xchar	*user;
	X{
	X	register FILE *	f;
	X	register char *	cp;
	X	register int	i, j;
	X	register int	ngcount, okcount, dorecheck;
	X	register int	pass;
	X	char *		ngs[sizeof header.nbuf / 2];
	X	char *		ngsbug[sizeof header.nbuf / 2];
	X	char		uses[sizeof header.nbuf / 2];
	X	char		tbuf[sizeof header.nbuf];
	X	char		abuf[BUFLEN];
	X
	X/* uses values
	X**  0 - haven't seen the newsgroup name anyplace
	X**  1 - write newsgroup name back into Newsgroup: line
	X**  2 - exact newsgroup name found in active or aliases file
	X**  3 - newsgroup name found as prefix in bugs file (but not #2)
	X**  4 - (2) plus name in bugs file
	X*/
	X
	X#define NGUNSEEN 0
	X#define NGOK 1
	X#define NGALIAS 2
	X#define NGBUGS 3
	X#define NGABUGS 4
	X
	X	ngcount = 0;
	X	/*
	X	** Split header.nbuf into constituent newsgroups.
	X	** Zap "local" newsgroups of articles from remote sites.
	X	*/
	X	cp = tbuf;
	X	(void) strcpy(cp, header.nbuf);
	X	for ( ; ; ) {
	X		while (*cp == NGDELIM || *cp == ' ')
	X			++cp;
	X		if (*cp == '\0')
	X			break;
	X		ngs[ngcount] = cp;
	X		ngsbug[ngcount] = (char *) NULL;
	X		uses[ngcount] = NGUNSEEN;
	X		do {
	X			++cp;
	X		} while (*cp != '\0' && *cp != NGDELIM && *cp != ' ');
	X		if (*cp != '\0')
	X			*cp++ = '\0';
	X		/*
	X		** Check for local only distribution on incoming
	X		** newsgroups.  This might occur if someone posted to
	X		** general,net.unix
	X		*/
	X		if (isproc && index(ngs[ngcount], '.') == NULL &&
	X			index(header.nbuf, '.') != NULL) {
	X				logerr("Local group %s removed",
	X					ngs[ngcount]);
	X				continue;
	X		}
	X		uses[ngcount] = NGOK;	/* it should go in "Newsgroups" line */
	X		++ngcount;
	X	}
	X	/*
	X	** Check groups against active file.
	X	*/
	Xrecheck:
	X	dorecheck = okcount = 0;
	X	is_mod[0] = '\0';
	X	is_mod_file_okay = is_mod_init;
	X	rewind(actfp); clearerr(actfp);
	X	while (okcount < ngcount && fgets(bfr, BUFLEN, actfp) == bfr) {
	X		if ((cp = index(bfr, ' ')) == NULL)
	X			continue;	/* strange line in input! */
	X		*cp = '\0';
	X		for (i = 0; i < ngcount; ++i)
	X			if (STRCMP(bfr, ngs[i]) == NGUNSEEN) { /* localize? */
	X				/* newsgroup 12345 12345 X */
	X				/*  cp +    01234567890123 */
	X				if (!isproc && cp[13]  == 'n')
	X					uses[i] = NGOK;
	X				else {
	X					if (uses[i] < NGALIAS)
	X						uses[i] = NGALIAS;
	X					if (cp[13] == 'm') {
	X						strcpy(is_mod, bfr);
	X						if (!is_mod_file_okay)
	X						     is_mod_file_okay =
	X						       mod_file_okay(user,bfr);
	X					}
	X					++okcount;
	X				}
	X			}
	X	}
	X	/*
	X	** See what groups we can find in the bugs file
	X	*/
	X	if ((f = fopen(BUGFILE, "r")) != NULL) {
	X		while (fgets(bfr, BUFLEN, f) == bfr) {
	X			if (bfr[0] == '#')
	X				continue;
	X			cp = index(bfr, '\n');
	X			*cp = '.';
	X			for (i = 0; i < ngcount; ++i) {
	X				register int bfrlen = strlen(bfr);
	X				register int ngslen = strlen(ngs[i]);
	X				if (uses[i] == NGBUGS || uses[i] == NGABUGS)
	X					continue;
	X				if (PREFIX(ngs[i], bfr) ||
	X				    (bfrlen-1 == ngslen &&
	X				     !STRNCMP(ngs[i], bfr, ngslen))) {
	X					if (uses[i] == NGALIAS)
	X						uses[i] = NGABUGS;
	X					else {
	X						bfr[bfrlen-1] = '\0';
	X						cp = "Bug group %s -> %s [ok]";
	X						log(cp, ngs[i], bfr);
	X						if (ngsbug[i] == (char *) NULL)
	X							ngsbug[i] = ngs[i];
	X						ngs[i] = AllocCpy(bfr);
	X						bfr[bfrlen-1] = '.';
	X						uses[i] = NGBUGS;
	X						okcount++;
	X						dorecheck++;
	X					}
	X				}
	X			}
	X		}
	X		(void) fclose(f);
	X	}
	X
	X#ifdef ALWAYSALIAS
	X	okcount = 0;
	X#endif /* ALWAYSALIAS */
	X	/*
	X	** Handle groups absent from active and bug_groups files.
	X	*/
	X	if (okcount < ngcount) {
	X		/*
	X		** See if remaining groups are in our alias list.
	X		*/
	X		f = xfopen(ALIASES, "r");
	X		while (okcount < ngcount &&
	X		     fscanf(f, "%s %s%*[^\n]", abuf, bfr) == 2) {
	X			if (abuf[0] == '#')
	X				continue;
	X			for (i = 0; i < ngcount; ++i) {
	X#ifndef ALWAYSALIAS
	X				if (uses[i] > NGOK && uses[i] != NGBUGS)
	X					continue;
	X#endif /* ALWAYSALIAS */
	X				cp = (char *) NULL;
	X				if (uses[i] == NGBUGS)
	X				    if (STRCMP(ngsbug[i], abuf) == 0)
	X					cp = "Aliased newsgroup %s to %s";
	X				if (cp == (char *) NULL) {
	X			           if (STRCMP(ngs[i], abuf) != 0)
	X					continue;
	X			           if (isproc)
	X					cp = "Aliased newsgroup %s to %s";
	X			           else
	X					cp = "Please change %s to %s";
	X				}
	X				logerr(cp, abuf, bfr);
	X				if (uses[i] == NGBUGS) {
	X					free(ngs[i]);
	X					ngsbug[i] = (char *) NULL;
	X				}
	X				ngs[i] = AllocCpy(bfr);
	X				++dorecheck;
	X#ifdef ALWAYSALIAS
	X				if (uses[i] != NGBUGS)
	X#endif /* ALWAYSALIAS */
	X					++okcount;
	X				uses[i] = NGALIAS;
	X			}
	X		}
	X		(void) fclose(f);
	X		for (i = 0; i < ngcount; ++i) {
	X			if (uses[i] > NGOK)
	X				continue;
	X			if (isproc)
	X				log("Unknown newsgroup %s not localized",
	X					ngs[i]);
	X			else
	X				logerr("Unknown newsgroup %s", ngs[i]);
	X#ifdef ALWAYSALIAS
	X			++okcount;	/* so we know to exit below */
	X		}
	X		if (!isproc && okcount > 0)
	X#else /* !ALWAYSALIAS */
	X		}
	X		if (!isproc)
	X#endif /* !ALWAYSALIAS */
	X			newssave(infp, (char *) NULL);
	X	}
	X
	X	/*
	X	 * Unfortunately, if you alias an unmoderated group to a
	X	 * moderated group, you must recheck the active file to see
	X	 * if the new group is moderated. Rude but necessary.
	X	 */
	X
	X	if (dorecheck)
	X		goto recheck;
	X
	X	/*
	X	** Zap duplicates.
	X	*/
	X	for (i = 0; i < ngcount - 1; ++i) {
	X		if (uses[i] == NGUNSEEN)
	X			continue;
	X		for (j = i + 1; ((j < ngcount) && (uses[i] != NGUNSEEN)); ++j){
	X			register int kill = -1;
	X			register int keep = -1;
	X			if (uses[j] == NGUNSEEN)
	X				continue;
	X			if (uses[i] == NGABUGS || uses[j] == NGABUGS) {
	X				register int k = i;
	X				register int l = j;
	X				if (uses[i] == NGABUGS && uses[j] == NGABUGS) {
	X					if (strlen(ngs[j]) < strlen(ngs[i])) {
	X						k = j;
	X						l = i;
	X					}
	X				} else if (uses[i] == NGABUGS) {
	X					k = j;
	X					l = i;
	X				}
	X				strcpy(bfr, ngs[k]);
	X				strcat(bfr, ".");
	X				if (PREFIX(ngs[l], bfr)) {
	X					kill = k;
	X					keep = l;
	X					if (uses[k] != NGBUGS ||
	X					    ngsbug[l] == (char *) NULL)
	X						logerr("Duplicate %s removed",
	X							ngs[k]);
	X				}
	X			}
	X			if (kill < 0) {
	X			if (STRCMP(ngs[i], ngs[j]) != 0)
	X					continue;
	X				keep = i;
	X				kill = j;
	X				if (uses[j] != NGBUGS)
	X					logerr("Duplicate %s removed", ngs[j]);
	X				if (uses[i] < uses[j])
	X					uses[i] = uses[j];
	X			}
	X			if (kill >= 0) {
	X				if (uses[kill] == NGBUGS) {
	X					if (ngsbug[keep] == (char *) NULL)
	X						ngsbug[keep] = ngsbug[kill];
	X					else if (ngsbug[kill] != (char*) NULL){
	X						sprintf(bfr, "%s,%s",
	X							ngsbug[keep],
	X							ngsbug[kill]);
	X						if (ngsbug[keep] < tbuf || ngsbug[keep] > &tbuf[sizeof tbuf - 1])
	X							free(ngsbug[keep]);
	X						ngsbug[keep] = AllocCpy(bfr);
	X					}
	X				}
	X				uses[kill] = NGUNSEEN;
	X			}
	X		}
	X	}
	X	for (pass = 1; pass <= 2; ++pass) {
	X		register int	avail;
	X
	X		if (pass == 1) {
	X			/*
	X			** Rewrite header.nbuf.
	X			*/
	X			cp = header.nbuf;
	X			avail = sizeof header.nbuf;
	X		} else {
	X			/*
	X			** Fill in nbuf.
	X			*/
	X			cp = nbuf;
	X			avail = sizeof nbuf;
	X		}
	X		for (i = 0; i < ngcount; ++i) {
	X			if (uses[i] < pass)
	X				continue;
	X			if (pass == 1)
	X				j = strlen(ngsbug[i] == (char *) NULL ? ngs[i] : ngsbug[i]);
	X			else
	X				j = strlen(ngs[i]);
	X			if (j + 2 > avail) {
	X				logerr("Redone Newsgroups too long");
	X				break;
	X			}
	X			if (pass == 1)
	X				(void) strcpy(cp,
	X					ngsbug[i] == (char *) NULL ? ngs[i] : ngsbug[i]);
	X			else
	X				(void) strcpy(cp, ngs[i]);
	X			cp += j;
	X			*cp++ = (pass == 1) ? NGDELIM : '\0';
	X			avail -= (j + 1);
	X		}
	X		if (pass == 1) {
	X			if (cp == header.nbuf)
	X				*cp = '\0';
	X			else	*(cp - 1) = '\0';
	X		} else	*cp = '\0';
	X	}
	X	/*
	X	** Free aliases.
	X	*/
	X	for (i = 0; i < ngcount; ++i) {
	X		if (ngs[i] < tbuf || ngs[i] > &tbuf[sizeof tbuf - 1])
	X			free(ngs[i]);
	X		if (ngsbug[i] != NULL &&
	X		    (ngsbug[i] < tbuf || ngsbug[i] > &tbuf[sizeof tbuf - 1]))
	X			free(ngsbug[i]);
	X	}
	X	return nbuf[0] == '\0';
	X
	X#undef NGUNSEEN 0
	X#undef NGOK 1
	X#undef NGALIAS 2
	X#undef NGBUGS 3
	X#undef NGABUGS 4
	X
	X}
	X
	X/* Check $LIB/moderators to see if user is listed as a known moderator
	X * of the newsgroup in ngname..... return TRUE if user is ok.
	X */
	X
	Xmod_file_okay(user, ngname)
	Xchar	*user, *ngname;
	X{
	X	FILE *mfd;
	X	char *grplist = NULL;
	X	char *p, *getgrplist();
	X	int ret = FALSE;
	X	char mfn[BUFLEN], mgrp[BUFLEN], mlist[LBUFLEN];
	X
	X	sprintf(mfn, "%s/%s", LIB, "moderators");
	X	mfd = fopen(mfn, "r");
	X	if (mfd == NULL)
	X		return FALSE;
	X	while ((!ret) && fscanf(mfd, "%[^:]:%s\n", mgrp, mlist) != EOF) {
	X		if (feof(mfd))
	X			break;
	X		if (mgrp[0] == '#')
	X			continue;
	X		if (!STRCMP(ngname, mgrp)) {
	X			while (*(p = ((p = rindex(mlist, ',')) ? p : mlist ))
	X			      && (ret == FALSE)) {
	X					if (*p == ',')
	X						*p++ = '\0';
	X					if (*p == '\\') {
	X						*p++ = '\0';
	X						if (!grplist)
	X							grplist = getgrplist(user);
	X						if (ngmatch(p,grplist))
	X							ret = TRUE;
	X					} else if (!STRCMP(p, user))
	X						ret = TRUE;
	X					*p = '\0';
	X			}
	X		}
	X	}
	X	fclose(mfd);
	X	return ret;
	X}
	X
	X/*
	X * Figure out who posted the article (which is locally entered).
	X * The results are placed in the header structure hp.
	X */
	Xgensender(hp, logname)
	Xstruct hbuf *hp;
	Xchar *logname;
	X{
	X	register char *fn, *p;
	X	char buf[BUFLEN];
	X	char *fullname(), *getenv();
	X	int fd, n;
	X	extern char *mydomain();
	X
	X	if ((fn = getenv("NAME")) == NULL) {
	X		(void) sprintf(buf, "%s/%s", userhome, ".name");
	X		if ((fd = open(buf, 0)) >= 0) {
	X			n = read(fd, buf, sizeof buf);
	X			(void) close(fd);
	X			if (n > 0 && buf[0] >= 'A') {
	X				for (p = fn = buf; *p; p++)
	X					if (*p < ' ')
	X						*p = '\0';
	X			}
	X		}
	X	}
	X
	X	if (fn == NULL)
	X		fn = fullname(logname);
	X
	X	(void) sprintf(hp->path, "%s", logname);
	X	(void) sprintf(hp->from, "%s@%s (%s)", logname, FROMSYSNAME, fn);
	X}
	X
	X/*
	X * Trap interrupts.
	X */
	Xonsig(n)
	Xint n;
	X{
	X	static int numsigs = 0;
	X	/*
	X	 * Most UNIX systems reset caught signals to SIG_DFL.
	X	 * This bad design requires that the trap be set again here.
	X	 * Unfortunately, if the signal recurs before the trap is set,
	X	 * the program will die, possibly leaving the lock in place.
	X	 */
	X	if (++numsigs > 100) {
	X		xerror("inews ran away looping on signal %d", n);
	X	}
	X	(void) signal(n, onsig);
	X	SigTrap = n;
	X}
	X
	X/*
	X * If the stdin begins with "#" the input is some kind of batch.  if
	X * the first line is:
	X *	#!cunbatch
	X * or
	X *	#!c7unbatch
	X * then fork off a pipe to do the either a
	X *	"compress -d"
	X * or a
	X *	"decode | compress -d"
	X * and check their output for more batch headers.  They probably
	X * contain a batch format that looks like this:
	X *	#! rnews 1234
	X *	article with 1234 chars
	X *	#! rnews 4321
	X *	article with 4321 chars
	X * If so, then for each article, copy the indicated number of chars into
	X * a temp file, fork a copy of ourselves, make its input the temp file,
	X * and allow the copy to process the article.  This avoids an exec of
	X * rnews for each article.
	X */
	X
	Xcheckbatch()
	X{
	X	int c;
	X	char *cp;
	X
	X	setbuf(infp, (char *)NULL);
	X	while ((c = getc(infp)) == '#') {
	X		/* some kind of batch, investigate further */
	X		int i;
	X		char cmd[BUFLEN];
	X		cmd[0] = c;
	X		fgets(cmd + 1, BUFLEN, infp);
	X		if (strncmp(cmd, "#! cunbatch", 11) == 0) {
	X			(void) sprintf(cmd, "%s/compress", LIB);
	X			input_pipe(cmd, "compress", "-d", (char *) 0);
	X			setbuf(infp, (char *)NULL);
	X			continue;	/* look for the #! rnews */
	X		} else if (strncmp(cmd, "#! c7unbatch", 12) == 0) {
	X			(void) sprintf(cmd, "%s/decode | %s/compress -d",
	X				LIB, LIB);
	X			input_pipe("/bin/sh", "news-unpack", "-c", cmd);
	X			setbuf(infp, (char *)NULL);
	X			continue;	/* look for the #! rnews */
	X		} else if (strncmp(cmd, "#! rnews ", 9) == 0 ||
	X			strncmp(cmd, "! rnews ", 8) == 0) {
	X			/* instead of execing unbatch do it ourselves */
	X			register int fd, rc, wc;
	X			int piped[2];
	X			register long size, asize;
	X			char *tfilename;
	X			int pid, wpid, exstat;
	X#define CPBFSZ 8192
	X			char buf[CPBFSZ];
	X
	X			tfilename = 0;
	X			cp = malloc((unsigned)BUFSIZ);
	X			if (cp != NULL)
	X				setbuf(infp, cp);
	X			do {
	X				while (STRNCMP(cmd, "#! rnews ", 9)) {
	X					fprintf(stderr, "out of sync, skipping %s\n", cmd);
	X					if (fgets(cmd, BUFLEN, infp) == NULL)
	X						exit(0);
	X				}
	X				asize = atol(cmd + 9);
	X				if (asize <= 0)
	X					xerror("checkbatch: bad batch count %ld", asize);
	X				fd = -1;
	X				size = asize;
	X				do {
	X					if (size > CPBFSZ)
	X						rc = CPBFSZ;
	X					else
	X						rc = size;
	X					rc = fread(buf, 1, rc, infp);
	X					if (rc <= 0)
	X						break;
	X					if (fd < 0) {
	X						if (rc == asize)
	X							break;	/* fits in buffer */
	X						if (!tfilename) {
	X							tfilename = "/tmp/unbnewsXXXXXX";
	X							MKTEMP(tfilename);
	X						}
	X						if ((fd = creat(tfilename, 0666)) < 0) {
	X							fprintf(stderr, "rnews: creat of \"%s\" failed",
	X								tfilename);
	X							perror(" ");
	X							exit(1);
	X						}
	X					}
	X					wc = write(fd, buf, rc);	/* write to temp file */
	X					if (wc != rc) {
	X						fprintf(stderr, "write of %d to \"%s\" returned %d",
	X							rc, tfilename, wc);
	X						perror(" ");
	X						exit(1);
	X					}
	X					size -= rc;
	X				} while (size > 0);
	X				if (fd >= 0)
	X					(void) close(fd);
	X
	X				/*
	X				 * If we got a truncated batch, don't process
	X				 * the last article; it will probably be
	X				 * received again. 
	X				 */
	X				if ((rc < asize) && (size > 0))
	X					break;
	X
	X				/*
	X				 * This differs from the old unbatcher in
	X				 * that we don't exec rnews, mainly because
	X				 * we ARE rnews.  Instead we fork off a copy
	X				 * of ourselves for each article and allow it
	X				 * to process. 
	X				 */
	X				if (rc == asize) {
	X					/*
	X					 * article fits in buffer, use a pipe
	X					 * instead of a temporary file. 
	X					 */
	X					if (pipe(piped) != 0)
	X						xerror("checkbatch: pipe() failed");
	X				}
	X				while ((pid = fork()) == -1) {
	X					fprintf(stderr, "fork failed, waiting...\r\n");
	X					sleep(60);
	X				}
	X				if (pid == 0) {
	X					if (rc == asize) {
	X						/* article fits in buffer
	X						 * make the output of the
	X						 * pipe for STDIN 
	X						 */
	X						(void) fclose(infp);
	X						/* redundant but why not */
	X						(void) close(0);
	X						if ((i = dup(piped[0])) != 0)
	X							xerror("dup() returned %d, should be 0", i);
	X						(void) close(piped[0]);
	X						(void) close(piped[1]);
	X						infp = fdopen(0, "r");
	X					} else	/* supstitute temp file as
	X						 * input */
	X						freopen(tfilename, "r", infp);
	X					return;	/* from checkbatch as if
	X						 * normal article */
	X				}
	X				/* parent of fork */
	X				if (rc == asize) {
	X					/* article fits in buffer */
	X					wc = write(piped[1], buf, rc);
	X					if (wc != rc) {
	X						fprintf(stderr, "write of %d to pipe returned %d",
	X							rc, wc);
	X						perror("rnews: write");
	X						exit(1);
	X					}
	X					(void) close(piped[0]);
	X					(void) close(piped[1]);
	X				}
	X				while ((wpid = wait(&exstat)) >= 0 && wpid != pid);
	X				if (tfilename)
	X					(void) unlink(tfilename);
	X			} while (fgets(cmd, BUFLEN, infp) != NULL);
	X			exit(0);/* all done */
	X
	X		} else {
	X			docmd(cmd);
	X			xxit(0);
	X		}
	X	}			/* while a batch */
	X	cp = malloc((unsigned)BUFSIZ);
	X	if (cp != NULL)
	X		setbuf(infp, cp);
	X	if (c != EOF)
	X		(void) ungetc(c, infp);
	X	clearerr(infp);
	X}
	X
	X/*
	X * The input requires some processing so fork and exec the indicated command
	X * with its output piped to our input. 
	X */
	Xstatic 
	Xinput_pipe(cmd, arg0, arg1, arg2)
	Xchar *cmd, *arg0, *arg1, *arg2;
	X{
	X	int i, pid;
	X	int piped[2];
	X
	X	if (pipe(piped) != 0) {
	X		perror("checkbatch: pipe() failed");
	X		exit(1);
	X	}
	X	fflush(stdout);
	X	while ((pid = vfork()) == -1) {
	X		perror("checkbatch: fork failed, waiting");
	X		sleep(60);
	X	}
	X	if (pid == 0) {		/* child process */
	X		/*
	X		 * setup a pipe such that the exec'ed process will read our
	X		 * input file and write to the pipe 
	X		 */
	X		(void) close(1);
	X		if ((i = dup(piped[1])) != 1)
	X			xerror("dup() returned %d, should be 1", i);
	X		(void) close(piped[0]);
	X		(void) close(piped[1]);
	X		execl(cmd, arg0, arg1, arg2, (char *) 0);
	X		perror("checkbatch");
	X		xerror("Unable to exec %s to unpack news.", cmd);
	X	} else {		/* parent process */
	X		/* make the output of the pipe for STDIN */
	X		(void) fclose(infp);
	X		(void) close(0);
	X		if ((i = dup(piped[0])) != 0)
	X			xerror("dup() returned %d, should be 0", i);
	X		(void) close(piped[0]);
	X		(void) close(piped[1]);
	X		/*
	X		 * there should be a way to clear any buffered input and just
	X		 * replace file descriptor 0 but I can't find a portable way. 
	X		 */
	X		infp = fdopen(0, "r");
	X	}
	X}
	X
	X#define MAXARGS 32
	X
	Xdocmd(p)
	Xregister char *p;
	X{
	X	char *args[MAXARGS];
	X	register char **ap = args;
	X	char path[BUFSIZ];
	X	char *rindex(), *cp;
	X
	X	while (*p && !isspace(*p))		/* skip leading #! crud */
	X		p++;
	X
	X	while (isspace(*p))
	X		p++;
	X
	X	while (*p != '\0') {
	X		*ap++ = p;
	X		if (ap >= &args[MAXARGS]) {
	X			logerr("inews: unbatch: Too many args to %s", args[0]);
	X			exit(2);
	X		}
	X		while (*p && !isspace(*p))
	X			p++;
	X		if (*p)
	X			*p++ = '\0';
	X		while (isspace(*p))
	X			p++;
	X	}
	X	*ap = (char *)0;
	X
	X	if (ap == args) {
	X		logerr("inews: unbatch: no command to execute");
	X		exit(2);
	X	}
	X
	X	/* strip off any leading pathname in case someone gets tricky */
	X	cp = rindex(args[0], '/');
	X	if (cp++ == NULL)
	X		cp = args[0];
	X
	X# ifdef HOME
	X	sprintf(path, "%s/%s/%s", logdir(HOME), LIBDIR, cp);
	X# else /* !HOME */
	X	sprintf(path, "%s/%s", LIBDIR, cp);
	X# endif /* HOME */
	X
	X	/*
	X	 * "path" is absolute, no searching is needed,  we use
	X	 * 'execvp' solely so that sh scripts will be handled
	X	 */
	X	(void) execvp(path, args);
	X	perror(path);
	X	xxit(2);
	X}
	X
	X/*
	X *	Exit and cleanup.
	X */
	Xxxit(status)
	Xint status;
	X{
	X	(void) unlink(INFILE);
	X	(void) unlink(ARTICLE);
	X	while (lockcount > 0)
	X		unlock();
	X	idunlock();
	X	exit(status);
	X}
	X
	Xrwaccess(fname)
	Xchar *fname;
	X{
	X	int fd;
	X
	X	fd = open(fname, 2);
	X	if (fd < 0)
	X		return 0;
	X	(void) close(fd);
	X	return 1;
	X}
	X
	Xexists(fname)
	Xchar *fname;
	X{
	X	int fd;
	X
	X	fd = open(fname, 0);
	X	if (fd < 0)
	X		return 0;
	X	(void) close(fd);
	X	return 1;
	X}
	X
	Xint	lockcount = 0;			/* no. of times we've called lock */
	X
	X#ifdef	VMS
	X
	X#define	SUBLOCK	"/tmp/netnews.lck.1"
	X
	X/*
	X * Newsystem locking.
	X * These routines are different for VMS because we can not
	X * effectively simulate links, and VMS supports multiple
	X * version numbers of files
	X */
	Xlock()
	X{
	X	register int i;
	X	register int fd;
	X
	X	if (lockcount++ == 0) {
	X		i = DEADTIME;
	X		while ((fd = creat(SUBLOCK, 0444)) < 0) {
	X			if (--i < 0) {
	X				(void) unlink(SUBLOCK);
	X				logerr("News system locked up");
	X			}
	X			if (i < -3)
	X				xerror("Unable to unlock news system");
	X			sleep((unsigned)1);
	X		}
	X		(void) close(fd);
	X	}
	X}
	X
	Xunlock()
	X{
	X	if (--lockcount == 0)
	X		(void) unlink(SUBLOCK); 
	X}
	X
	X#else /* !VMS */
	X
	X/*
	X * Newsystem locking.
	X */
	X
	X#if defined(BSD4_2) || defined(LOCKF)
	X#ifdef LOCKF
	X#include <unistd.h>
	X#else /* !LOCKF */
	X#include <sys/file.h>
	X#endif /* !LOCKF */
	Xstatic int LockFd = -1;
	Xlock()
	X{
	X	LockFd = open(SUBFILE, 2);
	X	if (LockFd < 0)
	X		logerr("Can't open(\"%s\", 2) to lock", SUBFILE);
	X	/* This will sleep until the other program releases the lock */
	X	/* We may need to alarm out of this, but I don't think so */
	X#ifdef LOCKF
	X	if (lockf(LockFd, F_LOCK, 0L) < 0)
	X#else
	X	if (flock(LockFd, LOCK_EX) < 0)
	X#endif
	X		xerror("Can't get lock on %s: %s", SUBFILE, errmsg(errno));
	X}
	X
	Xunlock()
	X{
	X	(void) close(LockFd);
	X}
	X#else /* !BSD4_2 */
	Xlock()
	X{
	X	register int i;
	X	extern int errno;
	X
	X	if (lockcount++ == 0) {
	X		i = DEADTIME;
	X		while (link(SEQFILE, LOCKFILE)) {
	X			if (errno != EEXIST)
	X				break;
	X			if (--i < 0)
	X				xerror("News system locked up");
	X			sleep((unsigned)1);
	X		}
	X	}
	X}
	X
	Xunlock()
	X{
	X	if (--lockcount == 0)
	X		(void) unlink(LOCKFILE);
	X}
	X#endif /* !BSD4_2 */
	X#endif /* !VMS */
	X
	X#ifdef NFSCLIENT
	X#define PROC 0004
	X#endif /* NFSCLIENT */
	X
	X/* VARARGS1 */
	Xerror(message, arg1, arg2, arg3)
	Xchar *message;
	Xlong arg1, arg2, arg3;
	X{
	X	char buffer[LBUFLEN];
	X
	X	fflush(stdout);
	X	(void) sprintf(buffer, message, arg1, arg2, arg3);
	X	logerr(buffer);
	X	xxit(mode == PROC ? 0 : 1);
	X}
SHAR_EOF
if test 37308 -ne "`wc -c < 'ifuncs.c'`"
then
	echo shar: error transmitting "'ifuncs.c'" '(should have been 37308 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'inews.c'" '(38632 characters)'
if test -f 'inews.c'
then
	echo shar: will not over-write existing file "'inews.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'inews.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * inews - insert, receive, and transmit news articles.
	X *
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)inews.c	2.85	11/30/87";
	X#endif /* SCCSID */
	X
	X#include "iparams.h"
	X
	X# ifdef LOCKF
	X# include <unistd.h>
	X# include <fcntl.h>
	X
	X# if defined(F_RDLCK) && defined(F_SETLK)
	Xstruct flock news_lock;
	X#  endif /* F_RDLCK  && F_SETLK */
	X# endif /* LOCKF */
	X
	X#ifdef BSD4_2
	X# include <sys/file.h>
	X#else	/* !BSD4_2 */
	X# if defined(USG) && !defined(LOCKF)
	X# include <fcntl.h>
	X# endif /* USG */
	X#endif /* !BSD4_2 */
	X/* local defines for inews */
	X
	X#define OPTION	0	/* pick up an option string */
	X#define STRING	1	/* pick up a string of arguments */
	X
	X#define UNKNOWN 0001	/* possible modes for news program */
	X#define UNPROC	0002	/* Unprocessed input */
	X#define PROC	0004	/* Processed input */
	X#define	CONTROL	0010	/* Control Message */
	X#define	CREATENG 0020	/* Create a new newsgroup */
	X
	X#define DONT_SPOOL	0
	X#define	DO_SPOOL	1
	X#define	EXPIRE_RUNNING	2
	Xint spool_news = DONT_SPOOL;
	X
	Xextern char histline[];
	Xchar	forgedname[NAMELEN];	/* A user specified -f option. */
	X/* Fake sys line in case they forget their own system */
	Xstruct srec dummy_srec = { "MEMEME", "", "all", "", "" };
	X
	Xchar *Progname = "inews";	/* used by xerror to identify failing program */
	X
	Xstruct {			/* options table. */
	X	char	optlet;		/* option character. */
	X	char	filchar;	/* if to pickup string, fill character. */
	X	int	flag;		/* TRUE if have seen this opt. */
	X	int	oldmode;	/* OR of legal input modes. */
	X	int	newmode;	/* output mode. */
	X	char	*buf;		/* string buffer */
	X} *optpt, options[] = { /*
	Xoptlet	filchar		flag	oldmode	newmode		buf	*/
	X't',	' ',		FALSE,	UNPROC,	UNKNOWN,	header.title,
	X'n',	NGDELIM,	FALSE,	UNPROC,	UNKNOWN,	header.nbuf,
	X'd',	'\0',		FALSE,	UNPROC,	UNKNOWN,	header.distribution,
	X'e',	' ',		FALSE,	UNPROC,	UNKNOWN,	header.expdate,
	X'p',	'\0',		FALSE,	UNKNOWN|PROC,	PROC,	filename,
	X'f',	'\0',		FALSE,	UNPROC,	UNKNOWN,	forgedname,
	X'F',	' ',		FALSE,	UNPROC,	UNKNOWN,	header.followid,
	X'c',	' ',		FALSE,	UNKNOWN,UNKNOWN,	header.ctlmsg,
	X#define COPT 'C'
	XCOPT,	' ',		FALSE,	UNKNOWN,CREATENG,	header.ctlmsg,
	X#define hflag	options[9].flag
	X'h',	'\0',		FALSE,	UNPROC,	UNKNOWN,	filename,
	X#define oflag	options[10].flag
	X'o',	'\0',		FALSE,	UNPROC, UNKNOWN,	header.organization,
	X#define Mflag	options[11].flag
	X'M',	'\0',		FALSE,	UNPROC, UNKNOWN,	filename,
	X'a',	'\0',		FALSE,	UNPROC, UNKNOWN,	header.approved,
	X'U',	'\0',		FALSE,	PROC, PROC,		filename,
	X#define Sflag	options[14].flag
	X'S',	'\0',		FALSE,	UNKNOWN|PROC, 	UNPROC,	filename,
	X'x',	'\0',		FALSE,	UNPROC, UNKNOWN,	not_here,
	X'r',	'\0',		FALSE,	UNPROC, UNKNOWN,	header.replyto,
	X#define vflag	options[17].flag
	X'v',	'\0',		FALSE,	UNPROC, UNKNOWN,	filename,
	X'\0',	'\0',		0,	0,	0,		(char *)NULL
	X};
	X
	XFILE *mailhdr();
	Xextern int errno, xxit();
	X
	Xstruct timeb Now;
	X
	X/*
	X *	Authors:
	X *		Matt Glickman	glickman@ucbarpa.Berkeley.ARPA
	X *		Mark Horton	mark@cbosgd.UUCP
	X *		Stephen Daniels	swd@mcnc.UUCP
	X *		Tom Truscott	trt@duke.UUCP
	X *		Rick Adams	rick@seismo.CSS.GOV
	X *	IHCC version adapted by:
	X *		Larry Marek	larry@ihuxf.UUCP
	X */
	Xmain(argc, argv)
	Xint	argc;
	Xregister char **argv;
	X{
	X	int	state;		/* which type of argument to pick up	*/
	X	int	tlen, len;	/* temps for string processing routine	*/
	X	register char *ptr;	/* pointer to rest of buffer		*/
	X	int	filchar;	/* fill character (state = STRING)	*/
	X	char	*user = NULL, *home = NULL;	/* environment temps	*/
	X	struct passwd	*pw;	/* struct for pw lookup			*/
	X	struct group	*gp;	/* struct for group lookup		*/
	X	register int	i;
	X	FILE	*mfd;		/* mail file file-descriptor		*/
	X
	X	/* uuxqt doesn't close all its files */
	X	for (i = 3; !close(i); i++)
	X		;
	X	/* set up defaults and initialize. */
	X	mode = UNKNOWN;
	X	infp = stdin;
	X	pathinit();
	X	savmask = umask(N_UMASK);	/* set up mask */
	X	ptr = rindex(*argv, '/');
	X	if (!ptr)
	X		ptr = *argv - 1;
	X	actfp = xfopen(ACTIVE, "r+");
	X#ifndef NFSCLIENT
	X#ifdef	LOCKF
	X# if	defined(F_RDLCK) && defined(F_SETLK)
	X	news_lock.l_type = F_RDLCK;
	X	if (fcntl(fileno(actfp), F_SETLK, &news_lock) < 0) {
	X# else /* !F_RDLCK */
	X	if (lockf(fileno(actfp), F_TLOCK, 0L) < 0) {
	X# endif /* !F_RDLCK */
	X		if (errno != EAGAIN && errno != EACCES)
	X#else	/* !LOCKF */
	X#ifdef BSD4_2
	X	if (flock(fileno(actfp), LOCK_SH|LOCK_NB) < 0) {
	X		if (errno != EWOULDBLOCK)
	X#else	/* !BSD4_2 */
	X	sprintf(bfr, "%s.lock", ACTIVE);
	X	if (LINK(ACTIVE, bfr) < 0) {
	X		if (errno != EEXIST)
	X#endif /* V7 */
	X#endif	/* !BSD4_2 */
	X			xerror("Can't lock %s: %s", ACTIVE, errmsg(errno));
	X		spool_news = EXPIRE_RUNNING;
	X	} else {
	X#ifdef SPOOLNEWS
	X		if (argc > 1 && !STRCMP(*(argv+1), "-S")) {
	X			argc--;
	X			argv++;
	X			Sflag = 1;
	X		} else
	X			spool_news = DO_SPOOL;
	X
	X#endif /* SPOOLNEWS */
	X	}
	X	if (spool_news != EXPIRE_RUNNING) {
	X		/* only unlock if we locked */
	X#ifdef	LOCKF
	X		(void) lockf(fileno(actfp), F_ULOCK, 0L);
	X#else	/* !LOCKF */
	X#ifdef 	BSD4_2
	X		(void) flock(fileno(actfp), LOCK_UN);
	X#else	/* !BSD4_2 */
	X		(void) UNLINK(bfr);
	X#endif 	/* V7 */
	X#endif	/* !BSD4_2 */
	X	} else {	/* expire is running */
	X		if (argc > 1 && !STRCMP(*(argv+1), "-S"))
	X			exit(42);	/* inform rnews -U by exit status */
	X	}
	X	(void) signal(SIGTERM, xxit);
	X	if (argc > 1 && !STRCMP(*(argv+1), "-U")) {
	X		/* can't unspool while things are locked */
	X		if (spool_news == EXPIRE_RUNNING)
	X			xxit(0);
	X		dounspool();
	X		/* NOT REACHED */
	X	}
	X#endif /* !NFSCLIENT */
	X
	X	if (!STRNCMP(ptr+1, "rnews", 5)) {
	X#ifndef NFSCLIENT
	X		mode = PROC;
	X		if (spool_news != DONT_SPOOL) {
	X			dospool((char *)NULL, FALSE);
	X			/* NOT REACHED */
	X		}
	X#else /* NFSCLIENT */
	X		mfd = mailhdr((struct hbuf *)NULL, "Improper use of INEWS");
	X		if (mfd != NULL) {
	X		    fprintf(mfd,"System: %s\n\nINEWS is running improperly as RNEWS on slave NFS site by user %s.\n", LOCALSYSNAME, username);
	X		    (void) mclose(mfd);
	X		    exit(1);
	X		}
	X#endif /* NFSCLIENT */
	X#ifdef NICENESS
	X		if (nice(0) < NICENESS)
	X			(void) nice(NICENESS);
	X#endif /* NICENESS */
	X	} else {
	X	/* it's not rnews, so it must be inews */
	X		if (argc < 2)
	X			goto usage;
	X#ifndef SPOOLINEWS
	X		if (spool_news == DO_SPOOL)
	X			spool_news = DONT_SPOOL;
	X#endif /* SPOOLINEWS */
	X	}
	X
	X	state = OPTION;
	X	header.title[0] = header.nbuf[0] = filename[0] = '\0';
	X
	X	/* check for existence of special files */
	X#ifdef DBM
	X	chkfile(ARTFILE);
	X#else
	X	chkdir(ARTFILE);
	X#endif /* DBM */
	X	chkfile(ACTIVE);
	X	SigTrap = FALSE;	/* true if a signal has been caught */
	X	if (mode != PROC) {
	X		(void) signal(SIGHUP, onsig);
	X		(void) signal(SIGINT, onsig);
	X	}
	X	/*
	X	 * Catch "filesize exceeded" signals on 4.2BSD systems
	X	 * - the history files may exceed this limit.
	X	 */
	X#ifdef  SIGXFSZ
	X	(void) signal(SIGXFSZ, SIG_IGN);
	X#endif /* SIGXFSZ */
	X	uid = getuid();
	X	gid = getgid();
	X	duid = geteuid();
	X	dgid = getegid();
	X	(void) ftime(&Now);
	X#ifndef NFSCLIENT
	X	if (uid == 0 && duid == 0) {
	X#else /* NFSCLIENT */
	X        if (duid == 0) {
	X#endif /* NFSCLIENT */
	X		/*
	X		 * Must go through with this kludge since
	X		 * some systems do not honor the setuid bit
	X		 * when root invokes a setuid program.
	X		 *
	X		 * On NFS slave systems, inews is setuid to ROOT.  This allows
	X		 * inews to setuid/gid (real and effective) to NEWSUSR and
	X		 * NEWSGRP respectively.  This *must* happen so that the "rsh"
	X		 * program will run as user NEWSUSR and not as the user running
	X		 * inews. "rsh" runs as the "real" user even when the program
	X		 * calling it is setuid.
	X		 */
	X		if ((pw = getpwnam(NEWSUSR)) == NULL)
	X			xerror("Cannot get NEWSU pw entry");
	X
	X		duid = pw->pw_uid;
	X		if ((gp = getgrnam(NEWSGRP)) == NULL)
	X			xerror("Cannot get NEWSG gr entry");
	X		dgid = gp->gr_gid;
	X		(void) setgid(dgid);
	X		(void) setuid(duid);
	X	}
	X
	X#ifndef DOGETUSER
	X	/*
	X	 * Force the use of 'getuser()' to prevent forgery of articles
	X	 * by just changing $LOGNAME
	X	 */
	X	if (isatty(fileno(stderr))) {
	X		if ((user = getenv("USER")) == NULL)
	X			user = getenv("LOGNAME");
	X		if ((home = getenv("HOME")) == NULL)
	X			home = getenv("LOGDIR");
	X	}
	X#endif /* !DOGETUSER */
	X	if (user == NULL || home == NULL)
	X		getuser();
	X	else {
	X		if (STRCMP(username, "Unknown") == 0 || username[0] == 0) {
	X			username = AllocCpy(user);
	X		}
	X		userhome = AllocCpy(home);
	X	}
	X	getuser();
	X
	X	/* loop once per arg. */
	X
	X	++argv;		/* skip first arg, which is prog name. */
	X
	X	while (--argc) {
	X	    if (state == OPTION) {
	X		if (**argv != '-') {
	X			xerror("Bad option string \"%s\"", *argv);
	X		}
	X		while (*++*argv != '\0') {
	X			for (optpt = options; optpt->optlet != '\0'; ++optpt) {
	X				if (optpt->optlet == **argv)
	X					goto found;
	X			}
	X			/* unknown option letter */
	Xusage:
	X			fprintf(stderr, "usage: inews -t title");
	X			fprintf(stderr, " [ -n newsgroups ]");
	X			fprintf(stderr, " [ -e expiration date ]\n");
	X			fprintf(stderr, "\t[ -f sender]\n\n");
	X			xxit(1);
	X
	X		    found:;
	X#ifdef NFSCLIENT
	X			if (optpt->optlet == COPT) {
	X			    fprintf(stderr, "Cannot create new newsgroups from an NFS slave system.\n\n");
	X			    xxit(1);
	X			}
	X#endif /* NFSCLIENT */
	X			if (optpt->flag == TRUE || (mode != UNKNOWN &&
	X			    (mode&optpt->oldmode) == 0)) {
	X				xerror("Bad %c option", **argv);
	X			}
	X			if (mode == UNKNOWN)
	X				mode = optpt->newmode;
	X			filchar = optpt->filchar;
	X			optpt->flag = TRUE;
	X			state = STRING;
	X			ptr = optpt->buf;
	X			len = BUFLEN;
	X		}
	X
	X		argv++;		/* done with this option arg. */
	X
	X	    } else {
	X
	X		/*
	X		 * Pick up a piece of a string and put it into
	X		 * the appropriate buffer.
	X		 */
	X		if (**argv == '-') {
	X			state = OPTION;
	X			argc++;	/* uncount this arg. */
	X			continue;
	X		}
	X
	X		if ((tlen = strlen(*argv)) >= len)
	X			xerror("Argument string too long");
	X		(void) strcpy(ptr, *argv++);
	X		ptr += tlen;
	X		if (*(ptr-1) != filchar)
	X			*ptr++ = filchar;
	X		len -= tlen + 1;
	X		*ptr = '\0';
	X	    }
	X	}
	X
	X	/*
	X	 * ALL of the command line has now been processed. (!)
	X	 */
	X
	X	if (*filename) {
	X		infp = freopen(filename, "r", stdin);
	X		if (infp == NULL)
	X			xerror("freopen(%s): %s", filename, errmsg(errno));
	X	} else
	X		infp = stdin;
	X
	X	tty = isatty(fileno(infp));
	X
	X#ifndef NFSCLIENT
	X	if (mode == CREATENG)
	X		createng();
	X#endif /* !NFSCLIENT */
	X
	X	if (header.ctlmsg[0] != '\0' && header.title[0] == '\0')
	X		(void) strcpy(header.title, header.ctlmsg);
	X
	X	if (*header.nbuf) {
	X		lcase(header.nbuf);
	X		ptr = index(header.nbuf, '\0');
	X		if (ptr[-1] == NGDELIM)
	X			*--ptr = '\0';
	X	}
	X	(void) nstrip(header.title);
	X	(void) nstrip(header.expdate);
	X	(void) nstrip(header.followid);
	X	if (mode != PROC) {
	X		if (hflag) {
	X			header.path[0] = '\0';
	X			(void) hread(&header, infp, FALSE);
	X			/* there are certain fields we won't let him specify. */
	X			if (header.from[0]) {
	X				(void) fixfrom(&header);
	X				if (Sflag && !Mflag && !header.approved[0] &
	X					!header.sender[0]) {
	X					register char *p;
	X					strcpy(bfr, header.from);
	X					p  = strpbrk(bfr, "@ !");
	X					if (p)
	X						*p = '\0';
	X					if ((pw = getpwnam(bfr)) != NULL) {
	X						uid = pw->pw_uid;
	X						gid = pw->pw_gid;
	X						username = AllocCpy(bfr);
	X					}
	X				} else {
	X					(void) strcpy(forgedname, header.from);
	X					header.from[0] = '\0';
	X				}
	X			}
	X			if (!header.approved[0])
	X				Mflag = FALSE;
	X			header.sender[0] = '\0';
	X			if (header.subdate[0] && cgtdate(header.subdate) < 0)
	X				header.subdate[0] = '\0';
	X		}
	X
	X		if (header.ident[0] == '\0')
	X			getident(&header);
	X
	X		if (forgedname[0]) {
	X			register char *p1;
	X			if (Mflag)
	X				sprintf(header.path, "%s!%s",
	X					PATHSYSNAME, username);
	X			else if (!header.path[0]) {
	X				(void) strcpy(header.path, forgedname);
	X
	X				if ((p1 = strpbrk(header.path, " (<")) != NULL)
	X					*p1 = '\0';
	X			}
	X			if (!Mflag && !strpbrk(forgedname, "@ (<"))
	X				(void) sprintf(header.from,"%s@%s",
	X					forgedname, FROMSYSNAME);
	X			else
	X				(void) strncpy(header.from, forgedname, BUFLEN);
	X
	X			(void) sprintf(header.sender, "%s@%s",
	X				username, FROMSYSNAME);
	X		} else {
	X			gensender(&header, username);
	X		}
	X#ifdef MYORG
	X		if (header.organization[0] == '\0' && !Mflag &&
	X			header.sender[0] == '\0') {
	X			strncpy(header.organization, MYORG, BUFLEN);
	X			if (STRNCMP(header.organization, "Frobozz", 7) == 0)
	X				header.organization[0] = '\0';
	X			if (ptr = getenv("ORGANIZATION"))
	X				strncpy(header.organization, ptr, BUFLEN);
	X			/*
	X			 * Note that the organization can also be turned off by
	X			 * setting it to the null string, either in MYORG or
	X			 * $ORGANIZATION in the environment.
	X			 */
	X			if (header.organization[0] == '/') {
	X				mfd = fopen(header.organization, "r");
	X				if (mfd) {
	X					(void) fgets(header.organization, sizeof header.organization, mfd);
	X					(void) fclose(mfd);
	X				} else {
	X					logerr("Couldn't open %s",
	X						header.organization);
	X					header.organization[0] = '\0';
	X				}
	X				ptr = index(header.organization, '\n');
	X				if (ptr)
	X					*ptr = '\0';
	X			}
	X		}
	X#endif /* MYORG */
	X	}
	X
	X	/* Authorize newsgroups. */
	X	if (mode == PROC) {
	X#ifdef NFSCLIENT
	X		mfd = mailhdr((struct hbuf *)NULL, "Improper use of INEWS");
	X		if (mfd != NULL) {
	X		    fprintf(mfd,"System: %s\n\nINEWS is running improperly as RNEWS on slave NFS site by user %s.\n", LOCALSYSNAME, username);
	X		    (void) mclose(mfd);
	X		    exit(1);
	X		}
	X#else /* !NFSCLIENT */
	X		checkbatch();
	X		(void) signal(SIGHUP, SIG_IGN);
	X		(void) signal(SIGINT, SIG_IGN);
	X		(void) signal(SIGQUIT, SIG_IGN);
	X		header.ident[0] = '\0';
	X		if (hread(&header, infp, TRUE) == NULL)
	X			xerror("%s: Inbound news is garbled", filename);
	X		input(bfr[0] != '\n');
	X	}
	X	/* always check history */
	X
	X	if (history(&header)) {
	X		log("Duplicate article %s rejected. Path: %s",
	X			header.ident, header.path);
	X		xxit(0);
	X#endif /* !NFSCLIENT */
	X	}
	X
	X	/* Easy way to make control messages, since all.all.ctl is unblessed */
	X	if (mode != PROC && PREFIX(header.title, "cmsg ") && header.ctlmsg[0] == 0)
	X		(void) strcpy(header.ctlmsg, &header.title[5]);
	X	is_ctl = mode != CREATENG &&
	X		(ngmatch(header.nbuf, "all.all.ctl,") || header.ctlmsg[0]);
	X#ifdef DEBUG
	X	fprintf(stderr,"is_ctl set to %d\n", is_ctl);
	X#endif
	X
	X	if (mode != CREATENG) {
	X		if (!*header.title)
	X			error("No title, ng %s from %s", header.nbuf,
	X				header.from);
	X		if (!*header.nbuf)
	X			(void) strcpy(header.nbuf, DFLTNG);
	X	}
	X
	X	if (mode <= UNPROC) {
	X#ifdef FASCIST
	X		if (uid && uid != ROOTID && fascist(username, header.nbuf))
	X			xerror("User %s is not authorized to post to newsgroup %s",
	X				username, header.nbuf);
	X#endif /* FASCIST */
	X#ifndef NFSCLIENT
	X		ctlcheck();
	X#endif /* !NFSCLIENT */
	X	}
	X
	X#ifndef NFSCLIENT
	X	if (mode == CREATENG)
	X		createng();
	X#endif /* !NFSCLIENT */
	X
	X	/* Determine input. */
	X	if (mode != PROC)
	X		input(FALSE);
	X	if (header.intnumlines == 0 && !is_ctl)
	X		error("%s rejected: no text lines", header.ident);
	X
	X	dates(&header);
	X
	X	/* Do the actual insertion. */
	X	insert();
	X	/* NOTREACHED */
	X}
	X
	X/* check for existence of file */
	Xstatic chkfile(f)
	Xchar *f;
	X{
	X	FILE	*mfd;		/* mail file file-descriptor		*/
	X	char	cbuf[BUFLEN];	/* command buffer			*/
	X
	X	if (rwaccess(f))
	X		return;	/* everything is ok */
	X	mfd = mailhdr((struct hbuf *)NULL,
	X		exists(f) ? "Unwritable files!" : "Missing files!");
	X	if (mfd == NULL)
	X		return;
	X	putc('\n', mfd);
	X	fprintf(mfd, "System: %s\n\nThere was a problem with %s!!\n",
	X		LOCALSYSNAME, f);
	X#ifndef NFSCLIENT
	X	(void) sprintf(cbuf, "touch %s;chmod 666 %s", f, f);
	X	(void) system(cbuf);
	X	if (rwaccess(f))
	X		fprintf(mfd, "The problem has been taken care of.\n");
	X	else
	X		fprintf(mfd, "Corrective action failed - check suid bits.\n");
	X#else /* NFSCLIENT */
	X	fprintf(mfd, "Corrective action must take place on \"%s\", the master NFS news system.\n", NFSSYSNAME);
	X#endif /* NFSCLIENT */
	X	(void) mclose(mfd);
	X}
	X
	X#ifndef DBM
	X/* check for existence of directory */
	Xstatic chkdir(d)
	Xchar *d;
	X{
	X	FILE	*mfd;		/* mail file file-descriptor		*/
	X	char	dir[BUFLEN];	/* holds directory name			*/
	X
	X	sprintf(dir, "%s.d", d);
	X	if (eaccess(dir, 07) == 0)
	X		return; /* everything is ok */
	X	mfd = mailhdr((struct hbuf *)NULL,
	X		exists(dir) ? "Unwritable directories" : "Missing directories");
	X	if (mfd == NULL)
	X		return;
	X	putc('\n', mfd);
	X	fprintf(mfd, "System: %s\n\nThere was a problem with %s!\n",
	X		LOCALSYSNAME, dir);
	X#ifndef NFSCLIENT
	X	(void) mkdir(dir, 0775);
	X	if (eaccess(dir, 07) == 0)
	X		fprintf(mfd, "The problem has been taken care of.\n");
	X	else
	X		fprintf(mfd, "Corrective action failed - check suid bits.\n");
	X#else /* NFSCLIENT */
	X	fprintf(mfd, "Corrective action must take place on \"%s\", the master NFS news system.\n", NFSSYSNAME);
	X#endif /* NFSCLIENT */
	X	(void) mclose(mfd);
	X}
	X
	X/*
	X * This version of access checks against effective uid and effective gid
	X */
	Xeaccess(name, mode)
	Xregister char *name;
	Xregister int mode;
	X{	
	X	struct stat statb;
	X	int euserid = geteuid();
	X	int egroupid = getegid();
	X
	X	if (stat(name, &statb) == 0) {
	X		if (euserid == 0) {
	X			if ((statb.st_mode&S_IFMT) != S_IFREG || mode != 1)
	X				return 0;
	X		    	/* root needs execute permission for someone */
	X			mode = (S_IEXEC|(S_IEXEC>>3)|(S_IEXEC>>6));
	X		}
	X		else if (euserid == statb.st_uid)
	X			mode <<= 6;
	X		else if (egroupid == statb.st_gid)
	X			mode <<= 3;
	X#ifdef BSD4_2
	X		/* in BSD4_2 you can be in several groups */
	X		else {
	X			int groups[NGROUPS];
	X			register int n;
	X			n = getgroups(NGROUPS,groups);
	X			while(--n >= 0) {
	X				if(groups[n] == statb.st_gid) {
	X					mode <<= 3;
	X					break;
	X				}
	X			}
	X		}
	X#endif /* BSD4_2 */
	X
	X		if (statb.st_mode & mode)
	X			return 0;
	X	}
	X	return -1;
	X}
	X#endif /* DBM */
	X
	X#ifndef NFSCLIENT
	Xdospool(batchcmd, dolhwrite)
	Xchar *batchcmd;
	Xint dolhwrite;
	X{
	X	register int c;
	X	register FILE *sp;
	X	register struct tm *tp;
	X	time_t t;
	X	char buf[BUFLEN], sfile[BUFLEN];
	X	extern struct tm *gmtime();
	X
	X	(void) sprintf(sfile, "%s/.spXXXXXX", SPOOL);
	X	MKTEMP(sfile);
	X	sp = xfopen(sfile, "w");
	X	if (batchcmd != NULL) {
	X		if (not_here[0] != '\0')
	X			fprintf(sp, "%s -x %s\n", batchcmd, not_here);
	X		else
	X			fprintf(sp, "%s\n", batchcmd);
	X	} else
	X		if (not_here[0] != '\0')
	X			fprintf(sp, "#! inews -x %s -p\n", not_here);
	X	if (dolhwrite)
	X		lhwrite(&header, sp);
	X	while ((c = getc(infp)) != EOF)
	X		putc(c, sp);
	X	fclose(sp);
	X
	X	(void) time(&t);
	X	tp = gmtime(&t);
	X	/* This file name "has to" be unique  (right?) */
	X#ifdef USG
	X	(void) sprintf(buf, "%s/.rnews/%2.2d%2.2d%2.2d%2.2d%2.2d%x",
	X#else
	X#ifdef VMS
	X	/* Eunice doesn't like dots in directory names */
	X	(void) sprintf(buf, "%s/+rnews/%02d%02d%02d%02d%02d%x",
	X#else /* V7 */
	X	(void) sprintf(buf, "%s/.rnews/%02d%02d%02d%02d%02d%x",
	X#endif /* V7 */
	X#endif /* VMS */
	X		SPOOL,
	X		tp->tm_year, tp->tm_mon+1, tp->tm_mday,
	X		tp->tm_hour, tp->tm_min, getpid());
	X
	X#ifdef IHCC
	X	log("Spooling %s into %s", header.ident, (rindex(buf,'/') + 1));
	X#endif /* IHCC */
	X
	X	if (LINK(sfile, buf) < 0) {
	X		char dbuf[BUFLEN];
	X#ifdef VMS
	X		sprintf(dbuf, "%s/+rnews", SPOOL);
	X#else /* !VMS */
	X		sprintf(dbuf, "%s/.rnews", SPOOL);
	X#endif /* !VMS */
	X		if (mkdir(dbuf, 0777&~N_UMASK) < 0)
	X			xerror("Cannot mkdir %s: %s", dbuf, errmsg(errno));
	X		if (LINK(sfile, buf) < 0) 
	X			xerror("Cannot link(%s,%s): %s", sfile, buf,
	X				errmsg(errno));
	X	}
	X	(void) UNLINK(sfile);
	X	xxit(0);
	X	/* NOTREACHED */
	X}
	X
	X/*
	X *	Create a newsgroup
	X */
	Xcreateng()
	X{
	X	register char *cp;
	X
	X	/*
	X	 * Only certain users are allowed to create newsgroups
	X	 */
	X	if (uid != ROOTID && uid != duid && uid) {
	X		logerr("Please contact one of the local netnews people");
	X		xerror("to create group \"%s\" for you", header.ctlmsg);
	X	}
	X	if (header.distribution[0] == '\0')
	X#ifdef ORGDISTRIB
	X		strcpy(header.distribution, ORGDISTRIB);
	X#else /* !ORGDISTRIB */
	X		strcpy(header.distribution, "local");
	X#endif /* !ORGDISTRIB */
	X
	X	(void) strcpy(header.nbuf, header.ctlmsg);
	X	if ((cp=index(header.nbuf, ' ')) != NULL)
	X		*cp = '\0';
	X
	X	if (header.approved[0] == '\0')
	X		(void) sprintf(header.approved, "%s@%s",
	X				username, FROMSYSNAME);
	X	(void) sprintf(bfr, "%s/inews -n %s.ctl -c newgroup %s -d %s -a \"%s\"",
	X		LIB, header.nbuf, header.ctlmsg, header.distribution,
	X		header.approved);
	X	if (tty) {
	X		printf("Please type in a paragraph describing the new newsgroup.\n");
	X		printf("End with control D as usual.\n");
	X	}
	X	printf("%s\n", bfr);
	X	(void) fflush(stdout);
	X	(void) system(bfr);
	X	exit(0);
	X	/*NOTREACHED*/
	X}
	X
	Xchar firstbufname[BUFLEN];
	X/*
	X *	Link ARTICLE into dir for ngname and update active file.
	X */
	Xlong
	Xlocalize(ngname)
	Xchar	*ngname;
	X{
	X	char afline[BUFLEN];
	X	long ngsize;
	X	long fpos;
	X	int e;
	X	char *cp;
	X
	X	lock();
	X	(void) rewind(actfp); clearerr(actfp);
	X
	X	for(;;) {
	X		fpos = ftell(actfp);
	X		if (fgets(afline, sizeof afline, actfp) == NULL) {
	X			unlock();
	X			logerr("Can't find \"%s\" in active file", ngname);
	X			return FALSE;		/* No such newsgroup locally */
	X		}
	X		if (PREFIX(afline, ngname)) {
	X			(void) sscanf(afline, "%s %ld", bfr, &ngsize);
	X			if (STRCMP(bfr, ngname) == 0) {
	X				if (ngsize < 0 || ngsize > 99998) {
	X					logerr("found bad ngsize %ld ng %s, setting to 1", ngsize, bfr);
	X					ngsize = 1;
	X				}
	X				break;
	X			}
	X		}
	X	}
	X	for (;;) {
	X		cp = dirname(ngname);
	X
	X		(void) sprintf(bfr, "%s/%ld", cp, ngsize+1);
	X#ifdef VMS
	X		/*
	X		 * The effect of this code is to store the article in the first
	X		 * newsgroup's directory and to put symbolic links elsewhere.
	X		 * If this is the first group, firstbufname is not yet filled
	X		 * in. It should be portable to other link-less systems.
	X		 * epimass!jbuck
	X		 */
	X		if (firstbufname[0]) {
	X			if (vmslink(firstbufname, bfr) == 0)
	X				break;
	X		} else if (rename(ARTICLE, bfr) == 0)
	X			break;
	X#else /* !VMS */
	X		if (link(ARTICLE, bfr) == 0)
	X			break;
	X#endif /* !VMS */
	X		if (!exists(cp))
	X			mknewsg(cp, ngname);
	X#ifdef VMS
	X		if (firstbufname[0]) {
	X			if (vmslink(firstbufname, bfr) == 0)
	X				break;
	X		} else if (rename(ARTICLE, bfr) == 0) 
	X			break;
	X#else /* !VMS */
	X		if (link(ARTICLE, bfr) == 0)
	X			break;
	X#endif /* !VMS */
	X		e = errno;	/* keep log from clobbering it */
	X		log("Cannot install article as %s: %s", bfr, errmsg(errno));
	X		if (e != EEXIST) {
	X			logerr("Link into %s failed (%s); check dir permissions.",
	X			    bfr, errmsg(e));
	X			unlock();
	X			return FALSE;
	X		}
	X		ngsize++;
	X	}
	X
	X	/*
	X	 * This works around a bug in the 4.1bsd stdio
	X	 * on fseeks to non even offsets in r+w files
	X	 */
	X	if (fpos&1)
	X		(void) rewind(actfp);
	X
	X	(void) fseek(actfp, fpos, 0);
	X	/*
	X	 * Has to be same size as old because of %05d.
	X	 * This will overflow with 99999 articles.
	X	 */
	X	fprintf(actfp, "%s %05ld", ngname, ngsize+1);
	X#if defined(USG) || defined(MG1)
	X	/*
	X	 * U G L Y   K L U D G E
	X	 * This utter piece of tripe is the only way I know of to get
	X	 * around the fact that ATT BROKE standard IO in System 5.2.
	X	 * Basically, you can't open a file for "r+" and then try and
	X	 * write to it. This works on all "real" USGUnix systems, It will
	X	 * probably break on some obscure look alike that doesnt use the
	X	 * real ATT stdio.h
	X	 * Don't blame me, blame ATT. stdio should have already done the
	X	 * following line for us, but it doesn't
	X	 * also broken in WCW MG-1 42nix 2.0
	X	 */
	X	 actfp->_flag |= _IOWRT;
	X#endif /* USG */
	X	(void) fflush(actfp);
	X	if (ferror(actfp))
	X		xerror("Active file write failed");
	X	unlock();
	X	if (firstbufname[0] == '\0')
	X		(void) strcpy(firstbufname, bfr);
	X	(void) sprintf(bfr, "%s/%ld ", ngname, ngsize+1);
	X	addhist(bfr);
	X	return ngsize+1;
	X}
	X#endif /* !NFSCLIENT */
	X
	X/*
	X *	Localize for each newsgroup and broadcast.
	X */
	Xinsert()
	X{
	X	register char *ptr;
	X	register FILE *tfp;
	X	register int c;
	X	struct srec srec;	/* struct for sys file lookup	*/
	X	struct tm *tm, *gmtime();
	X	int is_invalid = FALSE;
	X	int exitcode = 0;
	X	long now;
	X#ifdef DOXREFS
	X	register char *nextref = header.xref;
	X#endif /* DOXREFS */
	X
	X	/* Clean up Newsgroups: line */
	X	if (!is_ctl && mode != CREATENG) {
	X#ifdef MODFILEONLY
	X	    if (mode <= UNPROC) header.approved[0] = '\0';
	X#endif /* MODFILEONLY */
	X	    is_invalid =
	X		ngfcheck(username, mode == PROC, header.approved[0] != '\0');
	X	}
	X
	X	(void) time(&now);
	X	tm = gmtime(&now);
	X	if (header.expdate[0])
	X		addhist(" ");
	X#ifdef USG
	X	sprintf(bfr,"%2.2d/%2.2d/%d %2.2d:%2.2d\t",
	X#else /* !USG */
	X	sprintf(bfr,"%02d/%02d/%d %02d:%02d\t",
	X#endif /* !USG */
	X		tm->tm_mon+1, tm->tm_mday, tm->tm_year,tm->tm_hour, tm->tm_min);
	X	addhist(bfr);
	X	log("%s %s ng %s subj '%s' from %s", spool_news != DONT_SPOOL
	X		? "queued" : (mode==PROC ? "received" : "posted"),
	X		header.ident, header.nbuf, header.title, header.from);
	X
	X	/* Write article to temp file. */
	X	MKTEMP(ARTICLE);
	X	tfp = xfopen(ARTICLE, "w");
	X
	X#ifndef NFSCLIENT
	X	if (is_invalid) {
	X		logerr("No valid newsgroups found, moved to junk");
	X		if (localize("junk"))
	X			savehist(histline);
	X		exitcode = 1;
	X		goto writeout;
	X	}
	X
	X#ifdef ZAPNOTES
	X	if (STRNCMP(header.title, "Re: Orphaned Response", 21) == 0) {
	X		logerr("Orphaned Response, moved to junk");
	X		if (localize("junk"))
	X			savehist(histline);
	X		exitcode = 1;
	X		goto writeout;
	X	}
	X#endif	/* ZAPNOTES */
	X
	X	if (time((time_t *)0) > (cgtdate(header.subdate) + HISTEXP) ){
	X		logerr("Article too old, moved to junk");
	X		if (localize("junk"))
	X			savehist(histline);
	X		exitcode = 1;
	X		goto writeout;
	X	}
	X#endif /* !NFSCLIENT */
	X
	X	if (is_mod[0] != '\0' 	/* one of the groups is moderated */
	X	    && header.approved[0] == '\0') { /* and unapproved */
	X		if (is_mod_file_okay) {
	X			(void) sprintf(header.approved, "%s@%s",
	X					username, FROMSYSNAME);
	X		} else {
	X			struct hbuf mhdr;
	X			FILE *mfd, *mhopen();
	X			register char *p;
	X			char modadd[BUFLEN], *replyname();
	X#ifndef NFSCLIENT
	X#ifdef DONTFOWARD
	X			if(mode == PROC) {
	X				logerr("Unapproved article in moderated group %s",
	X					is_mod);
	X				if (localize("junk"))
	X					savehist(histline);
	X				goto writeout;
	X			}
	X#endif /* DONTFORWARD */
	X#endif /* !NFSCLIENT */
	X			fprintf(stderr,"%s is moderated and may not ", is_mod);
	X			fprintf(stderr,"be posted to directly.\nYour ");
	X			fprintf(stderr, "article is being mailed to the ");
	X			fprintf(stderr, "moderator who will post it for ");
	X			fprintf(stderr, "you.\n");
	X			/* Let's find a path to the backbone */
	X			sprintf(bfr, "%s/mailpaths", LIB);
	X			mfd = xfopen(bfr, "r");
	X			do {
	X				if (fscanf(mfd, "%s %s", bfr, modadd) != 2)
	X					xerror("Can't find backbone in %s/mailpaths",
	X						LIB);
	X			} while (STRCMP(bfr, "backbone") != 0
	X			     && !ngmatch(is_mod, bfr));
	X			(void) fclose(mfd);
	X			/* fake a header for mailhdr */
	X			mhdr.from[0] = '\0';
	X			mhdr.replyto[0] = '\0';
	X			p = is_mod;
	X			while (*++p)
	X				if (*p == '.')
	X					*p = '-';
	X			sprintf(mhdr.path, modadd, is_mod);
	X			mfd = mhopen(&mhdr);
	X			if (mfd == NULL)
	X				xerror("Can't send mail to %s", mhdr.path);
	X			fprintf(mfd, "To: %s\n", replyname(&mhdr));
	X			lhwrite(&header, mfd);
	X			putc('\n', mfd);
	X			while ((c = getc(infp)) != EOF)
	X				putc(c, mfd);
	X			mclose(mfd);
	X			log("Article mailed to %s", mhdr.path);
	X			xxit(0);
	X		}
	X	}
	X
	X#ifndef NFSCLIENT
	X	if (mode != PROC && spool_news != DONT_SPOOL)  {
	X		if (spool_news != EXPIRE_RUNNING
	X			&& ngmatch(header.nbuf,"to.all.ctl"))
	X				spool_news = DONT_SPOOL;
	X		if (spool_news != DONT_SPOOL) {
	X			fprintf(stderr,
	X			"Your article has been spooled for later processing.\n");
	X			dospool("#! inews -S -h", TRUE);
	X			/* NOT REACHED */
	X		}
	X	}
	X#endif /* !NFSCLIENT */
	X
	X	if (is_ctl) {
	X		exitcode = control(&header);
	X#ifndef NFSCLIENT
	X		if (localize("control") && exitcode != 0)
	X			savehist(histline);
	X	} else {
	X		if (s_find(&srec, LOCALPATHSYSNAME) == FALSE) {
	X			logerr("Cannot find my name '%s' in %s",
	X				LOCALPATHSYSNAME, SUBFILE);
	X			srec = dummy_srec;
	X		}
	X#ifdef DOXREFS
	X		(void) strncpy(nextref, PATHSYSNAME, BUFLEN);
	X#endif /* DOXREFS */
	X		for (ptr = nbuf; *ptr;) {
	X			if (ngmatch(ptr,srec.s_nbuf) || index(ptr,'.') == NULL){
	X#ifdef DOXREFS
	X				while (*nextref++)
	X					;
	X				(void) sprintf(--nextref, " %s:%ld", ptr, localize(ptr));
	X#else /* !DOXREFS */
	X				(void) localize(ptr);
	X#endif /* !DOXREFS */
	X			}
	X			while (*ptr++)
	X				;
	X		}
	X		if (firstbufname[0] == '\0') {
	X			logerr("Newsgroups in active, but not sys");
	X			(void) localize("junk");
	X		}
	X#endif /* !NFSCLIENT */
	X	}
	X#ifdef DOXREFS
	X	if (index(header.nbuf, NGDELIM) == NULL)
	X		header.xref[0] = '\0';
	X#endif /* DOXREFS */
	X
	Xwriteout:
	X	/* Part 1 of kludge to get around article truncation problem */
	X	if ( (c=getc(infp)) != EOF) {
	X		ungetc(c, infp);
	X		if (c == ' ' || c == '\t') {
	X			header.intnumlines++;
	X			(void) sprintf(header.numlines, "%d",
	X				header.intnumlines);
	X		}
	X	}
	X	/* End of part 1 */
	X	if (header.expdate[0] != '\0' && mode != PROC) {
	X		/* Make sure it's fully qualified */
	X		long t = cgtdate(header.expdate);
	X		strcpy(header.expdate, arpadate(&t));
	X	}
	X
	X	lhwrite(&header, tfp);
	X	if ((c = getc(infp)) != EOF) {
	X		/* Part 2 of kludge to get around article truncation problem */
	X		if (c == ' ' || c == '\t' )
	X			putc('\n', tfp);
	X		/* End of part 2 */
	X		ungetc(c, infp);
	X		while (fgets(bfr, BUFLEN, infp) != NULL)
	X			fputs(bfr, tfp);
	X		if (bfr[strlen(bfr)-1] != '\n')
	X			putc('\n',tfp);
	X	}
	X	if (ferror(tfp))
	X		xerror("Write failed for temp file");
	X	(void) fclose(tfp);
	X	(void) fclose(infp);
	X	if(exitcode == 0) {
	X		if (vflag) {
	X			printf("%s\n", header.ident);
	X			fflush(stdout);
	X		}
	X		/* article has passed all the checks, so work in background */
	X		if (mode != PROC) {
	X#ifndef NFSCLIENT
	X			int pid;
	X			if ((pid=fork()) < 0)
	X				xerror("Can't fork");
	X			else if (pid > 0)
	X				_exit(0);
	X		}
	X#ifdef SIGTTOU
	X		(void) signal(SIGTTOU, SIG_IGN);
	X#endif /* SIGTTOU */
	X		savehist(histline);
	X		if (header.supersedes[0] != '\0') {
	X			char *av[2];
	X
	X			av[0] = "cancel";
	X			av[1] = header.supersedes;
	X			c_cancel(2, av);
	X		}
	X		broadcast(mode==PROC);
	X#else /* NFSCLIENT */
	X			int status;
	X			char command[LBUFLEN];
	X
	X			(void) sprintf(command, NFSCMDFORMAT, NFSCMDARGS);
	X			status = system(command);
	X			(void) unlink(ARTICLE);
	X			exit(status);
	X		}
	X#endif /* NFSCLIENT */
	X	}
	X	xxit((mode == PROC && filename[0] == '\0') ? 0 :
	X		(exitcode < 0 ? 0 : exitcode));
	X}
	X
	Xinput(usegunk)
	X{
	X	register char *cp;
	X	register int c;
	X	register int empty = TRUE;
	X	FILE *tmpfp;
	X	int consec_newlines = 0;
	X	int linecount = 0;
	X	int linserted = 0;
	X
	X	MKTEMP(INFILE);
	X	tmpfp = xfopen(INFILE, "w");
	X	for ( ; ; ) {
	X		if (SigTrap)
	X			break;
	X		if (usegunk)
	X			usegunk = FALSE;
	X		else if (fgets(bfr, BUFLEN, infp) != bfr)
	X			break;
	X#ifndef NFSCLIENT
	X 		if (mode == PROC) {	/* zap trailing empty lines */
	X#ifdef ZAPNOTES
	X			if (empty && bfr[0] == '#' && bfr[2] == ':'
	X				&& header.nf_id[0] == '\0'
	X				&& header.nf_from[0] == '\0' ) {
	X				(void) strcpy(header.nf_id, bfr);
	X				(void) nstrip(header.nf_id);
	X				(void) fgets(bfr, BUFLEN, infp);
	X				(void) strcpy(header.nf_from, bfr);
	X				(void) nstrip(header.nf_from);
	X				(void) fgets(bfr, BUFLEN, infp);
	X
	X				if (header.numlines[0]) {
	X					header.intnumlines -= 2;
	X					(void) sprintf(header.numlines, "%d", header.intnumlines);
	X				}
	X
	X				/* Strip trailing " - (nf)" */
	X				if ((cp = rindex(header.title, '-')) != NULL
	X				    && !STRCMP(--cp, " - (nf)"))
	X					*cp = '\0';
	X				log("Stripped notes header on %s", header.ident);
	X				continue;
	X			}
	X#endif /* ZAPNOTES */
	X 			if (bfr[0] == '\n' ||
	X				/* Bandage for older versions of inews */
	X				bfr[1] == '\n' && !isascii(bfr[0])) {
	X 				consec_newlines++;	/* count it, in case */
	X 				continue;		/* but don't write it*/
	X 			}
	X 			/* foo! a non-empty line. write out all saved lines. */
	X 			while (consec_newlines > 0) {
	X				putc('\n', tmpfp);
	X				consec_newlines--;
	X				linecount++;
	X			}
	X 		}
	X#endif /* !NFSCLIENT */
	X		if (mode != PROC && tty && STRCMP(bfr, ".\n") == 0)
	X			break;
	X		for (cp = bfr; c = toascii(*cp); cp++) {
	X			if (isprint(c) || isspace(c) || c == '\b')
	X				putc(c, tmpfp);
	X			if (c == '\n')
	X				linecount++;
	X		}
	X		if (bfr[0] == '>')
	X			linserted++;
	X		if (bfr[0] == '<') /* kludge to allow diff's to be posted */
	X			linserted--;
	X		empty = FALSE;
	X	}
	X	if (*filename)
	X		(void) fclose(infp);
	X	if (mode != PROC &&
	X		linecount > LNCNT && linserted > (linecount-linserted))
	X		error("Article rejected: %s included more text than new text",
	X			username);
	X
	X	if (mode != PROC && !is_ctl && header.sender[0] == '\0' && !Sflag) {
	X		int siglines = 0;
	X		char sbuf[BUFLEN];
	X		(void) sprintf(bfr, "%s/%s", userhome, ".signature");
	X		if (access(bfr, 4) == 0) {
	X			if ((infp = fopen(bfr, "r")) == NULL) {
	X				(void) fprintf(stderr,
	X    "inews: \"%s\" left off (must be readable by \"inews\" owner)\n", bfr);
	X				goto finish;
	X			}
	X
	X			while (fgets(sbuf, sizeof sbuf, infp) != NULL)
	X				if (++siglines > 4)
	X					break;
	X			if (siglines > 4)
	X				fprintf(stderr,".signature not included (> 4 lines)\n");
	X			else {
	X				rewind(infp);
	X				fprintf(tmpfp, "-- \n");	/* To separate */
	X				linecount++;
	X				while ((c = getc(infp)) != EOF) {
	X					putc(c, tmpfp);
	X					if (c == '\n')
	X						linecount++;
	X				}
	X			}
	X			(void) fclose(infp);
	X		}
	X	}
	X
	Xfinish:
	X	if (ferror(tmpfp))
	X		xerror("write failed to temp file");
	X	(void) fclose(tmpfp);
	X	if (SigTrap) {
	X		if (tty)
	X			fprintf(stderr, "Interrupt\n");
	X		if (tty && !empty)
	X			fwait(fsubr(newssave, (char *) NULL, (char *) NULL));
	X		if (!tty)
	X			log("Blown away by an interrupt %d", SigTrap);
	X		xxit(1);
	X	}
	X	if (tty)
	X		fprintf(stderr, "EOT\n");
	X	fflush(stdout);
	X	infp = fopen(INFILE, "r");
	X	if (header.numlines[0]) {
	X		/*
	X		 * Check line count if there's already one attached to
	X		 * the article.  Could make this a fatal error -
	X		 * throwing it away if it got chopped, in hopes that
	X		 * another copy will come in later with a correct
	X		 * line count.  But that seems a bit much for now.
	X		 */
	X		if (linecount != header.intnumlines) {
	X			if (linecount == 0)
	X				error("%s rejected. linecount expected %d, got 0", header.ident, header.intnumlines);
	X			if (linecount > header.intnumlines ||
	X			    linecount+consec_newlines < header.intnumlines)
	X				log("linecount expected %d, got %d", header.intnumlines, linecount+consec_newlines);
	X		}
	X		/* adjust count for blank lines we stripped off */
	X		if (consec_newlines) {
	X			header.intnumlines -= consec_newlines;
	X			if (header.intnumlines < 0 )
	X				header.intnumlines = 0; /* paranoia */
	X			(void) sprintf(header.numlines, "%d", header.intnumlines);
	X		}
	X
	X	} else {
	X		/* Attach a line count to the article. */
	X		header.intnumlines = linecount;
	X		(void) sprintf(header.numlines, "%d", linecount);
	X	}
	X}
	X
	X#ifndef NFSCLIENT
	X
	X/*
	X * Make the directory for a new newsgroup.  ngname should be the
	X * full pathname of the directory.  Do the other stuff too.
	X * The various games with setuid and chown are to try to make sure
	X * the directory is owned by NEWSUSR and NEWSGRP, which is tough to
	X * do if you aren't root.  This will work on a UCB system (which allows
	X * setuid(geteuid()) or a USG system (which allows you to give away files
	X * you own with chown), otherwise you have to change your kernel to allow
	X * one of these things or run with your dirs 777 so that it doesn't matter
	X * who owns them.
	X */
	Xmknewsg(fulldir, ngname)
	Xchar	*fulldir;
	Xchar	*ngname;
	X{
	X#ifdef USG
	X	register char *p;
	X	char parent[200];
	X	char sysbuf[200];
	X	struct stat sbuf;
	X#endif /* USG */
	X
	X	if (ngname == NULL || !isalpha(ngname[0]))
	X		xerror("Tried to make illegal newsgroup %s", ngname);
	X
	X#ifdef USG
	X	/*
	X	 * If the parent is 755 the setuid(getuid)
	X	 * will fail, and since mkdir is suid, and our real uid is random,
	X	 * the mkdir will fail.  So we have to temporarily chmod it to 777.
	X	 */
	X	(void) strcpy(parent, fulldir);
	X	while (p = rindex(parent, '/')) {
	X		*p = '\0';
	X		if (stat(parent, &sbuf) == 0) {
	X			(void) chmod(parent, 0777);
	X			break;
	X		}
	X	}
	X#endif /* USG */
	X
	X	/* Create the directory */
	X	mkparents(fulldir);
	X	if (mkdir(fulldir, 0777) < 0)
	X		xerror("Cannot mkdir %s: %s", fulldir, errmsg(errno));
	X
	X#ifdef USG
	X	/*
	X	 * Give away the directories we just created which were assigned
	X	 * our real uid.
	X	 */
	X	(void) setuid(uid);
	X	(void) chown(fulldir, duid, dgid);
	X
	X	(void) strcpy(sysbuf, fulldir);
	X	while (p = rindex(sysbuf, '/')) {
	X		*p = '\0';
	X		/* stop when get to last known good parent */
	X		if (STRCMP(sysbuf, parent) == 0)
	X			break;
	X		(void) chown(sysbuf, duid, dgid);
	X	}
	X	(void) setuid(duid);
	X	(void) chmod(parent, (int)sbuf.st_mode);	/* put it back */
	X#endif /* USG */
	X
	X	log("make newsgroup %s in dir %s", ngname, fulldir);
	X}
	X
	X/*
	X * If any parent directories of this dir don't exist, create them.
	X */
	Xmkparents(dname)
	Xchar *dname;
	X{
	X	char buf[200];
	X	register char *p;
	X
	X	(void) strcpy(buf, dname);
	X	p = rindex(buf, '/');
	X	if (p)
	X		*p = '\0';
	X	if (exists(buf))
	X		return;
	X	mkparents(buf);
	X	if (mkdir(buf, 0777) < 0)
	X		xerror("Can not mkdir %s: %s", buf, errmsg(errno));
	X}
	X
	Xdounspool()
	X{
	X	register DIR	*dirp;
	X	register struct direct *dir;
	X	register int foundsome;
	X	int pid, status, ret;
	X	char spbuf[BUFLEN];
	X#ifdef LOCKF
	X	FILE* LockFd;
	X#endif /* LOCKF */
	X#ifdef VMS
	X	sprintf(spbuf, "%s/+rnews", SPOOL);
	X#else /* !VMS */
	X	sprintf(spbuf, "%s/.rnews", SPOOL);
	X#endif /* !VMS */
	X
	X	if (chdir(spbuf) < 0)
	X		xerror("chdir(%s):%s", spbuf, errmsg(errno));
	X
	X	dirp = opendir(".");
	X	if (dirp == NULL)	/* Boy are things screwed up */
	X		xerror("opendir can't open .:%s", errmsg(errno));
	X#ifdef	LOCKF
	X	LockFd = xfopen(SEQFILE, "r+w");
	X	if (lockf(fileno(LockFd), F_TLOCK, 0L) < 0) {
	X		if (errno != EAGAIN && errno != EACCES)
	X#else	/* !LOCKF */
	X#ifdef BSD4_2
	X	if (flock(dirp->dd_fd, LOCK_EX|LOCK_NB) < 0) {
	X		if (errno != EWOULDBLOCK)
	X#else	/* V7 */
	X	strcat(spbuf, ".lock");
	X	sprintf(bfr, "%s.tmp", spbuf);
	X	(void) close(creat(bfr, 0666));
	X	ret = LINK(bfr, spbuf);
	X	status = errno;
	X	(void) UNLINK(bfr);
	X	errno = status;
	X	if (ret < 0) {
	X		if (errno != EEXIST)
	X#endif /* V7 */
	X#endif	/* !LOCKF */
	X			xerror("Can't lock %s: %s", spbuf, errmsg(errno));
	X		xxit(3); /* another rnews -U is running */
	X	}
	X
	X	do {
	X		foundsome = 0;
	X
	X		while ((dir=readdir(dirp)) != NULL) {
	X			if (dir->d_name[0] == '.')
	X				continue;
	X
	X#ifdef IHCC
	X			log("Unspooling from %s", dir->d_name);
	X#endif /* IHCC */
	X
	X			if ((pid=vfork()) == -1)
	X				xerror("Can't fork: %s", errmsg(errno));
	X			if (pid == 0) {
	X#ifdef LOGDIR
	X				char bufr[BUFSIZ];
	X				sprintf(bufr, "%s/%s", logdir(HOME), RNEWS);
	X				execl(bufr, "rnews", "-S", "-p", dir->d_name,
	X					(char *) NULL);
	X#else /* !LOGDIR */
	X				execl(RNEWS, "rnews", "-S", "-p", dir->d_name,
	X					(char *) NULL);
	X#endif /* !LOGDIR */
	X				_exit(1);
	X			}
	X			
	X			while ((ret=wait(&status)) != pid && ret != -1)
	X				/* continue */;
	X
	X			if (((status>>8)&0177) == 42) {
	X				/* expire has started up, shutdown rnews -U */
	X				break;
	X			}
	X
	X			if (status != 0) {
	X				sprintf(bfr, "../%s", dir->d_name);
	X				(void) LINK(dir->d_name, bfr);
	X				logerr("rnews failed, status %ld. Batch saved in %s/%s",
	X					(long)status, SPOOL, dir->d_name);
	X			}
	X			(void) unlink(dir->d_name);
	X			foundsome++;
	X		}
	X		rewinddir(dirp);
	X	} while (foundsome); /* keep rereading the directory until it's empty */
	X#ifndef LOCKF
	X#ifndef BSD4_2
	X	(void) UNLINK(spbuf);
	X#endif
	X#endif
	X
	X	xxit(0);
	X}
	X#endif /* !NFSCLIENT */
SHAR_EOF
if test 38632 -ne "`wc -c < 'inews.c'`"
then
	echo shar: error transmitting "'inews.c'" '(should have been 38632 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'logdir.c'" '(2152 characters)'
if test -f 'logdir.c'
then
	echo shar: will not over-write existing file "'logdir.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'logdir.c'
	X/*
	X *	UNIX shell - logdir routine
	X *
	X *	Joe Steffen
	X *	Bell Telephone Laboratories
	X *
	X *	This routine does not use the getpwent(3) library routine
	X *	because the latter uses the stdio package.  The allocation of
	X *	storage in this package destroys the integrity of the shell's
	X *	storage allocation.
	X *
	X *	Modified 2/82 by DJ Molny
	X *
	X *	This routine now implements name cacheing, so multiple requests
	X *	for the same logdir do not result in multiple open/reads of
	X *	/etc/passwd.  If the previous request was successful and the name
	X *	is the same as the last request, the same login directory is returned.
	X */
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)logdir.c	1.4	4/16/85";
	X#endif /* SCCSID */
	X
	X#define	BUFSIZ	160
	X
	Xstatic char line[BUFSIZ+1];
	X
	Xchar *
	Xlogdir(name)
	Xchar *name;
	X{
	X	int	pwf;
	X	static char lastname[BUFSIZ+1];
	X	static char lastdir[BUFSIZ+1];
	X	register char *p;
	X	register int i, j;
	X	char *getenv(), *field(), *strcpy();
	X	
	X	if (*lastdir && !strcmp(lastname,name))		/* djm */
	X		return(lastdir);
	X
	X	strcpy(lastname, name);			/* djm */
	X	strcpy(lastdir, "");			/* djm */
	X	
	X#ifdef IHCC
	X	/* if the logname is exptools, see if $TOOLS is set */
	X	if (strcmp(name, "exptools") &&
	X	    (p = getenv("TOOLS")) != 0 && *p != '\0') {
	X		strcpy(lastdir, p);
	X		return(lastdir);
	X	}
	X#endif
	X
	X	/* attempt to open the password file */
	X	if ((pwf = open("/etc/passwd", 0)) == -1)
	X		return(0);
	X		
	X	/* find the matching password entry */
	X	do {
	X		/* get the next line in the password file */
	X		i = read(pwf, line, BUFSIZ);
	X		for (j = 0; j < i; j++)
	X			if (line[j] == '\n')
	X				break;
	X		/* return a null pointer if the whole file has been read */
	X		if (j >= i)
	X			return(0);
	X		line[++j] = 0;			/* terminate the line */
	X		lseek(pwf, (long) (j - i), 1);	/* point at the next line */
	X		p = field(line);		/* get the logname */
	X	} while (strcmp(name, line) != 0);
	X	close(pwf);
	X	
	X	/* skip the intervening fields */
	X	p = field(p);
	X	p = field(p);
	X	p = field(p);
	X	p = field(p);
	X	
	X	/* return the login directory */
	X	field(p);
	X	strcpy(lastdir,p);			/* djm */
	X	return(p);
	X}
	X
	Xstatic char *
	Xfield(p)
	Xregister char *p;
	X{
	X	while (*p && *p != ':')
	X		++p;
	X	if (*p) *p++ = 0;
	X	return(p);
	X}
SHAR_EOF
if test 2152 -ne "`wc -c < 'logdir.c'`"
then
	echo shar: error transmitting "'logdir.c'" '(should have been 2152 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ndir.c'" '(2603 characters)'
if test -f 'ndir.c'
then
	echo shar: will not over-write existing file "'ndir.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'ndir.c'
	X#include "defs.h"
	X#if !defined(BSD4_2) && !defined(BSD4_1C) && !defined(HP9K5)
	X#ifdef M_XENIX
	X#include <sys/types.h>
	X#endif /* M_XENIX */
	X#include <sys/param.h>
	X#include "ndir.h"
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)ndir.c	1.12	10/15/87";
	X#endif /* SCCSID */
	X
	X/*
	X * support for Berkeley directory reading routine on a V7 file system
	X */
	X
	Xextern char *malloc();
	X
	X/*
	X * open a directory.
	X */
	XDIR *
	Xopendir(name)
	Xchar *name;
	X{
	X	register DIR *dirp;
	X	register int fd;
	X
	X	if ((fd = open(name, 0)) == -1)
	X		return NULL;
	X	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
	X		close (fd);
	X		return NULL;
	X	}
	X	dirp->dd_fd = fd;
	X	dirp->dd_loc = 0;
	X	return dirp;
	X}
	X
	X/*
	X * read an old style directory entry and present it as a new one
	X */
	X#ifdef pyr
	X/* Pyramid in the AT&T universe */
	X#define ODIRSIZ 248
	Xstruct olddirect {
	X	long	od_ino;
	X	short	od_fill1, od_fill2;
	X	char od_name[ODIRSIZ];
	X};
	X#else /* V7 file system */
	X#define	ODIRSIZ	14
	X
	Xstruct	olddirect {
	X	short	od_ino;
	X	char	od_name[ODIRSIZ];
	X};
	X#endif /* !pyr */
	X
	X/*
	X * get next entry in a directory.
	X */
	Xstruct direct *
	Xreaddir(dirp)
	Xregister DIR *dirp;
	X{
	X	register struct olddirect *dp;
	X	static struct direct dir;
	X
	X	for (;;) {
	X		if (dirp->dd_loc == 0) {
	X			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf, 
	X			    DIRBLKSIZ);
	X			if (dirp->dd_size <= 0)
	X				return NULL;
	X		}
	X		if (dirp->dd_loc >= dirp->dd_size) {
	X			dirp->dd_loc = 0;
	X			continue;
	X		}
	X		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
	X		dirp->dd_loc += sizeof(struct olddirect);
	X		if (dp->od_ino == 0)
	X			continue;
	X		dir.d_ino = dp->od_ino;
	X		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
	X		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
	X		dir.d_namlen = strlen(dir.d_name);
	X		dir.d_reclen = DIRSIZ(&dir);
	X		return (&dir);
	X	}
	X}
	X
	X/*
	X * close a directory.
	X */
	Xvoid
	Xclosedir(dirp)
	Xregister DIR *dirp;
	X{
	X	close(dirp->dd_fd);
	X	dirp->dd_fd = -1;
	X	dirp->dd_loc = 0;
	X	free((char *)dirp);
	X}
	X
	X/*
	X * seek to an entry in a directory.
	X * Only values returned by "telldir" should be passed to seekdir.
	X */
	Xvoid
	Xseekdir(dirp, loc)
	Xregister DIR *dirp;
	Xlong loc;
	X{
	X	long curloc, base, offset;
	X	struct direct *dp;
	X	long lseek(), telldir();
	X
	X	curloc = telldir(dirp);
	X	if (loc == curloc)
	X		return;
	X	base = loc & ~(DIRBLKSIZ - 1);
	X	offset = loc & (DIRBLKSIZ - 1);
	X	(void) lseek(dirp->dd_fd, base, 0);
	X	dirp->dd_loc = 0;
	X	while (dirp->dd_loc < offset) {
	X		dp = readdir(dirp);
	X		if (dp == NULL)
	X			return;
	X	}
	X}
	X
	X/*
	X * return a pointer into a directory
	X */
	Xlong
	Xtelldir(dirp)
	XDIR *dirp;
	X{
	X	return lseek(dirp->dd_fd, 0L, 1) - dirp->dd_size + dirp->dd_loc;
	X}
	X#endif /* !BSD4_2 && !BSD4_1C && !HP9K5 */
SHAR_EOF
if test 2603 -ne "`wc -c < 'ndir.c'`"
then
	echo shar: error transmitting "'ndir.c'" '(should have been 2603 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'pathinit.c'" '(11712 characters)'
if test -f 'pathinit.c'
then
	echo shar: will not over-write existing file "'pathinit.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'pathinit.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * This function initializes all the strings used for the various
	X * filenames.  They cannot be compiled into the program, since that
	X * would be non-portable.  With this convention, the netnews sub-system
	X * can be owned by any non-privileged user.  It is also possible
	X * to work when the administration randomly moves users from one
	X * filesystem to another.  The convention is that a particular user
	X * (HOME, see Makefile) is searched for in /etc/passwd and all files
	X * are presumed relative to there.  This method also allows one copy
	X * of the object code to be used on ANY machine.  (this code runs
	X * un-modified on 50+ machines at IH!!)
	X *
	X * The disadvantage to using this method is that all netnews programs
	X * (inews, readnews, rnews, checknews) must first search /etc/passwd
	X * before they can start up.  This can cause significant overhead if
	X * you have a big password file.
	X *
	X * Some games are played with ifdefs to get four .o files out of this
	X * one source file.  INEW is defined for inews, READ for readnews,
	X * CHKN for checknews, and EXP for expire.
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)pathinit.c	1.25	11/19/87";
	X#endif /* SCCSID */
	X
	X#if defined(INEW) || defined(EXP)
	X#include	"iparams.h"
	X#endif /* INEW || EXP */
	X
	X#ifdef READ
	X#include	"rparams.h"
	X#endif /* READ */
	X
	X#if defined(CHKN)
	X#include "params.h"
	X#endif /* CHKN */
	X
	X
	Xchar *FROMSYSNAME, *PATHSYSNAME, *LOCALSYSNAME, *LOCALPATHSYSNAME;
	Xchar *SPOOL, *LIB, *BIN, *ACTIVE, *SUBFILE, *ARTFILE,
	X	*username = "Unknown", *userhome;
	X
	X#ifdef INEW
	Xchar *LOCKFILE, *SEQFILE, *ARTICLE, *INFILE, *TELLME;
	Xint c_cancel();
	X
	X#ifdef NFSCLIENT
	Xchar *NFSSYSNAME;
	X#else /* !NFSCLIENT */
	Xint c_newgroup(), c_ihave(), c_sendme(), c_rmgroup(),
	X    c_sendsys(), c_version(), c_checkgroups(), c_unimp();
	X#endif /* !NFSCLIENT */
	X
	Xstruct msgtype msgtype[] = {
	X	"cancel", NULL, c_cancel,
	X#ifndef NFSCLIENT
	X	"newgroup", NULL, c_newgroup,
	X	"ihave", NULL, c_ihave,
	X	"sendme", NULL, c_sendme,
	X	"sendbad", NULL, c_sendme,
	X	"rmgroup", NULL, c_rmgroup,
	X	"sendsys", NULL, c_sendsys,
	X	"version", NULL, c_version,
	X	"checkgroups", NULL, c_checkgroups,
	X	"delsub", NULL, c_unimp,
	X#endif /* !NFSCLIENT */
	X	NULL, NULL, NULL
	X};
	X#endif /* INEW */
	X
	X#if defined(INEW) || defined(READ)
	Xchar *ALIASES, *BUGFILE;
	X#endif /* INEW || READ */
	X
	X#ifdef EXP
	Xchar *OLDNEWS;
	X#endif /* EXP */
	X
	X#ifdef READ
	Xchar *MAILPARSER;
	X#endif /* READ */
	X
	X
	Xstruct passwd *getpwnam();
	Xchar *rindex();
	X
	X#define Sprintf(where,fmt,arg)	(void) sprintf(bfr,fmt,arg); where = AllocCpy(bfr)
	X
	Xchar *
	XAllocCpy(cp)
	Xregister char *cp;
	X{
	X	register char *mp;
	X	char *malloc();
	X
	X	mp = malloc((unsigned)strlen(cp) + 1);
	X
	X	if (mp == NULL)
	X		xerror("malloc failed on %s", cp);
	X
	X	(void) strcpy(mp, cp);
	X	return mp;
	X}
	X
	Xpathinit()
	X{
	X#ifndef ROOTID
	X	struct passwd	*pw;	/* struct for pw lookup	*/
	X#endif /* !ROOTID */
	X#ifdef EXP
	X	char *p;
	X#endif /* EXP */
	X#ifndef CHKN
	X	struct utsname ubuf;
	X	char buf[BUFLEN];
	X	extern char *mydomain();
	X#endif /* CHKN */
	X
	X#ifdef HOME
	X	/* Relative to the home directory of user HOME */
	X	(void) sprintf(bfr, "%s/%s", logdir(HOME), SPOOLDIR);
	X	SPOOL = AllocCpy(bfr);
	X	(void) sprintf(bfr, "%s/%s", logdir(HOME), LIBDIR);
	X	LIB = AllocCpy(bfr);
	X#else /* !HOME */
	X	/* Fixed paths defined in Makefile */
	X	SPOOL = AllocCpy(SPOOLDIR);
	X	LIB = AllocCpy(LIBDIR);
	X#endif /* !HOME */
	X
	X#ifndef CHKN
	X	uname(&ubuf);
	X
	X#ifdef HIDDENNET_IN_LOCALSYSNAME
	X	/* old compatibility code, remove when HIDDENNET is used no more */
	X	if (STRCMP(ubuf.nodename, HIDDENNET) != 0)
	X		(void) sprintf(buf, "%s.%s%s", ubuf.nodename, HIDDENNET,
	X			mydomain());
	X	else
	X#endif
	X		(void) sprintf(buf, "%s%s", ubuf.nodename, mydomain());
	X	LOCALSYSNAME = AllocCpy(buf);
	X
	X#ifdef GENERICFROM
	X	(void) sprintf(buf, GENERICFROM, ubuf.nodename, mydomain());
	X	FROMSYSNAME = AllocCpy(buf);
	X#else /* !GENERICFROM */
	X	FROMSYSNAME = LOCALSYSNAME;
	X#endif /* !GENERICFROM */
	X
	X	LOCALPATHSYSNAME = AllocCpy(ubuf.nodename);
	X
	X#ifdef GENERICPATH
	X	(void) sprintf(buf, GENERICPATH, ubuf.nodename, mydomain());
	X	PATHSYSNAME = AllocCpy(buf);
	X#else	/* !GENERICPATH */
	X	PATHSYSNAME = LOCALPATHSYSNAME;
	X#endif	/* !GENERICPATH */
	X
	X#endif /* !CHKN */
	X
	X#ifdef LOGDIR
	X	(void) sprintf(bfr, "%s/%s", logdir(HOME), BINDIR);
	X	BIN = AllocCpy(bfr);
	X#else /* !LOGDIR */
	X	Sprintf(BIN, "%s", BINDIR);
	X#endif /* !LOGDIR */
	X
	X	Sprintf(ACTIVE, "%s/active", LIB);
	X
	X#ifdef EXP
	X	(void) strcpy(bfr, SPOOL);
	X	p = rindex(bfr, '/');
	X	if (p) {
	X		strcpy(++p, "oldnews");
	X		OLDNEWS = AllocCpy(bfr);
	X	} else
	X		OLDNEWS = AllocCpy("oldnews");
	X#endif /* EXP */
	X
	X#ifndef CHKN
	X	Sprintf(SUBFILE, "%s/sys", LIB);
	X	Sprintf(ARTFILE, "%s/history", LIB);
	X# endif /* !CHKN */
	X
	X# ifdef READ
	X#ifdef SENDMAIL
	X	Sprintf(MAILPARSER, "%s -oi -oem", SENDMAIL);
	X#else /* !SENDMAIL */
	X	Sprintf(MAILPARSER, "%s/recmail", LIB);
	X#endif /* !SENDMAIL */
	X# endif /* READ */
	X
	X# if defined(READ) || defined(INEW)
	X	Sprintf(ALIASES, "%s/aliases", LIB);
	X	Sprintf(BUGFILE, "%s/buggroups", LIB);
	X# endif /* READ || INEW */
	X# ifdef INEW
	X	Sprintf(LOCKFILE, "%s/LOCK", LIB);
	X	Sprintf(SEQFILE, "%s/seq", LIB);
	X#ifndef NFSCLIENT
	X	Sprintf(ARTICLE, "%s/.arXXXXXX", SPOOL);
	X	Sprintf(INFILE, "%s/.inXXXXXX", SPOOL);
	X#else /* NFSCLIENT */
	X	Sprintf(ARTICLE, "/tmp/.arXXXXXX", SPOOL);
	X	Sprintf(INFILE, "/tmp/.inXXXXXX", SPOOL);
	X	parse_nfssysname();
	X#endif /* NFSCLIENT */
	X/*
	X * The person notified by the netnews sub-system.  Again, no name is
	X * compiled in, but instead the information is taken from a file.
	X * If the file does not exist, a "default" person will get the mail.
	X * If the file exists, but is empty, nobody will get the mail.  This
	X * may seem backwards, but is a better fail-safe.
	X */
	X# ifdef NOTIFY
	X	parse_notify();
	X# endif /* NOTIFY */
	X
	X/*
	X * Since the netnews owner's id number is different on different
	X * systems, we'll extract it from the /etc/passwd file.  If no entry,
	X * default to root.  This id number seems to only be used to control who
	X * can input certain control messages or cancel any message.  Note that
	X * entry is the name from the "notify" file as found above if possible.
	X * Defining ROOTID in defs.h hardwires in a number and avoids
	X * another search of /etc/passwd.
	X */
	X# ifndef ROOTID
	X	if ((pw = getpwnam(TELLME)) != NULL)
	X		ROOTID =  pw->pw_uid;
	X	else if ((pw = getpwnam(HOME)) != NULL)
	X		ROOTID =  pw->pw_uid;
	X	else
	X		ROOTID = 0;		/* nobody left, let only root */
	X# endif /* !ROOTID */
	X#endif /* INEW */
	X}
	X
	X#ifdef INEW
	X#ifdef NOTIFY
	X/*
	X * Attempt to parse the LIB/notify file into the global structure msgtype[].
	X */
	Xparse_notify()
	X{
	X	FILE *nfd;
	X	int valid = 0, done = 0;
	X	register struct msgtype *mp;
	X	char mtype[BUFLEN], addr[BUFLEN];
	X
	X	(void) sprintf(bfr, "%s/notify", LIB);
	X#ifndef ROOTID
	X	TELLME = AllocCpy(NOTIFY);	
	X#endif /* !ROOTID */
	X	if ( (nfd = fopen(bfr, "r")) == NULL) {
	X		/* 
	X		 * Set defaults to NOTIFY
	X		 */
	X#ifdef debug
	X		log("parse_notify: %s/notify not found", LIB);
	X#endif /* debug */
	X		(void)setmsg("all", NOTIFY);
	X		return;
	X	}
	X	do  {
	X		mtype[0] = addr[0] = 0;
	X		switch( get_notify(nfd, mtype, addr) ) {
	X		case 0:
	X			continue;
	X		case 1:
	X			valid += setmsg(mtype, "");
	X			break;
	X		case 2:
	X			valid += setmsg(mtype, addr);
	X			break;
	X		case -1:
	X			if( !valid ) {
	X#ifdef debug
	X				log("parse_notify: no valid entries found.");
	X#endif /* debug */
	X				setmsg("all", ""); /* send mail to no one */
	X			}
	X			done = 1;
	X		}
	X	} while( !done );
	X
	X	/*
	X	 * point to zero length string for all entries we haven't touched
	X	 */
	X	for(mp=msgtype; mp->m_name; mp++)
	X		if(mp->m_who_to == 0)
	X			mp->m_who_to = "";
	X}
	X
	Xsetmsg(what, to)
	Xchar *what, *to;
	X{
	X	register struct msgtype *mp;
	X#ifdef debug
	X	log("setmsg: what='%s', to='%s'", what, to);
	X#endif /* debug */
	X	/*
	X	 * Special case for "all"
	X	 */
	X	if(STRCMP(what, "all") == 0) {
	X		for(mp=msgtype; mp->m_name; mp++) {
	X			mp->m_who_to = AllocCpy(to);
	X#ifdef debug
	X			log("setmsg: '%s'='%s'", mp->m_name, mp->m_who_to);
	X#endif /* debug */
	X		}
	X		return 1;
	X	}
	X
	X	for(mp=msgtype; mp->m_name; mp++)
	X		if(STRCMP(mp->m_name, what) == 0) {
	X			mp->m_who_to = AllocCpy(to);
	X#ifdef debug
	X			log("setmsg: '%s'='%s'", mp->m_name, mp->m_who_to);
	X#endif /* debug */
	X			return 1;
	X		}
	X	return 0;
	X}
	X
	Xstatic
	Xget_notify(fp, s, t)
	XFILE *fp;
	Xregister char *s, *t;
	X{
	X	register char *cp;
	X	char buf[BUFSIZ];
	X
	X	if( cp=fgets(buf, sizeof(buf), fp ) ) {
	X		if( *cp == '\n' ) 
	X			return 0;
	X		while(*cp && *cp != ' ' && *cp != '\t' && *cp != '\n')
	X			*s++ = *cp++;
	X		*s = '\0';	/* terminate first string */
	X
	X		while(*cp && (*cp == ' ' || *cp == '\t' || *cp == '\n') )
	X			cp++;	/* look for start of second */
	X		if( !*cp || *cp == '\n' )
	X			return 1; 	/* no second string */
	X		
	X		while( *cp && *cp != '\n' )
	X			*t++ = *cp++;
	X		*t = '\0';
	X		return 2;
	X	} else
	X		return -1;
	X}
	X#endif /* NOTIFY */
	X#ifdef NFSCLIENT
	Xparse_nfssysname()
	X{
	X	FILE *nfsfd;
	X	extern FILE *mailhdr();
	X	char *nfsp;
	X	char buf[BUFSIZ];
	X
	X	sprintf(buf, "%s/nfssysname", LIB);
	X
	X	if ((nfsfd = fopen(buf, "r"))) {
	X		(void) fgets(buf, sizeof buf, nfsfd);
	X		(void) fclose(nfsfd);
	X		if (nfsp = index(buf, '\n')) *nfsp = '\0';
	X		NFSSYSNAME = AllocCpy(buf);
	X		return;
	X	}
	X
	X	if (nfsfd = mailhdr((struct hbuf *)NULL, "Missing File")) {
	X		(void) fprintf(nfsfd, "Can't find %s.\n\n", buf);
	X		(void) fprintf(nfsfd, "On an NFS client, inews cannot ");
	X		(void) fprintf(nfsfd, "operate without this file.\n");
	X		(void) mclose(nfsfd);
	X	}
	X
	X	xerror("Can't find %s.\nComplain to your new/systems manager.\n", buf);
	X}	
	X#endif /* NFSCLIENT */
	X#endif /* INEW */
	X
	X#ifndef CHKN
	X/*
	X * At sites where the are many mail domains within the support area of a single
	X * news administrator, it is much nicer to be able to read the local domain of
	X * a machine from a file.  What we do here is:
	X * 1)	Check for the presence of a LIBDIR/localdomain file.  If it doesn't 
	X * 	exist,assume that MYDOMAIN should be used instead.
	X * 2)	If it does exist, we make the following assumptions:
	X *	a)  If it is empty, has only comments, or only blank lines; we assume
	X *	    the domain is desired to be a zero length string ( ie "").  (this
	X *	    implies that the domain name is contained in the hostname.)
	X *	b)  If it is not empty, we assume the first line not beginning with a
	X *	    '#', blank/tab, or newline is the desired domain name.
	X *	    A like '.UUCP' or '.TEK.COM' should be used.  We could insure that
	X *	    the line begin with a '.' to be a valid domain name, but I don't 
	X *	    think it is necessary to put that restriction on it.
	X */
	Xchar *
	Xmydomain()
	X{
	X	static char *md = NULL;
	X	register char *cp;
	X	FILE *fp = NULL;
	X	char fbuf[BUFLEN];
	X	extern char *malloc(), *strcpy(), *index();
	X
	X	if(md)	/* we've been here before, so just return what we found */
	X		return(md);
	X
	X	(void) sprintf(fbuf,"%s/localdomain", LIBDIR);
	X	if ( (fp = fopen(fbuf,"r")) == NULL) {
	X		md = MYDOMAIN;	/* No localdomain file, use MYDOMAIN instead */
	X	} else {
	X		while(fgets(fbuf, sizeof(fbuf), fp) ) {
	X			if( *fbuf == '\n' || *fbuf == '#' 
	X			    || *fbuf == ' ' || *fbuf == '\t')
	X				continue;
	X	
	X			if( cp = index(fbuf, '\n') )
	X				*cp = '\0';
	X	
	X			if ( (md = malloc(strlen(fbuf) + 1)) == NULL)
	X				md = MYDOMAIN;	/* punt here */
	X			else
	X				(void)strcpy(md, fbuf);
	X			break;
	X		}
	X	}
	X
	X	if(fp)
	X		(void)fclose(fp);
	X
	X	if( md == NULL)
	X		md = "";
	X	
	X	return md;
	X}
	X#endif /* !CHKN */
SHAR_EOF
if test 11712 -ne "`wc -c < 'pathinit.c'`"
then
	echo shar: error transmitting "'pathinit.c'" '(should have been 11712 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'postnews.c'" '(28052 characters)'
if test -f 'postnews.c'
then
	echo shar: will not over-write existing file "'postnews.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'postnews.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * Postnews: post a news message to Usenet.  This C version replaces a shell
	X * script, and does more intelligent prompting and filtering than possible
	X * in a shell script.
	X */
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)postnews.c	1.36	11/30/87";
	X#endif /* SCCSID */
	X
	X#include "params.h"
	X
	X# ifndef ROOTID
	Xextern int ROOTID;
	X# endif	/* !ROOTID */
	X#define APPEND 1
	X#define REPLACE 2
	X
	Xextern char *MAILPARSER;
	X
	Xchar tempfname[50];		/* file name used for making article */
	Xchar original[BUFLEN];		/* file name of original, used in followup */
	Xchar homedir[BUFLEN];		/* HOME environment setting */
	Xchar user[SBUFLEN];		/* user name */
	Xchar ccname[BUFLEN];		/* file name for article copy */
	X
	X/* article header information */
	Xchar subject[BUFLEN];
	Xchar distribution[BUFLEN];
	Xchar references[BUFLEN];
	Xchar newsgroups[BUFLEN];
	Xchar isfrom[BUFLEN];
	Xchar msgid[BUFLEN];
	Xchar keywords[BUFLEN];
	Xchar summary[BUFLEN];
	X
	Xchar ngsep[] = { NGDELIM, '\0' };	/* == "," */
	X
	Xchar *Progname = "postnews";		/* for xerror */
	X
	Xtime_t fmodtime;
	Xchar buf[BUFLEN];
	X
	X#define MAXDISTR	16
	Xstruct distr {
	X	char abbr[24];
	X	char descr[128];
	X} distr[MAXDISTR];
	X
	Xchar def_distr[24] = "";	/* default distribution */
	XFILE *xfopen();
	X
	Xmain(argc, argv)
	Xchar *argv[];
	X{
	X	register int c;
	X
	X	init();
	X
	X	if (argc == 2) {
	X		if (!PREFIX(argv[1], SPOOL))
	X			xerror("Can only followup to articles in %s", SPOOL);
	X#ifdef SERVER
	X		{
	X			int artnum;
	X			char * group, *p;
	X			strcpy (buf,argv[1]);
	X			if ((group = rindex(buf,'/')) == NULL)
	X				xerror("Can't get article number");
	X			*group = '\0';
	X			artnum = atoi(++group);
	X			if (artnum == 0) 
	X				xerror("Can't get article number");
	X			group = &buf[strlen(SPOOL) + 1];
	X			for (p=group; *p ;++p)
	X				if (*p == '/')
	X					*p = '.';
	X			if (getarticle(group,artnum,"ARTICLE") == NULL)
	X				xerror("Can't find article");
	X		}
	X		followup(article_name());
	X		(void) strcpy(original, article_name());
	X#else	/* !SERVER */
	X		followup(argv[1]);
	X		(void) strcpy(original, argv[1]);
	X#endif	/* !SERVER */
	X	} else
	X	if (askyes("Is this message in response to some other message? ","no")) {
	X		char ng[BUFLEN], num[BUFLEN];
	X		long i, j, lastnum;
	X		register char *p;
	X		int fd, dir;
	X		char canpost;
	X
	X		getpr("In what newsgroup was the article posted? ",ng);
	X		if (!valid_ng(ng, &i, &j, &canpost, TRUE))
	X			if (canpost == 'i' )
	X				byebye("There is no such newsgroup.");
	X			else if (canpost == 'n')
	X				byebye("You are not allowed to post to that group.");
	X
	X		printf("Valid article numbers are from %ld to %ld\n", j, i);
	X		lastnum = i + 1;
	X		dir = -1;
	X
	X		for(;;) {
	X			getpr("\nWhat was the article number? ", num);
	X			switch(num[0]) {
	X			case '+':
	X				dir = 1;
	X				sprintf(num, "%ld", lastnum + 1);
	X				break;
	X			case '-':
	X				dir = -1;
	X				/* no break */
	X			case '\0':
	X				sprintf(num, "%ld", lastnum + dir);
	X				break;
	X			}
	X#ifdef SERVER
	X			if (getarticle(ng, atoi(num), "ARTICLE") == NULL)
	X					goto nothere;
	X			strcpy(original, article_name());
	X#else	/* !SERVER */
	X			(void) sprintf(original, "%s/%s", SPOOL, ng);
	X			for (p=original+strlen(SPOOL)+1; *p ;++p)
	X				if (*p == '.')
	X					*p = '/';
	X			(void) strcat(original, "/");
	X			(void) strcat(original, num);
	X#endif	/* !SERVER */
	X			if ((fd=open(original,0)) >= 0) {
	X				(void) close(fd);
	X#ifdef SERVER
	X				printf("\narticle %s in %s\n", num, ng);
	X#else	/* !SERVER */
	X				printf("\narticle %s\n", original);
	X#endif	/* !SERVER */
	X				if (article_line(original, "From: ", buf))
	X					printf("%s\n", buf);
	X				if (article_line(original, "Subject: ", buf))
	X					printf("%s\n", buf);
	X				if (askyes("Is this the one you want? ", "n"))
	X					break;
	X			} else
	X#ifdef SERVER
	Xnothere:
	X#endif	/* !SERVER */
	X				printf("I can't find that article.\n");
	X			lastnum = atol(num);
	X		}
	X
	X		followup(original);
	X	} else {
	X		do {
	X			getpr("Subject: ", subject);
	X			if (*subject == '?') {
	Xprintf("People read the subject line to learn what your article is about.\n");
	Xprintf("You want it to do the same job as a newspaper headline.\n");
	Xprintf("So type in something both brief and descriptive.\n");
	X				*subject = '\0';
	X			}
	X		} while (*subject == '\0');
	X		getpr("Keywords: ", keywords);
	X
	X		while (!get_newsgroup())
	X			;
	X		get_distribution((char *)0);
	X	}
	X
	X	if (pre_checks())
	X		xxit(1);
	X
	X	prep_article();
	X	c = 'e';
	X	for (;;) {
	X		if (c == 'e') {
	X			edit_article();
	X			post_checks();
	X		}
	X		do {
	X			do {
	X				getpr("\nWhat now?  [send, edit, list, quit, write, append] ", buf);
	X				c = buf[0];
	X			} while (c == '\0');
	X			if (isupper(c))
	X				c = tolower(c);
	X			if (c == 'q') {
	X				(void) UNLINK(tempfname);
	X				xxit(1);
	X			}
	X			if (c == 'l') {
	X				char *pager = getenv("PAGER");
	X				char lbuf[BUFLEN];
	X				if (pager == NULL || *pager == '\0') {
	X#ifdef PAGE
	X# ifdef LOGDIR
	X					(void) sprintf(lbuf,"%s/bin/%s", logdir(HOME), PAGE);
	X# else /* !LOGDIR */
	X					(void) strcpy(lbuf, PAGE);
	X# endif /* !LOGDIR */
	X					pager = lbuf;
	X#else /* !PAGE */
	X					pager = "cat";
	X#endif /* !PAGE */
	X				}
	X				sprintf(buf, "exec %s %s", pager, tempfname);
	X				(void)  system(buf);
	X			}
	X			if (c == 'w' || c == 'a') {
	X				register int ifd, ofd, nbytes;
	X				char iobuf[BUFSIZ];
	X				char fname[BUFLEN];
	X				getpr("Filename? ", fname);
	X				if (fname[0] == '\0')
	X					continue;
	X				ofd = (c == 'w') ? creat(fname, 0666)
	X						 : open(fname, 2);
	X				if (ofd < 0)
	X					perror(fname);
	X				else {
	X					if (c == 'a')
	X						(void) lseek(ofd, 0L, 2);
	X					ifd = open(tempfname, 0);
	X					if (ifd < 0)
	X						xerror("Can't reopen %s\n", tempfname);
	X					while ((nbytes = read(ifd, iobuf, BUFSIZ)) > 0 )
	X						write(ofd, iobuf, nbytes);
	X					close(ofd);
	X					close(ifd);
	X				}
	X			}
	X		} while (!index("eps", c));
	X		if (c != 'e')
	X			post_article(); /* will exit if posted successfully */
	X	};
	X}
	X
	X/*
	X * Find out the topic of interest.
	X */
	Xget_newsgroup()
	X{
	X	int n;
	X	long i;
	X	char canpost;
	X	static int first = 1;
	X
	X	printf("Newsgroups (enter one at a time, end with a blank line):\n");
	X	if (first) {
	X		printf("\nThe most relevant newsgroup should be the first, you should\n");
	X		printf("add others only if your article really MUST be read by people\n");
	X		printf("who choose not to read the appropriate group for your article.\n");
	X		printf("But DO use multiple newsgroups rather than posting many times.\n\n");
	X		first = 0;
	X	}
	X#ifndef SERVER
	X	printf("For a list of newsgroups, type ?\n");
	X#endif	/* !SERVER */
	X	n = 0;
	X	newsgroups[0] = '\0';
	X
	X	for(;;) {
	X		getpr("> ", buf);
	X		if (buf[0] == '\0')
	X			if (n == 0)
	X				return FALSE;
	X			else
	X				return TRUE;
	X#ifndef SERVER
	X		if (buf[0] == '?'){
	X			char *pager = getenv("PAGER");
	X			char lbuf[BUFLEN];
	X			if (pager == NULL) {
	X#ifdef PAGE
	X# ifdef LOGDIR
	X				(void) sprintf(lbuf,"%s/bin/%s", logdir(HOME), PAGE);
	X# else /* !LOGDIR */
	X				(void) strcpy(lbuf, PAGE);
	X# endif /* !LOGDIR */
	X				pager = lbuf;
	X#else /* !PAGE */
	X				pager = "cat";
	X#endif /* !PAGE */
	X			}
	X			printf("These are the currently active groups:\n");
	X			(void) fflush(stdout);
	X			sprintf(buf, "exec %s %s/newsgroups", pager, LIB);
	X			(void) system(buf);
	X			continue;
	X		}
	X#endif	/* !SERVER */
	X		if (valid_ng(buf, &i, &i, &canpost, FALSE)) {
	X			if (n++ != 0)
	X				(void) strcat(newsgroups, ngsep);
	X			(void) strcat(newsgroups, buf);
	X		} else {
	X			if (canpost == 'n')
	X				printf("You are not allowed to post to %s\n",
	X					buf);
	X			else if (canpost == 'i')
	X				printf("%s is not a valid newsgroup.\n", buf);
	X		}
	X	}
	X}
	X
	X/*
	X * Find out how widely the author wants the message distributed.
	X */
	Xget_distribution(deflt)
	X	char *deflt;
	X{
	X	register int i;
	X	register char *r;
	X	char def[BUFLEN];
	X	char *lastgroup;
	X
	X	lastgroup = newsgroups;
	X	(void) strcpy(def, newsgroups);
	X	r = index(def, NGDELIM);
	X	if (r)
	X		*r = '\0';
	X	r = index(def, '.');
	X	if (r) {
	X		*r = '\0';
	X		if (STRCMP(def, "net") == 0)
	X			(void) strcpy(def, "world");
	X	} else {
	X		distribution[0] = '\0';
	X		return;
	X	}
	X
	X	if (STRCMP(def, "to") == 0) {
	X		/*
	X		 * This only works if "to.xx" is the first (or only)
	X		 * newsgroup, but it usually is ..
	X		 * Perhaps we should make the distribution be "to.xxx" ??
	X		 */
	X		distribution[0] = '\0';
	X		return;		/* He's probably testing something */
	X	}
	X	if (deflt != (char *)0)
	X		(void) strcpy(def, deflt);
	X	if (ngmatch("misc.test", newsgroups))
	X		(void) strcpy(def, "local");
	X	for (i=0; distr[i].abbr[0]; i++) {
	X		if (STRCMP(distr[i].abbr, def) == 0)
	X			break;
	X	}
	X	if (distr[i].abbr[0] == '\0')
	X		strcpy(def, def_distr);
	X	for(;;) {
	X		do {
	X			(void) sprintf(buf, "Distribution (default='%s', '?' for help) : ", def);
	X			getpr(buf, distribution);
	X			if (distribution[0] == '\0') {
	X				if (STRCMP(def, "*None*") == 0)
	X					printf("You must enter a distribution, '?' for help.\n");
	X				(void) strcpy(distribution, def);
	X			}
	X		} while (STRCMP(distribution, "*None*") == 0);
	X
	X		/* Did the user ask for help? */
	X		if (distribution[0] == '?') {
	X			printf("How widely should your article be distributed?\n\n");
	X			for (i=0; distr[i].abbr[0]; i++)
	X				printf("%s\t%s\n", distr[i].abbr, distr[i].descr);
	X			printf("\nEnter the word that specifies the distribution that you require.\n");
	X			continue;
	X		}
	X
	X#ifdef SERVER
	X		return;		/* can't do this yet */
	X#else	/* !SERVER */
	X		/* Check that it's a proper distribution */
	X		for (i=0; distr[i].abbr[0]; i++) {
	X			if (strncmp(distr[i].abbr, distribution, sizeof(distr[0].abbr)) == 0) {
	X				return;
	X			}
	X		}
	X		if (STRCMP(distribution, def) != 0)
	X			printf("Type ? for help.\n");
	X		else {
	X			int once = TRUE;
	X
	X			do {
	X				r = lastgroup;
	X				while (r = index(r, NGDELIM))
	X					if (!PREFIX(++r, def))
	X						break;
	X				if (r == NULL) {
	X					/*
	X					 * no newsgroups are distribution
	X					 * names, and user simply will
	X					 * not type a valid distribution,
	X					 * assume that the default is OK.
	X					 */
	X					distribution[0] = '\0';
	X					return;
	X				}
	X				lastgroup = r;
	X				if (once)
	X					printf("Sorry, '%s' is an unknown distribution.  Type ? for help.\n", def);
	X				once = FALSE;
	X				strcpy(def, r);
	X				r = index(def, NGDELIM);
	X				if (r)
	X					*r = '\0';
	X				r = index(def, '.');
	X			} while (r == NULL);
	X			*r = '\0';
	X			if (STRCMP(def, "net") == 0)
	X				strcpy(def, "world");
	X		}
	X#endif	/* !SERVER */
	X	}
	X}
	X
	X/*
	X * Do sanity checks before the author types in the message.
	X */
	Xpre_checks()
	X{
	X	if (recording(newsgroups))
	X		return 1;
	X	return 0;
	X}
	X
	X/*
	X * Set up the temp file with headers.
	X */
	Xprep_article()
	X{
	X	FILE *tf, *of;
	X	struct stat stbuf;
	X
	X	(void) strcpy(tempfname, "/tmp/postXXXXXX");
	X	MKTEMP(tempfname);
	X
	X	/* insert a header */
	X	tf = xfopen(tempfname, "w");
	X	fprintf(tf, "Subject: %s\n", subject);
	X	fprintf(tf, "Newsgroups: %s\n", newsgroups);
	X	if (distribution[0] != '\0' && STRCMP(distribution, "world"))
	X		fprintf(tf, "Distribution: %s\n", distribution);
	X
	X	if (keywords[0] != '\0')
	X		fprintf(tf, "Keywords: %s\n", keywords);
	X	if (summary[0] != '\0')
	X		fprintf(tf, "Summary: %s\n", summary);
	X
	X	if (references[0] != '\0') {
	X		fprintf(tf, "References: %s\n\n", references);
	X
	X		if (askyes("Do you want to include a copy of the article? ", "no")){
	X			of = xfopen(original, "r");
	X			while (fgets(buf, BUFSIZ, of) != NULL)
	X				if (buf[0] == '\n')	/* skip headers */
	X					break;
	X			fprintf(tf, "In article %s, %s writes:\n", msgid, isfrom);
	X			while (fgets(buf, BUFSIZ, of) != NULL)
	X				fprintf(tf, "> %s", buf);
	X			(void) fclose(of);
	X			printf("OK, but please edit it to suppress unnecessary verbiage, signatures, etc.\n");
	X			(void) fflush(stdout);
	X		}
	X	}
	X
	X	fprintf(tf, "\n\n");
	X	(void) fflush(tf);
	X	(void) fstat(fileno(tf), &stbuf);
	X	fmodtime = stbuf.st_mtime;
	X	(void) fclose(tf);
	X}
	X
	Xedit_article()
	X{
	X	register char *p;
	X	char *editor;
	X	char *endflag = "";
	X	char *getenv();
	X
	X	/* edit the file */
	X	editor = getenv("EDITOR");
	X	if (editor == NULL)
	X		editor = DFTEDITOR;
	X
	X	p = editor + strlen(editor) - 2;
	X	if (STRCMP(p, "vi") == 0)
	X		endflag = "+";
	X
	X	(void) sprintf(buf, "A=%s;export A;exec %s %s %s",
	X		original, editor, endflag, tempfname);
	X
	X	(void) system(buf);
	X}
	X
	X/*
	X * Do sanity checks after the author has typed in the message.
	X */
	Xpost_checks()
	X{
	X	char group[BUFLEN];
	X	register char *c, *p;
	X	struct stat stbuf;
	X
	X	if (stat(tempfname, &stbuf) < 0) {
	X		printf("File deleted - no message posted.\n");
	X		(void) UNLINK(tempfname);
	X		xxit(1);
	X	}
	X	if (stbuf.st_size < 5) {
	X		printf("File too small (<5 characters) - no message posted.\n");
	X		(void) UNLINK(tempfname);
	X		xxit(1);
	X	}
	X
	X	if (stbuf.st_mtime == fmodtime) {
	X		printf("File not modified - no message posted.\n");
	X		(void) UNLINK(tempfname);
	X		xxit(1);
	X	}
	X
	X	/*
	X	 * Is this the right number?  Most of the headers are yet to be added
	X	 */
	X	if (stbuf.st_size > 64000) {
	X		printf("\nYour message will probably be truncated when it\n");
	X		printf("passes through a notesfile site, since it is\n");
	X		printf("greater than 64000 characters.\n\n");
	X		if (!askyes("Do you still want to post it? ","")) {
	X			sprintf(ccname, "%s/dead.article", homedir);
	X			save_article();
	X			(void) UNLINK(tempfname);
	X			xxit(1);
	X		}
	X	}
	X
	X	/*
	X	 * get the newsgroups from the edited article, in
	X	 * case they were altered in the editor
	X	 */
	X	if (!article_line(tempfname, "Newsgroups: ", group)) {
	X  nogroups:
	X		printf("Not sending to any newsgroups - no message posted\n");
	X		sprintf(ccname, "%s/dead.article", homedir);
	X		save_article();
	X		(void) UNLINK(tempfname);
	X		xxit(1);
	X	}
	X	c = &group[11];
	X	while (*c == ' ' || *c == '\t')
	X		c++;
	X	if (*c == '\0')
	X		goto nogroups;
	X	for (p = newsgroups; *c; c++)	/* copy to newsgroups, w/o blanks */
	X		if (*c != ' ' && *c != '\t')
	X			*p++ = *c;
	X	*p = '\0';
	X
	X	/* Sanity checks for certain newsgroups */
	X	if (ngmatch(newsgroups, "all.wanted") && ngmatch(distribution,"world,na,usa,att,btl,eunet,aus")) {
	X		printf("Is your message something that might go in your local\n");
	X		printf("newspaper, for example a used car ad, or an apartment\n");
	X		printf("for rent? ");
	X		if (askyes("","")) {
	X			printf("It's pointless to distribute your article widely, since\n");
	X			printf("people more than a hundred miles away won't be interested.\n");
	X			printf("Please use a more restricted distribution.\n");
	X			get_distribution("*None*");
	X			modify_article(tempfname, "Distribution: ", distribution,REPLACE);
	X		}
	X	}
	X
	X	if (ngmatch(newsgroups, "rec.humor,!rec.humor.all")) {
	X		if (askyes("Could this be offensive to anyone? ","")) {
	X			getpr("Whom might it offend? ", group);
	X			(void) sprintf(buf," - offensive to %s (rot 13)",group);
	X			modify_article(tempfname, "Subject: ", buf, APPEND);
	X			encode(tempfname);
	X		}
	X	}
	X
	X	if (ngmatch(newsgroups, "comp.sources.all,!comp.sources.wanted,!comp.sources.d")) {
	X		if (!article_line(tempfname, "Subject: ", group)) {
	X  nosubj:
	X			printf("There seems to be no subject for this article.\n");
	X			getpr("Subject: ", subject);
	X			modify_article(tempfname, "Subject: ", subject, REPLACE);
	X		} else {
	X			c = &group[8];
	X			while (*c == ' ' || *c == '\t')
	X				c++;
	X			if (*c == '\0')
	X				goto nosubj;
	X			strcpy(subject, c);
	X		}
	X		if (ngmatch(newsgroups, "all.wanted") || iswanted(subject)) {
	X			printf("Requests for sources should not be posted to any of\n");
	X			printf("the comp.sources newsgroups, please post such requests\n");
	X			printf("to comp.sources.wanted only.     Please reenter the newsgroups.\n\n");
	X			while (!get_newsgroup())
	X				;
	X			modify_article(tempfname, "Newsgroups: ", newsgroups, REPLACE);
	X		}
	X		if (ngmatch(newsgroups, "comp.sources.all")) {
	X			if (!ngmatch(newsgroups, "comp.sources.wanted") &&
	X			    stbuf.st_size < (4*1024)) {
	X				printf("Your article seems rather small to be a source distribution.\n");
	X				if (!askyes("Are you certain that this is really source? ", "")) {
	X
	X					while (!get_newsgroup())
	X						;
	X					modify_article(tempfname, "Newsgroups: ", newsgroups, REPLACE);
	X				}
	X			}
	X			if (index(newsgroups, NGDELIM)) {
	X				printf("Sources should be posted to one newsgroup only.\n");
	X				printf("Please pick the most appropriate group for your article.\n\n");
	X				while (!get_newsgroup())
	X					;
	X				modify_article(tempfname, "Newsgroups: ", newsgroups, REPLACE);
	X			}
	X		}
	X	}
	X}
	X
	Xiswanted(str)
	Xregister char *str;
	X{
	X	while (*str == ' ')
	X		str++;
	X
	X	if (PREFIX(str, "Re:"))
	X		return (FALSE);
	X
	X	if (isin(str, " wanted ") || isin(str, " can any") ||
	X	    isin(str, " need ") || isin(str, " please ") || isin(str, " help ")
	X	    || isin(str, " looking ") || index(str, '?'))
	X		return (TRUE);
	X
	X	return (FALSE);
	X}
	X
	Xisin(str, words)
	Xregister char *str, *words;
	X{
	X	register char *p;
	X	register sc, wc;
	X
	X	p = words;
	X	while (sc = *str++) {
	X		if ((wc = *p++) == '\0')
	X			return (TRUE);
	X		if (wc == ' ') {
	X			if (index(".,!?-; \t\n", sc))
	X				continue;
	X		} else {
	X			if (isupper(wc))
	X				wc = tolower(wc);
	X			if (isupper(sc))
	X				sc = tolower(sc);
	X			if (wc == sc)
	X				continue;
	X		}
	X		str -= p - words - 1;
	X		p = words;
	X	}
	X	if (*p == '\0')
	X		return (TRUE);
	X	return (FALSE);
	X}
	X
	X/*
	X * Save a copy of the article in the users NEWSARCHIVE directory.
	X */
	Xsave_article()
	X{
	X	FILE *in, *out;
	X	int c;
	X	time_t timenow, time();
	X	char *today, *ctime();
	X	struct stat stbuf;
	X	char filename[BUFLEN];
	X
	X	if (stat(ccname, &stbuf) == 0 && (stbuf.st_mode&S_IFMT) == S_IFDIR) {
	X		/*
	X		 * It would be much nicer here to write articles
	X		 * in MH format (numbered files, in rfc822 format)
	X		 *
	X		 * one day ..
	X		 */
	X		(void) sprintf(filename, "%s/author_copy", ccname);
	X		(void) strcpy(ccname, filename);
	X	}
	X	in = xfopen(tempfname, "r");
	X	out = xfopen(ccname, "a");
	X	timenow = time((time_t)0);
	X	today = ctime(&timenow);
	X	fprintf(out,"From postnews %s",today);
	X	while ((c=getc(in)) != EOF)
	X		putc(c, out);
	X	putc('\n', out);
	X	(void) fclose(in);
	X	(void) fclose(out);
	X}
	X
	X/*
	X * Post the article to the net.
	X */
	Xpost_article()
	X{
	X	int status;
	X
	X	printf("Posting article...\n");
	X	fflush(stdout);
	X	(void) sprintf(buf, "exec %s/%s -h < %s", LIB, "inews", tempfname);
	X	status = system(buf);
	X
	X	if (status) {
	X		printf("Article not posted - exit status %d\n", status);
	X		return;
	X	} else
	X		printf("Article posted successfully.\n");
	X
	X	if (ccname[0]) {
	X		printf("A copy has been saved in %s\n", ccname);
	X		save_article();
	X	}
	X	(void) UNLINK(tempfname);
	X	xxit(0);
	X}
	X
	X/*
	X * Initialization.
	X */
	Xinit()
	X{
	X	FILE *fd;
	X	register char *p;
	X	int i;
	X	char *getenv();
	X	struct passwd *pw;
	X
	X	references[0] = '\0';
	X	distribution[0] = '\0';
	X
	X	uid = getuid();
	X	pw = getpwuid(uid);
	X	if (pw == NULL) {
	X		fprintf(stderr,"You're not in /etc/passwd\n");
	X		xxit(1);
	X	}
	X	p = getenv("HOME");
	X	if (p == NULL) {
	X		p = getenv("LOGDIR");
	X		if (p == NULL) 
	X			p = pw->pw_dir;
	X	}
	X	(void) strncpy(user, pw->pw_name, SBUFLEN);
	X	(void) strcpy(homedir, p);
	X
	X	p = getenv("NEWSARCHIVE");
	X	if (p != NULL) {
	X		if (*p == '\0')
	X			sprintf(ccname, "%s/author_copy", homedir);
	X		else
	X			strcpy(ccname, p);
	X	}
	X
	X	pathinit();
	X#ifdef SERVER
	X	if (open_server() < 0) 
	X		xerror("Server error");
	X			/* do something to some up with distributions */
	X	if ((fd = open_active()) == NULL)
	X		xerror("Server error");
	X	strcpy(ACTIVE,active_name());
	X#else	/* !SERVER */
	X	(void) sprintf(buf, "%s/%s", LIB, "distributions");
	X
	X	fd = xfopen(buf, "r");
	X	for (i=0; i < MAXDISTR; i++) {
	X		if (fscanf(fd, "%s %[^\n]", distr[i].abbr, distr[i].descr)
	X			!= 2)
	X			break;
	X		if (STRCMP(distr[i].abbr, "default") == 0)
	X			strcpy(def_distr, distr[i--].descr);
	X	}
	X#endif	/* !SERVER */
	X	(void) fclose(fd);
	X	distr[i].abbr[0] = '\0';
	X	if (def_distr[0] == '\0')
	X		strcpy(def_distr, "world");	/* maybe "local" is better? */
	X}
	X
	X/*
	X * Get a yes or no answer to a question.	A default may be used.
	X */
	Xaskyes(msg, def)
	Xchar *msg, *def;
	X{
	X	for(;;) {
	X		printf("%s", msg);
	X		buf[0] = 0;
	X		(void) gets(buf);
	X		switch(buf[0]) {
	X		case 'y':
	X		case 'Y':
	X			return TRUE;
	X		case 'n':
	X		case 'N':
	X			return FALSE;
	X		case '\0':
	X			switch(*def) {
	X			case 'y':
	X			case 'Y':
	X				return TRUE;
	X			case 'n':
	X			case 'N':
	X				return FALSE;
	X			}
	X		default:
	X			printf("Please answer yes or no.\n");
	X		}
	X	}
	X}
	X
	X/*
	X * Get a character string into buf, using prompt msg.
	X */
	Xgetpr(msg, bptr)
	Xchar *msg, *bptr;
	X{
	X	static int numeof = 0;
	X	printf("%s", msg);
	X	(void) gets(bptr);
	X	(void) nstrip(bptr);
	X	if (feof(stdin)) {
	X		if (numeof++ > 3) {
	X			fprintf(stderr,"Too many EOFs\n");
	X			xxit(1);
	X		}
	X		clearerr(stdin);
	X	}
	X}
	X
	Xbyebye(mesg)
	Xchar *mesg;
	X{
	X	printf("%s\n", mesg);
	X	xxit(1);
	X}
	X
	X/*
	X * make a modification to the header of an article
	X *
	X *	 fname -- name of article
	X *	 field -- header field to modify
	X *	 line	-- modification line
	X *	 how	 -- APPEND or REPLACE
	X *
	X * example:
	X *	 modify_article("/tmp/article" , "Subject:" , "new subject" , REPLACE);
	X *
	X *
	X */
	Xmodify_article(fname, field, line, how)
	Xchar *fname, *field, *line;
	X{
	X	FILE *fpart, *fptmp;
	X	char *temp2fname = "/tmp/postXXXXXX";
	X	char lbfr[BUFLEN];
	X	register found = FALSE;
	X
	X	MKTEMP(temp2fname);
	X
	X	fptmp = xfopen(temp2fname, "w");
	X	fpart = xfopen(fname, "r");
	X
	X	while (fgets(lbfr, BUFLEN, fpart) != NULL) {
	X		if (PREFIX(lbfr, field)) {
	X			found = TRUE;
	X			(void) nstrip(lbfr);
	X			if (how == APPEND) {
	X				/* append to current field */
	X				(void) strcat(lbfr, line);
	X				(void) strcat(lbfr, "\n");
	X			} else
	X				/* replace current field */
	X				(void) sprintf(lbfr, "%s%s\n", field, line);
	X		}
	X		(void) fputs(lbfr, fptmp);
	X	}
	X
	X	fclose(fpart);
	X	fclose(fptmp);
	X
	X	fptmp = xfopen(temp2fname, "r");
	X	fpart = xfopen(fname, "w");
	X
	X	if (!found)
	X		fprintf(fpart, "%s%s\n", field, line);
	X	while (fgets(buf,BUFLEN,fptmp) != NULL)
	X		(void) fputs(buf, fpart);
	X
	X	(void) fclose(fpart);
	X	(void) fclose(fptmp);
	X	(void) UNLINK(temp2fname);
	X}
	X
	X
	X/* verify that newsgroup exists, and get number of entries */
	Xvalid_ng(ng, maxart, minart, canpost, exact)
	X     char *ng;
	X     
	Xlong *maxart, *minart;
	Xint exact;
	Xchar *canpost;
	X{
	X	char ng_check[BUFLEN], ng_read[BUFLEN], *cp;
	X	FILE *fp;
	X	int found_ng;
	X
	X	fp = xfopen(ACTIVE, "r");
	X	while (fgets(ng_read, BUFLEN, fp) != NULL) {
	X		switch (sscanf(ng_read, "%s %ld %ld %c", ng_check, maxart, minart, canpost)) {
	X		case 2:
	X			*minart = 1;
	X			/* fall through */
	X		case 3:
	X			*canpost = 'y';
	X			/* fall through */
	X		case 4:
	X			break;
	X
	X		default:
	X			printf("Active file (%s) corrupted. ", ACTIVE);
	X			byebye("Seek help!");
	X		}
	X			
	X		if (STRCMP(ng_check, ng) == 0) {
	X			(void) fclose(fp);
	X			if (*canpost != 'n') {
	X#ifdef FASCIST
	X				if (uid && uid != ROOTID && fascist(user, ng)) {
	X					*canpost = 'n';
	X					return FALSE;
	X				}
	X#endif /* FASCIST */
	X				return TRUE;
	X			} else
	X				return FALSE;
	X		}
	X	}
	X	(void) fclose(fp);
	X	*maxart = 0;
	X	*minart = 0;
	X	*canpost = 'i';
	X	if (exact) {
	X		return FALSE;
	X	}
	X	if ((fp = fopen(BUGFILE, "r")) == NULL) {
	X		return FALSE;
	X	}
	X	found_ng = FALSE;
	X	while (!found_ng && fgets(ng_check, BUFLEN, fp) == ng_check) {
	X		if (ng_check[0] == '#')
	X			continue;
	X		cp = index(ng_check, '\n');
	X		*cp = '.';
	X		if (prefix(ng, ng_check))
	X			found_ng = TRUE;
	X	}
	X	(void) fclose(fp);
	X	if (!found_ng)
	X		return FALSE;
	X	*canpost = 'y';
	X	return TRUE;
	X}
	X
	X/* get the line specified by field from an article */
	Xarticle_line(article, field, line)
	Xchar *article, *field, *line;
	X{
	X	FILE *fp;
	X	char *c;
	X
	X	fp = xfopen(article,"r");
	X	while ((c=fgets(line,BUFLEN,fp)) != NULL && !PREFIX(line, field))
	X		if (line[0] == '\n') {
	X			c = NULL;
	X			break;
	X		}
	X	(void) fclose(fp);
	X	if (c != NULL) {
	X		(void) nstrip(line);
	X		return TRUE;
	X	} else {
	X		line[0] = '\0';
	X		return FALSE;
	X	}
	X}
	X
	X/* get the header information for a followup article */
	Xfollowup(baseart)
	Xregister char *baseart;
	X{
	X	register char *p;
	X
	X	/* subject */
	X	if (article_line(baseart, "Subject: ", buf)) {
	X		p = buf+9;
	X		for ( ; ; ) {
	X			while (*p == ' ' || *p == '\t')
	X				++p;
	X			if ((*p != 'r' && *p != 'R') ||
	X				(p[1] != 'e' && p[1] != 'E') ||
	X				(p[2] != ':' && p[2] != ' '))
	X					break;
	X			p += 3;
	X		}
	X		(void) sprintf(subject, "Re: %s", p);
	X	} else {
	X		if (article_line(baseart, "From: ", buf))
	X			(void) sprintf(subject, "Re: orphan response from %s", buf);
	X		else
	X			(void) strcpy(subject, "Re: orphan response");
	X	}
	X
	X	/* newsgroup */
	X	if (article_line(baseart, "Newsgroups: ", buf))
	X		(void) strcpy(newsgroups, buf+12);
	X	if (ngmatch(newsgroups, "misc.jobs.all,!misc.jobs.misc")) {
	X		printf("Your followup has been directed to misc.jobs.misc\n");
	X		printf("It is the proper place for followup discussions\n");
	X		(void) strcpy(newsgroups,"misc.jobs.misc");
	X	}
	X
	X	/* distribution */
	X	if (article_line(baseart, "Distribution: ", buf))
	X		(void) strcpy(distribution, buf+14);
	X
	X	/* references */
	X	if (article_line(baseart, "References: ", buf)) {
	X		register char *rcp;
	X		(void) strcpy(references, buf+12);
	X		(void) strcat(references, " ");
	X		/* keep the number of references to a reasonable number */
	X		rcp = rindex(references, ' '); /* Can not fail */
	X		while ((int)(rcp - references) > 70) {
	X			while (*--rcp != ' ')
	X				;
	X			rcp[1] = '\0';
	X		}
	X	}
	X	if (article_line(baseart, "Message-ID: ", buf)) {
	X		(void) strcat(references, buf+12);
	X		(void) strcpy(msgid, buf+12);
	X	}
	X
	X	if (article_line(baseart, "From: ", buf))
	X		(void) strcpy(isfrom, buf+6);
	X
	X	if (article_line(baseart, "Keywords: ", buf))
	X		(void) strcpy(keywords, buf+10);
	X
	X	if (article_line(baseart, "Followup-To: ", buf)) {
	X		(void) strcpy(newsgroups, buf+13);
	X		if (STRCMP(newsgroups, "poster") == 0)
	X			byebye("Mail followups directly to poster.");
	X	}
	X
	X	get_summary();
	X}
	X
	Xget_summary()
	X{
	X	register char *p;
	X	register i;
	X
	X	printf("Please enter a short summary of your contribution to the discussion\n");
	X	printf("Just one or two lines ...   (end with a blank line)\n");
	X	p = summary;
	X	for (i = 0; i < 3; i++) {	/* 3 * 80 < 256, should be safe .. */
	X		getpr(">\t", p);
	X		if (*p == '\0')
	X			break;
	X		p = index(p, '\0');
	X		(void) strcpy(p, "\n\t ");
	X		p += 3;
	X	}
	X	if (p > summary)
	X		p[-3] = '\0';
	X}
	X
	Xencode(article)
	Xchar *article;
	X{
	X	FILE *fpart, *fphead, *fpcoded;
	X	char *headerfile = "/tmp/pheadXXXXXX";
	X	char *codedfile = "/tmp/pcodeXXXXXX";
	X
	X	MKTEMP(headerfile);
	X	MKTEMP(codedfile);
	X
	X	fpart = xfopen(article, "r");
	X
	X	/* place article header in "headerfile" file */
	X	fphead = xfopen(headerfile, "w");
	X	while (fgets(buf, BUFLEN, fpart) != NULL) {
	X		(void) fputs(buf, fphead);
	X		if (buf[0] == '\n')
	X			break;
	X	}
	X	(void) fclose(fphead);
	X
	X	/* place article body in "codedfile" file */
	X	fpcoded = xfopen(codedfile, "w");
	X	while (fgets(buf, BUFLEN, fpart) != NULL)
	X		(void) fputs(buf, fpcoded);
	X	(void) fclose(fpcoded);
	X	(void) fclose(fpart);
	X
	X	/* encode body and put back together with header */
	X	(void) rename(headerfile, article);
	X
	X	(void) sprintf(buf,"exec %s/%s 13 < %s >> %s\n", LIB, "caesar", codedfile, article);
	X	printf("Encoding article -- please stand by\n");
	X	(void) fflush(stdout);
	X	if (system(buf)) {
	X		printf("encoding failed");
	X		xxit(2);
	X	}
	X	(void) UNLINK(codedfile);
	X}
	X
	X
	X/*
	X * Print a recorded message warning the poor luser what he is doing
	X * and demand that he understands it before proceeding.  Only do
	X * this for newsgroups listed in LIBDIR/recording.
	X */
	Xrecording(ngrps)
	Xchar *ngrps;
	X{
	X	char recbuf[BUFLEN];
	X	FILE *fd;
	X	char nglist[BUFLEN], fname[BUFLEN];
	X	int  c, n, yes, retval = 0;
	X
	X	(void) sprintf(recbuf, "%s/%s", LIB, "recording");
	X	fd = fopen(recbuf, "r");
	X	if (fd == NULL)
	X		return 0;
	X	while ((fgets(recbuf, sizeof recbuf, fd)) != NULL) {
	X		(void) sscanf(recbuf, "%s %s", nglist, fname);
	X		if (ngmatch(ngrps, nglist)) {
	X			(void) fclose(fd);
	X			if (fname[0] == '/')
	X				(void) strcpy(recbuf, fname);
	X			else
	X				(void) sprintf(recbuf, "%s/%s", LIB, fname);
	X			fd = fopen(recbuf, "r");
	X			if (fd == NULL)
	X				return 0;
	X			while ((c = getc(fd)) != EOF)
	X				putc(c, stderr);
	X			fclose(fd);
	X			fprintf(stderr, "Do you understand this?  Hit <return> to proceed, <BREAK> to abort: ");
	X			fflush(stderr);
	X			n = read(0, recbuf, 100);
	X			c = recbuf[0];
	X			yes = (c=='y' || c=='Y' || c=='\n' || c=='\n' || c==0);
	X			if (n <= 0 || !yes)
	X				retval = -1;
	X		}
	X	}
	X	return retval;
	X}
	X
	Xxxit(i)
	X{
	X#ifdef SERVER
	X	(void) UNLINK(original);
	X	(void) UNLINK(active_name());
	X#endif	/* SERVER */
	X	exit(i);
	X}
SHAR_EOF
if test 28052 -ne "`wc -c < 'postnews.c'`"
then
	echo shar: error transmitting "'postnews.c'" '(should have been 28052 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'process.c'" '(3695 characters)'
if test -f 'process.c'
then
	echo shar: will not over-write existing file "'process.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'process.c'
	X/*
	X * This software is Copyright (c) 1986 by Rick Adams.
	X *
	X * Permission is hereby granted to copy, reproduce, redistribute or
	X * otherwise use this software as long as: there is no monetary
	X * profit gained specifically from the use or reproduction or this
	X * software, it is not sold, rented, traded or otherwise marketed, and
	X * this copyright notice is included prominently in any copy
	X * made.
	X *
	X * The author make no claims as to the fitness or correctness of
	X * this software for any use whatsoever, and it is provided as is. 
	X * Any use of this software is at the user's own risk.
	X *
	X * process - process options for readnews/vnews
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)process.c	2.19	11/30/87";
	X#endif /* SCCSID */
	X
	X#include "rparams.h"
	X
	Xchar	coptbuf[LBUFLEN], datebuf[LBUFLEN];
	X
	X#define OPTION	0	/* pick up an option string */
	X#define STRING	1	/* pick up a string of arguments */
	X
	Xstruct optable *optpt, options[] = { /*
	Xoptlet	filchar	flag	newstate oldmode	newmode	buf	*/
	X'p',	'\0',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,	
	X't',	'\0',	FALSE,	STRING,	ANY,		UNKNOWN,header.title,	
	X'a',	' ',	FALSE,	STRING,	ANY,		UNKNOWN,datebuf,
	X'n',   NGDELIM,	FALSE,	STRING,	ANY,		UNKNOWN,header.nbuf,
	X'c',	' ',	FALSE,	STRING,	UNKNOWN,	UNKNOWN,coptbuf,	
	X'l',	' ',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,
	X'r',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X's',   NGDELIM,	FALSE,	STRING,	ANY,		UNKNOWN,header.nbuf,
	X'x',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X'h',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X#ifdef TMAIL
	X'M',	'\0',	FALSE,	OPTION,	UNKNOWN,	MAIL,	(char *)NULL,
	X#else /* !TMAIL */
	X'\377',	'\0',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,
	X#endif /* !TMAIL */
	X'f',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X'u',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X'e',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X'K',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
	X'A',	'\0',	FALSE,	OPTION, UNKNOWN,	UNKNOWN,(char *)NULL,
	X'\0',	'\0',	0,	0,	0,		0,	(char *)NULL
	X};
	X
	Xprocess(argc,argv)
	Xregister int argc;
	Xregister char **argv;
	X{
	X	register int state = STRING;
	X	register char *ptr = header.nbuf;
	X	char filchar = NGDELIM;
	X	int len = LBUFLEN, tlen;
	X
	X	/* loop once per arg. */
	X
	X	if (argc > 1 && **argv != '-')
	X		nflag = TRUE;
	X
	X	while (--argc) {
	X	    if (state == OPTION) {
	X		if (**argv != '-') {
	X			xerror("Bad option string \"%s\"", *argv);
	X		}
	X		while (*++*argv != '\0') {
	X			for (optpt = options; optpt->optlet != '\0'; ++optpt) {
	X				if (optpt->optlet == **argv)
	X					goto found;
	X			}
	X			/* unknown option letter */
	X#ifdef TMAIL
	X			fprintf(stderr, "Usage: %s [ -a [ date ]] [ -n newsgroups ] [ -t titles ] [ -lprxhfuMK ]\n", Progname);
	X#else /* !TMAIL */
	X			fprintf(stderr, "Usage: %s [ -a [ date ]] [ -n newsgroups ] [ -t titles ] [ -lprxhfuK ]\n", Progname);
	X#endif /* !TMAIL */
	X			fprintf(stderr, "\t[ -c [ ``mailer'' ]]\n\n");
	X			fprintf(stderr, "       %s -s\n", Progname);
	X			exit(1);
	X
	X		    found:;
	X			if (mode != UNKNOWN && (mode&optpt->oldmode) == 0) {
	X				xerror("Bad %c option", **argv);
	X			}
	X			if (mode == UNKNOWN)
	X				mode = optpt->newmode;
	X			filchar = optpt->filchar;
	X			optpt->flag = TRUE;
	X			state = optpt->newstate;
	X			ptr = optpt->buf;
	X			len = LBUFLEN;
	X		}
	X
	X		argv++;		/* done with this option arg. */
	X
	X	    } else {
	X
	X		/*
	X		 * Pick up a piece of a string and put it into
	X		 * the appropriate buffer.
	X		 */
	X		if (**argv == '-') {
	X			state = OPTION;
	X			argc++;	/* uncount this arg. */
	X			continue;
	X		}
	X
	X		if ((tlen = strlen(*argv)) >= len)
	X			xerror("Argument string too long");
	X		strcpy(ptr, *argv++);
	X		ptr += tlen;
	X		if (*(ptr-1) != filchar)
	X			*ptr++ = filchar;
	X		len -= tlen + 1;
	X		*ptr = '\0';
	X	    }
	X	}
	X	return;
	X}
SHAR_EOF
if test 3695 -ne "`wc -c < 'process.c'`"
then
	echo shar: error transmitting "'process.c'" '(should have been 3695 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'readnews.c'" '(8225 characters)'
if test -f 'readnews.c'
then
	echo shar: will not over-write existing file "'readnews.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'readnews.c'
	X/*
	X * readnews - read news articles.
	X */
	X
	X#ifdef SCCSID
	Xstatic char	*SccsId = "@(#)readnews.c	2.33	10/15/87";
	X#endif /* SCCSID */
	X
	X#include "rparams.h"
	X
	X/*
	X * readnews - article reading program
	X */
	X
	X#ifndef SYSBUF
	Xchar	SYSBUF[BUFSIZ];	/* to buffer std out */
	X#endif
	X
	X#define OPTION	0	/* pick up an option string */
	X#define STRING	1	/* pick up a string of arguments */
	X
	Xstruct timeb Now;
	X
	Xint onsig(), cleanup();
	X
	X/*
	X *	Authors:
	X *		Matt Glickman	ucbvax!glickman
	X *		Mark Horton	cbosg!mark
	X *		Stephen Daniels	duke!swd
	X *		Tom Truscott	duke!trt
	X */
	X
	Xmain(argc, argv)
	Xint	argc;
	Xregister char	**argv;
	X{
	X	register char	*ptr;	/* pointer to rest of buffer		*/
	X	char	*user = NULL, *home = NULL;
	X	int	optflag = FALSE, space = FALSE;
	X	struct utsname ubuf;
	X	char	*myrc;
	X
	X	/* set up defaults and initialize. */
	X	pathinit();
	X	mode = UNKNOWN;
	X	header.title[0] = header.nbuf[0] = '\0';
	X	coptbuf[0] = datebuf[0] = '\0';
	X	uname(&ubuf);
	X	strcpy(FROMSYSNAME, ubuf.nodename);
	X
	X	savmask = umask(N_UMASK);	/* set up mask */
	X	uid = getuid();
	X	gid = getgid();
	X	duid = geteuid();
	X	dgid = getegid();
	X	(void) ftime(&Now);
	X	/* give reasonable error message if SPOOL directory
	X	 * is unaccessable... usually means system administrator
	X	 * has "turned off" news reading...
	X	 */
	X#ifdef SERVER
	X	if (open_server() < 0)
	X#else	/* !SERVER */
	X	if (access(SPOOL, 05))
	X#endif	/* !SERVER */
	X	{
	X		fputs("News articles are not available at this time\n",stderr);
	X		xxit(1);
	X	}
	X#ifndef SHELL
	X	if ((SHELL = getenv("SHELL")) == NULL)
	X		SHELL = "/bin/sh";
	X#endif
	X	/*
	X	 * IHCC forces the use of 'getuser()' to prevent forgery of articles
	X	 * by just changing $LOGNAME
	X	 * Note that this shouldn't matter in readnews, since inews
	X	 * does all the actual posting of news.
	X	 */
	X#ifndef IHCC
	X	if ((user = getenv("USER")) == NULL)
	X		user = getenv("LOGNAME");
	X	if ((home = getenv("HOME")) == NULL)
	X		home = getenv("LOGDIR");
	X#endif /* ! IHCC */
	X	if (user == NULL || home == NULL)
	X		getuser();
	X	else {
	X		username = AllocCpy(user);
	X		(void) strcpy(header.path, username);
	X		userhome = AllocCpy(home);
	X	}
	X
	X	if (!(MAILER = getenv("MAILER")))
	X		MAILER = "mail";	/* was /bin/mail */
	X
	X#ifdef PAGE
	X	if (myrc = getenv("PAGER"))
	X		PAGER = AllocCpy(myrc);
	X	else {
	X# ifdef IHCC
	X		(void) sprintf(bfr, "%s/bin/%s", logdir(HOME), PAGE);
	X		PAGER = AllocCpy(bfr);
	X# else /* !IHCC */
	X		PAGER = PAGE;
	X# endif /* !IHCC */
	X	}
	X#endif /* PAGE */
	X
	X	if (ptr = getenv("NEWSOPTS"))
	X		(void) strcpy(rcbuf, ptr);
	X	else
	X		*rcbuf = '\0';
	X	if (*rcbuf) {
	X		(void) strcat(rcbuf, " \1");
	X		ptr = rcbuf;
	X		while (*++ptr)
	X			if (isspace(*ptr))
	X				*ptr = '\0';
	X		for (ptr = rcbuf; ; ptr++) {
	X			if (!*ptr)
	X				continue;
	X			if (*ptr == '\1')
	X				break;
	X			if (++line > LINES)
	X				xerror("Too many options.");
	X			if ((rcline[line] = malloc((unsigned)(strlen(ptr) + 1))) == NULL)
	X				xerror("Not enough memory.");
	X			argvrc[line] = rcline[line];
	X			(void) strcpy(rcline[line], ptr);
	X			while (*ptr)
	X				ptr++;
	X		}
	X	}
	X	myrc = getenv("NEWSRC");
	X	if (myrc == NULL) {
	X		myrc = NEWSRC;
	X		(void) sprintf(newsrc, "%s/%s", userhome, myrc);
	X	} else {
	X		(void) strcpy(newsrc, myrc);
	X	}
	X	if (access(newsrc, 0))
	X		newrc(newsrc);
	X	if ((rcfp = fopen(newsrc, "r")) != NULL) {
	X		rcreadok = FALSE;
	X		while (fgets(rcbuf, LBUFLEN, rcfp) != NULL) {
	X			if (!(space = isspace(*rcbuf)))
	X				optflag = FALSE;
	X			if (!STRNCMP(rcbuf, "options ", 8))
	X				optflag = TRUE;
	X			if (optflag) {
	X				(void) strcat(rcbuf, "\1");
	X				if (space)
	X					ptr = rcbuf - 1;
	X				else
	X					ptr = &rcbuf[7];
	X				while (*++ptr)
	X					if (isspace(*ptr))
	X						*ptr = '\0';
	X				if (space)
	X					ptr = rcbuf;
	X				else
	X					ptr = &rcbuf[8];
	X				for (; ; ptr++) {
	X					if (!*ptr)
	X						continue;
	X					if (*ptr == '\1')
	X						break;
	X					if (++line > LINES)
	X						xerror("Too many options.");
	X					if ((rcline[line] = malloc((unsigned)(strlen(ptr) + 1))) == NULL)
	X						xerror("Not enough memory.");
	X					argvrc[line] = rcline[line];
	X					(void) strcpy(rcline[line], ptr);
	X					while (*ptr)
	X						ptr++;
	X				}
	X			}
	X		}
	X		(void) fclose(rcfp);
	X		rcreadok = TRUE;
	X	}
	X	if (line != -1) {
	X#ifdef DEBUG
	X		register int i;
	X		for (i = 0; i <= line; i++)
	X			fprintf(stderr, "options:  %s\n", rcline[i]);
	X#endif
	X		process(line + 2, argvrc);
	X		do {
	X#ifdef DEBUG
	X			fprintf(stderr, "Freeing %d\n", line);
	X#endif
	X			free(rcline[line]);
	X		} while (line--);
	X	}
	X
	X	argv++;
	X	(void) strcat(header.nbuf, ADMSUB);
	X	process(argc, argv);
	X	if (!nflag)
	X		(void) sprintf(header.nbuf, "%s,%s", ADMSUB, DFLTSUB);
	X	else {
	X		char *p = rindex(header.nbuf, ',');
	X		if (p && p[1] == '\0')	/* strip of trailing NGDELIM */
	X			*p ='\0';
	X	}
	X	lcase(header.nbuf);
	X	makehimask(header.nbuf, "junk");
	X	makehimask(header.nbuf, "control");
	X	makehimask(header.nbuf, "test");
	X
	X	setbuf(stdout, SYSBUF);
	X	SigTrap = FALSE;	/* true if a signal has been caught */
	X	if (!pflag && !lflag && !eflag) {
	X		(void) signal(SIGQUIT, SIG_IGN);
	X		(void) signal(SIGHUP, cleanup);
	X		(void) signal(SIGINT, onsig);
	X		(void) signal(SIGPIPE, onsig);
	X	} else {
	X		if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
	X			(void) signal(SIGQUIT, cleanup);
	X		if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
	X			(void) signal(SIGHUP, cleanup);
	X		if (signal(SIGINT, SIG_IGN) != SIG_IGN)
	X			(void) signal(SIGINT, cleanup);
	X	}
	X
	X	/*
	X	 * ALL of the command line has now been processed. (!)
	X	 */
	X
	X	if (!*header.nbuf)
	X		strcpy(header.nbuf, DFLTSUB);
	X	if (sflag) {
	X		printf("Subscription list:  %s\n", header.nbuf);
	X		xxit(0);
	X	}
	X	if (xflag)
	X		line = -1;
	X	rcfp = xfopen(newsrc, "r");
	X	while (fgets(rcbuf, LBUFLEN, rcfp) != NULL) {
	X		if (!nstrip(rcbuf))
	X			xerror(".newsrc line too long");
	X		if (++line >= LINES)
	X			xerror("Too many .newsrc lines");
	X		if ((rcline[line] = malloc((unsigned)(strlen(rcbuf) + 1))) == NULL)
	X			xerror("Not enough memory");
	X		(void) strcpy(rcline[line], rcbuf);
	X	}
	X	fclose(rcfp);
	X
	X	if (SigTrap) {
	X		if (SigTrap == SIGHUP || !rcreadok)
	X			xxit(0);
	X		fprintf(stdout, "Abort (n)?  ");
	X		(void) fflush(stdout);
	X		if (gets(bfr) == NULL || *bfr == 'y' || *bfr == 'Y')
	X			xxit(0);
	X		SigTrap = FALSE;
	X	}
	X#ifdef SERVER
	X    if ((actfp = open_active()) == NULL)
	X		xerror("Cannot open active newsgroups file");
	X    strcpy(ACTIVE, active_name());
	X    (void) fclose(actfp);
	X    actfp = NULL;
	X#endif	/* !SERVER */
	X	sortactive();
	X	actfp = xfopen(ACTIVE, "r");
	X#ifdef DEBUG
	X	fprintf(stderr, "header.nbuf = %s\n", header.nbuf);
	X#endif /* DEBUG */
	X	if (Kflag)
	X		news++;
	X	else {
	X		switch (mode) {
	X		case UNKNOWN:
	X			readr();
	X			break;
	X#ifdef TMAIL
	X		case MAIL:
	X			Mail();
	X			break;
	X#endif /* TMAIL */
	X		}
	X	}
	X
	X	cleanup(0);
	X	/*NOTREACHED*/
	X}
	X
	Xcleanup(signo)
	X{
	X	extern short ospeed;
	X
	X	(void) signal(SIGHUP, SIG_IGN);
	X	(void) fflush(stdout);
	X	if (news && !xflag && !lflag && !tflag) {
	X		if (*groupdir && mode != MAIL)
	X			updaterc();
	X		writeoutrc();
	X	}
	X	/*
	X	 * stop vnews from clearing the screen if we're
	X	 * killed by a hangup
	X	 */
	X	if (signo == SIGHUP)
	X		ospeed = 0;
	X	xxit(0);
	X}
	X
	X/*
	X * Write out the .newsrc file. It's already been cleaned up by sortactive()
	X * Take care that data is all written, and flushed, before we destroy the
	X * old copy.
	X */
	Xwriteoutrc()
	X{
	X	FILE *wrcfp;
	X	char aline[BUFLEN];
	X	register int i;
	X
	X	/* NEVER write it out if xflag */
	X	if (xflag || !rcreadok)
	X		return;
	X
	X	(void) strcpy(aline, newsrc);
	X	(void) strcat(aline, ".new");
	X
	X#ifdef VMS
	X	(void) vmsdelete(aline);
	X#endif
	X	wrcfp = xfopen(aline, "w");
	X
	X	for (i = 0; i <= line; i++) {
	X		if (rcline[i] != NULL)
	X			if (fprintf(wrcfp, "%s\n", rcline[i]) < 0)
	X				goto fouled;
	X	}
	X	if (fclose(wrcfp) < 0)
	X		goto fouled;
	X
	X#ifdef VMS
	X	(void) vmsdelete(newsrc);
	X#endif
	X	if (rename(aline, newsrc) < 0)
	X		xerror("Cannot rename %s to %s", aline, newsrc);
	X	return;
	X
	X  fouled:
	X	xerror("Error writing new .newsrc file - no changes made\n");
	X	return;
	X}
	X
	X/*
	X * Forbid newsgroup ng, unless he asked for it in nbuf.
	X */
	Xmakehimask(nbuf, ng)
	Xchar *nbuf, *ng;
	X{
	X	if (!findex(nbuf, ng))
	X		(void) sprintf(rindex(nbuf, '\0'), ",!%s", ng);
	X}
	X
	X/*
	X * Return true if the string searchfor is in string, but not if preceded by !.
	X */
	Xfindex(string, searchfor)
	Xchar *string, *searchfor;
	X{
	X	register char first;
	X	register char *p;
	X
	X	first = *searchfor;
	X	for (p=index(string, first); p; p = index(p+1, first)) {
	X		if (((p==string) || (p[-1]!='!')) && STRNCMP(p, searchfor, strlen(searchfor)) == 0)
	X			return TRUE;
	X	}
	X	return FALSE;
	X}
SHAR_EOF
if test 8225 -ne "`wc -c < 'readnews.c'`"
then
	echo shar: error transmitting "'readnews.c'" '(should have been 8225 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

