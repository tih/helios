#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	misc/L.cmds
#	misc/README
#	misc/arbitron
#	misc/article.c
#	misc/batcher
#	misc/bncvt-2-unbatch
#	misc/delay
#	misc/dirform
#	misc/euuname.sh
#	misc/grabheaders.c
#	misc/keepnews
#	misc/net.recording
# This archive created: Wed Mar  1 10:49:14 1989
export PATH; PATH=/bin:$PATH
echo shar: extracting "'L.cmds'" '(217 characters)'
if test -f 'L.cmds'
then
	echo shar: will not over-write existing file "'L.cmds'"
else
sed 's/^	X//' << \SHAR_EOF > 'L.cmds'
	X#
	X# If rnews lives in a peculiar directory on your system
	X# (e.g. /usr/new under 4.3 BSD) make sure that uucp can
	X# find it using the PATH in /usr/lib/uucp/L.cmds.
	X#
	XPATH=/bin:/usr/bin:/usr/ucb:/usr/new
	X#
	Xrnews,Error
SHAR_EOF
if test 217 -ne "`wc -c < 'L.cmds'`"
then
	echo shar: error transmitting "'L.cmds'" '(should have been 217 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'README'" '(158 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
sed 's/^	X//' << \SHAR_EOF > 'README'
	XThese are programs that have been useful for some people.
	XThey are provided for your potential use, but are not
	Xconsidered part of the official news release.
SHAR_EOF
if test 158 -ne "`wc -c < 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 158 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'arbitron'" '(9694 characters)'
if test -f 'arbitron'
then
	echo shar: will not over-write existing file "'arbitron'"
else
sed 's/^	X//' << \SHAR_EOF > 'arbitron'
	XFrom reid@decwrl.DEC.COM Wed Jun  4 13:23:12 1986
	XReceived: by seismo.CSS.GOV; Wed, 4 Jun 86 12:52:01 EDT
	XReceived: from saturn.DEC.COM by sonora.DEC.COM (4.22.05/4.7.34)
	X	id AA09759; Wed, 4 Jun 86 09:51:39 pdt
	XReceived: by saturn.DEC.COM (4.22.05/4.7.34)
	X	id AA15981; Wed, 4 Jun 86 09:52:49 pdt
	XFrom: reid@decwrl.DEC.COM (Brian Reid)
	XMessage-Id: <8606041652.AA15981@saturn.DEC.COM>
	XDate:  4 Jun 1986 0952-PDT (Wednesday)
	XTo: rick
	XSubject: arbitron packaged with news
	XStatus: R
	X
	XCould you please delete the "arbitron" script that is packaged with
	Xnews, and replace it with the one below? Thanks. It has a lot of bug
	Xfixes.
	X
	X#! /bin/sh
	X# @(#)arbitron	2.2	05/30/86
	X# arbitron -- this program produces rating sweeps for USENET.
	X#
	X# Usage: arbitron
	X#
	X# To use this program, edit the "configuration" section below so that the
	X# information is correct for your site, and then run it. It will produce a
	X# readership survey for your machine and mail that survey to decwrl, with
	X# a cc to you.
	X#
	X# To participate in the international monthly ratings sweeps, 
	X# run "arbitron" every month. I will run the statistics program on the last
	X# day of each month; it will include any report that has reached it by that
	X# time. To make sure your site's data is included, run the survey program no
	X# later than the 20th day of each month.
	X#
	X# Brian Reid, DEC Western Research Lab, reid@decwrl
	X# Updated and bugfixed by 
	X#	Spencer Thomas, U.of Utah
	X#	Geoff Kuenning, SAH Consulting
	X# Updated to work with 2.10.1 and older news systems by
	X#	Lindsay Cleveland, AT&T Technologies/Bell Labs
	X#
	X# Note that the results of this program are dependent on the rate at which
	X# you expire news.  If you are a small site that expires news rapidly, the
	X# results may indicate fewer active readers than you actually have.
	X#
	X# copied to a certain extent from the "subscribers"
	X# script posted by Blonder, McCreery, and Herron.
	X###########################################################################
	X# Configuration information. Edit this section to reflect your site data. #
	XTMPDIR=/tmp
	XNEWS=/usr/lib/news
	XSPOOL=/usr/spool/news
	X
	X# Make a crude stab at determining the system type
	Xif [ -d /usr/ucb ]
	Xthen
	X    STYPE="bsd"
	Xelse
	X    STYPE="usg"
	Xfi
	X
	X# Range of /etc/passwd UID's that represent actual people (rather than
	X# maintenance accounts or daemons or whatever)
	XlowUID=5
	XhighUID=9999
	X
	X# If you aren't running a distributed news system (nntpd & rrn, usually),
	X# leave NEWSHOST blank. Else set it to the name of the host from which you
	X# can rcp a copy of the active file.
	XNEWSHOST=
	X
	X# uucp path: {ihnp4, decvax, ucbvax}!decwrl!netsurvey
	X# summarypath="netsurvey@decwrl.dec.com $USER"
	Xsummarypath="ihnp4!decwrl!netsurvey"
	X
	X# We need to find the uucp name of your host. If this code doesn't work,
	X# then just put it in literally like this:
	X#	hostname="ihnp4"
	X
	Xcase $STYPE in
	X	bsd) hostname=`(hostname || uuname -l) 2>&-`;;
	X        sysv)hostname=`(uname -n || uuname -l ||  hostname) 2>&-`;;
	X	*)   hostname=`(uuname -l) 2>&-`;;
	Xesac;
	X
	XPATH=$NEWS:/usr/local/bin:/usr/ucb:/usr/bin:/bin
	X############################################################################
	Xexport PATH
	X# ---------------------------------------------------------------------------
	Xtrap "rm -f $TMPDIR/arb.*.$$; exit" 0 1 2 3 15
	Xset `date`
	Xdat="$2$6"
	Xdestination="${MAILER-mail} $summarypath"
	X
	X################################
	X# Here are several expressions, each of which figures out approximately how
	X# many people use this machine. Comment out all but 1 of them; pick the one
	X# you like best. Initially the most universal but least reliable of them is
	X# uncommented.
	X# # ###### Scheme #1: fast but usually returns too big a number
	Xnusers=`awk -F: "BEGIN {N=0}\\$3>=$lowUID && \\$3<=$highUID{N=N+1}END{print N}" </etc/passwd`
	X
	X# # ###### Scheme #2 (works with BSD systems)
	X#nusers=`last | sort -u +0 -1 | wc -l`
	X
	X# # ###### Scheme #3 (works with USG systems)
	X#nusers=`who /etc/wtmp | sort -u +0 -1 | wc -l`
	X
	X# # ###### Scheme #4 (provided by Lindsay Cleveland)
	X# # ###### (Same idea as #1, but excludes various junk accounts)
	X#awk -F: "\$3 >= $lowUID && \$3 <= $highUID{printf \"if test -d %s ; then echo %s;egrep : %s/.newsrc; fi\n\",\$6,\$1,\$6}" \
	X#	</etc/passwd | sh 2>/dev/null | awk  -f $tmpdir/arb.sel.$$ >$tmpdir/arb.tmp.$$
	X#nusers=`awk "BEGIN {N=0} NF == 1{N=N+1}END{print N}" <$tmpdir/arb.tmp.$$`
	X################################
	X#
	X# Set up awk scripts;  these are too large to pass as arguments on most
	X# systems. It also eliminates lines that have
	X# colons but no article numbers on them (usually due to new groups that
	X# haven't been posted to yet). As a side effect, this script removes the
	X# first colon from each line, which makes life easier for later awk scripts.
	X#
	Xcat > $TMPDIR/arb.sel.$$ << 'CAT'
	X/^[a-z]*\..*: *[0-9].*$/	{ split($0,n,":"); print n[1], n[2] }
	XNF == 1	&& $1 ~ /^[a-z]*$/{ print $1 }
	XCAT
	X#
	X# This second awk script generates the actual output report.
	X# We use 'sed' to substitute in the shell variables to save ourselves
	X# endless hassle trying to find quoting/backslashing problems.
	X#
	X# The input to this script consists of three types of lines:
	X#
	X#	(1) Active-file lines.  These have four fields:  newsgroup name,
	X#	    first existing article, last article number, 'y' or 'n'
	X#	    to allow/disallow posting.
	X#			mod.mac 00001 00001 y
	X#	    These all come first, which is important.
	X#	(2) User names.  These have one field.
	X#			usenet
	X#	(3) .newsrc lines.  These have two fields:  the newsgroup name,
	X#	    and the articles-read information.  The latter can be
	X#	    arbitrarily complex.  It can also be arbitrarily long;
	X#	    this can potentially break either awk or sed, in which
	X#	    case the script will not work.
	X#			mod.map  1-199
	X#			mod.sources  1-337
	X#
	X#	The script uses the type 1 lines to build a table of newsgroups
	X#	and their active article ranges.  The .newsrc (type 3) lines are
	X#	then used to deduce which groups are being read by a user (a group
	X#	is being read if the last article seen is in that group's active
	X#	article range).  The user names are used to keep track of who reads
	X#	each group, which isn't all that useful but is interesting.  When
	X#	all input has been read, a report is printed summarizing the results.
	X#
	Xsed  -e "s/NUSERS/$nusers/g" -e "s/HOSTNAME/$hostname/g" \
	X     -e "s/DATE/$dat/g" \
	X  > $TMPDIR/arb.fmt.$$ << 'DOG'
	X# makereport -- utility for "arbitron". Shamelessly copied from the
	X# similar script distributed with "subscribers.sh" by Blonder, McCreery, and
	X# Herron.
	X# 
	XBEGIN	{ rdrcount = 0 ; reader = "" ; grpcount = 0 ; realusers = 0}
	X
	X# Active file line:  count newsgroups, record and cross-index group, and
	X# record first and last article numbers.  Set group's reader count and list
	X# to none.
	XNF == 4	{
	X	  grpcount++
	X	  grpname[grpcount] = $1
	X	  grpnumber[$1] = grpcount
	X	  grplast[grpcount] = $2
	X	  grpfirst[grpcount] = $3
	X	  grpcounts[grpcount] = 0
	X	  grpreaders[grpcount] = ""
	X	}
	X# User name.  Count readers, record and cross-index reader.
	X			# 1 field means it's a user name
	XNF == 1 { rdrcount++; rdrname[rdrcount] = $1; rdrnumber[$1] = rdrcount
	X	  reader = $1}
	X
	X# .newsrc line.  Break out the final number, which is the last article that
	X# has actually been read.  This is a pretty good indicator of the person's
	X# true interest in the group.  If 'lastread' for the group is a current
	X# (unexpired) article, record a reader for that group.  Finally, record
	X# the user as a "real" user of the news system.
	X			# 2 fields means it's a .newsrc line
	XNF == 2 { gnum = grpnumber[$1] 
	X	  n1 = split($2, n2, "-")
	X	  n3 = split(n2[n1], n4, ",")
	X	  lastread = n4[n3]
	X	  if (lastread >= grpfirst[gnum]) {
	X# To exclude groups with no traffic, use the next line instead of previous
	X# 	  if ((grpfirst[gnum] != grplast[gnum]) && (lastread >= grpfirst[gnum]) && (lastread <= grplast[gnum])) {
	X		  grpcounts[gnum]++
	X		  if (realuser[rdrcount] == 0) {
	X		      realuser[rdrcount]=1
	X		      realusers++
	X		  }
	X	  }
	X	} 
	X
	X#	End of file.  Print the report in 2 columns.
	XEND	{printf("9999 Host\t\t%s\n","HOSTNAME")
	X	 printf("9998 Users\t\t%d\n",NUSERS)
	X	 printf("9997 NetReaders\t%d\n",realusers)
	X	 printf("9996 ReportDate\t%s\n","DATE")
	X
	X	 for (i = 1;  i <= grpcount;  i++) {
	X	    if (grpcounts[i] > 0) {
	X		printf("%d %s\n",grpcounts[i], grpname[i])
	X	    }
	X	}
	X    }
	XDOG
	X
	Xcat >$TMPDIR/arb.pwd.$$ <<'MOUSE'
	XBEGIN {seen["/"]=1; seen[""] = 1;}
	X{if (seen[$6]!=1) {
	X		printf("if [ -r %s/.newsrc ] ; then ", $6)
	X		printf("echo %s; egrep : < %s/.newsrc ; fi\n", $1, $6)
	X		seen[$6]=1;
	X                  }
	X}
	XMOUSE
	X# First get the list of .newsrc files with duplicates and unreadable files
	X# removed.
	Xawk -F: -f $TMPDIR/arb.pwd.$$ \
	X	</etc/passwd | \
	X	 sh | \
	X	 awk -f $TMPDIR/arb.sel.$$ >$TMPDIR/arb.tmp.$$
	X# Check to make sure that we found some
	X
	X# but first, make sure we have an active file
	Xif test X$NEWSHOST = X
	Xthen
	XACTIVE=$NEWS/active
	Xelse
	XACTIVE=/tmp/arb.active.$$
	Xrcp $NEWSHOST:$NEWS/active $ACTIVE
	Xfi
	X
	Xif test -s $TMPDIR/arb.tmp.$$
	Xthen
	X    # See if "active" file has 4 fields or only two (pre-2.10.2)
	X    set `grep '^net.announce' $ACTIVE | sed 1q`
	X    if test $# -eq 2 ; \
	X      then	egrep  '^[a-z]*\.' $ACTIVE | \
	X	    while read group last ; \
	X	    do	dir=`echo "$group" | sed 's;\.;/;g'`; \
	X		    first=`ls $SPOOL/$dir | grep '^[0-9]*' | sort -n | sed 1q`; \
	X		    case $STYPE in
	X		        usg) echo "$group $last ${first:-$last} X";; \
	X		 	*) echo "$group $last ${first-$last} X" ;;\
	X		    esac; \
	X	    done ; \
	X      else	egrep '^[a-z]*\.' $ACTIVE ; \
	X    fi | sort | \
	X	sort | \
	X	awk -f $TMPDIR/arb.fmt.$$ - $TMPDIR/arb.tmp.$$ | sort -nr | \
	X	grep -v '^$' | \
	X	sed -e 's/^999[0-9] //' | $destination
	Xelse
	X    echo Unable to find any readable .newsrc files 2>&1
	X    exit 1
	Xfi
	X
SHAR_EOF
if test 9694 -ne "`wc -c < 'arbitron'`"
then
	echo shar: error transmitting "'arbitron'" '(should have been 9694 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'article.c'" '(3193 characters)'
if test -f 'article.c'
then
	echo shar: will not over-write existing file "'article.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'article.c'
	X/* down!honey 4/84 */
	X/* article msg-id [ ... msg-id ] */
	X * where message-id is usually of the form number@machine.domain,
	X * and the domain in the message-id is optional.
	X *
	X * BUGS:
	X *	Cannot handle all domains, for instance, BERKELEY.EDU.
	X */
	X
	X#define HISTORY "/usr/lib/news/history"
	X#define NEWSDIR "/usr/spool/news"
	X
	Xchar	*formats[] = {		/* add as appropriate */
	X	"<%s.uucp>",
	X	"<%s>",
	X	"<%s.arpa>",
	X	"<%s.oz>",
	X	0
	X};
	X
	X#include <stdio.h>
	X#include <sysexits.h>
	X#include <ctype.h>
	X
	Xtypedef struct {
	X	char	*dptr;
	X	int	dsize;
	X} datum;
	X
	X#if defined(USG_INDEX)
	X/* S3 or S5 both call strchr() what 4.X BSD calls index */
	X#define index strchr
	X#endif
	X
	Xlong	lseek();
	Xchar	*index();
	Xdatum	fetch(), dofetch();
	X
	Xmain(argc, argv)
	Xchar **argv;
	X{
	X	int	fd;
	X	char	buf[BUFSIZ], *ptr1, *ptr2;
	X	datum	content;
	X
	X	if ((fd = open(HISTORY, 0)) < 0) {
	X		perror(HISTORY);
	X		exit(EX_UNAVAILABLE);
	X	}
	X	if (dbminit(HISTORY) < 0) {
	X		fprintf(stderr, "dbm error\n");
	X		exit(EX_UNAVAILABLE);
	X	}
	X	for (--argc, argv++; argc; --argc, argv++) {
	X		long	foff;		/* file offset */
	X		content = dofetch(*argv);
	X		if (content.dptr == 0) {
	X			printf("%s: No such key\n", *argv);
	X			continue;
	X		}
	X
	X		/* Correct a machine dependent bug here, caused		*/
	X		/* because the lseek offset pointed to by dptr might	*/
	X		/* not be long-aligned.					*/
	X		/* Guy Harris suggested bug fix to prevent core drop.	*/
	X		/* This bug was written up in net.bugs.4bsd and		*/
	X		/* cross-posted to net.news.b				*/
	X		bcopy(content.dptr, (char *)&foff, sizeof foff);
	X
	X		if (lseek(fd, foff, 0) < 0)
	X			continue;
	X		if (read(fd, buf, sizeof buf) <= 0)
	X			continue;
	X
	X		/*
	X		 * To understand this piece of code, you must understand
	X		 * that the format of lines in the history file are either:
	X		 * <msg-id>TAB<date>SPACE<time>TABthenNL
	X		 * <msg-id>TAB<date>SPACE<time>TAB<spoolpathname>NL
	X		 * <msg-id>TAB<date>SPACE<time>TAB<spoolpathname>SPACE...
	X		 * The first format occurs when expired,
	X		 * the second form occurs when exactly one pathname,
	X		 * and the third occurs when cross-postings.
	X		 */
	X		 *
	X
	X		/* remove end of line */
	X		if ((ptr2 = index(buf, '\n')) == 0)
	X			continue;
	X		*ptr2 = '\0';
	X
	X		/* The 4th field contains the article file name */
	X
	X		if ((ptr1 = index(buf, '\t')) == 0)
	X			continue;
	X		ptr1++;
	X
	X		/* ptr1 now at begin of field 2 - the date field */
	X
	X		if ((ptr1 = index(ptr1, '\t')) == 0)
	X			continue;
	X		ptr1++;
	X
	X		/* ptr1 now at begin of field 4 - the article spool pathname */
	X		/* or the newline that has been converted to a NULL */
	X
	X		/* change net.unix/231 to net/unix/231 */
	X		for (ptr2 = ptr1; ptr2 = index(ptr2, '.'); *ptr2 = '/')
	X			;
	X
	X		/* terminate after the first pathname, if any */
	X		if ((ptr2 = index(ptr1, ' ')) != NULL)
	X			*ptr2 = '\0';
	X
	X		if (*ptr1 == '\0')
	X			printf("expired\n");
	X		else
	X			printf("%s/%s\n", NEWSDIR, ptr1);
	X	}
	X	exit(EX_OK);
	X}
	X
	Xdatum
	Xdofetch(str)
	Xchar	*str;
	X{
	X	datum	key, content;
	X	char	buf[BUFSIZ], **fmt;
	X	register char *rcp;
	X
	X	for (fmt = formats; *fmt; fmt++) {
	X		sprintf(buf, *fmt, str);
	X		rcp = buf - 1;
	X		while (*++rcp)
	X			if (isupper(*rcp))
	X				*rcp = tolower(*rcp);
	X		key.dptr = buf;
	X		key.dsize = strlen(buf) + 1;
	X		content = fetch(key);
	X		if (content.dptr)
	X			break;
	X	}
	X	return(content);
	X}
SHAR_EOF
if test 3193 -ne "`wc -c < 'article.c'`"
then
	echo shar: error transmitting "'article.c'" '(should have been 3193 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'batcher'" '(5314 characters)'
if test -f 'batcher'
then
	echo shar: will not over-write existing file "'batcher'"
else
sed 's/^	X//' << \SHAR_EOF > 'batcher'
	XFrom sdcsvax!ncr-sd!greg@s3sun.CSS.GOV Mon Feb  3 14:24:25 1986
	XReceived: by seismo.CSS.GOV; Mon, 3 Feb 86 12:48:57 EST
	XReturn-Path: <sdcsvax!ncr-sd!greg>
	XReceived: by s3sun.CSS.GOV (4.24/s3-5.0)
	X	id AA01660; Sun, 2 Feb 86 00:14:55 pst hops=0
	XFrom: sdcsvax!ncr-sd!greg.@s3sun.CSS.GOV
	XReceived: by sdcsvax.ucsd.edu (5.31/4.41)
	X	id AA16013; Sat, 1 Feb 86 23:56:26 PST hops=0
	XDate: Sat, 1 Feb 86 23:56:26 PST
	XMessage-Id: <8602020756.AA16013@sdcsvax.ucsd.edu>
	XTo: noscvax!rick@siesmo.ARPA, sdcsvax!s3sun!seismo!rick@s3sun.CSS.GOV
	XSubject: Batcher script for news
	XStatus: R
	X
	X:	shar:	Shell Archiver
	X# Run this text with /bin/sh to create:
	X#	batcher
	X
	X# I sent this a few days ago, and haven't gotten a reply.  This one is a
	X# revision that incorporates some fixes suggested by some other San Diego
	X# sites that have been running it.  Again, lease let me know if it arrives,
	X# otherwise I'll try retransmitting it in a few days.
	X# 
	X# This is a script that replaces sendbatch and csendbatch.  I recommend it to
	X# you for inclusion in 2.10.3.  It has some nice attributes, particularly for
	X# me, where I have a lot of news connections to maintain.  The most useful to
	X# me is that the default if no arguments are given is to send to everybody,
	X# so that I don't have to run around modifying crontab all the time -- all
	X# of the maintenance is in news/sys.
	X# 
	X# Here are some sample sites from news/sys to show how it works:
	X# 
	X# sdcsvax:sd,sdnet,ca,to.sdcsvax::uux - -r -n sdcsvax!rnews
	X# sdcsvax:net,fa,mod,na,usa:F:/usr/spool/batch/c.sdcsvax
	X# ncrcae:net,fa,mod,na,usa,ncr,to.ncrcae:F:/usr/spool/batch/c.ncrcae
	X# local:net,fa,mod,na,usa,ca,sdnet,sd,to.local:F:/usr/spool/batch/b.local
	X# 
	X# The name chosen determines the type of transmission; the "b." prefix
	X# causes news to be sent batched and the "c." prefix causes news to be
	X# sent compressed (and batched).
	X# 
	X# The batcher works by looking for files in /usr/spool/batch with a prefix
	X# of "[abc]."; if it is invoked with no arguments, it will pick up all such
	X# files, otherwise it only picks up files with those prefixes and the names
	X# given as arguments.  If the host status is OK, it will batch up at most
	X# ten batches and queue them to be delivered to the specified site.  The "a."
	X# prefix is for packaging agents not covered by the standard batching and
	X# compression algorithms; if you need it, consult the code for details.
	X# 
	X# It also handles the *.cmd files to specify the transmission method as did
	X# sendbatch and csendbatch.
	X# 
	X# Here are the relevant entries from the System V crontab table; note that
	X# System V has a separate file for each user, so if you don't have this,
	X# you may have to modify them so the invocation UID is correct.  Versions
	X# of cron also differ on the complexity of the expressions permitted; use
	X# this as a guide, not as gospel.
	X# 
	X# 56	19-23,0-7 *	*	1-5	. /usr/lib/news/batcher	# daily
	X# 56	*	*	*	0,6	. /usr/lib/news/batcher	# weekends
	X# 
	X# These lines cause the batcher to be invoked hourly from 8pm (well, 19:56)
	X# to 8am on weekdays and all day on the weekends.  This causes any queued
	X# news to be sent (assuming it thinks the site is alive and well).  I view
	X# the traffic to my backbone sites as important, so I also deliver to them
	X# during the days on weekdays since they have the CPU horsepower to handle
	X# it.  Here is the crontab entry to do that:
	X# 
	X# 56	8-18	*	*	1-5	sh /usr/lib/news/batcher ncrcae sdcsvax
	X# 
	X# I hope this is useful to you.
	X# 
	X# -- Greg Noel, NCR Rancho Bernardo    Greg@ncr-sd.UUCP or Greg@nosc.ARPA
	X
	Xsed 's/^X//' <<'SHAR_EOF' >batcher; chmod 644 batcher
	XXNEWS=/usr/lib/news	BATCH=/usr/spool/batch
	XXUUCP=/usr/lib/uucp	SPOOL=/usr/spool/uucp
	XXPATH=$NEWS:/bin:/usr/bin export PATH
	XXeval `grep TZ= /etc/profile`
	XXcase $# in
	XX0|1)	Files="-name [abc].$1*" ;;
	XX*)	y="(" Files=""
	XX	for file do Files="$Files $y -name [abc].$file*"; y=-o; done
	XX	Files="$Files )"
	XXesac
	XXfor rmt in `find $BATCH -type f $Files -print`
	XXdo	case $rmt in
	XX	*.cmd)	continue ;;
	XX	*.tmp)	continue ;;
	XX	*.work)	rmt=`expr $rmt : "\(.*\).work"`
	XX		if test -f $rmt; then continue; fi ;;
	XX	esac
	XX	site=`expr $rmt : ".*/[abc].\(.*\)"`
	XX	site=`expr $site : "\(......\)" \| $site`
	XX	case $rmt in
	XX	*/b.*)	if test -s $rmt.cmd -a -x $rmt.cmd
	XX		then	CMD="batch $rmt 60000 | $rmt.cmd \$flag"
	XX		else	CMD="batch $rmt 60000 | uux - -r -n $site!rnews"
	XX		fi ;;
	XX	*/c.*)	if test -s $rmt.cmd -a -x $rmt.cmd
	XX		then	CMD="batch $rmt 100000 | compress -q | $rmt.cmd \$flag"
	XX		else	CMD="batch $rmt 100000 | compress -q | uux - -r -n $site!cunbatch"
	XX		fi ;;
	XX	*/a.*)	CMD=`sed -n "s/^$site://p" $NEWS/cmds`
	XX		case "$CMD" in "") echo "OOPS -- no command for $site"
	XX			continue ;;
	XX		esac ;;
	XX	*)	echo "OOPS -- matched illegal file type!"; continue ;;
	XX	esac
	XX	if test -f $SPOOL/STST.$site
	XX	then	if test ! -s $SPOOL/STST.$site
	XX		then	continue	# Hmmmm....  Info file is null
	XX		fi
	XX		read <$SPOOL/STST.$site status garbage
	XX		case $status in
	XX		3)	flag=no ;;	# already talking
	XX		*)	continue ;;
	XX		esac
	XX	else	flag=yes	# start conversation first time through
	XX	fi
	XX	# Send a maximum of ten batches to remote site
	XX	loops=x
	XX	while test -s $rmt -o -s $rmt.work
	XX	do	eval $CMD
	XX		if test $? -ne 0 -o $loops = xxxxxxxxxx; then break; fi
	XX		case $flag in yes) $UUCP/uucico -r1 & ;; esac
	XX		flag=no loops=x$loops
	XX	done
	XXdone
	XSHAR_EOF
	Xexit 0
	X
	X
SHAR_EOF
if test 5314 -ne "`wc -c < 'batcher'`"
then
	echo shar: error transmitting "'batcher'" '(should have been 5314 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'bncvt-2-unbatch'" '(4220 characters)'
if test -f 'bncvt-2-unbatch'
then
	echo shar: will not over-write existing file "'bncvt-2-unbatch'"
else
sed 's/^	X//' << \SHAR_EOF > 'bncvt-2-unbatch'
	XFrom csg@pyramid.UUCP (Carl S. Gutekunst) Wed Oct 30 22:12:27 1985
	XRelay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site seismo.UUCP
	XPosting-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site pyramid.UUCP
	XPath: seismo!lll-crg!dual!pyramid!csg
	XFrom: csg@pyramid.UUCP (Carl S. Gutekunst)
	XNewsgroups: net.sources
	XSubject: bncvt -- filter bnproc batches to unbatch
	XMessage-ID: <54@pyramid.UUCP>
	XDate: 31 Oct 85 03:12:27 GMT
	XDate-Received: 31 Oct 85 12:52:30 GMT
	XReply-To: csg@pyramid.UUCP (Carl S. Gutekunst)
	XFollowup-To: net.sources.bugs
	XOrganization: Pyramid Technology, Mountain View, CA
	XLines: 104
	XKeywords: news bnproc unbatch bncvt
	X
	X/*===========================================================================**
	X**              BBBBBBB   NN    NN    CCCCC   VV    VV  TTTTTTTT             **
	X**              BB    BB  NNN   NN   CC   CC  VV    VV     TT                **
	X**              BB    BB  NNNN  NN  CC        VV    VV     TT                **
	X**              BBBBBBB   NN NN NN  CC        VV    VV     TT                **
	X**              BB    BB  NN  NNNN  CC         VV  VV      TT                **
	X**              BB    BB  NN   NNN   CC   CC    VVVV       TT                **
	X**              BBBBBBB   NN    NN    CCCCC      VV        TT                **
	X**===========================================================================**
	X**  Copyright (C) 1985 by PYRAMID TECHNOLOGY CORPORATION, Mountain View, CA  **
	X**===========================================================================**
	X** Permission is granted to freely use and distribute this software, as long **
	X** as no attempt is made to profit from it, and this notice is included.     **
	X**===========================================================================**
	X**
	X** ** bncvt.c -- utility to filter bnproc news batches to unbatch.
	X**
	X**    Written in a fit of desperation by Carl S. Gutekunst
	X**
	X** ** Decsription:
	X**
	X**	This filter accepts uncompressed news batches in "bnproc" format and
	X**	writes them out in "unbatch" format. Using 2.10.3 news, its output can
	X**	be piped directly into rnews.
	X**
	X**	The filter also adjusts for the bnproc "article eater" bug, which threw
	X**	off the article byte count and caused rnews to discard entire articles.
	X**
	X** ** Execution (for 2.10.3 netnews):
	X**
	X**	uncompress | bncvt | rnews
	X**
	X** ** Generation:
	X**
	X**	cc bncvt.c -o bncvt -s -O
	X**
	X** ** $Log:	bncvt.c,v $
	X**	Revision 1.1  85/10/30  19:07:13  csg
	X**	Initial version, written in a fit of desperation by Carl S. Gutekunst.
	X**	
	X**===========================================================================*/
	X
	X#include <stdio.h>
	X
	X#define LINESIZE 128			/* Size of the input line buffer     */
	X
	Xstatic char RCSid[] = "$Header: bncvt.c,v 1.1 85/10/30 19:07:13 csg Rel $";
	X
	Xmain ()
	X{
	X   char linebuf[LINESIZE], *lp;		/* Single line buffer, and pointer   */
	X   int expected, nbytes;		/* Bytes expected and read so far    */
	X
	X   nbytes = expected = 0;
	X   while (fgets (linebuf, LINESIZE, stdin) != NULL)
	X   {
	X      /*
	X       * Check for an article eater. This is a DEL character, either 0x7F or
	X       * 0xFF, in the first column preceeding a new article byte count. It
	X       * usually throws off the byte count, so we have to add some padding
	X       * to keep rnews from losing sync (and discarding the next article).
	X       */
	X
	X      if ((linebuf[0] & 0x7F) == 0x7F)
	X      {
	X	 if (expected > 0)
	X	    while (nbytes++ < expected)
	X	       putc ('\0', stdout);
	X      }
	X
	X      /*
	X       * If we aren't expecting text, then we're expecting an article byte
	X       * count. This is a left-justified integer, immediately followed by a
	X       * newline. We ignore leading article-eater DEL characters.
	X       */
	X
	X      if (nbytes >= expected)
	X      {
	X	 nbytes = expected = 0;
	X	 lp = linebuf;
	X	 while ((*lp & 0x7F) == 0x7F)
	X	    ++lp;
	X	 while (*lp >= '0' && *lp <= '9')
	X	    expected = expected * 10 + (*lp++ - '0');
	X
	X	 if (*lp == '\n' && expected > 0)
	X	    printf ("#! rnews %d\n", expected);
	X	 else
	X	 {  fprintf (stderr, "Sync->%s", linebuf);
	X	    expected = 0;
	X	 }
	X      }
	X
	X      /*
	X       * Another normal line of text: write it out.
	X       */
	X
	X      else
	X      {
	X	 fputs (linebuf, stdout);
	X	 nbytes += strlen (linebuf);
	X      }
	X   }
	X}
	X
	X
SHAR_EOF
if test 4220 -ne "`wc -c < 'bncvt-2-unbatch'`"
then
	echo shar: error transmitting "'bncvt-2-unbatch'" '(should have been 4220 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'delay'" '(2461 characters)'
if test -f 'delay'
then
	echo shar: will not over-write existing file "'delay'"
else
sed 's/^	X//' << \SHAR_EOF > 'delay'
	X#
	X#	Note, Date-Received knows abotu yout local timezone
	X#
	X./grabheaders | awk '
	XBEGIN{
	X	t = "Jan 31 Feb 28 Mar 31 Apr 30 May 31 Jun 30 Jul 31 Aug 31 Sep 30 Oct 31 Nov 30 Dec 31"
	X	split(t,x)
	X	n = 0;
	X	for(i=1;i<24;i+=2) {
	X		month[x[i]] = month[(i+1)/2] = (i+1)/2
	X		days[(i+1)/2] = n
	X		n += x[i+1]
	X	}
	X}
	X
	X/^Date: /{
	X	if (NF == 7 ){
	X		t = $6
	X		x[1] = $3
	X		x[2] = $4
	X		x[3] = $5
	X	} else if (NF == 5 && split($3,x,"-") == 3) {
	X		t = $4
	X	} else if (NF == 4 && split($2,x,"-") == 3) {
	X		t = $3
	X	}else if (NF == 6) {
	X		t = $5
	X		x[1] = $2
	X		x[2] = $3
	X		x[3] = $4
	X	}else{
	X		print "Bad date",messageid, $0
	X		next
	X	}
	X	sent = x[1] + days[month[x[2]]] + (x[3]-80)*365
	X	if (x[3]%4 == 0 && month[x[2]] > 2)
	X		sent++
	X	split(t,x,":")
	X	sent *= 60*24
	X	sent += x[1] * 60 + x[2]
	X}
	X/^Date-Received: /{
	X	if (NF < 3){
	X		print "Date-received", messageid ,$0
	X		rec = 0
	X		next
	X	}
	X	split($2,x,"/")
	X	rec = x[2] + days[x[1]+0] +(x[3]-80)*365
	X	if (x[3]%4 == 0 && x[1] > 2)
	X		rec++
	X	split($3,x,":")
	X	rec *= 60*24
	X	rec += x[1] * 60 + x[2] + 1.44
	X	if ($4 != "GMT")
	X		rec += 60*5
	X	if (rec > today)
	X		today = rec
	X}
	X/^Message-ID: /{messageid = $2}
	X/^Path: /{
	X	n = split($2,x,"!")
	X	if( n > 2)
	X		feed = x[2]
	X	else
	X		feed = x[1]
	X}
	X/^$/{
	X	n = int((rec - sent)/(60*24)+0.999)
	X	if( rec > 0 ) {
	X		if ( n >= 0) {
	X			adelay[n]++
	X			if( n > amaxdelay)
	X				amaxdelay = n
	X		} else {
	X			adelay[-1]++
	X			print "Time Warp", messageid
	X		}
	X		totdelay++
	X		feedsite[feed]++
	X	}
	X	rec = sent = 0
	X}
	XEND {
	X	n = int((rec - sent)/(60*24)+0.999)
	X	if( rec > 0 ) {
	X		if ( n >= 0) {
	X			adelay[n]++
	X			if( n > amaxdelay)
	X				amaxdelay = n
	X		} else {
	X			adelay[-1]++
	X			print "Time Warp", messageid
	X		}
	X		totdelay++
	X		feedsite[feed]++
	X	}
	X	i = 0
	X	count = 0
	X	printf("\n\tPropagation Delay\n")
	X	printf("\n\t     No. of   Cumulative\n")
	X	printf("\tDays Articles Percent\n")
	X	if (adelay[-1] > 0) {
	X		printf("\t <0%8d%7d%% (Time Warp)\n",adelay[-1],0)
	X		count += adelay[-1]
	X	}
	X	while (i <= amaxdelay) {
	X		count += adelay[i]
	X		if( adelay[i] != 0 )
	X			printf("\t%3d%8d%7d%%\n",i,adelay[i],(count*100)/totdelay)
	X		i++
	X	}
	X
	X	n = 0
	X	for (i in feedsite)
	X		ptr[++n] = i
	X
	X	j = 1
	X	while (j < n){
	X		if  (feedsite[ptr[j]] < feedsite[ptr[j+1]]){
	X			temp = ptr[j]
	X			ptr[j] = ptr[j+1]
	X			ptr[j+1] = temp
	X			if( j > 1) {
	X				j--
	X				continue
	X			}
	X		}
	X		j++
	X	}
	X	printf("\n\tDistribution of news feeds\n")
	X	printf("\t   Count Percent   Site\n")
	X	j = 0
	X	while (++j <= n){
	X		i =feedsite[ptr[j]]
	X		printf("\t%8d%7d%%   %s\n",i,(i*100)/totdelay,ptr[j]);
	X	}
	X}'
SHAR_EOF
if test 2461 -ne "`wc -c < 'delay'`"
then
	echo shar: error transmitting "'delay'" '(should have been 2461 characters)'
fi
chmod +x 'delay'
fi # end of overwriting check
echo shar: extracting "'dirform'" '(11998 characters)'
if test -f 'dirform'
then
	echo shar: will not over-write existing file "'dirform'"
else
sed 's/^	X//' << \SHAR_EOF > 'dirform'
	X#N
	X#S
	X#O
	X#C
	X#E
	X#T
	X#P
	X#L
	X#R
	X#W
	X#U
	X#
	Xsitename	connection(FREQUENCY), connection(FREQUENCY),
	X	connection(FREQUENCY)
	X============================================================================
	X
	XThe entire map is intended to be processed by pathalias, a program that
	Xgenerates UUCP routes from this data.  All lines beginning in `#' are
	Xcomment lines to pathalias, however the UUCP Project has defined a set
	Xof these comment lines to have specific format so that a complete
	Xdatabase could be built.
	X
	XThe generic form of these lines is
	X
	X#<field id letter><tab><field data>
	X
	XEach host has an entry in the following format.  The entry should begin
	Xwith the #N line, end with a blank line after the pathalias data, and
	Xnot contain any other blank lines, since there are ed, sed, and awk
	Xscripts that use expressions like /^#N $1/,/^$/ for the purpose of
	Xseparating the map out into files, each containing one site entry.
	X
	X#N	UUCP name of site
	X#S	manufacturer machine model; operating system & version
	X#O	organization name
	X#C	contact person's name
	X#E	contact person's electronic mail address
	X#T	contact person's telephone number
	X#P	organization's address
	X#L	longitude / latitude
	X#R	remarks
	X#U	netnews neighbors
	X#W	who last edited the entry ; date edited
	X#
	Xsitename	remote1(FREQUENCY), remote2(FREQUENCY),
	X	remote3(FREQUENCY)
	X
	XExample of a completed entry:
	X
	X#N	ucbvax
	X#S	DEC VAX-11/750; 4.3 BSD UNIX
	X#O	University of California at Berkeley
	X#C	Robert W. Henry
	X#E	ucbvax!postmaster
	X#T	+1 415 642 1024
	X#P	573 Evans Hall, Berkeley, CA 94720
	X#L	37 52 29 N / 122 13 44 W 
	X#R	This is also UCB-VAX.BERKELEY.EDU [10.2.0.78] on the internet
	X#U	decvax ibmpa ucsfcgl ucbtopaz ucbcad
	X#W	ucbvax!fair (Erik E. Fair); Sat Jun 22 03:35:16 PDT 1985
	X#
	Xucbvax = "UCB-VAX.BERKELEY.EDU"
	X#
	Xucbvax	decvax(DAILY/4), ihnp4(DAILY/2),
	X	sun(POLLED)
	X
	XSpecific Field Descriptions
	X
	X#N	system name
	X
	XYour system's UUCP name should go here. Either the uname(1) command
	Xfrom System III or System V UNIX; or the uuname(1) command from Version
	X7 UNIX will tell you what UUCP is using for the local UUCP name.
	X
	XOne of the goals of the UUCP Project is to keep duplicate UUCP host
	Xnames from appearing because there exist mailers in the world which
	Xassume that the UUCP name space contains no duplicates (and attempts
	XUUCP path optimization on that basis), and it's just plain confusing to
	Xhave two different sites with the same name.
	X
	XAt present, the most severe restriction on UUCP names is that the name
	Xmust be unique somewhere in the first six characters, because of a poor
	Xsoftware design decision made by AT&T for the System V release of UNIX.
	X
	XThis does not mean that your site name has to be six characters or less
	Xin length. Just unique within that length.
	X
	XWith regard to choosing system names, HARRIS'S LAMENT:
	X
	X	``All the good ones are taken.''
	X
	X#S	machine type; operating system
	X
	XThis is a quick description of your equipment. Machine type should
	Xbe manufacturer and model, and after a semi-colon(;), the operating
	Xsystem name and version number (if you have it). Some examples:
	X
	X	DEC PDP-11/70; 2.9 BSD UNIX
	X	DEC PDP-11/45; ULTRIX-11
	X	DEC VAX-11/780; VMS 4.0
	X	SUN 2/150; 4.2 BSD UNIX
	X	Pyramid 90x; OSx 2.1
	X	CoData 3300; Version 7 UniPlus+
	X	Callan Unistar 200; System V UniPlus+
	X	IBM PC/XT; Coherent
	X	Intel 386; XENIX 3.0
	X	CRDS Universe 68; UNOS
	X
	X#O	organization name
	X
	XThis should be the full name of your organization, squeezed to fit
	Xinside 80 columns as necessary. Don't be afraid to abbreviate where the
	Xabbreviation would be clear to the entire world (say a famous
	Xinstitution like MIT or CERN), but beware of duplication (In USC the C
	Xcould be either California or Carolina).
	X
	X#C	contact person
	X
	XThis should be the full name (or names, separated by commas) of the
	Xperson responsible for handling queries from the outside world about
	Xyour machine.
	X
	X#E	contact person's electronic address
	X
	XThis should be just a machine name, and a user name, like
	X`ucbvax!fair'. It should not be a full path, since we will be able to
	Xgenerate a path to the given address from the data you're giving us.
	XThere is no problem with the machine name not being the same as the #N
	Xfield (i.e. the contact `lives' on another machine at your site).
	X
	XAlso, it's a good idea to give a generic address or alias (if your mail
	Xsystem is capable of providing aliases) like `usenet' or `postmaster',
	Xso that if the contact person leaves the institution or is re-assigned
	Xto other duties, he doesn't keep getting mail about the system. In a
	Xperfect world, people would send notice to the UUCP Project, but in
	Xpractice, they don't, so the data does get out of date. If you give a
	Xgeneric address you can easily change it to point at the appropriate
	Xperson.
	X
	XMultiple electronic addresses should be separated by commas, and all of
	Xthem should be specified in the manner described above.
	X
	X#T	contact person's telephone number
	X
	XFormat: +<country code><space><area code><space><prefix><space><number>
	X
	XExample:
	X
	X#T	+1 415 642 1024
	X
	XThis is the international format for the representation of phone
	Xnumbers. The country code for the United States of America is 1. Other
	Xcountry codes should be listed in your telephone book.
	X
	XIf you must list an extension (i.e. what to ask the receptionist for,
	Xif not the name of the contact person), list it after the main phone
	Xnumber with an `x' in front of it to distinguish it from the rest of
	Xthe phone number.
	X
	XExample:
	X
	X#T	+1 415 549 3854 x37
	X
	XMultiple phone numbers should be separated by commas, and all of them
	Xshould be completely specified as described above to prevent confusion.
	X
	X#P      organization's address
	X
	XThis field should be one line filled with whatever else anyone would
	Xneed after the contact person's name, and your organization's name
	X(given in other fields above), to mail you something in the physical
	Xmails. Generally, if there's room, it's best to spell out things
	Xlike Road, Street, Avenue, and Boulevard, since this is an international
	Xnetwork, and the abbreviations will not necessarily be obvious to someone
	Xfrom Finland, for example.
	X
	X#L      longitude and latitude
	X
	XThis should be in the following format:
	X
	X#L	NN MM [SS] N|S / NNN MM [SS] E|W  [city]
	X
	XTwo fields, with optional third.
	X
	XFirst number is Latitude in degrees (NN), minutes (MM), and seconds (SS),
	Xand a N or S to indicate North or South of the Equator.
	X
	XA Slash Separator.
	X
	XSecond number is Longitude in degrees (NNN), minutes (MM), and seconds (SS),
	Xand a E or W to indicate East or West of the Prime Meridian in Greenwich,
	XEngland.
	X
	XSeconds are optional, but it is worth noting that the more accurate you
	Xare, the more accurate maps we can make of the network (including
	Xblow-ups of various high density areas, like New Jersey, or the San
	XFrancisco Bay Area).
	X
	XIf you give the coordinates for your city (i.e. without fudging for
	Xwhere you are relative to that), add the word `city' at the end of the
	Xend of the specification, to indicate that. If you know where you are
	Xrelative to a given coordinate for which you have longitude and
	Xlatitude data, then the following fudge factors can be useful:
	X
	X1 degree	=	69.2 miles	=	111 kilometers
	X1 minute	=	1.15 miles	=	1.9 kilometers
	X1 second	=	101.5 feet	=	31 meters
	X
	XThe Prime Meridian is through Greenwich, England, and longitudes go no
	Xhigher than 180 degrees West or East of Greenwich. Latitudes go no
	Xhigher than 90 degrees North or South of the Equator.
	X
	XBeware that the distance between two degrees of longitude decreases as
	Xyou get further away from the Equator. (Imagine all those longitudinal
	Xlines converging on the north and south poles...) These numbers are
	Xgood for the Equator.  If you're in Alaska or Norway, for example, they
	Xare certainly too large for you to fudge longitude accurately.
	X
	X#R      remarks
	X
	XThis is for one line of comment. As noted before, all lines beginning
	Xwith a `#' character are comment lines, so if you need more than one
	Xline to tell us something about your site, do so between the end of the
	Xmap data (the #?\t fields) and the pathalias data.
	X
	X#U	netnews neighbors
	X
	XThe USENET is the network that moves netnews around, specifically,
	Xnet.announce. If you send net.announce to any of your UUCP neighbors,
	Xlist their names here, delimited by spaces. Example:
	X
	X#U	ihnp4 decvax mcvax seismo
	X
	XSince some places have lots of USENET neighbors, continuation lines
	Xshould be just another #U and more site names.
	X
	X#W      who last edited the entry and when
	X
	XThis field should contain an email address, a name in parentheses,
	Xfollowed by a semi-colon, and the output of the date program.
	XExample:
	X
	X#W	ucbvax!fair (Erik E. Fair); Sat Jun 22 03:35:16 PDT 1985
	X
	XThe same rules for email address that apply in the contact's email
	Xaddress apply here also. (i.e. only one system name, and user name).
	XIt is intended that this field be used for automatic ageing of the
	Xmap entries so that we can do more automated checking and updating
	Xof the entire map. See getdate(3) from the netnews source for other
	Xacceptable date formats.
	X
	XPATHALIAS DATA (or, documenting your UUCP connections & frequency of use)
	X
	XThe DEMAND, DAILY, etc., entries represent imaginary connect costs (see
	Xbelow) used by pathalias to calculate lowest cost paths.  The cost
	Xbreakdown is:
	X
	X	LOCAL		25	local area network
	X	DEDICATED	95	high speed dedicated
	X	DIRECT		200	local call
	X	DEMAND          300     normal call (long distance, anytime)
	X	HOURLY		500	hourly poll
	X	EVENING		1800	time restricted call
	X	DAILY		5000	daily poll
	X	WEEKLY		30000	irregular poll
	X	DEAD            a very high number - not usable path
	X
	XAdditionally, HIGH and LOW (used like DAILY+HIGH) are -5 and +5
	Xrespectively, for baud-rate or quality bonuses/penalties.  Arithmetic
	Xexpressions can be used, however, you should be aware that the results
	Xare often counter-intuitive (e.g. (DAILY*4) means every 4 days, not 4
	Xtimes a day).
	X
	XThe numbers are intended to represent frequency of connection, which
	Xseems to be far more important than baud rates for this type of
	Xtraffic.  There is an assumed high overhead for each hop; thus,
	XHOURLY is far more than DAILY/24.
	X
	XThere are a few other cost names that sometimes appear in the map;
	Xthese are discouraged.  Some are synonyms for the prefered
	Xnames above (e.g. POLLED means DAILY), some are obsolete (e.g.
	Xthe letters A through F, which are letter grades for connections.)
	XIt is not acceptable to make up new names or spellings (pathalias
	Xgets very upset when people do that...).
	X
	XLOCAL AREA NETWORKS
	X
	XFor local area networks, (since they are usually completely connected),
	Xthere is a list notation for specifying them. Usually there is one
	Xgateway machine to the outside world; it is best that the definition of
	Xthe network appear in that system's pathalias entry, and the other
	Xsystems just note that they connect to the LAN.  An abbreviated map
	Xentry for the sake of example:
	X
	X#N	frobozz
	X#O	Frobozz Skonk Works
	X#C	Joe Palooka
	X#E	frobozz!postmaster
	X#R	gateway machine to Frobozz Company LAN
	X#
	Xfrobozz	ucbvax(DEMAND), ihnp4(EVENING), seismo(DAILY),
	X	mcvax(WEEKLY), akgua(EVENING)
	X#
	X#	LAN addressed user@host
	X#
	XFROBOZZ-ETHER = @{frobozz, frob1, frob2, frob3}(LOCAL)
	X#
	X#	LAN addressed BerkNet style host:user
	X#
	XFROBOZZ-BERKNET = {frobozz, frob4, frob5, frob6}:(LOCAL)
	X
	XFor the other sites on the LAN, their map entries should reflect
	Xwho is in charge of the machine, and their pathalias data
	Xwould appear like this (again, this example is abbreviated):
	X
	X#N	frob1
	X#O	Frobozz Skonk Works, Software Development System
	X#C	Joe Palooka
	X#E	frobozz!postmaster
	X#
	Xfrob1	FROBOZZ-ETHER
	X
	XWHAT TO DO WITH THIS STUFF
	X
	XOnce you have finished constructing your pathalias entry, mail it off
	Xto {ucbvax,ihnp4,akgua,seismo}!cbosgd!uucpmap, which is a mailing list
	Xof the regional map coordinators.  They maintain assigned geographic
	Xsections of the map, and the entire map is posted on a rolling basis in
	Xthe USENET newsgroups mod.map.uucp over the course of a month (at the
	Xend of the month they start over).
	X
	XQuestions or comments about this specification should also be directed at
	Xcbosgd!uucpmap.
	X
SHAR_EOF
if test 11998 -ne "`wc -c < 'dirform'`"
then
	echo shar: error transmitting "'dirform'" '(should have been 11998 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'euuname.sh'" '(767 characters)'
if test -f 'euuname.sh'
then
	echo shar: will not over-write existing file "'euuname.sh'"
else
sed 's/^	X//' << \SHAR_EOF > 'euuname.sh'
	X: From cbosg!mcnc!unc!smb Sat Feb 27 05:45:42 1982
	X: Date: 27-Feb-82 05:45:41-EST
	X
	X: Heres a shell file that should be distributed with netnews.
	X: Its intended to be the program that replies to the mapping control
	X: message, it extracts info from the L.sys file, add extra names, and
	X: suppresses private ones.
	X
	X: To use this, change the senduuname control message to call
	X: LIBDIR/euuname instead of uuname, and install this script in that location.
	X: the lists secret and extras are names you want deleted from added to
	X: your uuname output.
	X
	XPATH=/usr/ucb:/bin:/usr/bin
	Xexport PATH
	Xcd /usr/lib/news
	Xtrap "rm -f /tmp/nam$$; exit" 0 1 2
	Xsort secret >/tmp/nam$$
	Xecho Subject: edited uuname output enclosed
	X((cat extras; uuname) | sort | comm -23 - /tmp/nam$$) | uniq
SHAR_EOF
if test 767 -ne "`wc -c < 'euuname.sh'`"
then
	echo shar: error transmitting "'euuname.sh'" '(should have been 767 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'grabheaders.c'" '(1621 characters)'
if test -f 'grabheaders.c'
then
	echo shar: will not over-write existing file "'grabheaders.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'grabheaders.c'
	X#include <stdio.h>
	X#include <sys/types.h>
	X#include <sys/stat.h>
	X
	X#define HISTORY	"/usr/new/lib/news/history"
	X#define SPOOL	"/usr/spool/news"
	X
	X#include <sys/types.h>
	X#include <sys/timeb.h>
	X#include <ctype.h>
	X#include <sys/time.h>
	X
	X#define	NULL	0
	X#define daysec (24L*60L*60L)
	X
	Xmain()
	X{
	X	FILE *Hfile, *Afile;
	X	char buffer[BUFSIZ], datestr[BUFSIZ];
	X	char *index();
	X	struct stat stbuf;
	X	struct timeb now;
	X	long t;
	X
	X	Hfile = fopen(HISTORY, "r");
	X	if (Hfile == NULL) {
	X		perror(HISTORY);
	X		exit(1);
	X	}
	X
	X	if (chdir(SPOOL) < 0) {
	X		perror(SPOOL);
	X		exit(1);
	X	}
	X
	X	(void) ftime(&now);
	X
	X	while (fgets(buffer, BUFSIZ, Hfile) != NULL) {
	X		register char *p, *file;
	X
	X		p = index(buffer, '\t');
	X		if (p == NULL)
	X			continue;
	X		file = index(p+1, '\t');
	X		if (file == NULL || file[1] == '\n')
	X			continue;
	X		*file = '\0';
	X		t = getdate(p, &now);
	X		if ( (t+daysec*14L) < now.time)
	X			continue;
	X		strcpy(datestr, p);
	X		p = file;
	X		while (*++p != ' ' && *p != '\n')
	X			if (*p == '.')
	X				*p = '/';
	X		*p = '\0';
	X		file++;
	X		if (       strncmp(file, "net", 3)  && strncmp(file, "mod", 3)
	X			&& strncmp(file, "comp", 4) && strncmp(file, "sci", 3)
	X			&& strncmp(file, "news", 4) && strncmp(file, "rec", 3)
	X			&& strncmp(file, "talk", 4) && strncmp(file, "misc", 4)
	X			&& strncmp(file, "soc", 4)
	X			)
	X			continue;
	X		Afile = fopen(file, "r");
	X		if (Afile == NULL)
	X			continue;
	X		while (fgets(buffer, BUFSIZ, Afile) != NULL &&
	X		    buffer[0] != '\n')
	X		    fputs(buffer, stdout);
	X		fstat(fileno(Afile), &stbuf);
	X		printf("Date-Received: %s\n", datestr);
	X		printf("Bytes: %ld\n\n", stbuf.st_size - ftell(Afile));
	X		fclose(Afile);
	X	}
	X	printf("\n");
	X}
SHAR_EOF
if test 1621 -ne "`wc -c < 'grabheaders.c'`"
then
	echo shar: error transmitting "'grabheaders.c'" '(should have been 1621 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'keepnews'" '(17621 characters)'
if test -f 'keepnews'
then
	echo shar: will not over-write existing file "'keepnews'"
else
sed 's/^	X//' << \SHAR_EOF > 'keepnews'
	XFrom chuqui@nsc.UUCP (Chuq Von Rospach) Thu Jun  6 20:36:39 1985
	XRelay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site seismo.UUCP
	XPosting-Version: version B 2.10.2 9/17/84 chuqui version 1.7 9/23/84; site nsc.UUCP
	XPath: seismo!nsc!chuqui
	XFrom: chuqui@nsc.UUCP (Chuq Von Rospach)
	XNewsgroups: net.sources
	XSubject: YA News Archiver
	XMessage-ID: <2806@nsc.UUCP>
	XDate: 7 Jun 85 00:36:39 GMT
	XDate-Received: 7 Jun 85 06:25:58 GMT
	XDistribution: net
	XOrganization: The Blue Parrot
	XLines: 566
	X
	XHere is a netnews archiver similar to the recently posted keepnews but
	Xdesigned to work with much larger archives where the wonderful quadratic
	Xsearch time feature of the Unix (Unix is a trademark of AT&T Bell Labs,
	Xquadratic search times are a feature of Unix) becomes a real problem. This
	Xarchive also knows how to walk through a directory tree so you can simply
	Xset it on /usr/spool/oldnews and let it do its work. There are lots of
	Xother nifty things I call features (and you might, too) that make it a lot
	Xeasier to use than anything else I've seen set up to work on archives. Mine
	Xsimply outgrew any capability to do anything with about the same time I got
	Xa request for information out of it. I found out (the hard way) that
	Xkeepnews wasn't terribly reliable working under 2.10.2, so I finally
	Xdecided to hack together my own.
	X
	XComments, enhancements, bug fixes, etc... are welcome, but I can only work
	Xon them on a time available basis...
	X
	Xchuq
	X------- 
	X#	This is a shell archive.
	X#	Remove everything above and including the cut line.
	X#	Then run the rest of the file through sh.
	X#-----cut here-----cut here-----cut here-----cut here-----
	X#!/bin/sh
	X# shar:	Shell Archiver
	X#	Run the following text with /bin/sh to create:
	X#	README
	X#	Makefile
	X#	savenews.c
	X# This archive created: Thu Jun  6 17:28:50 1985
	X# By:	Chuq Von Rospach (The Blue Parrot)
	Xcat << \SHAR_EOF > README
	XSavenews --
	X
	XSavenews is a short program designed to make handling of usenet archives
	Xgenerated by 'expire -a' easier, and to make it possible to find stuff in
	Xthe archive once it is there. 
	X
	XIt was created by me when I had to get something out of my archives and
	Xrealized that there was no way I was going to find anything in 70 megabytes
	Xof random data. It keeps a set of logs of the Subject lines of the articles
	Xand stores the articles themselves in a hashed subdirectory format designed
	Xto minimize the quadratic lookup hassles of the unix directory system
	X(This, of course, is a feature). 
	X
	XIt has been put into the public domain by national semiconductor, and
	Xneither myself or national guarantee that this code even exists, much
	Xless that it does anything useful. This, BTW, is a disclaimer.
	X
	Xchuq von rospach
	Xnational semiconductor
	Xnsc!chuqui
	XSHAR_EOF
	Xcat << \SHAR_EOF > Makefile
	X#
	X# Makefile for savenews
	X#
	XCFLAGS = -g
	X
	Xsavenews: savenews.c
	X	${CC} ${CFLAGS} savenews.c -o savenews
	X
	Xclean:
	X	rm -f savenews
	X
	Xlint:
	X	lint -hx savenews.c
	XSHAR_EOF
	Xcat << \SHAR_EOF > savenews.c
	X/*
	X * savenews filename [filename ...]
	X *
	X * Savenews is a program designed to clean up and compact a
	X * usenet archive. It will take the filename(s) given to it as arguments
	X * and save them in a netnews archive (defined by SAVENEWS, default is
	X * /usr/spool/savenews).
	X *
	X * This program was set up to do two main things:
	X *
	X * 1) compact out the useless parts of the message, specifically the lines
	X *    in the header that don't serve a useful purpose in an archive. This 
	X *    is done by removing all but the following header lines: From, Date,
	X *    Newsgroups, Subject, and Message-ID, and seems to save an average of
	X *    500 bytes an article.
	X *
	X * 2) keep the quadratic nature of unix(TM AT&T Bell labs) directory searches
	X *    from making your life miserable. Storing a raw archive of
	X *    net.unix-wizards is a silly thing to do, for example. What I do is
	X *    create a one level subdirectory set to keep any one directory from
	X *    getting too large, but this program is currently set so that there
	X *    are enough directories to keep the total number of files in any one
	X *    directory below about 150 in the largest parts of my archive. The
	X *    algorithm I use is abs(atoi(Message-ID)%HASHVAL)) with HASHVAL being
	X *    prime. This quick and dirty hash gives you directories with the
	X *    numbers 0 to HASHVAL-1, and about the same number of files in each
	X *    given a random distribution of Message-ID numbers (not bad, in
	X *    reality)
	X *
	X * The program will add the name of the file and the subject line of the
	X * article in a logfile in subdirectory LOGS, the filename being the 
	X * newsgroup.
	X *
	X * As currently written, an article will be saved only to the first 
	X * newsgroup in the Newsgroups header line. This means that something
	X * posted to 'net.source,net.flame' will end up in net.sources, but that
	X * somethine posted to 'net.flame,net.sources' will end up in net.flame.
	X * I consider this a feature. Others may disagree.
	X *
	X * If an article is saved that has a duplicate message-ID of one already
	X * in the archive, then it will be saved by adding the character '_' and
	X * some small integer needed to make the filename unique. You can then
	X * use ls or find to look for these and see if they are duplicates (and
	X * remove them) or if they are simply botches by some other site (it does
	X * happen, unfortunately).
	X *
	X * This program will do intelligent things if given a non-news article,
	X * such as nothing. Don't push it, though -- I haven't tried it on
	X * special devices, symbolic links, and other wierdies and it is likely
	X * to throw up on some of them since I didn`t feel like protecting someone
	X * from trying to archive /dev (if tar can consider this a feature, so can
	X * I...)
	X *
	X * This program uses the 4.2 Directory routines (libndir). If you don't
	X * run 4.2, get ahold of a copy of the compatibility library for your
	X * system and use it, or hack up do_dir and is_dir to get around it
	X * if you believe in messing around with primitive hacks (I LIKE libndir)
	X *
	X * General usage: every so often run the program with 
	X * 'savenews /usr/spool/oldnews'. Look through /usr/spool/savenews
	X * for duplicated articles and remove them, and then copy all of the
	X * stuff to tape. Remove everything except the LOGS directory, so that
	X * people can use grep to look for things in the archive. It should be
	X * easy to get things back off of tape and make the archive useful this
	X * way. Thinking about it, if you can't use the archive, you might as well
	X * not have it, which is why this program got written (I needed something
	X * out of my archive, and it took me a week to find it).
	X *
	X * This program is designed to run under 2.10.2, but should work under any
	X * B news system. Anyone else is on their own. This is in
	X * the public domain by the kindness of my employer, national
	X * semiconductor, but neither I nor national make any guarantee that it
	X * will work, that we will support this program, or even admit that it
	X * exists. This is called a disclaimer, and means that if you use this 
	X * program, you are on your own. It DOES, however, pass lint cleanly, which
	X * is more than I can say for most stuff posted to the net. Feel free to 
	X * fix, break, enhance, change, or do anything to this program except
	X * claim it to be your own (unless, of course, you break it...). Passing
	X * enhancements back to me would be nice, too.
	X *
	X *	chuq von rospach, national semiconductor (nsc!chuqui)
	X *
	X */
	X
	X#include <stdio.h>
	X#include <sys/types.h>
	X#include <sys/stat.h>
	X#include <sys/dir.h>
	X#include <ctype.h>
	X
	X#define FALSE		0
	X#define TRUE		1
	X#define HASHVAL		37	/* hash value for sub-dirs. Prime number! */
	X#define NUMDIRS		1024	/* number of dirs that can be pushed */
	X#define SAVENEWS	"/usr/spool/savenews" /* home of the archive */
	X#define LOGFILE		"LOGS"  /* subdir in SAVENEWS to save logs in */
	X#define JOBLOG		"joblog" /* where log of this job is put */
	X#define DIRMODE		0755    /* mkdir with this mode */
	X#define COPYBUF		8192    /* block read/write buffer size */
	X
	Xchar *Progname;			/* name of the program for Eprintf */
	Xchar line[BUFSIZ];		/* general purpose line buffer */
	X
	X#define NUM_HEADERS	5	/* number of headers we are saving */
	X#define GROUP_HEADER	1	/* where Newsgroup will be found */
	X#define SUBJECT_HEADER	2	/* where Subject will be found */
	X#define MESSAGE_HEADER	3	/* where Message-ID will be found */
	Xchar header_data[NUM_HEADERS][BUFSIZ];
	Xchar *headers[NUM_HEADERS] =
	X{
	X    "From:",
	X    "Newsgroups:",
	X    "Subject:",
	X    "Message-ID:",
	X    "Date:"
	X};
	X
	Xlong num_saved = 0;		/* number of articles saved */
	XFILE *logfp;			/* file pointer to joblog file */
	X
	Xchar *rindex(), *strcat(), *pop_dir(), *strcpy(), *strsave(), *index();
	X
	Xmain(argc,argv)
	Xint argc;
	Xchar *argv[];
	X{
	X    register int i;
	X    char joblogfile[BUFSIZ];
	X    char *dirname;
	X    
	X    /*
	X     * This removes and preceeding pathname so that
	X     * anything printed out by Eprintf has just the 
	X     * program name and not where it came from
	X     */
	X    if ((Progname = rindex(argv[0],'/')) == NULL)  
	X	Progname = argv[0];			   
	X    else
	X	Progname++;				  
	X
	X    if (argc == 1) {
	X	fprintf(stderr,"Usage: %s file [file ...]\n",Progname);
	X	exit(1);
	X    }
	X
	X    sprintf(joblogfile,"%s/%s",SAVENEWS,JOBLOG);
	X    if ((logfp = fopen(joblogfile,"w")) == NULL)
	X	fprintf(stderr,"Can't open %s, logging suspended\n",joblogfile);
	X
	X    for (i = 1 ; i < argc; i++) {	/* process each parameter */
	X	register int rc;
	X	if ((rc = is_dir(argv[i])) == -1)
	X	    continue;
	X	else if (rc == TRUE)
	X	    do_dir(argv[i]);
	X	else
	X	    save_file(argv[i]);
	X    }
	X    while((dirname = pop_dir()) != NULL) {
	X	do_dir(dirname);	/* process whatever is left on dirstack */
	X    }
	X    printf("Total articles saved was %d\n",num_saved);
	X    exit(0);
	X}
	X
	Xdo_dir(dname) /* process a directory, push other directories on stack */
	X	      /* to be handled recursively later */
	Xchar *dname;
	X{
	X    DIR *dirp;
	X    struct direct *dp;
	X    char fullname[BUFSIZ];
	X
	X    if ((dirp = opendir(dname)) == NULL) {
	X	Eprintf("can't opendir %s\n",dname);
	X	return;
	X    }
	X
	X    for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
	X	register int rc;
	X
	X	if(dp->d_namlen == 2 && !strcmp(dp->d_name,"..") 
	X	|| (dp->d_namlen == 1 && !strcmp(dp->d_name,".")))
	X	    continue; /* skip . and .. */
	X
	X	sprintf(fullname,"%s/%s",dname,dp->d_name);
	X	if((rc = is_dir(fullname)) == -1)
	X	    continue;
	X	else if (rc == TRUE)
	X	    push_dir(fullname);
	X	else
	X	    save_file(fullname);
	X    }
	X    closedir(dirp);
	X}
	X
	Xis_dir(name)
	Xchar *name;
	X{
	X    struct stat sbuf;
	X
	X    if (stat(name,&sbuf) == -1) {
	X	Eprintf("can't stat '%s'\n",name);
	X	return(-1);
	X    }
	X    return((sbuf.st_mode & S_IFDIR) ? TRUE : FALSE);
	X}
	X
	X/* VARARGS */
	XEprintf(s1,s2,s3,s4,s5,s6,s7,s8,s9)
	Xchar *s1,*s2,*s3,*s4,*s5,*s6,*s7,*s8,*s9;
	X{
	X    if (logfp == NULL)
	X	return;
	X    fprintf(logfp,"%s: ",Progname);
	X    fprintf(logfp,s1,s2,s3,s4,s5,s6,s7,s8,s9);
	X    fflush(logfp);
	X}
	X
	X/*
	X * quick and dirty stack routines.
	X *
	X * push_dir(name) char *name; 
	X *	stores the given string in the stack
	X * char *pop_dir()
	X *	returns a string from the stack, or NULL if none.
	X */
	X
	Xstatic char *dirstack[NUMDIRS];
	Xstatic int lastdir = 0;
	Xstatic char pop_name[BUFSIZ];
	X
	Xpush_dir(name)
	Xchar *name;
	X{
	X    if (lastdir >= NUMDIRS) {
	X	Eprintf("push_dir overflow!\n");
	X	return;
	X    }
	X    dirstack[lastdir] = strsave(name);
	X    if (dirstack[lastdir] == NULL)
	X    {
	X	Eprintf("malloc failed!\n");
	X	return;
	X    }
	X    lastdir++;
	X}
	X
	Xchar *pop_dir()
	X{
	X    if(lastdir == 0)
	X	return(NULL);
	X    lastdir--;
	X    strcpy(pop_name,dirstack[lastdir]);
	X    dirstack[lastdir] = NULL;
	X    free(dirstack[lastdir]);
	X    return(pop_name);
	X}
	X
	Xchar *strsave(s)
	Xchar *s;
	X{
	X    char *p, *malloc();
	X
	X    if ((p = malloc((unsigned)strlen(s)+1)) != NULL)
	X	strcpy(p,s);
	X    return(p);
	X}
	X
	Xsave_file(name)		/* save the article in the archive */
	Xchar *name;
	X{
	X    FILE *fp, *ofp, *fopen(), *output_file();
	X    register int i, nc;
	X    char diskbuf[COPYBUF];
	X
	X    Eprintf("saving '%s'\n",name);
	X    if ((fp = fopen(name,"r")) == NULL) {
	X	Eprintf("can't open\n");
	X	return;
	X    }
	X
	X    if ((fgets(line,BUFSIZ,fp) == NULL)) {
	X	Eprintf("0 length file\n");
	X	fclose(fp);
	X	return;
	X    }
	X    if (!start_header(line)) {
	X	Eprintf("not a news article\n");
	X	fclose(fp);
	X	return;
	X    }
	X    read_header(fp);
	X    if ((ofp = output_file()) == NULL) {
	X	Eprintf("Can't save\n");
	X	fclose(fp);
	X	return;
	X    }
	X
	X    for (i = 0; i < NUM_HEADERS; i++)
	X	fprintf(ofp,"%s\n",header_data[i]);
	X    fputc('\n',ofp);
	X
	X    while ((nc = fread(diskbuf,sizeof(char),COPYBUF,fp)) != 0)
	X	fwrite(diskbuf,sizeof(char),nc,ofp);	/* copy body of article */
	X    fclose(ofp);
	X    fclose(fp);
	X    num_saved++;
	X    return;
	X}
	X
	Xstart_header(s) /* see if this is the start of a news article */
	Xchar *s;
	X{
	X    /*
	X     * If this is coming from B news, the first line will 'always' be
	X     * Relay-Version (at least, on my system). Your mileage my vary.
	X     */
	X    if (!strncmp(s,"Relay-Version:",14))
	X	return(TRUE);
	X    /*
	X     * If you are copying a section of archive already archived by 
	X     * sendnews, then the first line will be From (unless you changed
	X     * the headers data structure, then its up to you...)
	X     */
	X    if (!strncmp(s,"From:",5))
	X	return(TRUE);
	X    return(FALSE);
	X}
	X
	X/* 
	X * By the time we get here, the first line will already be read in and
	X * checked by start_header(). If we are re-copying a savenews archive
	X * (which happens when you decide to play with HASHVAL, trust me) then
	X * we need to save the From line, so we can't just throw it away. Hence
	X * the funky looking do-while setup instead of something a bit more
	X * straightforward
	X */
	Xread_header(fp)
	XFILE *fp;
	X{
	X    register int i;
	X
	X    for (i = 0; i < NUM_HEADERS; i++)
	X	header_data[i][0] = '\0';		/* remove last articles data */
	X
	X    do {
	X	char *cp;
	X
	X	if (line[0] == '\n')	/* always be a blank line after the header */
	X	    return;
	X
	X	for (i = 0 ; i < NUM_HEADERS; i++) {
	X	    if (!strncmp(headers[i],line,strlen(headers[i]))) {
	X		strcpy(header_data[i],line);
	X		if (cp = index(header_data[i],'\n'))
	X		    *cp = '\0';				/* eat newlines */
	X	    }
	X	}
	X    } while (fgets(line,BUFSIZ,fp) != NULL);
	X}
	X
	XFILE *output_file() /* generate the name in the archive */
	X{
	X    int hashval, copy = 0;
	X    FILE *fp, *fopen();
	X    char *p, newsgroup[BUFSIZ], message_id[BUFSIZ];
	X    char shortname[BUFSIZ], filename[BUFSIZ], filename2[BUFSIZ];
	X
	X    /* get the first newsgroup */
	X    p = index(header_data[GROUP_HEADER],':'); /* move past Newsgroups */
	X    if (!p) {
	X	Eprintf("Invalid newsgroups\n");
	X	return(NULL);
	X    }
	X    p++;	/* skip the colon */
	X    while (isspace(*p))
	X	p++;	/* skip whitespace */
	X    strcpy(newsgroup,p);
	X    if (p = index(newsgroup,','))
	X	*p= '\0';	/* newsgroup now only has one name in it */
	X    
	X    /* get the message-id */
	X    p = index(header_data[MESSAGE_HEADER],':');
	X    if (!p) {
	X	Eprintf("Invalid message-id\n");
	X	return(NULL);
	X    }
	X    p++;	/* skip the colon */
	X    while (isspace(*p))
	X	p++;	/* skip whitespace */
	X    if (*p == '<' || *p == '(')
	X	p++;
	X    if (*p == '-') /* make negative article id numbers positive (hack) */
	X	p++;
	X    strcpy(message_id,p);
	X    if (p = index(message_id,'.')) /* trim off the .UUCP if any */
	X	*p = '\0';
	X    else if (p = index(message_id,'>'))  /* or get the closing bracket */
	X	*p = '\0';
	X    else if (p = index(message_id,')')) /* or get the closing paren */
	X	*p = '\0';
	X    if (p = index(message_id,'@'))	/* change nnn@site */
	X	*p = '.';			/* to nnn.site */
	X
	X    /* generate the hash value for the subdirectory */
	X    hashval = atoi(message_id) % HASHVAL;
	X
	X    /* setup the filename to save to */
	X    sprintf(shortname,"%s/%d/%s",newsgroup,hashval,message_id);
	X    sprintf(filename,"%s/%s",SAVENEWS,shortname);
	X    while (exists(filename)) {	/* make it unique if neccessary */
	X
	X	sprintf(shortname,"%s/%d/%s_%d",newsgroup,hashval,message_id,++copy);
	X	sprintf(filename,"%s/%s",SAVENEWS,shortname);
	X    }
	X    
	X    strcpy(filename2,filename);			/* must chop off the filename */
	X    if (p = rindex(filename2,'/'))		/* since we don't want to */
	X	*p = '\0';				/* to makeparents */
	X    makeparents(filename2);
	X
	X    if ((fp = fopen(filename,"w")) == NULL) {
	X	Eprintf("Can't open %s for output\n",filename);
	X	return(NULL);
	X    }
	X    log(newsgroup,shortname);
	X    return(fp);
	X}
	X
	Xexists(name)
	Xchar *name;
	X{
	X    struct stat sbuf;
	X
	X    if (stat(name,&sbuf) == -1) {
	X	return(FALSE);
	X    }
	X    return(TRUE);
	X}
	X
	Xmakeparents(name) /* recursively make parent directories */
	Xchar *name;
	X{
	X    char *p, buf[BUFSIZ];
	X
	X    if (exists(name))
	X	return;
	X    strcpy(buf,name);
	X    if (!(p = rindex(buf,'/'))) {
	X	Eprintf("makeparents failed!\n");
	X	return;
	X    }
	X    *p = '\0';
	X    makeparents(buf);
	X    mkdir(name,DIRMODE);
	X}
	X
	Xlog(group,name) /* write to the logfile */
	Xchar *group, *name;
	X{
	X    char *subject, logfile[BUFSIZ];
	X    FILE *ofp, *fopen();
	X
	X    /* get the subject */
	X    subject = index(header_data[SUBJECT_HEADER],':');
	X    if (!subject) {
	X	Eprintf("Invalid subject, no log entry\n");
	X	return;
	X    }
	X    subject++;	/* skip the colon */
	X    while (isspace(*subject))
	X	subject++;	/* skip whitespace */
	X
	X    /* generate the place where it goes */
	X    sprintf(logfile,"%s/%s",SAVENEWS,LOGFILE);
	X    makeparents(logfile);
	X    strcat(logfile,"/");
	X    strcat(logfile,group);
	X
	X    if ((ofp = fopen(logfile,"a")) == NULL)
	X    {
	X	Eprintf("open failed on %s\n",logfile);
	X	return;
	X    }
	X    fprintf(ofp,"%s\t%s\n", name, subject);
	X    fclose(ofp);
	X}
	X
	XSHAR_EOF
	X#	End of shell archive
	Xexit 0
	X-- 
	X:From the misfiring synapses of:                  Chuq Von Rospach
	X{cbosgd,fortune,hplabs,ihnp4,seismo}!nsc!chuqui   nsc!chuqui@decwrl.ARPA
	X
	XThe offices were very nice, and the clients were only raping the land, and
	Xthen, of course, there was the money...
	X
	X
SHAR_EOF
if test 17621 -ne "`wc -c < 'keepnews'`"
then
	echo shar: error transmitting "'keepnews'" '(should have been 17621 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'net.recording'" '(195 characters)'
if test -f 'net.recording'
then
	echo shar: will not over-write existing file "'net.recording'"
else
sed 's/^	X//' << \SHAR_EOF > 'net.recording'
	XPosting to this newsgroup will cause your article to be broadcast to
	Xthe entire USENET, including sites outside of Bell Labs.  You should
	Xnot include any proprietary information in this article.
SHAR_EOF
if test 195 -ne "`wc -c < 'net.recording'`"
then
	echo shar: error transmitting "'net.recording'" '(should have been 195 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

