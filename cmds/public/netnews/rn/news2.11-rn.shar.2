#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	rn/EXTERN.h
#	rn/INTERN.h
#	rn/Makefile.SH
#	rn/Pnews.SH
#	rn/Rnmail.SH
#	rn/addng.h
#	rn/art.h
#	rn/art.help.SH
#	rn/artio.h
#	rn/artsrch.h
#	rn/artstate.h
#	rn/backpage.h
#	rn/bits.h
#	rn/cheat.h
#	rn/common.h
#	rn/final.h
#	rn/head.h
#	rn/help.h
#	rn/init.h
#	rn/intrp.h
#	rn/kfile.h
#	rn/last.h
#	rn/makedepend.SH
#	rn/makedir.SH
#	rn/mbox.saver.SH
#	rn/ndir.h
#	rn/newsetup.SH
#	rn/newsgroups.SH
#	rn/newsnews.SH
#	rn/ng.h
#	rn/ng.help.SH
#	rn/ngdata.h
#	rn/ngsrch.h
#	rn/ngstuff.h
#	rn/norm.saver.SH
#	rn/only.h
#	rn/pager.help.SH
#	rn/rcln.h
#	rn/rcstuff.h
#	rn/respond.h
#	rn/rn.h
#	rn/search.h
#	rn/subs.help.SH
#	rn/sw.h
#	rn/term.h
#	rn/util.h
# This archive created: Wed Mar  1 10:54:53 1989
export PATH; PATH=/bin:$PATH
echo shar: extracting "'EXTERN.h'" '(245 characters)'
if test -f 'EXTERN.h'
then
	echo shar: will not over-write existing file "'EXTERN.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'EXTERN.h'
	X/* $Header: EXTERN.h,v 4.3 85/05/01 11:58:01 lwall Exp $
	X *
	X * $Log:	EXTERN.h,v $
	X * Revision 4.3  85/05/01  11:58:01  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#undef EXT
	X#define EXT extern
	X
	X#undef INIT
	X#define INIT(x)
	X
	X#undef DOINIT
SHAR_EOF
if test 245 -ne "`wc -c < 'EXTERN.h'`"
then
	echo shar: error transmitting "'EXTERN.h'" '(should have been 245 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'INTERN.h'" '(243 characters)'
if test -f 'INTERN.h'
then
	echo shar: will not over-write existing file "'INTERN.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'INTERN.h'
	X/* $Header: INTERN.h,v 4.3 85/05/01 11:33:16 lwall Exp $
	X *
	X * $Log:	INTERN.h,v $
	X * Revision 4.3  85/05/01  11:33:16  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#undef EXT
	X#define EXT
	X
	X#undef INIT
	X#define INIT(x) = x
	X
	X#define DOINIT
SHAR_EOF
if test 243 -ne "`wc -c < 'INTERN.h'`"
then
	echo shar: error transmitting "'INTERN.h'" '(should have been 243 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Makefile.SH'" '(3426 characters)'
if test -f 'Makefile.SH'
then
	echo shar: will not over-write existing file "'Makefile.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting Makefile (with variable substitutions)"
	Xcat >Makefile <<!GROK!THIS!
	X# $Header: Makefile.SH,v 4.3.1.2 85/05/13 17:21:18 lwall Exp $
	X#
	X# $Log:	Makefile.SH,v $
	X# Revision 4.3.1.2  85/05/13  17:21:18  lwall
	X# System V make needs space before line-continuing backslash.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:30:15  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:33:26  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	XCC = $cc
	Xrnbin = $rnbin
	Xrnlib = $rnlib
	Xmansrc = $mansrc
	Xmanext = $manext
	XCFLAGS = $iandd -O
	XLDFLAGS = $iandd
	XNDIRC = $ndirc
	XNDIRO = $ndiro
	X
	Xlibs = $ndirlib $termlib $jobslib
	X!GROK!THIS!
	Xcat >>Makefile <<'!NO!SUBS!'
	X
	Xpublic = rn newsetup newsgroups Pnews Rnmail
	Xprivate = norm.saver mbox.saver ng.help art.help pager.help subs.help makedir filexp Pnews.header
	Xmanpages = rn.1 Pnews.1 Rnmail.1 newsetup.1 newsgroups.1
	Xutil = Makefile makedepend newsnews
	X
	Xh1 = addng.h art.h artio.h artsrch.h backpage.h bits.h cheat.h common.h
	Xh2 = final.h head.h help.h init.h intrp.h kfile.h last.h ndir.h ng.h
	Xh3 = ngdata.h ngsrch.h ngstuff.h only.h rcln.h rcstuff.h
	Xh4 = respond.h rn.h search.h sw.h term.h util.h
	X
	Xh = $(h1) $(h2) $(h3) $(h4)
	X
	Xc1 = addng.c art.c artio.c artsrch.c backpage.c bits.c cheat.c
	Xc2 = final.c head.c help.c init.c intrp.c kfile.c last.c $(NDIRC) ng.c
	Xc3 = ngdata.c ngsrch.c ngstuff.c only.c rcln.c rcstuff.c
	Xc4 = respond.c rn.c search.c sw.c term.c util.c
	X
	Xc = $(c1) $(c2) $(c3) $(c4)
	X
	Xobj1 = addng.o art.o artio.o artsrch.o backpage.o bits.o cheat.o
	Xobj2 = final.o head.o help.o init.o intrp.o kfile.o last.o $(NDIRO) ng.o
	Xobj3 = ngdata.o ngsrch.o ngstuff.o only.o rcln.o rcstuff.o
	Xobj4 = respond.o rn.o search.o sw.o term.o util.o
	X
	Xobj = $(obj1) $(obj2) $(obj3) $(obj4)
	X
	Xlintflags = -phbvxac
	X
	Xadd1 = Makefile.old Pnews Rnmail art.help
	Xadd2 = bsd config.h config.sh eunice filexp
	Xadd3 = loc makedepend makedir mbox.saver newsetup
	Xadd4 = newsgroups newsnews ng.help norm.saver pager.help
	Xadd5 = pdp11 rn subs.help usg v7
	X
	Xaddedbyconf = $(add1) $(add2) $(add3) $(add4) $(add5)
	X
	X# grrr
	XSHELL = /bin/sh
	X
	X.c.o:
	X	$(CC) -c $(CFLAGS) $*.c
	X
	Xall: $(public) $(private) $(util)
	X	touch all
	X
	Xrn: $(obj)
	X	$(CC) $(LDFLAGS) $(obj) $(libs) -o rn
	X
	X# if a .h file depends on another .h file...
	X$(h):
	X	touch $@
	X
	Xinstall: rn
	X# won't work with csh
	X	export PATH || exit 1
	X	- mv $(rnbin)/rn $(rnbin)/rn.old
	X	- if test `pwd` != $(rnbin); then cp $(public) $(rnbin); fi
	X	cd $(rnbin); chmod 755 $(public)
	X	chmod 755 makedir
	X	- ./makedir `./filexp $(rnlib)`
	X	- if test `pwd` != `./filexp $(rnlib)`; then cp INIT $(private) `./filexp $(rnlib)`; fi
	X	cd `./filexp $(rnlib)`; chmod 755 $(private)
	X	- if test ! -f `./filexp $(rnlib)/newsnews`; then cp newsnews `./filexp $(rnlib)`; fi
	X	- if test `pwd` != $(mansrc); then \
	Xfor page in $(manpages); do \
	Xcp $$page $(mansrc)/`basename $$page .1`.$(manext); \
	Xdone; \
	Xfi
	X
	Xclean:
	X	rm -f *.o
	X
	Xrealclean:
	X	rm -f rn *.o core $(addedbyconf)
	X
	X# The following lint has practically everything turned on.  Unfortunately,
	X# you have to wade through a lot of mumbo jumbo that can't be suppressed.
	X# If the source file has a /*NOSTRICT*/ somewhere, ignore the lint message
	X# for that spot.
	X
	Xlint:
	X	lint $(lintflags) $(defs) $(c) > rn.fuzz
	X
	Xdepend:
	X	makedepend
	X
	X# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
	X$(obj):
	X	@ echo "You haven't done a "'"make depend" yet!'; exit 1
	X!NO!SUBS!
	X$eunicefix Makefile
SHAR_EOF
if test 3426 -ne "`wc -c < 'Makefile.SH'`"
then
	echo shar: error transmitting "'Makefile.SH'" '(should have been 3426 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Pnews.SH'" '(14182 characters)'
if test -f 'Pnews.SH'
then
	echo shar: will not over-write existing file "'Pnews.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'Pnews.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting Pnews (with variable substitutions)"
	X$spitshell >Pnews <<!GROK!THIS!
	X$startsh
	X# $Header: Pnews.SH,v 4.3.1.4 86/09/05 15:21:10 lwall Exp $
	X#
	X# $Log:	Pnews.SH,v $
	X# Revision 4.3.1.4  86/09/05  15:21:10  lwall
	X# Changes for new top-level newsgroup names.
	X# 
	X# Revision 4.3.1.3  85/08/01  14:24:06  lwall
	X# Added AUTHORCOPY.  Temp file is no longer in /tmp.  'e editor' added.
	X# 
	X# Revision 4.3.1.2  85/05/17  10:36:46  lwall
	X# Removed some extra backslashes.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:30:21  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  12:20:33  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X#
	X# syntax: Pnews -h headerfile			or
	X#	  Pnews -h headerfile oldarticle	or
	X#         Pnews newsgroup title			or just
	X#         Pnews
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X# System dependencies
	X
	Xmailer="${mailer-/bin/mail}"
	X# if you change this to something that does signatures, take out signature code
	X
	Xcase $portable in
	Xdefine)
	X# your site name
	Xsitename=\`$hostcmd\`
	Xcase \$sitename in
	X	*.*)
	X		;;
	X	*)
	X		sitename=\${sitename}.$domain
	X		;;
	Xesac
	X# where recordings, distributions and moderators are kept
	Xlib=\`$filexp $lib\`
	X# where important rn things are kept
	Xrnlib=\`$filexp $rnlib\`
	X;;
	Xundef)
	X# your site name
	Xsitename="$sitename"
	X# where recordings, distributions and moderators are kept
	Xlib="$lib"
	X# where important rn things are kept
	Xrnlib="$rnlib"
	X;;
	Xesac
	X
	X# domain name - usually UUCP
	Xdomain="${domain-UUCP}"
	X# your organization name
	Xorgname="$orgname"
	X# what pager you use--if you have kernal paging use cat
	Xpager="\${PAGER-$pager}"
	X# how you derive full names, bsd, usg, or other
	Xnametype="$nametype"
	X# default editor
	Xdefeditor="$defeditor"
	X# how not to echo with newline
	Xn="$n"
	Xc="$c"
	X
	X# You should also look at the distribution warnings below marked !DIST!
	X# to make sure any distribution regions you are a member of are included.
	X# The following are some prototypical distribution groups.  If you do not
	X# use them all set the unused ones to a non-null string such as 'none'.
	Xloc="$locpref"
	Xorg="$orgpref"
	Xcity="$citypref"
	Xstate="$statepref"
	Xcntry="$cntrypref"
	Xcont="$contpref"
	X
	Xtest=${test-test}
	Xsed=${sed-sed}
	Xecho=${echo-echo}
	Xcat=${cat-cat}
	Xegrep=${egrep-egrep}
	Xgrep=${grep-grep}
	Xrm=${rm-rm}
	Xtr=${tr-tr}
	Xinews=${inews-inews}
	X
	X!GROK!THIS!
	X$spitshell >>Pnews <<'!NO!SUBS!'
	Xdotdir=${DOTDIR-${HOME-$LOGDIR}}
	Xtmpart=$dotdir/.article
	X
	Xif $test -f $dotdir/.pnewsexpert; then
	X    expertise=expert
	Xelse
	X    $cat <<'EOM'
	XI see you've never used this version of Pnews before.  I will give you extra
	Xhelp this first time through, but then you must remember what you learned.
	XIf you don't understand any question, type h and a CR (carriage return) for
	Xhelp.
	X
	XIf you've never posted an article to the net before, it is HIGHLY recommended
	Xthat you read the netiquette document found in mod.announce.newusers so
	Xthat you'll know to avoid the commonest blunders.  To do that, interrupt
	XPnews, and get to the top-level prompt of rn.  Say "g mod.announce.newusers"
	Xand you are on your way.
	X
	XEOM
	X    expertise=beginner
	Xfi
	X
	Xcase $cntry in
	X  can) stpr=Province ;;
	X  *)   stpr=State ;;
	Xesac
	X
	Xheaderfile=""
	Xcase $# in
	X0) ;;
	X*)  case $1 in
	X    -h)
	X	headerfile="$2"
	X	shift
	X	shift
	X	case $# in
	X	0)
	X	    oldart=""
	X	    ;;
	X	*)
	X	    oldart="$1"
	X	    shift
	X	    ;;
	X	esac
	X	;;
	X    esac
	X    ;;
	Xesac
	X
	Xcase $headerfile in
	X'')
	X    . $rnlib/Pnews.header
	X    ;;
	X*)
	X    $cat < $headerfile  > $tmpart
	X    ;;
	Xesac
	X    rescue="sleep 1; $cat $tmpart >>${HOME-$LOGDIR}/dead.article ; $echo Article appended to ${HOME-$LOGDIR}/dead.article ; exit"
	X    trap "$rescue" 1
	X    trap "$rescue" 2
	X
	X$echo ""
	Xset X `$sed < $tmpart -n -e '/^Distribution: /{' -e p -e q -e '}' -e '/^$/q'`
	Xshift
	Xcase $# in
	X0|1)
	X    set X `$sed < $tmpart -n -e '/^Newsgroups: /{' -e p -e q -e '}'`
	X    shift
	X    case $# in
	X    0|1)
	X	set "x misc.whatever"
	X	;;
	X    esac
	X    ;;
	X*)
	X    set $1 $2.whatever
	X    ;;
	Xesac
	Xshift
	X
	X#: play recorded message
	X#if $test -s ${lib}/recording ; then
	X#     ng=`$echo $1 | $sed "s/,.*//"`
	X#    _rec1=${lib}/`$sed -n "/^$ng/s/^.*	//p" ${lib}/recording`
	X#    _tmp=`$echo $ng |$sed "s/\..*//"`
	X#    _rec2=${lib}/`$cat -s ${lib}/recording|$grep ${_tmp}.all|$sed "s/^.*	//"`
	X#    if $test -f ${_rec1} ; then
	X#	$cat -s ${_rec1}
	X#    fi
	X#    if $test -f ${_rec2} ; then
	X#	$cat -s ${_rec2}
	X#    fi
	X#fi
	X
	X# tell them what we think they are doing... !DIST!
	Xcase $1 in
	Xnet.*|world.*|comp.*|news.*|sci.*|rec.*|misc.*|soc.*|talk.*|mod.*)
	X    $cat <<'EOM'
	XThis program posts news to thousands of machines throughout the entire
	Xcivilized world.  You message will cost the net hundreds if not thousands of
	Xdollars to send everywhere.  Please be sure you know what you are doing.
	X
	XEOM
	X    ;;
	X$cont.*)
	X    $echo 'This program posts news to many machines throughout the continent.'
	X    ;;
	X$cntry.*)
	X    $echo 'This program posts news to many machines throughout the country.'
	X    ;;
	X$state.*)
	X    $echo 'This program posts news to many machines throughout the state.'
	X    ;;
	X$city.*)
	X    $echo 'This program posts news to many machines throughout the city.'
	X    ;;
	X$org.*)
	X    $echo 'This program posts news to machines throughout the organization.'
	X    ;;
	X$loc.*)
	X    $echo 'This program posts news to machines throughout the local organization.'
	X    ;;
	X*.*)
	X    $echo 'This program may post news to many machines.'
	X    ;;
	X*)
	X    $echo 'This program posts news to everyone on the machine.'
	X    ;;
	Xesac
	Xans=""
	Xwhile $test "$ans" = "" ; do
	X    $echo $n "Are you absolutely sure that you want to do this? [ny] $c"
	X    read ans
	X    case $ans in
	X    y*) ;;
	X    f*) suppressmess=y ;;
	X    h*) $cat <<'EOH'
	X
	XType n or CR to exit, y to post.
	X
	XEOH
	X	ans="" ;;
	X    *) exit ;;
	X    esac
	Xdone
	X
	Xfile=h
	Xwhile $test "$file" = h ; do
	X    $echo ""
	X    $echo $n "Prepared file to include [none]: $c"
	X    read file
	X    case $file in
	X    h)
	X	$cat <<'EOH'
	X
	XIf you have already produced the body of your article, type the filename
	Xfor it here.  If you just want to proceed directly to the editor, type a
	XRETURN.  In any event, you will be allowed to edit as many times as you
	Xwant before you send off the article.
	XEOH
	X	;;
	X    '')
	X	$echo "" >> $tmpart
	X	state=edit
	X	;;
	X    *)
	X	$cat $file >>$tmpart
	X	state=ask
	X	;;
	X    esac
	Xdone
	X
	X$echo ""
	X
	Xwhile true ; do
	X    case $state in
	X    edit)
	X	case $expertise in
	X	beginner)
	X	    $cat </dev/null >$dotdir/.pnewsexpert
	X	    $cat <<'EOMessage'
	XA temporary file has been created for you to edit.  Be sure to leave at
	Xleast one blank line between the header and the body of your message.
	X(And until a certain bug is fixed all over the net, don't start the body of
	Xyour message with any indentation, or it may get eaten.)
	X
	XWithin the header may be fields that you don't understand.  If you don't
	Xunderstand a field (or even if you do), you can simply leave it blank, and
	Xit will go away when the article is posted.
	X
	XType return to get the default editor, or type the name of your favorite
	Xeditor.
	X
	XEOMessage
	X	    ;;
	X	esac
	X	case "${VISUAL-${EDITOR-}}" in
	X	'')
	X	    tmp=h
	X	    ;;
	X	*)
	X	    tmp=''
	X	    ;;
	X	esac
	X	while $test "$tmp" = h ; do
	X	    $echo $n "Editor [${VISUAL-${EDITOR-$defeditor}}]: $c"
	X	    read tmp
	X	    case $tmp in
	X	    h)
	X		$cat <<'EOH'
	X
	XType a return to get the default editor, or type the name of the editor you
	Xprefer.  The default editor depends on the VISUAL and EDITOR environment
	Xvariables.
	X
	XEOH
	X		;;
	X	    '')
	X		;;
	X	    *)
	X		VISUAL=$tmp
	X		export VISUAL
	X		;;
	X	    esac
	X	done
	X	trap : 2
	X	${VISUAL-${EDITOR-$defeditor}} $tmpart $oldart
	X	trap "$rescue" 2
	X	state=ask
	X	;;
	X	
	X    ask)
	X	$echo ""
	X	$echo $n "Send, abort, edit, or list? $c"
	X	read ans
	X	
	X	case "$ans" in
	X	a*)
	X	    state=rescue
	X	    ;;
	X	e*)
	X	    set $ans
	X	    case $# in
	X	    2)  VISUAL="$2" ;;
	X	    esac
	X	    state=edit
	X	    ;;
	X	l*)
	X	    $pager $tmpart
	X	    state=ask
	X	    ;;
	X	s*)
	X	    state=send
	X	    ;;
	X	h*)
	X	    $cat <<'EOH'
	X
	XType s to send the article, a to abort and append the article to dead.article,
	Xe to edit the article again, or l to list the article.
	X
	XTo invoke an alternate editor, type 'e editor'.
	XEOH
	X	esac
	X	;;
	X    
	X    send)
	X	set X `$sed < $tmpart -n -e '/^Newsgroups: /{' -e p -e q -e '}'`
	X	shift
	X	case $# in
	X	2)
	X	    state=cleanup
	X	    if $test -f $lib/moderators; then
	X		tryinews=no
	X		shift
	X		case "$1" in
	X		*,*) set `$echo $1 | tr ',' ' '`;;
	X		esac
	X		for newsgroup in $*; do
	X# the following screwy sed should prevent Eunice from hanging on no match
	X		    moderator=`$sed <$lib/moderators \
	X		    -e "/^$newsgroup[ 	]/!s/.*//" \
	X		    -e "s/^$newsgroup[ 	]//"`
	X		    case ${moderator}X in
	X		    X)  tryinews=yes
	X			;;
	X		    *)
	X			$echo Mailing to moderator $moderator
	X			case "$sign" in
	X			n*) ;;
	X			*)
	X			    if $test -f $dotdir/.signature; then
	X				echo $n "Append .signature file? [y] $c"
	X				read ans
	X				case $ans in
	X				''|y*)
	X				    echo "-- " >> $tmpart
	X				    cat $dotdir/.signature >> $tmpart
	X				    ;;
	X				esac
	X			    fi
	X			    sign=no
	X			    ;;
	X			esac
	X			case "$mailer" in
	X			*recmail)
	X			    $echo To: $moderator | $cat - $tmpart | $mailer
	X			    ;;
	X			*)
	X			    $mailer $moderator < $tmpart
	X			    ;;
	X			esac
	X			case $? in
	X			0) ;;
	X			*)
	X			    $echo Unable to mail to moderator $moderator
	X			    state=rescue
	X			    ;;
	X			esac
	X			;;
	X		    esac
	X		done
	X	    else
	X		tryinews=yes
	X	    fi
	X	    case "$tryinews" in
	X	    yes)
	X		if $inews -h < $tmpart ; then
	X		    : null
	X		else
	X		    state=rescue
	X		fi
	X		;;
	X	    esac
	X	    ;;
	X	*)
	X	    $echo ""
	X	    $echo "Malformed Newsgroups line."
	X	    $echo ""
	X	    sleep 1
	X	    state=edit
	X	    ;;
	X	esac
	X	;;
	X    rescue)
	X	$cat $tmpart >> ${HOME-$LOGDIR}/dead.article
	X	$echo "Article appended to ${HOME-$LOGDIR}/dead.article"
	X	$echo "A copy may be temporarily found in $tmpart"
	X	exit
	X	;;
	X    cleanup)
	X	case "${AUTHORCOPY-none}" in
	X	none)
	X	    ;;
	X	*)  if $echo From $USER `date` >> $AUTHORCOPY; then
	X		$cat $tmpart >> $AUTHORCOPY
	X		$echo "Article appended to $AUTHORCOPY"
	X		$echo "" >> $AUTHORCOPY
	X		$echo "" >> $AUTHORCOPY
	X	    else
	X		$echo "Cannot append to $AUTHORCOPY"
	X	    fi
	X	    ;;
	X	esac
	X	exit
	X	;;
	X    esac
	Xdone
	X!NO!SUBS!
	X$eunicefix Pnews
	Xchmod 755 Pnews
	X$spitshell >Pnews.header <<'!NO!SUBS!'
	Xcase $# in
	X0)
	X    ng=h
	X    while $test "$ng" = h ; do
	X	$echo ""
	X	$echo $n "Newsgroup(s): $c"
	X	read ng
	X	case $ng in
	X	h)
	X	    $cat <<'EOH'
	X
	XType the name of one or more newsgroups to which you wish to post an article.
	XIf you want to post to multiple newsgroups, it is better to do them all at
	Xonce than to post to each newsgroup individually, which defeats the news
	Xreading programs' strategies of eliminating duplicates.
	X
	XSeparate multiple newsgroup names with commas.
	XEOH
	X	    ;;
	X	esac
	X    done
	X    ;;
	X*)
	X    ng=$1
	X    shift
	X    ;;
	Xesac
	Xcase $ng in
	X*\ *)
	X    ng=`$echo "$ng" | $sed 's/[, ] */,/g'`
	X    ;;
	Xesac
	Xcase $ng in
	Xnet.*|mod.*|comp.*|news.*|sci.*|rec.*|misc.*|soc.*|talk.*)
	X    defdist=world
	X    dist=h
	X    ;;
	X*.*)
	X    defdist=`expr "X$ng" : 'X\([a-z0-9]*\)'`
	X    dist=h
	X    ;;
	X*)
	X    defdist=''
	X    dist=''
	X    ;;
	Xesac
	X
	Xwhile $test "$dist" = h ; do
	X    if $test -f $lib/distributions; then
	X	$echo " "
	X	$echo "Your local distribution prefixes are:"
	X	$cat $lib/distributions
	X	$echo " "
	X    else
	X	$egrep -v '[	 ]none$' <<EOM
	X
	XYour local distribution prefixes are:
	X    Local organization:	$loc
	X    Organization:		$org
	X    City:			$city
	X    $stpr:  		$state
	X    Country:		$cntry
	X    Continent:		$cont
	X    Everywhere:		world
	X
	XEOM
	X    fi
	X    $echo $n "Distribution ($defdist): $c"
	X    read dist
	X    case $dist in
	X    '') dist=$defdist ;;
	X    esac
	X    case $dist in
	X    h)
	X	$cat <<'EOH'
	X
	XThe Distribution line may be used to limit the distribution of an article
	Xto some subset of the systems that would receive the article based only on
	Xthe Newsgroups line.  For example, if you want to sell your car in talk.auto,
	Xand you live in New Jersey, you might want to put "nj" on the Distribution
	Xline to avoid advertising in California, which has enough problems of its own.
	XThe actual area designators to use depend on where you are, of course.
	XEOH
	X	;;
	X    ''|$loc*|$org*|$city*|$state*|$cntry*|$cont*|$defdist)
	X	;;
	X    net*|world*|comp*|news*|sci*|rec*|misc*|soc*|talk*)
	X	dist=''
	X	;;
	X    *)  
	X	if $test -f $lib/distributions && \
	X	  $egrep "^$dist[ 	]" $lib/distributions >$tmpart && \
	X	  $test -s $tmpart; then
	X	    : null
	X	else
	X	    $echo "Unrecognized distribution prefix--type h for help, CR to use anyway."
	X	    defdist=$dist
	X	    dist=h
	X	fi
	X	;;
	X    esac
	Xdone
	X
	Xcase $ng in
	X*net.general*)
	X    follow=`echo "$ng" | sed 's/net\.general/net.followup/g'`
	X    ;;
	X*)
	X    follow=""
	X    ;;
	Xesac
	X
	Xcase $# in
	X0)
	X    title=h
	X    while $test "$title" = h ; do
	X	$echo ""
	X	$echo $n "Title/Subject: $c"
	X	read title
	X	case $title in
	X	h)
	X	    $cat <<'EOH'
	X
	XType the title for your article.  Please make it as informative as possible
	X(within reason) so that people who aren't interested won't have to read the
	Xarticle to find out they aren't interested.  This includes marking movie
	Xspoilers as (spoiler), and rotated jokes as (rot 13).
	XEOH
	X	;;
	X	esac
	X    done
	X    ;;
	X*)
	X    title="$*"
	X    ;;
	Xesac
	X
	X# now build a file with a header for them to edit
	X
	Xset X ${USER-${LOGNAME-`who am i`}}
	Xshift
	Xlogname=$1
	Xcase $logname in
	X*!*) logname=`expr "$logname" : '!\(.*\)$'` ;;
	Xesac
	Xcase ${NAME-$nametype} in
	Xbsd)
	X    fullname=`$sed </etc/passwd -e "/^$logname:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^,:;]*\).*"'$'"/\1/" -e "q" -e "}" -e "d"`
	X    case $fullname in
	X    *'&'*) : GACK
	X	lname=`$echo $logname | $tr 'a-z' 'A-Z'`
	X	lname=`$echo $lname $logname | $sed 's/^\(.\)[^ ]* ./\1/'`
	X	fullname=`$echo "$fullname" | $sed "s/&/${lname}/"`
	X	;;
	X    esac
	X    ;;
	Xusg)
	X    fullname=`$sed </etc/passwd -e "/^$logname:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^(:]*\).*"'$'"/\1/" -e "s/^.*-//" -e "q" -e "}" -e "d"`
	X    ;;
	X*)
	X    fullname=${NAME-`$cat $dotdir/.fullname`}
	X    ;;
	Xesac
	X
	Xorgname=${ORGANIZATION-$orgname}
	Xcase $orgname in
	X/*) orgname=`$cat $orgname` ;;
	Xesac
	X
	X$cat > $tmpart <<EOHeader
	XFrom: $logname@$sitename ($fullname)
	XPath: $sitename!$logname
	XNewsgroups: $ng
	XSubject: $title
	XExpires: 
	XReferences: 
	XSender: 
	XReply-To: $logname@$sitename.$domain ($fullname)
	XFollowup-To: $follow
	XDistribution: $dist
	XOrganization: $orgname
	XKeywords: 
	X
	XEOHeader
	X
	X!NO!SUBS!
	X$eunicefix Pnews.header
SHAR_EOF
if test 14182 -ne "`wc -c < 'Pnews.SH'`"
then
	echo shar: error transmitting "'Pnews.SH'" '(should have been 14182 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Rnmail.SH'" '(5749 characters)'
if test -f 'Rnmail.SH'
then
	echo shar: will not over-write existing file "'Rnmail.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'Rnmail.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting Rnmail (with variable substitutions)"
	X$spitshell >Rnmail <<!GROK!THIS!
	X$startsh
	X# $Header: Rnmail.SH,v 4.3.1.4 85/08/01 14:23:05 lwall Exp $
	X# 
	X# $Log:	Rnmail.SH,v $
	X# Revision 4.3.1.4  85/08/01  14:23:05  lwall
	X# Added MAILRECORD.  Temp file is no longer in /tmp.  'e editor' added.
	X# 
	X# Revision 4.3.1.3  85/05/20  16:25:17  lwall
	X# Shouldn't ask editor if EDITOR or VISUAL defined.
	X# 
	X# Revision 4.3.1.2  85/05/17  10:36:19  lwall
	X# Added "-- " before .signature.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:30:38  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:34:18  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X#
	X# syntax: Rnmail -h headerfile [oldart]		or
	X#         Rnmail destination-list 		or just
	X#         Rnmail
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X# System dependencies
	X
	Xmailer="${mailer-/bin/mail}"
	X# if you change this to something that does signatures, take out signature code
	X
	X# your site name
	Xcase $portable in
	Xdefine) sitename=\`$hostcmd\` ;;
	Xundef) sitename="$sitename" ;;
	Xesac
	X# your organization name
	Xorgname="$orgname"
	X# what pager you use--if you have kernal paging use cat
	Xpager="\${PAGER-$pager}"
	X# how you derive full names, bsd, usg, or other
	Xnametype="$nametype"
	X# default editor
	Xdefeditor="$defeditor"
	X# how not to do a newline with echo
	Xn="$n"
	Xc="$c"
	X
	Xtest=${test-test}
	Xsed=${sed-sed}
	Xecho=${echo-echo}
	Xcat=${cat-cat}
	Xgrep=${grep-grep}
	Xrm=${rm-rm}
	X
	X!GROK!THIS!
	X$spitshell >>Rnmail <<'!NO!SUBS!'
	Xdotdir=${DOTDIR-${HOME-$LOGDIR}}
	Xtmpart=$dotdir/.letter
	X
	Xheaderfile=""
	Xcase $# in
	X0) ;;
	X*)  case $1 in
	X    -h)
	X	headerfile="$2"
	X	case $# in
	X	3) oldart=$3 ;;
	X	esac
	X	;;
	X    esac
	X    ;;
	Xesac
	X
	Xcase $headerfile in
	X'')
	X    case $# in
	X    0)
	X	to=h
	X	while $test "$to" = h ; do
	X	    $echo ""
	X	    $echo $n "To: $c"
	X	    read to
	X	    case $to in
	X	    h)
	X		$cat <<'EOH'
	X
	XType the net address of those people that you wish the message sent to.
	XAdditional recipients may be added on the Cc: line when you edit.
	X
	XSeparate multiple addresses with spaces.
	X
	XEOH
	X		;;
	X	    esac
	X	done
	X	;;
	X    *)
	X	to="$*"
	X	;;
	X    esac
	X    to=`$echo "$to" | $sed 's/  */ /g'`
	X
	X    title=h
	X    while $test "$title" = h ; do
	X	$echo ""
	X	$echo $n "Title/Subject: $c"
	X	read title
	X	case $title in
	X	h)
	X	    $cat <<'EOH'
	X
	XType the title for your message.  
	XEOH
	X	    ;;
	X	esac
	X    done
	X
	X# now build a file with a header for them to edit
	X    
	X    orgname=${ORGANIZATION-$orgname}
	X    case $orgname in
	X    /*) orgname=`$cat $orgname` ;;
	X    esac
	X
	X    $cat > $tmpart <<EOHeader
	XTo: $to
	XSubject: $title
	XOrganization: $orgname
	XCc:
	XBcc:
	X
	XEOHeader
	X
	X    ;;
	X*)
	X    $cat < $headerfile  > $tmpart
	X    ;;
	Xesac
	X
	X
	Xfile=h
	Xwhile $test "$file" = h ; do
	X    $echo ""
	X    $echo $n "Prepared file to include [none]: $c"
	X    read file
	X    case $file in
	X    h)
	X	$cat <<'EOH'
	X
	XIf you have already produced the body of your message, type the filename
	Xfor it here.  If you just want to proceed directly to the editor, type a
	XRETURN.  In any event, you will be allowed to edit as many times as you
	Xwant before you send off the message.
	XEOH
	X	;;
	X    '')
	X	$echo "" >> $tmpart
	X	state=edit
	X	;;
	X    *)
	X	$cat $file >>$tmpart
	X	state=ask
	X	;;
	X    esac
	Xdone
	X
	X$echo ""
	X
	Xwhile true ; do
	X    case $state in
	X    edit)
	X	rescue="sleep 1; $cat $tmpart >>${HOME-$LOGDIR}/dead.letter ; $echo Message appended to ${HOME-$LOGDIR}/dead.letter ; exit"
	X	trap "$rescue" 1
	X	trap : 2
	X	case "${VISUAL-${EDITOR-}}" in
	X	'')
	X	    tmp=h
	X	    ;;
	X	*)
	X	    tmp=''
	X	    ;;
	X	esac
	X	while $test "$tmp" = h ; do
	X	    $echo $n "Editor [${VISUAL-${EDITOR-$defeditor}}]: $c"
	X	    read tmp
	X	    case $tmp in
	X	    h)
	X		$cat <<'EOH'
	X
	XType a return to get the default editor, or type the name of the editor you
	Xprefer.  The default editor depends on the VISUAL and EDITOR environment
	Xvariables.
	X
	XEOH
	X		;;
	X	    '')
	X		;;
	X	    *)
	X		VISUAL=$tmp
	X		export VISUAL
	X		;;
	X	    esac
	X	done
	X	${VISUAL-${EDITOR-$defeditor}} $tmpart $oldart
	X	trap "$rescue" 2
	X	state=ask
	X	;;
	X	
	X    ask)
	X	$echo ""
	X	$echo $n "Send, abort, edit, or list? $c"
	X	read ans
	X	
	X	case $ans in
	X	a*)
	X	    state=rescue
	X	    ;;
	X	e*)
	X	    set $ans
	X	    case $# in
	X	    2)  VISUAL="$2" ;;
	X	    esac
	X	    state=edit
	X	    ;;
	X	l*)
	X	    $pager $tmpart
	X	    state=ask
	X	    ;;
	X	s*)
	X	    state=send
	X	    ;;
	X	h*)
	X	    $cat <<'EOH'
	X
	XType s to send the message, a to abort and append the message to dead.letter,
	Xe to edit the message again, or l to list the message.
	X
	XTo invoke an alternate editor, type 'e editor'.
	XEOH
	X	esac
	X	;;
	X    
	X    send)
	X	if $test -f $dotdir/.signature; then
	X	    echo $n "Append .signature file? [y] $c"
	X	    read ans
	X	    case $ans in
	X	    ''|y*)
	X		echo "-- " >> $tmpart
	X		cat $dotdir/.signature >> $tmpart
	X		;;
	X	    esac
	X	fi
	X	case $mailer in
	X	*sendmail)
	X	    $mailer -t <$tmpart
	X	    ;;
	X# but recmail does not know about Bcc, alas
	X	*recmail)
	X	    $mailer <$tmpart
	X	    ;;
	X	*)
	X	    set X `$sed <$tmpart -n -e '/^To:/{' -e 's/To: *//p' -e q -e '}'`
	X	    shift
	X	    set X "$@" `$sed <$tmpart -n -e '/^Cc:/{' -e 's/Cc: *//p' -e q -e '}'`
	X	    shift
	X	    set X "$@" `$sed <$tmpart -n -e '/^Bcc:/{' -e 's/Bcc: *//p' -e q -e '}'`
	X	    shift
	X	    $grep -v "^Bcc:"  <$tmpart | $mailer "$@"
	X	    ;;
	X	esac
	X	case $? in
	X	0)
	X	    state=cleanup
	X	    ;;
	X	*)
	X	    state=rescue
	X	    ;;
	X	esac
	X	;;
	X    rescue)
	X	$cat $tmpart >> ${HOME-$LOGDIR}/dead.letter
	X	$echo "Message appended to ${HOME-$LOGDIR}/dead.letter"
	X	$echo "A copy may be temporarily found in $tmpart"
	X	exit
	X	;;
	X    cleanup)
	X	case "${MAILRECORD-none}" in
	X	none)
	X	    ;;
	X	*)  if $cat $tmpart >> $MAILRECORD; then
	X		$echo "Article appended to $MAILRECORD"
	X	    else
	X		$echo "Cannot append to $MAILRECORD"
	X	    fi
	X	    ;;
	X	esac
	X	exit
	X	;;
	X    esac
	Xdone
	X!NO!SUBS!
	X$eunicefix Rnmail
	Xchmod 755 Rnmail
SHAR_EOF
if test 5749 -ne "`wc -c < 'Rnmail.SH'`"
then
	echo shar: error transmitting "'Rnmail.SH'" '(should have been 5749 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'addng.h'" '(275 characters)'
if test -f 'addng.h'
then
	echo shar: will not over-write existing file "'addng.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'addng.h'
	X/* $Header: addng.h,v 4.3 85/05/01 11:34:48 lwall Exp $
	X *
	X * $Log:	addng.h,v $
	X * Revision 4.3  85/05/01  11:34:48  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	Xvoid	addng_init();
	X#ifdef FINDNEWNG
	X    bool	newlist();
	X    long	birthof();
	X    bool	scanactive();
	X#endif
SHAR_EOF
if test 275 -ne "`wc -c < 'addng.h'`"
then
	echo shar: error transmitting "'addng.h'" '(should have been 275 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'art.h'" '(347 characters)'
if test -f 'art.h'
then
	echo shar: will not over-write existing file "'art.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'art.h'
	X/* $Header: art.h,v 4.3 85/05/01 11:35:29 lwall Exp $
	X *
	X * $Log:	art.h,v $
	X * Revision 4.3  85/05/01  11:35:29  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X/* do_article() return values */
	X
	X#define DA_NORM 0
	X#define DA_RAISE 1
	X#define DA_CLEAN 2
	X#define DA_TOEND 3
	X
	Xvoid	art_init();
	Xint	do_article();
	Xint	page_switch();
	Xbool	innermore();
SHAR_EOF
if test 347 -ne "`wc -c < 'art.h'`"
then
	echo shar: error transmitting "'art.h'" '(should have been 347 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'art.help.SH'" '(2735 characters)'
if test -f 'art.help.SH'
then
	echo shar: will not over-write existing file "'art.help.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'art.help.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting art.help (with variable substitutions)"
	X$spitshell >art.help <<!GROK!THIS!
	X$startsh
	X# $Header: art.help.SH,v 4.3 85/05/01 11:35:34 lwall Exp $
	X# 
	X# $Log:	art.help.SH,v $
	X# Revision 4.3  85/05/01  11:35:34  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X# 
	X$pager <<'EOT'
	XArticle Selection commands:
	X
	Xn,SP	Scan forward for next unread article.
	XN	Go to next article.
	X^N	Scan forward for next unread article with same subject.
	Xp,P,^P	Same as n,N,^N, only going backwards.
	X-	Go to previously displayed article.
	Xnumber	Go to specified article.
	Xrange{,range} command{:command}
	X	Apply one or more commands to one or more ranges of articles.
	X	Ranges are of the form: number | number-number.  You may use . for
	X	the current article, and $ for the last article.
	X 	Valid commands are: j, m, M, s, S, and !.
	X/pattern/modifiers
	X	Scan forward for article containing pattern in the subject line.
	X	(Use ?pat? to scan backwards; append h to scan headers, a to scan
	X	entire articles, r to scan read articles, c to make case sensitive.
	X/pattern/modifiers:command{:command}
	X	Apply one or more commands to the set of articles matching pattern.
	X	Use a K modifier to save entire command to the KILL file for this
	X	newsgroup.  Commands m and M, if first, imply an r modifier.
	X 	Valid commands are: j, m, M, s, S, and !.
	Xf,F	Submit a followup article (F = include this article).
	Xr,R	Reply through net mail (R = include this article).
	Xs ...	Save to file or pipe via sh.
	XS ...	Save via preferred shell.
	Xw,W	Like s and S but save without the header.
	X| ...	Same as s|...
	XC	Cancel this article, if yours.
	X^R,v	Restart article (v=verbose).
	X^X	Restart article, rot13 mode.
	Xc	Catch up (mark all articles as read).
	X^B	Back up one page.
	X^L	Refresh the screen.  You can get back to the pager with this.
	XX	Refresh screen in rot13 mode.
	X^	Go to first unread article.  Disables subject search mode.
	X$	Go to end of newsgroup.  Disables subject search mode.
	X#       Print last article number.
	X&	Print current values of command-line switches.
	X&switch {switch}
	X	Set or unset more switches.
	X&&	Print current macro definitions.
	X&&def	Define a new macro.
	Xj	Junk this article (mark it read).  Stays at end of article.
	Xm	Mark article as still unread.
	XM	Mark article as still unread upon exiting newsgroup or Y command.
	XY	Yank back articles marked temporarily read via M.
	Xk	Mark current SUBJECT as read.
	XK	Mark current SUBJECT as read, and save command in KILL file.
	X=	List subjects of unread articles.
	Xu	Unsubscribe to this newsgroup.
	X^K	Edit local KILL file (the one for this newsgroup).
	Xq	Quit this newsgroup for now.
	XQ	Quit newsgroup, staying at current newsgroup.
	XEOT
	X
	X!GROK!THIS!
	X$eunicefix art.help
	Xchmod 755 art.help
SHAR_EOF
if test 2735 -ne "`wc -c < 'art.help.SH'`"
then
	echo shar: error transmitting "'art.help.SH'" '(should have been 2735 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'artio.h'" '(635 characters)'
if test -f 'artio.h'
then
	echo shar: will not over-write existing file "'artio.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'artio.h'
	X/* $Header: artio.h,v 4.3 85/05/01 11:35:43 lwall Exp $
	X *
	X * $Log:	artio.h,v $
	X * Revision 4.3  85/05/01  11:35:43  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT ART_POS artpos INIT(0);	/* byte position in article file */
	X
	XEXT ART_LINE artline INIT(0);		/* current line number in article file */
	XEXT FILE *artfp INIT(Nullfp);		/* current article file pointer */
	XEXT ART_NUM openart INIT(0);		/* what is the currently open article number? */
	X#ifdef LINKART
	X    EXT char *linkartname INIT(nullstr);/* real name of article for Eunice */
	X#endif
	X
	Xvoid	artio_init();
	XFILE	*artopen();			/* open an article unless already opened */
SHAR_EOF
if test 635 -ne "`wc -c < 'artio.h'`"
then
	echo shar: error transmitting "'artio.h'" '(should have been 635 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'artsrch.h'" '(963 characters)'
if test -f 'artsrch.h'
then
	echo shar: will not over-write existing file "'artsrch.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'artsrch.h'
	X/* $Header: artsrch.h,v 4.3 85/05/01 11:35:55 lwall Exp $
	X *
	X * $Log:	artsrch.h,v $
	X * Revision 4.3  85/05/01  11:35:55  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifndef NBRA
	X#include "search.h"
	X#endif
	X
	X#ifdef ARTSEARCH
	X
	X#define SRCH_ABORT 0
	X#define SRCH_INTR 1
	X#define SRCH_FOUND 2
	X#define SRCH_NOTFOUND 3
	X#define SRCH_DONE 4
	X#define SRCH_SUBJDONE 5
	X#define SRCH_ERROR 6
	X#endif
	X
	XEXT char *lastpat INIT(nullstr);	/* last search pattern */
	X#ifdef ARTSEARCH
	X    EXT COMPEX sub_compex;		/* last compiled subject search */
	X    EXT COMPEX art_compex;		/* last compiled normal search */
	X#   ifdef CONDSUB
	X	EXT COMPEX *bra_compex INIT(&art_compex);
	X					/* current compex with brackets */
	X#   endif
	X    EXT char art_howmuch;		/* search just the subjects */
	X    EXT bool art_doread;		/* search read articles? */
	X#endif
	X
	Xvoid	artsrch_init();
	X#ifdef ARTSEARCH
	X    int		art_search();
	X    bool	wanted();	/* return TRUE if current article matches pattern */
	X#endif
SHAR_EOF
if test 963 -ne "`wc -c < 'artsrch.h'`"
then
	echo shar: error transmitting "'artsrch.h'" '(should have been 963 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'artstate.h'" '(1097 characters)'
if test -f 'artstate.h'
then
	echo shar: will not over-write existing file "'artstate.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'artstate.h'
	X/* $Header: artstate.h,v 4.3.1.2 85/05/13 09:30:30 lwall Exp $
	X *
	X * $Log:	artstate.h,v $
	X * Revision 4.3.1.2  85/05/13  09:30:30  lwall
	X * Added CUSTOMLINES option.
	X * 
	X * Revision 4.3.1.1  85/05/10  11:31:32  lwall
	X * Branch for patches.
	X * 
	X * Revision 4.3  85/05/01  11:35:59  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT bool reread INIT(FALSE);		/* consider current art temporarily */
	X				    /* unread? */
	XEXT bool do_fseek INIT(FALSE);	/* should we back up in article file? */
	X
	XEXT bool oldsubject INIT(FALSE);	/* not 1st art in subject thread */
	XEXT ART_LINE topline INIT(-1);		/* top line of current screen */
	XEXT bool do_hiding INIT(TRUE);		/* hide header lines with -h? */
	X#ifdef ROTATION
	XEXT bool rotate INIT(FALSE);		/* has rotation been requested? */
	X#endif
	XEXT char *prompt;			/* pointer to current prompt */
	X
	XEXT char *firstline INIT(Nullch);			/* special first line? */
	X#ifdef CUSTOMLINES
	XEXT char *hideline INIT(Nullch);		/* custom line hiding? */
	XEXT char *pagestop INIT(Nullch);		/* custom page terminator? */
	XEXT COMPEX hide_compex;
	XEXT COMPEX page_compex;
	X#endif
SHAR_EOF
if test 1097 -ne "`wc -c < 'artstate.h'`"
then
	echo shar: error transmitting "'artstate.h'" '(should have been 1097 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'backpage.h'" '(512 characters)'
if test -f 'backpage.h'
then
	echo shar: will not over-write existing file "'backpage.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'backpage.h'
	X/* $Header: backpage.h,v 4.3 85/05/01 11:36:11 lwall Exp $
	X *
	X * $Log:	backpage.h,v $
	X * Revision 4.3  85/05/01  11:36:11  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X/* things for doing the 'back page' command */
	X
	XEXT int varyfd INIT(0);			/* virtual array file for storing  */
	X					/* file offsets */
	XEXT ART_POS varybuf[VARYSIZE];		/* current window onto virtual array */
	X
	XEXT long oldoffset INIT(-1);		/* offset to block currently in window */
	X
	Xvoid	backpage_init();
	XART_POS	vrdary();
	Xvoid	vwtary();
SHAR_EOF
if test 512 -ne "`wc -c < 'backpage.h'`"
then
	echo shar: error transmitting "'backpage.h'" '(should have been 512 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'bits.h'" '(1907 characters)'
if test -f 'bits.h'
then
	echo shar: will not over-write existing file "'bits.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'bits.h'
	X/* $Header: bits.h,v 4.3.1.2 86/11/03 09:49:58 lwall Exp $
	X *
	X * $Log:	bits.h,v $
	X * Revision 4.3.1.2  86/11/03  09:49:58  lwall
	X * Added firstbit variable.
	X * 
	X * Revision 4.3.1.1  85/05/10  11:31:52  lwall
	X * Branch for patches.
	X * 
	X * Revision 4.3  85/05/01  11:36:39  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *ctlarea INIT(Nullch);	/* one bit for each article in current newsgroup */
	X			/* with the following interpretation: */
	X			/*	0 => unread  */
	X			/*	1 => read    */
	X
	X/* if subscripting is faster than shifting on your machine, define this */
	X#undef USESUBSCRIPT
	X#ifdef USESUBSCRIPT
	XEXT char powerof2[] INIT({1,2,4,8,16,32,64,128});
	X#define pow2(x) powerof2[x]
	X#else
	X#define pow2(x) (1 << (x))
	X#endif
	X
	X#ifdef lint
	XEXT bool nonesuch INIT(FALSE);
	X#define ctl_set(a)
	X#define ctl_clear(a)
	X#define ctl_read(a) nonesuch
	X#define was_read(a) nonesuch
	X#else
	X#define ctl_set(a) (ctlarea[(OFFSET(a)) / BITSPERBYTE] |= pow2((OFFSET(a)) % BITSPERBYTE))
	X#define ctl_clear(a) (ctlarea[(OFFSET(a)) / BITSPERBYTE] &= ~pow2((OFFSET(a)) % BITSPERBYTE))
	X#define ctl_read(a) ((ctlarea[(OFFSET(a)) / BITSPERBYTE] & pow2((OFFSET(a)) % BITSPERBYTE)) != 0)
	X
	X#define was_read(a) ((a)<firstbit || ctl_read(a))
	X#endif lint
	X
	XEXT ART_NUM absfirst INIT(0);	/* 1st real article in current newsgroup */
	XEXT ART_NUM firstart INIT(0);	/* minimum unread article number in newsgroup */
	XEXT ART_NUM firstbit INIT(0);	/* minimum valid bit, usually == firstart */
	XEXT ART_NUM lastart INIT(0);	/* maximum article number in newsgroup */
	X
	X#ifdef DELAYMARK
	XEXT FILE *dmfp INIT(Nullfp);
	XEXT char *dmname INIT(Nullch);
	XEXT int dmcount INIT(0);
	X#endif
	X
	Xvoid	bits_init();
	Xvoid	checkpoint_rc();
	Xvoid	restore_ng();
	Xvoid	onemore();
	Xvoid	oneless();
	Xvoid	unmark_as_read();
	Xvoid	delay_unmark();
	Xvoid	mark_as_read();
	Xvoid	check_first();
	X#ifdef DELAYMARK
	X    void	yankback();
	X#endif
	Xint	chase_xrefs();
	Xint	initctl();
	Xvoid	grow_ctl();
SHAR_EOF
if test 1907 -ne "`wc -c < 'bits.h'`"
then
	echo shar: error transmitting "'bits.h'" '(should have been 1907 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'cheat.h'" '(449 characters)'
if test -f 'cheat.h'
then
	echo shar: will not over-write existing file "'cheat.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'cheat.h'
	X/* $Header: cheat.h,v 4.3 85/05/01 11:36:58 lwall Exp $
	X *
	X * $Log:	cheat.h,v $
	X * Revision 4.3  85/05/01  11:36:58  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef ARTSEARCH
	XEXT ART_NUM srchahead INIT(0); 	/* are we in subject scan mode? */
	X				/* (if so, contains art # found or -1) */
	X#endif
	X
	X#ifdef PENDING
	X#   ifdef CACHESUBJ
	X	EXT ART_NUM subj_to_get;
	X#   endif
	X#endif
	X
	Xvoid	cheat_init();
	Xvoid	look_ahead();
	Xvoid	collect_subjects();
SHAR_EOF
if test 449 -ne "`wc -c < 'cheat.h'`"
then
	echo shar: error transmitting "'cheat.h'" '(should have been 449 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'common.h'" '(22201 characters)'
if test -f 'common.h'
then
	echo shar: will not over-write existing file "'common.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'common.h'
	X/* $Header: common.h,v 4.3.1.4 86/10/31 15:46:09 lwall Exp $
	X * 
	X * $Log:	common.h,v $
	X * Revision 4.3.1.4  86/10/31  15:46:09  lwall
	X * Expanded maximum number of .newsrc lines for net reorganization.
	X * 
	X * Revision 4.3.1.3  85/05/23  17:19:32  lwall
	X * Now allows 'r' and 'f' on null articles.
	X * 
	X * Revision 4.3.1.2  85/05/13  09:30:39  lwall
	X * Added CUSTOMLINES option.
	X * 
	X * Revision 4.3.1.1  85/05/10  11:32:04  lwall
	X * Branch for patches.
	X * 
	X * Revision 4.3  85/05/01  11:37:11  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#include "config.h"	/* generated by installation script */
	X#ifdef WHOAMI
	X#    include <whoami.h>
	X#endif
	X
	X#include <stdio.h>
	X#include <sys/types.h>
	X#include <sys/stat.h>
	X#include <ctype.h>
	X
	X#ifndef isalnum
	X#   define isalnum(c) (isalpha(c) || isdigit(c))
	X#endif
	X
	X#include <errno.h>
	X#include <signal.h>
	X#ifdef IOCTL
	X#include <sys/ioctl.h>
	X#endif IOCTL
	X
	X#ifdef FCNTL
	X#   include <fcntl.h>
	X#endif
	X
	X#ifdef TERMIO
	X#   include <termio.h>
	X#else
	X#   include <sgtty.h>
	X#endif
	X
	X#ifdef GETPWENT
	X#   include <pwd.h>
	X#endif
	X
	X#define BITSPERBYTE 8
	X#define LBUFLEN 512	/* line buffer length */
	X			/* (don't worry, .newsrc lines can exceed this) */
	X#ifdef pdp11
	X#   define CBUFLEN 256	/* command buffer length */
	X#   define PUSHSIZE 128
	X#else
	X#   define CBUFLEN 512	/* command buffer length */
	X#   define PUSHSIZE 256
	X#endif
	X#ifdef pdp11
	X#   define MAXFILENAME 128
	X#else
	X#   define MAXFILENAME 512
	X#endif
	X#define LONGKEY 15	/* longest keyword: currently "posting-version" */
	X#define FINISHCMD 0177
	X
	X/* some handy defs */
	X
	X#define bool char
	X#define TRUE (1)
	X#define FALSE (0)
	X#define Null(t) ((t)0)
	X#define Nullch Null(char *)
	X#define Nullfp Null(FILE *)
	X
	X#define Ctl(ch) (ch & 037)
	X
	X#define strNE(s1,s2) (strcmp(s1,s2))
	X#define strEQ(s1,s2) (!strcmp(s1,s2))
	X#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
	X#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))
	X
	X/* Things we can figure out ourselves */
	X
	X#ifdef SIGTSTP
	X#   define BERKELEY 	/* include job control signals? */
	X#endif
	X
	X#ifdef SIGPROF
	X#   define BSD42		/* do we have Berkeley 4.2? */
	X#endif
	X
	X#ifdef FIONREAD
	X#   define PENDING
	X#else
	X#   ifdef O_NDELAY
	X#	define PENDING
	X#   endif
	X#endif
	X
	X#ifdef EUNICE
	X#   define LINKART		/* add 1 level of possible indirection */
	X#   define UNLINK(victim) while (!unlink(victim))
	X#else
	X#   define UNLINK(victim) unlink(victim)
	X#endif
	X
	X/* Valid substitutions for strings marked with % comment are:
	X *	%a	Current article number
	X *	%A	Full name of current article (%P/%c/%a)
	X *		(if LINKART defined, is the name of the real article)
	X *	%b	Destination of a save command, a mailbox or command
	X *	%B	The byte offset to the beginning of the article for saves
	X *		with or without the header
	X *	%c	Current newsgroup, directory form
	X *	%C	Current newsgroup, dot form
	X *	%d	%P/%c
	X *	%D	Old Distribution: line
	X *	%f	Old From: line or Reply-To: line
	X *	%F	Newsgroups to followup to from Newsgroups: and Followup-To:
	X *	%h	Name of header file to pass to mail or news poster
	X *	%H	Host name (yours)
	X *	%i	Old Message-I.D.: line, with <>
	X *	%I	Inclusion indicator
	X *	%l	News administrator login name
	X *	%L	Login name (yours)
	X *	%M	Number of articles markd with M
	X *	%n	Newsgroups from source article
	X *	%N	Full name (yours)
	X *	%o	Organization (yours)
	X *	%O	Original working directory (where you ran rn from)
	X *	%p	Your private news directory (-d switch)
	X *	%P	Public news spool directory (SPOOLDIR)
	X *	%r	Last reference (parent article id)
	X *	%R	New references list
	X *	%s	Subject, with all Re's and (nf)'s stripped off
	X *	%S	Subject, with one Re stripped off
	X *	%t	New To: line derived from From: and Reply-To (Internet always)
	X *	%T	New To: line derived from Path:
	X *	%u	Number of unread articles
	X *	%U	Number of unread articles disregarding current article
	X *	%x	News library directory, usually /usr/lib/news
	X *	%X	Rn library directory, usually %x/rn
	X *	%z	Size of current article in bytes.
	X *	%~	Home directory
	X *	%.	Directory containing . files
	X *	%$	current process number
	X *	%{name} Environment variable "name".  %{name-default} form allowed.
	X *	%[name]	Header line beginning with "Name: ", without "Name: " 
	X *	%"prompt"
	X *		Print prompt and insert what is typed.
	X *	%`command`
	X *		Insert output of command.
	X *	%(test_text=pattern?if_text:else_text)
	X *		Substitute if_text if test_text matches pattern, otherwise
	X *		substitute else_text.  Use != for negated match.
	X *		% substitutions are done on test_text, if_text, and else_text.
	X *		(Note: %() only works if CONDSUB defined.)
	X *	%digit	Substitute the text matched by the nth bracket in the last
	X *		pattern that had brackets.  %0 matches the last bracket
	X *		matched, in case you had alternatives.
	X *
	X *	Put ^ in the middle to capitalize the first letter: %^C = Net.jokes
	X *	Put _ in the middle to capitalize last component: %_c = net/Jokes
	X *
	X *	~ interpretation in filename expansion happens after % expansion, so
	X *	you could put ~%{NEWSLOGNAME-news} and it will expand correctly.
	X */
	X
	X/* *** System Dependent Stuff *** */
	X
	X/* NOTE: many of these are defined in the config.h file */
	X
	X/* name of organization */
	X#ifndef ORGNAME
	X#   define ORGNAME "ACME Widget Company, Widget Falls, Southern North Dakota"
	X#endif
	X
	X#ifndef MBOXCHAR
	X#   define MBOXCHAR 'F'	/* how to recognize a mailbox by 1st char */
	X#endif
	X
	X#ifndef ROOTID
	X#   define ROOTID 0        /* uid of superuser */
	X#endif
	X
	X#ifdef NORMSIG
	X#   define sigset signal
	X#   define sigignore(sig) signal(sig,SIG_IGN)
	X#endif
	X
	X#ifndef LOGDIRFIELD
	X#   define LOGDIRFIELD 6		/* Which field (origin 1) is the */
	X					/* login directory in /etc/passwd? */
	X					/* (If it is not kept in passwd, */
	X					/* but getpwnam() returns it, */
	X					/* define the symbol GETPWENT) */
	X#endif
	X#ifndef GCOSFIELD
	X#   define GCOSFIELD 5
	X#endif
	X
	X#ifndef NEGCHAR
	X#   define NEGCHAR '!'
	X#endif
	X
	X/* Space conservation section */
	X
	X/* To save D space, cut down size of MAXRCLINE, NGMAX, VARYSIZE. */
	X#define MAXRCLINE 1000	/* number of lines allowed in .newsrc */
	X			/* several parallel arrays affected. */
	X			/* (You can have more lines in the active file, */
	X			/* just not in the .newsrc) */
	X#define HASHSIZ 1103	/* should be prime, and at least MAXRCLINE + 10% */
	X#define NGMAX 100	/* number of newsgroups allowed on command line */
	X			/* undefine ONLY symbol to disable "only" feature */
	X#define VARYSIZE 256	/* this makes a block 1024 bytes long in DECville */
	X			/* (used by virtual array routines) */
	X
	X/* Undefine any of the following features to save both I and D space */
	X/* In general, earlier ones are easier to get along without */
	X/* Pdp11's without split I and D may have to undefine them all */
	X#define DEBUGGING	/* include debugging code */
	X#define CUSTOMLINES	/* include code for HIDELINE and PAGESTOP */
	X#define PUSHBACK	/* macros and keymaps using pushback buffer */
	X#define SPEEDOVERMEM	/* use more memory to run faster */
	X#define WORDERASE	/* enable ^W to erase a word */
	X#define MAILCALL	/* check periodically for mail */
	X#define CLEAREOL	/* use clear to end-of-line instead of clear screen */
	X#define NOFIREWORKS	/* keep whole screen from flashing on certain */
	X			/* terminals such as older Televideos */
	X#define VERIFY		/* echo the command they just typed */
	X#define HASHNG		/* hash newsgroup lines for fast lookup-- */
	X			/* linear search used if not defined */
	X#define CONDSUB		/* allow %(cond?text:text) */
	X#define BACKTICK	/* allow %`command` */
	X#define PROMPTTTY	/* allow %"prompt" */
	X#define ULSMARTS	/* catch _^H in text and do underlining */
	X#define TERMMOD		/* allow terminal type modifier on switches */
	X#define BAUDMOD		/* allow baudrate modifier on switches */
	X#define GETLOGIN	/* use getlogin() routine as backup to environment */
	X			/* variables USER or LOGNAME */
	X#define ORGFILE		/* if organization begins with /, look up in file */
	X#define TILDENAME	/* allow ~logname expansion */
	X#define SETENV		/* allow command line environment variable setting */
	X#define GETWD		/* use our getwd() instead of piped in pwd */
	X#ifndef BSD42		/* 4.2 sites should just use groups for this */
	X#define SETUIDGID	/* substitute eaccess() for access() so that rn */
	X			/* can run setuid or setgid */
	X			/* if not setuid or setgid, you don't need it */
	X#endif
	X#define MAKEDIR		/* use our makedir() instead of shell script */
	X#define MEMHELP		/* keep help messages in memory */
	X#define VERBOSE		/* compile in more informative messages */
	X#define TERSE		/* compile in shorter messages */
	X			/* (Note: both VERBOSE and TERSE can be defined; -t
	X			 * sets terse mode.  One or the other MUST be defined.
	X			 */
	X#ifndef pdp11
	X#   define CACHESUBJ	/* cache subject lines in memory */
	X			/* without this ^N still works but runs really slow */
	X			/* but you save lots and lots of D space */
	X#   define CACHEFIRST	/* keep absolute first article numbers in memory */
	X			/* cost: about 2k */
	X#endif
	X#define ROTATION	/* enable x, X and ^X commands to work */
	X#define DELBOGUS	/* ask if bogus newsgroups should be deleted */
	X#define RELOCATE	/* allow newsgroup rearranging */
	X#define ESCSUBS		/* escape substitutions in multi-character commands */
	X#define DELAYMARK	/* allow articles to be temporarily marked as read */
	X			/* until exit from current newsgroup or Y command */
	X#define MCHASE		/* unmark xrefed articles on m or M */
	X#define MUNGHEADER	/* allow alternate header formatting via */
	X			/* environment variable ALTHEADER (not impl) */
	X#define ASYNC_PARSE	/* allow parsing headers asyncronously to reading */
	X			/* used by MCHASE and MUNGHEADER */
	X#define FINDNEWNG	/* check for new newsgroups on startup */
	X#define FASTNEW		/* do optimizations on FINDNEWNG for faster startup */
	X			/* (this optimization can make occasional mistakes */
	X			/* if a group is removed and another group of the */
	X			/* same length is added, and if no softpointers are */
	X			/* affected by said change.) */
	X#define INNERSEARCH	/* search command 'g' with article */
	X#define CATCHUP		/* catchup command at newsgroup level */
	X#define NGSEARCH	/* newsgroup pattern matching */
	X#define ONLY		/* newsgroup restrictions by pattern */
	X#define KILLFILES	/* automatic article killer files */
	X#define ARTSEARCH	/* pattern searches among articles */
	X			/* /, ?, ^N, ^P, k, K */
	X
	X/* some dependencies among options */
	X
	X#ifndef ARTSEARCH
	X#   undef KILLFILES
	X#   undef INNERSEARCH
	X#   undef CACHESUBJ
	X#endif
	X
	X#ifndef DELAYMARK
	X#   ifndef MCHASE
	X#	ifndef MUNGHEADER
	X#	    undef ASYNC_PARSE
	X#	endif
	X#   endif
	X#endif
	X
	X#ifndef SETUIDGID
	X#   define eaccess access
	X#endif
	X
	X#ifdef ONLY				/* idiot lint doesn't grok #if */
	X#   define NGSORONLY
	X#else
	X#   ifdef NGSEARCH
	X#	define NGSORONLY
	X#   endif
	X#endif
	X
	X#ifdef VERBOSE
	X#   ifdef TERSE
	X#	define IF(c) if (c)
	X#	define ELSE else
	X#   else !TERSE
	X#	define IF(c)
	X#	define ELSE
	X#   endif
	X#else !VERBOSE
	X#   ifndef TERSE
	X#	define TERSE
	X#   endif
	X#   define IF(c) "IF" outside of VERBOSE???
	X#   define ELSE "ELSE" outside of VERBOSE???
	X#endif
	X
	X#ifdef DEBUGGING
	X#   define assert(ex) {if (!(ex)){fprintf(stderr,"Assertion failed: file %s, line %d\n", __FILE__, __LINE__);sig_catcher(0);}}
	X#else
	X#   define assert(ex) ;
	X#endif
	X
	X#ifdef SPEEDOVERMEM
	X#   define OFFSET(x) (x)
	X#else
	X#   define OFFSET(x) ((x)-absfirst)
	X#endif
	X
	X/* If you're strapped for space use the help messages in shell scripts */
	X/* if {NG,ART,PAGER,SUBS}HELP is undefined, help messages are in memory */
	X#ifdef MEMHELP  /* undef MEMHELP above to get them all as sh scripts */
	X#   undef NGHELP
	X#   undef ARTHELP
	X#   undef PAGERHELP
	X#   undef SUBSHELP
	X#else
	X#   ifndef NGHELP			/* % and ~ */
	X#	define NGHELP "%X/ng.help"
	X#   endif
	X#   ifndef ARTHELP			/* % and ~ */
	X#	define ARTHELP "%X/art.help"
	X#   endif
	X#   ifndef PAGERHELP		/* % and ~ */
	X#	define PAGERHELP "%X/pager.help"
	X#   endif
	X#   ifndef SUBSHELP		/* % and ~ */
	X#	define SUBSHELP "%X/subs.help"
	X#   endif
	X#endif
	X
	X#ifdef CLEAREOL
	X#   define TCSIZE 512	/* capacity for termcap strings */
	X#else
	X#   ifdef pdp11
	X#	define TCSIZE 256	/* capacity for termcap strings */
	X#   else
	X#	define TCSIZE 512	/* capacity for termcap srings */
	X#   endif
	X#endif
	X
	X/* Additional ideas:
	X *	Make the do_newsgroup() routine a separate process.
	X *	Keep .newsrc on disk instead of in memory.
	X *	Overlays, if you have them.
	X *	Get a bigger machine.
	X */
	X
	X/* End of Space Conservation Section */
	X
	X/* More System Dependencies */
	X
	X/* news library */
	X#ifndef LIB		/* ~ and %l only ("~%l" is permissable) */
	X#   define LIB "/usr/lib/news"
	X#endif
	X
	X/* path to private executables */
	X#ifndef RNLIB		/* ~, %x and %l only */
	X#   define RNLIB "%x/rn"
	X#endif
	X
	X/* system-wide RNINIT switches */
	X#ifndef GLOBINIT
	X#   define GLOBINIT "%X/INIT"
	X#endif
	X
	X/* where to find news files */
	X#ifndef SPOOL			/* % and ~ */
	X#   define SPOOL "/usr/spool/news"
	X#endif
	X
	X/* file containing list of active newsgroups and max article numbers */
	X#ifndef ACTIVE			/* % and ~ */
	X#   define ACTIVE "%x/active"
	X#endif
	X
	X/* location of history file */
	X#ifndef ARTFILE			/* % and ~ */
	X#    define ARTFILE "%x/history"
	X#endif
	X
	X/* command to setup a new .newsrc */
	X#ifndef NEWSETUP		/* % and ~ */
	X#   define NEWSETUP "newsetup"
	X#endif
	X
	X/* command to display a list of un-subscribed-to newsgroups */
	X#ifndef NEWSGROUPS		/* % and ~ */
	X#   define NEWSGROUPS "newsgroups"
	X#endif
	X
	X/* preferred shell for use in doshell routine */
	X/*  ksh or sh would be okay here */
	X#ifndef PREFSHELL
	X#   define PREFSHELL "/bin/csh"
	X#endif
	X
	X/* path to fastest starting shell */
	X#ifndef SH
	X#   define SH "/bin/sh"
	X#endif
	X
	X/* path to default editor */
	X#ifndef DEFEDITOR
	X#   define DEFEDITOR "/usr/ucb/vi"
	X#endif
	X
	X/* location of macro file */
	X#ifndef RNMACRO
	X#   ifdef PUSHBACK
	X#	define RNMACRO "%./.rnmac"
	X#   endif
	X#endif
	X
	X/* location of full name */
	X#ifndef FULLNAMEFILE
	X#   ifndef PASSNAMES
	X#	define FULLNAMEFILE "%./.fullname"
	X#   endif
	X#endif
	X
	X/* virtual array file name template */
	X#ifndef VARYNAME		/* % and ~ */
	X#   define VARYNAME "/tmp/rnvary.%$"
	X#endif
	X
	X/* file to pass header to followup article poster */
	X#ifndef HEADNAME		/* % and ~ */
	X#   define HEADNAME "%./.rnhead"
	X/* or alternately #define HEADNAME "/tmp/rnhead.%$" */
	X#endif
	X
	X#ifndef MAKEDIR
	X/* shell script to make n-deep subdirectories */
	X#   ifndef DIRMAKER		/* % and ~ */
	X#	define DIRMAKER "%X/makedir"
	X#   endif
	X#endif
	X
	X/* location of newsrc file */
	X#ifndef RCNAME		/* % and ~ */
	X#   define RCNAME "%./.newsrc"
	X#endif
	X
	X/* temporary newsrc file in case we crash while writing out */
	X#ifndef RCTNAME		/* % and ~ */
	X#   define RCTNAME "%./.newnewsrc"
	X#endif
	X
	X/* newsrc file at the beginning of this session */
	X#ifndef RCBNAME		/* % and ~ */
	X#   define RCBNAME "%./.oldnewsrc"
	X#endif
	X
	X/* if existent, contains process number of current or crashed rn */
	X#ifndef LOCKNAME		/* % and ~ */
	X#   define LOCKNAME "%./.rnlock"
	X#endif
	X
	X/* information from last invocation of rn */
	X#ifndef LASTNAME		/* % and ~ */
	X#   define LASTNAME "%./.rnlast"
	X#endif
	X
	X/* file with soft pointers into the active file */
	X#ifndef SOFTNAME		/* % and ~ */
	X#   define SOFTNAME "%./.rnsoft"
	X#endif
	X
	X/* list of article numbers to mark as unread later (see M and Y cmmands) */
	X#ifndef RNDELNAME		/* % and ~ */
	X#   define RNDELNAME "%./.rndelay"
	X#endif
	X
	X/* a motd-like file for rn */
	X#ifndef NEWSNEWSNAME		/* % and ~ */
	X#   define NEWSNEWSNAME "%X/newsnews"
	X#endif
	X
	X/* command to send a reply */
	X#ifndef MAILPOSTER		/* % and ~ */
	X#   define MAILPOSTER "Rnmail -h %h"
	X#endif
	X
	X#ifdef INTERNET
	X#   ifndef MAILHEADER		/* % */
	X#	ifdef CONDSUB
	X#	    define MAILHEADER "To: %t\nSubject: Re: %S\nNewsgroups: %n\nIn-Reply-To: %i\n%(%[references]!=^$?References\\: %[references]\n)Organization: %o\nCc: \nBcc: \n\n"
	X#	else
	X#	    define MAILHEADER "To: %t\nSubject: Re: %S\nNewsgroups: %n\nIn-Reply-To: %i\nReferences: %[references]\nCc: \nBcc: \n\n"
	X#	endif
	X#   endif
	X#else
	X#   ifndef MAILHEADER		/* % */
	X#	ifdef CONDSUB
	X#	    define MAILHEADER "To: %T\nSubject: %(%i=^$?:Re: %S\nNewsgroups: %n\nIn-Reply-To: %i)\n%(%[references]!=^$?References\\: %[references]\n)Organization: %o\nCc: \nBcc: \n\n"
	X#	else
	X#	    define MAILHEADER "To: %T\nSubject: Re: %S\nNewsgroups: %n\nIn-Reply-To: %i\nReferences: %[references]\nCc: \nBcc: \n\n"
	X#	endif
	X#   endif
	X#endif
	X
	X#ifndef YOUSAID			/* % */
	X#   define YOUSAID "In article %i you write:"
	X#endif
	X
	X/* command to submit a followup article */
	X#ifndef NEWSPOSTER		/* % and ~ */
	X#   define NEWSPOSTER "Pnews -h %h"
	X#endif
	X
	X#ifndef NEWSHEADER		/* % */
	X#   ifdef CONDSUB
	X#	define NEWSHEADER "Newsgroups: %(%F=^$?%C:%F)\nSubject: %(%S=^$?%\"\n\nSubject: \":Re: %S)\nSummary: \nExpires: \n%(%R=^$?:References: %R\n)Sender: \nReply-To: %L@%H.UUCP (%N)\nFollowup-To: \nDistribution: %(%i=^$?%\"Distribution: \":%D)\nOrganization: %o\nKeywords: %[keywords]\n\n"
	X#   else
	X#	define NEWSHEADER "Newsgroups: %F\nSubject: Re: %S\nSummary: \nExpires: \nReferences: %R\nSender: \nReply-To: %L@%H.UUCP (%N)\nFollowup-To: \nDistribution: %D\nOrganization: %o\nKeywords: %[keywords]\n\n"
	X#   endif
	X#endif
	X
	X#ifndef ATTRIBUTION		/* % */
	X#   define ATTRIBUTION "In article %i %f writes:"
	X#endif
	X
	X#ifndef PIPESAVER		/* % */
	X#   ifdef CONDSUB
	X#	define PIPESAVER "%(%B=^0$?<%A:tail +%Bc %A |) %b"
	X#   else
	X#	define PIPESAVER "tail +%Bc %A | %b"
	X#   endif
	X#endif
	X
	X#ifndef NORMSAVER		/* % and ~ */
	X#   define NORMSAVER "%X/norm.saver %A %P %c %a %B %C \"%b\""
	X#endif
	X
	X#ifndef MBOXSAVER		/* % and ~ */
	X#   ifdef MININACT		/* 2.10.2 site? */
	X#	define MBOXSAVER "%X/mbox.saver %A %P %c %a %B %C \"%b\" \"From %T %`date`\""
	X#   else
	X#	ifdef CONDSUB
	X#	    define MBOXSAVER "%X/mbox.saver %A %P %c %a %B %C \"%b\" \"From %T %(%[date]=^\\(\\w*\\), \\(\\w*\\)-\\(\\w*\\)-\\(\\w*\\) \\([^ ]*\\)?%1 %3 %(%2=..?%2: %2) %5 19%4)\""
	X					/* header munging with a vengeance */
	X#	else
	X#	    define MBOXSAVER "%X/mbox.saver %A %P %c %a %B %C \"%b\" \"From %T %[posted]\""
	X#	endif
	X#   endif
	X#endif
	X
	X#ifdef MKDIRS
	X
	X#   ifndef SAVEDIR			/* % and ~ */
	X#	define SAVEDIR "%p/%c"
	X#   endif
	X#   ifndef SAVENAME		/* % */
	X#	define SAVENAME "%a"
	X#   endif
	X
	X#else
	X
	X#   ifndef SAVEDIR			/* % and ~ */
	X#	define SAVEDIR "%p"
	X#   endif
	X#   ifndef SAVENAME		/* % */
	X#	define SAVENAME "%^C"
	X#   endif
	X
	X#endif
	X
	X#ifndef KILLGLOBAL		/* % and ~ */
	X#   define KILLGLOBAL "%p/KILL"
	X#endif
	X
	X#ifndef KILLLOCAL		/* % and ~ */
	X#   define KILLLOCAL "%p/%c/KILL"
	X#endif
	X
	X/* how to cancel an article */
	X#ifndef CANCEL
	X#   ifdef MININACT			/* 2.10.2 ? */
	X#	define CANCEL "%x/inews -h < %h"
	X#   else
	X#	define CANCEL "inews -h < %h"
	X#   endif
	X#endif
	X
	X/* how to cancel an article, continued */
	X#ifndef CANCELHEADER
	X#   define CANCELHEADER "Newsgroups: %n\nSubject: cmsg cancel %i\nReferences: %R\nReply-To: %L@%H.UUCP (%N)\nDistribution: %D\nOrganization: %o\n"
	X#endif
	X
	X/* where to find the mail file */
	X#ifndef MAILFILE
	X#   define MAILFILE "/usr/spool/mail/%L"
	X#endif
	X
	X/* some important types */
	X
	Xtypedef int		NG_NUM;		/* newsgroup number */
	Xtypedef long		ART_NUM;	/* article number */
	X#ifdef pdp11
	X    typedef short	ART_UNREAD;	/* ordinarily this should be long */
	X					/* like ART_NUM, but assuming that */
	X					/* we stay less than 32767 articles */
	X					/* behind saves a lot of space. */
	X					/* NOTE: do not make unsigned. */
	X#else
	X    typedef long	ART_UNREAD;
	X#endif
	Xtypedef long		ART_POS;	/* char position in article file */
	Xtypedef int		ART_LINE;	/* line position in article file */
	Xtypedef short		ACT_POS;	/* char position in active file */
	Xtypedef unsigned int	MEM_SIZE;	/* for passing to malloc */
	X
	X/* *** end of the machine dependent stuff *** */
	X
	X/* GLOBAL THINGS */
	X
	X/* file statistics area */
	X
	XEXT struct stat filestat;
	X
	X/* various things of type char */
	X
	Xchar	*index();
	Xchar	*rindex();
	Xchar	*getenv();
	Xchar	*strcat();
	Xchar	*strcpy();
	Xchar	*sprintf();
	X
	XEXT char buf[LBUFLEN+1];	/* general purpose line buffer */
	XEXT char cmd_buf[CBUFLEN];	/* buffer for formatting system commands */
	X
	XEXT char *indstr INIT(">");	/* indent for old article embedded in followup */
	X
	XEXT char *cwd INIT(Nullch);		/* current working directory */
	XEXT char *dfltcmd INIT(Nullch);	/* 1st char is default command */
	X
	X/* switches */
	X
	X#ifdef DEBUGGING
	X    EXT int debug INIT(0);				/* -D */
	X#   define DEB_INNERSRCH 32 
	X#   define DEB_FILEXP 64 
	X#   define DEB_HASH 128
	X#   define DEB_XREF_MARKER 256
	X#   define DEB_CTLAREA_BITMAP 512
	X#   define DEB_SOFT_POINTERS 1024
	X#   define DEB_NEWSRC_LINE 2048
	X#   define DEB_SEARCH_AHEAD 4096
	X#   define DEB_CHECKPOINTING 8192
	X#   define DEB_FEED_XREF 16384
	X#endif
	X
	X#ifdef ARTSEARCH
	X    EXT int scanon INIT(0);				/* -S */
	X#endif
	X
	XEXT bool mbox_always INIT(FALSE);			/* -M */
	XEXT bool norm_always INIT(FALSE);			/* -N */
	XEXT bool checkflag INIT(FALSE);			/* -c */
	XEXT bool suppress_cn INIT(FALSE);			/* -s */
	XEXT int countdown INIT(5);	/* how many lines to list before invoking -s */
	XEXT bool muck_up_clear INIT(FALSE);			/* -loco */
	XEXT bool erase_screen INIT(FALSE);			/* -e */
	X#ifdef CLEAREOL
	XEXT bool can_home_clear INIT(FALSE);		/* fancy -e -- PWP */
	X#endif CLEAREOL
	XEXT bool findlast INIT(FALSE);			/* -r */
	XEXT bool typeahead INIT(FALSE);			/* -T */
	X#ifdef VERBOSE
	X#   ifdef TERSE
	X	EXT bool verbose INIT(TRUE);			/* +t */
	X#   endif
	X#endif
	X#ifdef VERIFY
	X    EXT bool verify INIT(FALSE);			/* -v */
	X#endif
	X
	X#define NOMARKING 0
	X#define STANDOUT 1
	X#define UNDERLINE 2
	XEXT int marking INIT(NOMARKING);			/* -m */
	X
	XEXT ART_LINE initlines INIT(0);		/* -i */
	X
	X/* miscellania */
	X
	Xlong atol(), fseek(), ftell();
	XEXT bool in_ng INIT(FALSE);		/* current state of rn */
	XEXT char mode INIT('i');		/* current state of rn */
	X
	XEXT FILE *tmpfp INIT(Nullfp);	/* scratch fp used for .rnlock, .rnlast, etc. */
	X
	XEXT NG_NUM nextrcline INIT(0);	/* 1st unused slot in rcline array */
	X			/* startup to avoid checking twice in a row */
	X
	Xextern errno;
	X
	X/* Factored strings */
	X
	XEXT char nullstr[] INIT("");
	XEXT char sh[] INIT(SH);
	XEXT char defeditor[] INIT(DEFEDITOR);
	XEXT char hforhelp[] INIT("Type h for help.\n");
	X#ifdef STRICTCR
	XEXT char badcr[] INIT("\nUnnecessary CR ignored.\n");
	X#endif
	XEXT char readerr[] INIT("rn read error");
	XEXT char unsubto[] INIT("\n\nUnsubscribed to newsgroup %s\n");
	XEXT char cantopen[] INIT("Can't open %s\n");
	XEXT char cantcreate[] INIT("Can't create %s\n");
	X
	X#ifdef VERBOSE
	X    EXT char nocd[] INIT("Can't chdir to directory %s\n");
	X#else
	X    EXT char nocd[] INIT("Can't find %s\n");
	X#endif
	X
	X#ifdef NOLINEBUF
	X#define FLUSH ,fflush(stdout)
	X#else
	X#define FLUSH
	X#endif
	X
	X#ifdef lint
	X#undef FLUSH
	X#define FLUSH
	X#undef putchar
	X#define putchar(c)
	X#endif
SHAR_EOF
if test 22201 -ne "`wc -c < 'common.h'`"
then
	echo shar: error transmitting "'common.h'" '(should have been 22201 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'final.h'" '(704 characters)'
if test -f 'final.h'
then
	echo shar: will not over-write existing file "'final.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'final.h'
	X/* $Header: final.h,v 4.3 85/05/01 11:38:17 lwall Exp $
	X * 
	X * $Log:	final.h,v $
	X * Revision 4.3  85/05/01  11:38:17  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X/* cleanup status for fast exits */
	X
	XEXT bool panic INIT(FALSE);		/* we got hung up or something-- */
	X					/*  so leave tty alone */
	XEXT bool rc_changed INIT(FALSE);	/* need we rewrite .newsrc? */
	XEXT bool doing_ng INIT(FALSE);		/* do we need to reconstitute */
	X					/* current rc line? */
	X
	XEXT char int_count INIT(0);		/* how many interrupts we've had */
	X
	X/* signal catching routines */
	X
	Xint	int_catcher();
	Xint	sig_catcher();
	X#ifdef SIGTSTP
	X    int	stop_catcher();
	X    int	cont_catcher();
	X#endif
	X
	Xvoid	final_init();
	Xvoid	finalize();
SHAR_EOF
if test 704 -ne "`wc -c < 'final.h'`"
then
	echo shar: error transmitting "'final.h'" '(should have been 704 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'head.h'" '(3553 characters)'
if test -f 'head.h'
then
	echo shar: will not over-write existing file "'head.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'head.h'
	X/* $Header: head.h,v 4.3 85/05/01 11:38:31 lwall Exp $
	X *
	X * $Log:	head.h,v $
	X * Revision 4.3  85/05/01  11:38:31  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#define HEAD_FIRST 1
	X
	X/* types of header lines (if only C really believed in enums)
	X * (These must stay in alphabetic order at least in the first letter.
	X * Within each letter it helps to arrange in increasing likelihood.)
	X */
	X
	X#define PAST_HEADER	0	/* body */
	X#define SOME_LINE	1	/* unrecognized */
	X#define ARTID_LINE	2	/* article-i.d. */
	X#define APPR_LINE	3	/* approved */
	X#define DIST_LINE	4	/* distribution */
	X#define DATE_LINE	5	/* date */
	X#define RECEIVED_LINE	6	/* date-received */
	X#define EXPIR_LINE	7	/* expires */
	X#define FOLLOW_LINE	8	/* followup-to */
	X#define FROM_LINE	9	/* from */
	X#define KEYW_LINE	10	/* keywords */
	X#define LINES_LINE	11	/* lines */
	X#define MESSID_LINE	12	/* message-id */
	X#define NFFR_LINE	13	/* nf-from */
	X#define NFID_LINE	14	/* nf-id */
	X#define NGS_LINE	15	/* newsgroups */
	X#define ORG_LINE	16	/* organization */
	X#define PATH_LINE	17	/* path */
	X#define POSTED_LINE	18	/* posted */
	X#define PVER_LINE	19	/* posting-version */
	X#define REPLY_LINE	20	/* reply-to */
	X#define REFS_LINE	21	/* references */
	X#define RVER_LINE	22	/* relay-version */
	X#define SENDER_LINE	23	/* sender */
	X#define SUMRY_LINE	24	/* summary */
	X#define SUBJ_LINE	25	/* subject */
	X#define XREF_LINE	26	/* xref */
	X
	X#define HEAD_LAST	27	/* one more than the last one above */
	X
	Xstruct headtype {
	X    char *ht_name;		/* header line identifier */
	X#ifdef pdp11
	X    short ht_minpos;
	X    short ht_maxpos;
	X#else
	X    ART_POS ht_minpos;		/* pointer to beginning of line in article */
	X    ART_POS ht_maxpos;		/* pointer to end of line in article */
	X#endif
	X    char ht_length;		/* could make these into nybbles but */
	X    char ht_flags;		/* it wouldn't save space normally */
	X};				/* due to alignment considerations */
	X
	X#define HT_HIDE 1	/* -h on this line */
	X#define HT_MAGIC 2	/* do any special processing on this line */
	X
	X/* This array must stay in the same order as the list above */
	X
	X#ifndef DOINIT
	XEXT struct headtype htype[HEAD_LAST];
	X#else
	Xstruct headtype htype[HEAD_LAST] = {
	X /* name             minpos   maxpos  length   flag */
	X    {"BODY",		0,	0,	4,	0		},
	X    {"unrecognized",	0,	0,	12,	0		},
	X    {"article-i.d.",	0,	0,	12,	HT_HIDE		},
	X    {"approved",	0,	0,	8,	HT_HIDE		},
	X    {"distribution",	0,	0,	12,	0		},
	X    {"date",		0,	0,	4,	0		},
	X    {"date-received",	0,	0,	13,	0		},
	X    {"expires",		0,	0,	7,	HT_HIDE|HT_MAGIC},
	X    {"followup-to",	0,	0,	11,	0		},
	X    {"from",		0,	0,	4,	0		},
	X    {"keywords",	0,	0,	8,	0		},
	X    {"lines",		0,	0,	5,	0		},
	X    {"message-id",	0,	0,	10,	0		},
	X    {"nf-from",		0,	0,	7,	HT_HIDE		},
	X    {"nf-id",		0,	0,	5,	HT_HIDE		},
	X    {"newsgroups",	0,	0,	10,	HT_MAGIC|HT_HIDE},
	X    {"organization",	0,	0,	12,	0		},
	X    {"path",		0,	0,	4,	HT_HIDE		},
	X    {"posted",		0,	0,	6,	HT_HIDE		},
	X    {"posting-version",	0,	0,	15,	HT_HIDE		},
	X    {"reply-to",	0,	0,	8,	0		},
	X    {"references",	0,	0,	10,	0		},
	X    {"relay-version",	0,	0,	13,	HT_HIDE		},
	X    {"sender",		0,	0,	6,	0		},
	X    {"summary",		0,	0,	7,	0		},
	X    {"subject",		0,	0,	7,	HT_MAGIC	},
	X    {"xref",		0,	0,	4,	HT_HIDE		}
	X};
	X#endif
	X
	X#ifdef ASYNC_PARSE
	XEXT ART_NUM parsed_art INIT(0);
	X#endif
	X
	XEXT char in_header INIT(0);		/* are we decoding the header? */
	X
	X#ifdef CACHESUBJ
	X    EXT char **subj_list INIT(Null(char **));
	X#endif
	X
	Xvoid	head_init();
	Xint	set_line_type();
	Xvoid	start_header();
	Xbool    parseline();
	X#ifdef ASYNC_PARSE
	X    int		parse_maybe();
	X#endif
	Xchar	*fetchsubj();
	Xchar	*fetchlines();
SHAR_EOF
if test 3553 -ne "`wc -c < 'head.h'`"
then
	echo shar: error transmitting "'head.h'" '(should have been 3553 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help.h'" '(276 characters)'
if test -f 'help.h'
then
	echo shar: will not over-write existing file "'help.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'help.h'
	X/* $Header: help.h,v 4.3 85/05/01 11:39:19 lwall Exp $
	X *
	X * $Log:	help.h,v $
	X * Revision 4.3  85/05/01  11:39:19  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	Xvoid	help_init();
	Xint	help_ng();
	Xint	help_art();
	Xint	help_page();
	X#ifdef ESCSUBS
	X    int	help_subs();
	X#endif
SHAR_EOF
if test 276 -ne "`wc -c < 'help.h'`"
then
	echo shar: error transmitting "'help.h'" '(should have been 276 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'init.h'" '(285 characters)'
if test -f 'init.h'
then
	echo shar: will not over-write existing file "'init.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'init.h'
	X/* $Header: init.h,v 4.3 85/05/01 11:40:46 lwall Exp $
	X *
	X * $Log:	init.h,v $
	X * Revision 4.3  85/05/01  11:40:46  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *lockname INIT(nullstr);
	X
	Xbool	initialize();
	Xvoid	lock_check();
	Xvoid	newsnews_check();
	Xvoid	version_check();
SHAR_EOF
if test 285 -ne "`wc -c < 'init.h'`"
then
	echo shar: error transmitting "'init.h'" '(should have been 285 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'intrp.h'" '(778 characters)'
if test -f 'intrp.h'
then
	echo shar: will not over-write existing file "'intrp.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'intrp.h'
	X/* $Header: intrp.h,v 4.3 85/05/01 11:41:48 lwall Exp $
	X *
	X * $Log:	intrp.h,v $
	X * Revision 4.3  85/05/01  11:41:48  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *lib INIT(Nullch);		/* news library */
	XEXT char *rnlib INIT(Nullch);		/* private news program library */
	XEXT char *origdir INIT(Nullch);		/* cwd when rn invoked */
	XEXT char *homedir INIT(Nullch);		/* login directory */
	XEXT char *dotdir INIT(Nullch);		/* where . files go */
	XEXT char *logname INIT(Nullch);		/* login id */
	XEXT char *sitename INIT(Nullch);	/* host name */
	X
	X#ifdef NEWSADMIN
	X    EXT char newsadmin[] INIT(NEWSADMIN);/* news administrator */
	X    EXT int newsuid INIT(0);
	X#endif
	X
	Xvoid    intrp_init();
	Xchar	*filexp();
	Xchar	*dointerp();
	Xvoid	interp();
	Xvoid	refscpy();
	Xchar	*getrealname();
SHAR_EOF
if test 778 -ne "`wc -c < 'intrp.h'`"
then
	echo shar: error transmitting "'intrp.h'" '(should have been 778 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'kfile.h'" '(530 characters)'
if test -f 'kfile.h'
then
	echo shar: will not over-write existing file "'kfile.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'kfile.h'
	X/* $Header: kfile.h,v 4.3 85/05/01 11:42:00 lwall Exp $
	X *
	X * $Log:	kfile.h,v $
	X * Revision 4.3  85/05/01  11:42:00  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#define KF_GLOBAL 0
	X#define KF_LOCAL 1
	X
	X#ifdef KILLFILES
	XEXT FILE *globkfp INIT(Nullfp);		/* global article killer file */
	XEXT FILE *localkfp INIT(Nullfp);	/* local (for this newsgroup) */
	X					/*  article killer file */
	X#endif
	X
	Xvoid	kfile_init();
	Xint	do_kfile();
	Xvoid	kill_unwanted();
	Xint	edit_kfile();
	Xvoid	open_kfile();
	Xvoid    kf_append();
	Xvoid	setthru();
	X
SHAR_EOF
if test 530 -ne "`wc -c < 'kfile.h'`"
then
	echo shar: error transmitting "'kfile.h'" '(should have been 530 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'last.h'" '(427 characters)'
if test -f 'last.h'
then
	echo shar: will not over-write existing file "'last.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'last.h'
	X/* $Header: last.h,v 4.3 85/05/01 11:42:22 lwall Exp $
	X *
	X * $Log:	last.h,v $
	X * Revision 4.3  85/05/01  11:42:22  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *lastngname INIT(Nullch);	/* last newsgroup read, from .rnlast file */
	XEXT long lasttime INIT(0);	/* time last rn was started up */
	XEXT long lastactsiz INIT(0);	/* size of active file when rn last started up */
	X
	Xvoid	last_init();
	Xvoid    writelast();
SHAR_EOF
if test 427 -ne "`wc -c < 'last.h'`"
then
	echo shar: error transmitting "'last.h'" '(should have been 427 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'makedepend.SH'" '(2143 characters)'
if test -f 'makedepend.SH'
then
	echo shar: will not over-write existing file "'makedepend.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'makedepend.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting makedepend (with variable substitutions)"
	X$spitshell >makedepend <<!GROK!THIS!
	X$startsh
	X# $Header: makedepend.SH,v 4.3.1.2 85/05/13 15:53:42 lwall Exp $
	X#
	X# $Log:	makedepend.SH,v $
	X# Revision 4.3.1.2  85/05/13  15:53:42  lwall
	X# Made cpp look in /usr/local/include too.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:35:10  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:42:26  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X$cat /dev/null >.deptmp
	X$echo "(Note: this is going to take a while.)"
	X$rm -f X*.c
	Xfor file in *.c; do
	X    filebase=\`basename \$file .c\`
	X    $echo "Finding dependencies for \$filebase.o."
	X    $sed -n <\$file >X\$file \\
	X	-e "/^\${filebase}_init(/q" \\
	X	-e '/^#/{' \\
	X	-e 's|/\*.*$||' \\
	X	-e p \\
	X	-e '}'
	X    $cpp -I/usr/local/include X\$file | $sed  \\
	X	-e '/^# *[0-9]/!d' \\
	X	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
	X	-e 's|: \./|: |' \\
	X	-e 's|: X|: |' | \\
	X	$uniq | $sort | $uniq >> .deptmp
	Xdone
	X
	Xfor file in *.SH; do
	X    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
	Xdone
	X
	X$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'
	X
	Xif $test -s .deptmp; then
	X    echo "Updating Makefile..."
	X    echo "# If this runs make out of memory, delete /usr/include lines." >>Makefile.new
	X    $cat .deptmp >>Makefile.new
	Xelse
	X    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
	X    $egrep '^#include ' *.c *.h >.deptmp
	X    echo "Updating Makefile..."
	X    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' >> Makefile.new
	X    <.deptmp $sed -n 's|c:#include <\(.*\)>.*\$\$|o: /usr/include/\1|p' >> Makefile.new
	X    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> Makefile.new
	X    <.deptmp $sed -n 's|h:#include <\(.*\)>.*\$\$|h: /usr/include/\1|p' >> Makefile.new
	Xfi
	X$mv Makefile Makefile.old
	X$mv Makefile.new Makefile
	X$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> Makefile
	Xrm .deptmp X*.c
	X
	X!GROK!THIS!
	X$eunicefix makedepend
	Xchmod 755 makedepend
SHAR_EOF
if test 2143 -ne "`wc -c < 'makedepend.SH'`"
then
	echo shar: error transmitting "'makedepend.SH'" '(should have been 2143 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'makedir.SH'" '(1087 characters)'
if test -f 'makedir.SH'
then
	echo shar: will not over-write existing file "'makedir.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'makedir.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting makedir (with variable substitutions)"
	X$spitshell >makedir <<!GROK!THIS!
	X$startsh
	X# $Header: makedir.SH,v 4.3 85/05/01 11:42:31 lwall Exp $
	X# 
	X# $Log:	makedir.SH,v $
	X# Revision 4.3  85/05/01  11:42:31  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	Xcase \$# in
	X  0)
	X    $echo "makedir pathname filenameflag"
	X    exit 1
	X    ;;
	Xesac
	X
	X: guarantee one slash before 1st component
	Xcase \$1 in
	X  /*) ;;
	X  *)  set ./\$1 \$2 ;;
	Xesac
	X
	X: strip last component if it is to be a filename
	Xcase X\$2 in
	X  X1) set \`$echo \$1 | $sed 's:\(.*\)/[^/]*\$:\1:'\` ;;
	X  *)  set \$1 ;;
	Xesac
	X
	X: return reasonable status if nothing to be created
	Xif $test -d "\$1" ; then
	X    exit 0
	Xfi
	X
	Xlist=''
	Xwhile true ; do
	X    case \$1 in
	X    */*)
	X	list="\$1 \$list"
	X	set \`echo \$1 | $sed 's:\(.*\)/:\1 :'\`
	X	;;
	X    *)
	X	break
	X	;;
	X    esac
	Xdone
	X
	Xset \$list
	X
	Xfor dir do
	X    $mkdir \$dir >/dev/null 2>&1
	Xdone
	X!GROK!THIS!
	X$eunicefix makedir
	Xchmod 755 makedir
SHAR_EOF
if test 1087 -ne "`wc -c < 'makedir.SH'`"
then
	echo shar: error transmitting "'makedir.SH'" '(should have been 1087 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'mbox.saver.SH'" '(1071 characters)'
if test -f 'mbox.saver.SH'
then
	echo shar: will not over-write existing file "'mbox.saver.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'mbox.saver.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting mbox.saver (with variable substitutions)"
	X$spitshell >mbox.saver <<!GROK!THIS!
	X$startsh
	X# $Header: mbox.saver.SH,v 4.3.1.2 85/05/20 15:55:37 lwall Exp $
	X# 
	X# $Log:	mbox.saver.SH,v $
	X# Revision 4.3.1.2  85/05/20  15:55:37  lwall
	X# Turned $5 into \$5.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:35:30  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:42:51  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X# 
	X#	Arguments:
	X#	1 Full name of article (%A)
	X#	2 Public news spool directory (%P)
	X#	3 Directory of current newsgroup (%c)
	X#	4 Article number (%a)
	X#	5 Where in article to start (%B)
	X#	6 Newsgroup name (%C)
	X#	7 Save destination (%b)
	X#	8 First line of message, normally From...
	X#
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X( $echo ""
	X  $echo "\$8"
	X  case "\$5" in
	X  0) $echo "Article \$4 of \$6:" ;;
	X  esac
	X  $tail +\$5c \$1 | $sed "s/^From/>From/"
	X  $echo ""
	X  $echo "" ) >> \$7
	X!GROK!THIS!
	X$eunicefix mbox.saver
	Xchmod 755 mbox.saver
SHAR_EOF
echo shar: 4 control characters may be missing from "'rn/mbox.saver.SH'"
if test 1071 -ne "`wc -c < 'mbox.saver.SH'`"
then
	echo shar: error transmitting "'mbox.saver.SH'" '(should have been 1071 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ndir.h'" '(1391 characters)'
if test -f 'ndir.h'
then
	echo shar: will not over-write existing file "'ndir.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ndir.h'
	X/* $Header: ndir.h,v 4.3 85/05/01 11:43:00 lwall Exp $
	X *
	X * $Log:	ndir.h,v $
	X * Revision 4.3  85/05/01  11:43:00  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef LIBNDIR
	X#   include <ndir.h>
	X#else
	X#   ifndef USENDIR
	X#	include <sys/dir.h>
	X#   else
	X
	X#ifndef DEV_BSIZE
	X#define	DEV_BSIZE	512
	X#endif
	X#define DIRBLKSIZ	DEV_BSIZE
	X#define	MAXNAMLEN	255
	X
	Xstruct	direct {
	X	long	d_ino;			/* inode number of entry */
	X	short	d_reclen;		/* length of this record */
	X	short	d_namlen;		/* length of string in d_name */
	X	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
	X};
	X
	X/*
	X * The DIRSIZ macro gives the minimum record length which will hold
	X * the directory entry.  This requires the amount of space in struct direct
	X * without the d_name field, plus enough space for the name with a terminating
	X * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
	X */
	X#undef DIRSIZ
	X#define DIRSIZ(dp) \
	X    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))
	X
	X/*
	X * Definitions for library routines operating on directories.
	X */
	Xtypedef struct _dirdesc {
	X	int	dd_fd;
	X	long	dd_loc;
	X	long	dd_size;
	X	char	dd_buf[DIRBLKSIZ];
	X} DIR;
	X#ifndef NULL
	X#define NULL 0
	X#endif
	Xextern	DIR *opendir();
	Xextern	struct direct *readdir();
	Xextern	long telldir();
	Xextern	void seekdir();
	X#define rewinddir(dirp)	seekdir((dirp), (long)0)
	Xextern	void closedir();
	X
	X#   endif
	X#endif
SHAR_EOF
if test 1391 -ne "`wc -c < 'ndir.h'`"
then
	echo shar: error transmitting "'ndir.h'" '(should have been 1391 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'newsetup.SH'" '(4338 characters)'
if test -f 'newsetup.SH'
then
	echo shar: will not over-write existing file "'newsetup.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'newsetup.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting newsetup (with variable substitutions)"
	X$spitshell >newsetup <<!GROK!THIS!
	X$startsh
	X# $Header: newsetup.SH,v 4.3.1.2 86/09/05 15:41:04 lwall Exp $
	X# 
	X# $Log:	newsetup.SH,v $
	X# Revision 4.3.1.2  86/09/05  15:41:04  lwall
	X# Changes for newsgroup renaming.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:35:43  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:43:05  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X: syntax: newsetup
	X
	X: System dependencies
	X: You will want to change the definitions below to reflect the distribution
	X: areas around you.  If you have more areas than this you will need to modify
	X: the sed below.
	X
	Xlocorg="$locpref"
	Xorganization="$orgpref"
	Xcity="$citypref"
	Xstate="$statepref"
	Xcntry="$cntrypref"
	Xcont="$contpref"
	Xactive="${active-/usr/lib/news/active}"
	X
	Xdotdir="\${DOTDIR-\${HOME-\$LOGDIR}}"
	X$rm -f \$dotdir/.oldnewsrc
	X$echo "Creating .newsrc in \$dotdir to be used by news programs."
	X
	Xcase \$active in
	X~*) active=\`$filexp \$active\` ;;
	Xesac
	X
	X: NOTE: SED WILL NOT TAKE MORE THAN 10 WFILES, SO BEWARE
	X
	X$sort <\$active | $sed >/tmp/n.tmp\$\$	\\
	X	-e 's/^\([^ ]*\) .*\$/\1:/'	\\
	X	-e '/^control:/{'		\\
	X	-e "  w /tmp/n.test\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e '/^junk:/{'			\\
	X	-e "  w /tmp/n.test\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e '/test:/{'			\\
	X	-e "  w /tmp/n.test\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^net\./{"			\\
	X	-e "  w /tmp/n.net\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^mod\./{"			\\
	X	-e "  w /tmp/n.mod\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^\$locorg\./{"		\\
	X	-e "  w /tmp/n.\$locorg\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^\$organization\./{"	\\
	X	-e "  w /tmp/n.\$organization\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^\$city\./{"		\\
	X	-e "  w /tmp/n.\$city\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^\$state\./{" 		\\
	X	-e "  w /tmp/n.\$state\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^fa\./{"			\\
	X	-e "  w /tmp/n.fa\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'
	X
	X$sed </tmp/n.tmp\$\$ >/tmp/n.local\$\$	\\
	X	-e "/^\$cntry\./{" 		\\
	X	-e "  w /tmp/n.\$cntry\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^\$cont\./{" 		\\
	X	-e "  w /tmp/n.\$cont\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^to\./{"			\\
	X	-e "  w /tmp/n.to\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^comp\./{"			\\
	X	-e "  w /tmp/n.comp\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^news\./{"			\\
	X	-e "  w /tmp/n.news\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^rec\./{"			\\
	X	-e "  w /tmp/n.rec\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^sci\./{"			\\
	X	-e "  w /tmp/n.sci\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^soc\./{"			\\
	X	-e "  w /tmp/n.soc\$\$"		\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/^talk\./{"			\\
	X	-e "  w /tmp/n.talk\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'				\\
	X	-e "/\./{"			\\
	X	-e "  w /tmp/n.misc\$\$"	\\
	X	-e '  d'			\\
	X	-e '}'
	X
	X
	Xif $test -s \$dotdir/.newsrc ; then
	X    $echo "Saving your current .newsrc as .oldnewsrc..."
	X    $mv -f \$dotdir/.newsrc \$dotdir/.oldnewsrc
	Xfi
	X
	X: newsrc order determined here
	X$cat \\
	X    /tmp/n.local\$\$ \\
	X    /tmp/n.\$locorg\$\$ \\
	X    /tmp/n.\$organization\$\$ \\
	X    /tmp/n.\$city\$\$ \\
	X    /tmp/n.\$state\$\$ \\
	X    /tmp/n.\$cntry\$\$ \\
	X    /tmp/n.\$cont\$\$ \\
	X    /tmp/n.mod\$\$ \\
	X    /tmp/n.news\$\$ \\
	X    /tmp/n.comp\$\$ \\
	X    /tmp/n.sci\$\$ \\
	X    /tmp/n.rec\$\$ \\
	X    /tmp/n.soc\$\$ \\
	X    /tmp/n.misc\$\$ \\
	X    /tmp/n.talk\$\$ \\
	X    /tmp/n.net\$\$ \\
	X    /tmp/n.fa\$\$ \\
	X    /tmp/n.test\$\$ \\
	X| $uniq >\$dotdir/.newsrc
	X
	X$rm -f	/tmp/n.to\$\$ \\
	X	/tmp/n.tmp\$\$ \\
	X	/tmp/n.local\$\$ \\
	X	/tmp/n.\$locorg\$\$ \\
	X	/tmp/n.\$organization\$\$ \\
	X	/tmp/n.\$city\$\$ \\
	X	/tmp/n.\$state\$\$ \\
	X	/tmp/n.\$cntry\$\$ \\
	X	/tmp/n.\$cont\$\$ \\
	X	/tmp/n.mod\$\$ \\
	X	/tmp/n.news\$\$ \\
	X	/tmp/n.comp\$\$ \\
	X	/tmp/n.sci\$\$ \\
	X	/tmp/n.soc\$\$ \\
	X	/tmp/n.rec\$\$ \\
	X	/tmp/n.talk\$\$ \\
	X	/tmp/n.net\$\$ \\
	X	/tmp/n.fa\$\$ \\
	X	/tmp/n.misc\$\$ \\
	X	/tmp/n.test\$\$
	X
	X$cat <<'EOH'
	XDone.
	X
	XIf you have never used the news system before, you may find the articles
	Xin mod.announce.newuser to be helpful.  There is also a manual entry for rn.
	X
	XTo get rid of newsgroups you aren't interested in, use the 'u' command.
	XType h for help at any time while running rn.
	XEOH
	X!GROK!THIS!
	X$eunicefix newsetup
	Xchmod 755 newsetup
SHAR_EOF
if test 4338 -ne "`wc -c < 'newsetup.SH'`"
then
	echo shar: error transmitting "'newsetup.SH'" '(should have been 4338 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'newsgroups.SH'" '(1598 characters)'
if test -f 'newsgroups.SH'
then
	echo shar: will not over-write existing file "'newsgroups.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'newsgroups.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting newsgroups (with variable substitutions)"
	X$spitshell >newsgroups <<!GROK!THIS!
	X$startsh
	X# $Header: newsgroups.SH,v 4.3 85/05/01 11:43:27 lwall Exp $
	X# 
	X# $Log:	newsgroups.SH,v $
	X# Revision 4.3  85/05/01  11:43:27  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X: syntax: newsgroups [pattern] [pipeflag]
	X
	X: System Dependencies
	X
	X: You might want to change pager to a "make column" program if you have one.
	X: On the other hand, if your kernel does paging, cat would probably do.
	Xpager="${pager-/usr/ucb/more}"
	Xactive="${active-/usr/lib/news/active}"
	X
	X: End of system dependencies, hopefully
	X
	Xcase \$active in
	X~*) active=\`$filexp \$active\` ;;
	Xesac
	X
	Xif $test \$# -ge 2 ; then
	X    pager=$cat
	Xelse
	X    $echo "Completely unsubscribed newsgroups:"
	Xfi
	X
	Xdotdir=\${DOTDIR-\${HOME-\$LOGDIR}}
	X
	X: Throwing .newsrc into the pot twice is a lovely hack to prevent
	X: bogus newsgroups from showing up as unsubscribed.
	X
	X$cat \$dotdir/.newsrc \$dotdir/.newsrc \$active | \\
	X$sed	-e '/^options/d' \\
	X	-e '/^[	 ]/d' \\
	X	-e '/^control/d' \\
	X	-e '/^to\./d' \\
	X	-e 's/^\([^ !:]*\)[ !:].*\$/\1/' \\
	X	-e "/.*\$1/p" \\
	X	-e 'd' | \\
	X$sort | $uniq -u | \$pager
	Xif $test \$# -ge 2 ; then
	X    exit
	Xfi
	X$echo $n "[Type return to continue] $c"
	Xread tmp
	X$echo ""
	X$echo "Unsubscribed but mentioned in .newsrc:"
	X$sed < \$dotdir/.newsrc \\
	X	-e "/\$1.*!/"'s/^\([^!]*\)!.*\$/\1/p' \\
	X	-e 'd' | \\
	X$sort | \$pager
	X!GROK!THIS!
	X$eunicefix newsgroups
	Xchmod 755 newsgroups
SHAR_EOF
if test 1598 -ne "`wc -c < 'newsgroups.SH'`"
then
	echo shar: error transmitting "'newsgroups.SH'" '(should have been 1598 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'newsnews.SH'" '(1301 characters)'
if test -f 'newsnews.SH'
then
	echo shar: will not over-write existing file "'newsnews.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'newsnews.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting newsnews (with variable substitutions)"
	Xcat >newsnews <<!GROK!THIS!
	X			*** NEWS NEWS ***
	X
	XWelcome to rn.  There are more options to rn than you want to think about, so
	Xwe won't list them here.  If you want to find out about them, read the manual
	Xpage(s).  There are some important things to remember, though:
	X
	X  * Rn is not a modified readnews.  Don't expect the commands to be identical.
	X  * Rn runs in cbreak mode.  This means you don't have to type carriage return
	X    on single character commands.  (There are some multi-character commands.)
	X  * At ANY prompt in rn, you may type 'h' for help.  There are many different
	X    help menus, depending on where you are in rn.  Typing <esc>h in the
	X    middle of a multi-character command will list escape substitutions.
	X  * Typing a space to any prompt means to do the normal thing.  You could
	X    spend all day reading news and never hit anything but the space bar.
	X
	XThis particular message comes from $rnlib/newsnews.  You will only
	Xsee it once.  You news administrator should feel free to substitute his or
	Xher own message whenever something new happens to rn, and then the file
	Xwill again be displayed, just once for each person.
	X
	XLarry Wall	sdcrdcf!lwall
	X!GROK!THIS!
	X$eunicefix newsnews
SHAR_EOF
if test 1301 -ne "`wc -c < 'newsnews.SH'`"
then
	echo shar: error transmitting "'newsnews.SH'" '(should have been 1301 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ng.h'" '(940 characters)'
if test -f 'ng.h'
then
	echo shar: will not over-write existing file "'ng.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ng.h'
	X/* $Header: ng.h,v 4.3 85/05/01 11:44:29 lwall Exp $
	X *
	X * $Log:	ng.h,v $
	X * Revision 4.3  85/05/01  11:44:29  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT ART_NUM art INIT(0);	/* current or prospective article # */
	X
	XEXT int checkcount INIT(0);	/* how many articles have we read */
	X			/*   in the current newsgroup since */
	X			/*   the last checkpoint? */
	XEXT int docheckwhen INIT(20);	/* how often to do checkpoint */
	X
	X#ifdef MAILCALL
	XEXT int mailcount INIT(0);			/* check for mail when 0 mod 10 */
	X#endif
	XEXT char *mailcall INIT(nullstr);
	X
	XEXT bool forcelast INIT(FALSE);			/* ought we show "End of newsgroup"? */
	XEXT bool forcegrow INIT(FALSE);		/* do we want to recalculate size */
	X				    /* of newsgroup, e.g. after posting? */
	X
	X#define NG_ERROR -1
	X#define NG_NORM 0
	X#define NG_ASK 1
	X#define NG_MINUS 2
	X
	Xvoid    ng_init();
	Xint	do_newsgroup();
	Xint	art_switch();
	X#ifdef MAILCALL
	X    void	setmail();
	X#endif
	Xvoid	setdfltcmd();
SHAR_EOF
if test 940 -ne "`wc -c < 'ng.h'`"
then
	echo shar: error transmitting "'ng.h'" '(should have been 940 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ng.help.SH'" '(1777 characters)'
if test -f 'ng.help.SH'
then
	echo shar: will not over-write existing file "'ng.help.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'ng.help.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting ng.help (with variable substitutions)"
	X$spitshell >ng.help <<!GROK!THIS!
	X$startsh
	X# $Header: ng.help.SH,v 4.3 85/05/01 11:44:34 lwall Exp $
	X# 
	X# $Log:	ng.help.SH,v $
	X# Revision 4.3  85/05/01  11:44:34  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	X$pager <<'EOT'
	XNewsgroup Selection commands:
	X
	Xy,SP	Do this newsgroup now.
	X.cmd	Do this newsgroup, executing cmd as first command.
	X=	Equivalent to .=<carriage return>.
	Xu	Unsubscribe from this newsgroup.
	Xc	Catch up (mark this newsgroup all read).
	X
	Xn	Go to the next newsgroup with unread news.
	XN	Go to the next newsgroup.
	Xp	Go to the previous newsgroup with unread news.
	XP	Go to the previous newsgroup.
	X-	Go to the previously displayed newsgroup.
	X1	Go to the first newsgroup.
	X^	Go to the first newsgroup with unread news.
	X$	Go to the last newsgroup.
	Xg name	Go to the named newsgroup.  Subscribe to new newsgroups this way too.
	X/pat	Search forward for newsgroup matching pattern.
	X?pat	Search backward for newsgroup matching pattern.
	X	(Use * and ? style patterns.  Append r to include read newsgroups.)
	Xl pat	List unsubscribed newsgroups containing pattern.
	Xm name	Move named newsgroup elsewhere (no name moves current newsgroup).
	Xo pat	Only display newsgroups matching pattern.  Omit pat to unrestrict.
	Xa pat	Like o, but also scans for unsubscribed newsgroups matching pattern.
	XL	List current .newsrc.
	X&	Print current command-line switch settings.
	X&switch {switch}
	X	Set (or unset) more command-line switches.
	X&&	Print current macro definitions.
	X&&def	Define a new macro.
	X!cmd	Shell escape.
	Xq	Quit rn.
	X^K	Edit the global KILL file.  Use commands like /pattern/j to suppress
	X	pattern in every newsgroup.
	Xv	Print version.
	XEOT
	X!GROK!THIS!
	X$eunicefix ng.help
	Xchmod 755 ng.help
SHAR_EOF
if test 1777 -ne "`wc -c < 'ng.help.SH'`"
then
	echo shar: error transmitting "'ng.help.SH'" '(should have been 1777 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ngdata.h'" '(625 characters)'
if test -f 'ngdata.h'
then
	echo shar: will not over-write existing file "'ngdata.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ngdata.h'
	X/* $Header: ngdata.h,v 4.3 85/05/01 11:44:48 lwall Exp $
	X *
	X * $Log:	ngdata.h,v $
	X * Revision 4.3  85/05/01  11:44:48  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT FILE *actfp INIT(Nullfp);	/* the active file */
	XEXT bool writesoft INIT(FALSE);	/* rewrite the soft pointer file? */
	XEXT int softtries INIT(0), softmisses INIT(0);
	X
	X#ifdef CACHEFIRST
	X    EXT ART_NUM abs1st[MAXRCLINE];	/* 1st real article in newsgroup */
	X#else
	X# ifdef MININACT
	X    EXT ART_NUM abs1st INIT(0);
	X# endif
	X#endif
	X
	XEXT char *moderated;
	X
	Xvoid	ngdata_init();
	XART_NUM	getngsize();
	XACT_POS findact();
	XART_NUM	getabsfirst();
	XART_NUM	getngmin();
SHAR_EOF
if test 625 -ne "`wc -c < 'ngdata.h'`"
then
	echo shar: error transmitting "'ngdata.h'" '(should have been 625 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ngsrch.h'" '(474 characters)'
if test -f 'ngsrch.h'
then
	echo shar: will not over-write existing file "'ngsrch.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ngsrch.h'
	X/* $Header: ngsrch.h,v 4.3 85/05/01 11:44:56 lwall Exp $
	X *
	X * $Log:	ngsrch.h,v $
	X * Revision 4.3  85/05/01  11:44:56  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef NGSEARCH
	X#define NGS_ABORT 0
	X#define NGS_FOUND 1
	X#define NGS_INTR 2
	X#define NGS_NOTFOUND 3
	X
	XEXT bool ng_doread INIT(FALSE);		/* search read newsgroups? */
	X#endif
	X
	Xvoid	ngsrch_init();
	X#ifdef NGSEARCH 
	X    int		ng_search();
	X    bool	ng_wanted();
	X#endif
	X#ifdef NGSORONLY
	X    char	*ng_comp();
	X#endif
SHAR_EOF
if test 474 -ne "`wc -c < 'ngsrch.h'`"
then
	echo shar: error transmitting "'ngsrch.h'" '(should have been 474 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ngstuff.h'" '(330 characters)'
if test -f 'ngstuff.h'
then
	echo shar: will not over-write existing file "'ngstuff.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ngstuff.h'
	X/* $Header: ngstuff.h,v 4.3 85/05/01 11:45:12 lwall Exp $
	X *
	X * $Log:	ngstuff.h,v $
	X * Revision 4.3  85/05/01  11:45:12  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#define NN_NORM 0
	X#define NN_INP 1
	X#define NN_REREAD 2
	X#define NN_ASK 3
	X
	Xvoid	ngstuff_init();
	Xint	escapade();
	Xint	switcheroo();
	Xint	numnum();
	Xint	perform();
SHAR_EOF
if test 330 -ne "`wc -c < 'ngstuff.h'`"
then
	echo shar: error transmitting "'ngstuff.h'" '(should have been 330 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'norm.saver.SH'" '(974 characters)'
if test -f 'norm.saver.SH'
then
	echo shar: will not over-write existing file "'norm.saver.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'norm.saver.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting norm.saver (with variable substitutions)"
	X$spitshell >norm.saver <<!GROK!THIS!
	X$startsh
	X# $Header: norm.saver.SH,v 4.3.1.2 85/05/20 15:56:24 lwall Exp $
	X# 
	X# $Log:	norm.saver.SH,v $
	X# Revision 4.3.1.2  85/05/20  15:56:24  lwall
	X# Turned $5 into \$5.
	X# 
	X# Revision 4.3.1.1  85/05/10  11:36:52  lwall
	X# Branch for patches.
	X# 
	X# Revision 4.3  85/05/01  11:45:16  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X# 
	X#	Arguments:
	X#	1 Full name of article (%A)
	X#	2 Public news spool directory (%P)
	X#	3 Directory of current newsgroup (%c)
	X#	4 Article number (%a)
	X#	5 Where in article to start (%B)
	X#	6 Newsgroup name (%C)
	X#	7 Save destination (%b)
	X#
	Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
	X
	X( case "\$5" in
	X  0) $echo "Article \$4 of \$6:" ;;
	X  esac
	X  $tail +\$5c \$1
	X  $echo ""
	X  $echo "" ) >> \$7
	X!GROK!THIS!
	X$eunicefix norm.saver
	Xchmod 755 norm.saver
SHAR_EOF
if test 974 -ne "`wc -c < 'norm.saver.SH'`"
then
	echo shar: error transmitting "'norm.saver.SH'" '(should have been 974 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'only.h'" '(662 characters)'
if test -f 'only.h'
then
	echo shar: will not over-write existing file "'only.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'only.h'
	X/* $Header: only.h,v 4.3 85/05/01 11:45:27 lwall Exp $
	X *
	X * $Log:	only.h,v $
	X * Revision 4.3  85/05/01  11:45:27  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifndef NBRA
	X#include "search.h"
	X#endif
	X
	X#ifdef ONLY
	X    EXT char *ngtodo[NGMAX];		/* restrictions in effect */
	X#   ifdef SPEEDOVERMEM
	X	EXT COMPEX *compextodo[NGMAX];	/* restrictions in compiled form */
	X#   endif
	X#endif
	X
	XEXT int maxngtodo INIT(0);			/*  0 => no restrictions */
	X					/* >0 => # of entries in ngtodo */
	X
	Xvoid	only_init();
	Xbool	inlist();	/* return TRUE if ngname is in command line list */
	X			/* or if there was no list */
	Xvoid	setngtodo();
	X#ifdef ONLY
	X    void	end_only();
	X#endif
SHAR_EOF
if test 662 -ne "`wc -c < 'only.h'`"
then
	echo shar: error transmitting "'only.h'" '(should have been 662 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'pager.help.SH'" '(1633 characters)'
if test -f 'pager.help.SH'
then
	echo shar: will not over-write existing file "'pager.help.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'pager.help.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting pager.help (with variable substitutions)"
	X$spitshell >pager.help <<!GROK!THIS!
	X$startsh
	X# $Header: pager.help.SH,v 4.3 85/05/01 11:45:31 lwall Exp $
	X#
	X# $Log:	pager.help.SH,v $
	X# Revision 4.3  85/05/01  11:45:31  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	X$pager <<'EOT'
	XPaging commands:
	X
	XSP	Display the next page.
	Xx	Display the next page decrypted (rot13).
	Xd	Display half a page more.
	XCR	Display one more line.
	X^R,v,^X	Restart the current article (v=verbose header, ^X=rot13).
	X^B	Back up one page.
	X^L,X	Refresh the screen (X=rot13).
	Xg pat	Go to (search forward within article for) pattern.
	XG	Search again for current pattern within article.
	X^G	Search for next line beginning with \"Subject:\".
	XTAB	Search for next line beginning with a different character.
	Xq	Quit the pager, go to end of article.  Leave article read or unread.
	Xj	Junk this article (mark it read).  Goes to end of article.
	X
	XThe following commands skip the rest of the current article, then behave
	Xjust as if typed to the 'What next?' prompt at the end of the article:
	X
	Xn	Scan forward for next unread article.
	XN	Go to next article.
	X^N	Scan forward for next unread article with same title.
	Xp,P,^P	Same as n,N,^N, only going backwards.
	X-	Go to previously displayed article.
	X
	XThe following commands also take you to the end of the article.
	XType h at end of article for a description of these commands:
	X
	X	# $ & / = ? c C f F k K ^K m M number r R ^R s S u v w W Y ^ |
	X
	X(To return to the middle of the article after one of these commands, type ^L.)
	XEOT
	X!GROK!THIS!
	X$eunicefix pager.help
	Xchmod 755 pager.help
SHAR_EOF
if test 1633 -ne "`wc -c < 'pager.help.SH'`"
then
	echo shar: error transmitting "'pager.help.SH'" '(should have been 1633 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'rcln.h'" '(401 characters)'
if test -f 'rcln.h'
then
	echo shar: will not over-write existing file "'rcln.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'rcln.h'
	X/* $Header: rcln.h,v 4.3 85/05/01 11:45:52 lwall Exp $
	X *
	X * $Log:	rcln.h,v $
	X * Revision 4.3  85/05/01  11:45:52  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef DEBUGGING
	XEXT ART_NUM ngmax[MAXRCLINE];
	X#endif
	X
	Xvoid    rcln_init();
	X#ifdef CATCHUP
	X    void	catch_up();
	X#endif
	Xint	addartnum();
	X#ifdef MCHASE
	X    void	subartnum();
	X#endif
	Xvoid	prange();
	Xvoid	set_toread();
	Xvoid	checkexpired();
SHAR_EOF
if test 401 -ne "`wc -c < 'rcln.h'`"
then
	echo shar: error transmitting "'rcln.h'" '(should have been 401 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'rcstuff.h'" '(1293 characters)'
if test -f 'rcstuff.h'
then
	echo shar: will not over-write existing file "'rcstuff.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'rcstuff.h'
	X/* $Header: rcstuff.h,v 4.3 85/05/01 11:46:49 lwall Exp $
	X *
	X * $Log:	rcstuff.h,v $
	X * Revision 4.3  85/05/01  11:46:49  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *rcline[MAXRCLINE];/* pointers to lines of .newsrc */
	XEXT ART_UNREAD toread[MAXRCLINE];
	X			/* number of articles to be read in newsgroup */
	X			/* <0 => invalid or unsubscribed newsgroup */
	X#define TR_ONE ((ART_UNREAD) 1)
	X#define TR_NONE ((ART_UNREAD) 0)
	X#define TR_UNSUB ((ART_UNREAD) -1)
	X			/* keep this one as -1, some tests use >= TR_UNSUB */
	X#define TR_BOGUS ((ART_UNREAD) -2)
	X#define TR_JUNK ((ART_UNREAD) -3)
	X
	XEXT char rcchar[MAXRCLINE]; /* holds the character : or ! while spot is \0 */
	XEXT char rcnums[MAXRCLINE]; /* offset from rcline to numbers on line */
	XEXT ACT_POS softptr[MAXRCLINE];
	X			/* likely ptr to active file entry for newsgroup */
	XEXT bool paranoid INIT(FALSE);	/* did we detect some inconsistency in .newsrc? */
	X
	Xbool	rcstuff_init();
	Xbool	get_ng();	/* return TRUE if newsgroup can be found or added */
	XNG_NUM	add_newsgroup();
	X#ifdef RELOCATE
	X    NG_NUM	relocate_newsgroup();	/* move newsgroup around */
	X#endif
	Xvoid	list_newsgroups();
	XNG_NUM	find_ng();	/* return index of newsgroup */
	Xvoid	cleanup_rc();
	Xvoid	sethash();
	Xint	hash();
	Xvoid	newsrc_check();
	Xvoid	write_rc();
	Xvoid	get_old_rc();
SHAR_EOF
if test 1293 -ne "`wc -c < 'rcstuff.h'`"
then
	echo shar: error transmitting "'rcstuff.h'" '(should have been 1293 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'respond.h'" '(458 characters)'
if test -f 'respond.h'
then
	echo shar: will not over-write existing file "'respond.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'respond.h'
	X/* $Header: respond.h,v 4.3 85/05/01 11:47:50 lwall Exp $
	X *
	X * $Log:	respond.h,v $
	X * Revision 4.3  85/05/01  11:47:50  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *savedest INIT(Nullch);	/* value of %b */
	XEXT ART_POS savefrom INIT(0);		/* value of %B */
	XEXT char *headname INIT(Nullch);
	X
	X#define SAVE_ABORT 0
	X#define SAVE_DONE 1
	X
	Xvoid	respond_init();
	Xint	save_article();
	Xint	cancel_article();
	Xvoid	reply();
	Xvoid	followup();
	Xvoid	invoke();
SHAR_EOF
if test 458 -ne "`wc -c < 'respond.h'`"
then
	echo shar: error transmitting "'respond.h'" '(should have been 458 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'rn.h'" '(813 characters)'
if test -f 'rn.h'
then
	echo shar: will not over-write existing file "'rn.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'rn.h'
	X/* $Header: rn.h,v 4.3 85/05/01 11:48:19 lwall Exp $
	X *
	X * $Log:	rn.h,v $
	X * Revision 4.3  85/05/01  11:48:19  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT char *ngname INIT(Nullch);		/* name of current newsgroup */
	XEXT int ngnlen INIT(0);			/* current malloced size of ngname */
	XEXT char *ngdir INIT(Nullch);		/* same thing in directory name form */
	XEXT int ngdlen INIT(0);			/* current malloced size of ngdir */
	X
	XEXT NG_NUM ng INIT(0);		/* current newsgroup index into rcline and toread */
	XEXT NG_NUM current_ng INIT(0);	/* stable current newsgroup so we can ditz with ng */
	XEXT NG_NUM starthere INIT(0);   /* set to the first newsgroup with unread news on startup */
	XEXT char *spool INIT(Nullch);		/* public news spool directory */
	X
	Xvoid	rn_init();
	Xvoid	main();
	Xvoid	set_ngname();
	Xchar	*getngdir();
SHAR_EOF
if test 813 -ne "`wc -c < 'rn.h'`"
then
	echo shar: error transmitting "'rn.h'" '(should have been 813 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'search.h'" '(1052 characters)'
if test -f 'search.h'
then
	echo shar: will not over-write existing file "'search.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'search.h'
	X/* $Header: search.h,v 4.3 85/05/01 11:50:46 lwall Exp $
	X *
	X * $Log:	search.h,v $
	X * Revision 4.3  85/05/01  11:50:46  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifndef NBRA
	X#define	NBRA	10		/* the maximum number of meta-brackets in an
	X				   RE -- \( \) */
	X#define NALTS	10		/* the maximum number of \|'s */
	X 
	Xtypedef struct {	
	X    char *expbuf;		/* The compiled search string */
	X    int eblen;			/* Length of above buffer */
	X    char *alternatives[NALTS];	/* The list of \| seperated alternatives */
	X    char *braslist[NBRA];	/* RE meta-bracket start list */
	X    char *braelist[NBRA];	/* RE meta-bracket end list */
	X    char *brastr;		/* saved match string after execute() */
	X    char nbra;			/* The number of meta-brackets int the most
	X				   recenlty compiled RE */
	X    bool do_folding;		/* fold upper and lower case? */
	X} COMPEX;
	X
	Xvoid	search_init();
	Xvoid	init_compex();
	Xvoid	free_compex();
	Xchar	*getbracket();
	Xvoid	case_fold();
	Xchar	*compile(); 
	Xvoid	grow_eb();
	Xchar	*execute(); 
	Xbool	advance();
	Xbool	backref(); 
	Xbool	cclass(); 
	X#endif
SHAR_EOF
if test 1052 -ne "`wc -c < 'search.h'`"
then
	echo shar: error transmitting "'search.h'" '(should have been 1052 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'subs.help.SH'" '(1911 characters)'
if test -f 'subs.help.SH'
then
	echo shar: will not over-write existing file "'subs.help.SH'"
else
sed 's/^	X//' << \SHAR_EOF > 'subs.help.SH'
	Xcase $CONFIG in
	X    '') . config.sh ;;
	Xesac
	Xecho "Extracting subs.help (with variable substitutions)"
	X$spitshell >subs.help <<!GROK!THIS!
	X$startsh
	X# $Header: subs.help.SH,v 4.3 85/05/01 11:50:50 lwall Exp $
	X# 
	X# $Log:	subs.help.SH,v $
	X# Revision 4.3  85/05/01  11:50:50  lwall
	X# Baseline for release with 4.3bsd.
	X# 
	X
	X$pager <<'EOT'
	XValid substitutions are:
	X
	Xa	Current article number
	XA	Full name of current article (%P/%c/%a)
	Xb	Destination of last save command, often a mailbox
	XB	Bytes to ignore at beginning of last saved article
	Xc	Current newsgroup, directory form
	XC	Current newsgroup, dot form
	Xd	Full name of newsgroup directory (%P/%c)
	XD	Distribution line from current article\
	Xf	Who the current article is from
	XF	Newsgroups to followup to (from Newsgroups and Followup-To)
	Xh	(This help message)
	XH	Host name (yours)
	Xi	Message-I.D. line from current article, with <>
	XI	Reference indicator mark (see -F switch)
	Xl	News administrator's login name, if any
	XL	Login name (yours)
	Xm	Current mode, first letter of (init,newsgroup,article,pager,misc)
	XM	Number of article marked with M
	Xn	Newsgroups from current article
	XN	Full name (yours)
	Xo	Organization (yours)
	XO	Original working directory (where you ran rn from)
	Xp	Your private news directory (from -d)
	XP	Public news spool directory
	Xr	Last reference (parent article id)
	XR	References list for followup article
	Xs	Subject, with all Re's and (nf)'s stripped off
	XS	Subject, with one Re stripped off\
	Xt	New To line derived from From and Reply-To (Internet format)
	XT	New To line derived from Path
	Xu	Number of unread articles
	XU	Number of unread articles not counting current article
	Xx	News library directory
	XX	Rn library directory
	Xz	Length of current article in bytes
	X~	Your home directory
	X.	Directory containing . files
	X$	Current process number
	X/	Last search string
	XESC	Run preceding command through % interpretation
	XEOT
	X!GROK!THIS!
	X$eunicefix subs.help
	Xchmod 755 subs.help
SHAR_EOF
if test 1911 -ne "`wc -c < 'subs.help.SH'`"
then
	echo shar: error transmitting "'subs.help.SH'" '(should have been 1911 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'sw.h'" '(330 characters)'
if test -f 'sw.h'
then
	echo shar: will not over-write existing file "'sw.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'sw.h'
	X/* $Header: sw.h,v 4.3 85/05/01 11:51:07 lwall Exp $
	X *
	X * $Log:	sw.h,v $
	X * Revision 4.3  85/05/01  11:51:07  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef INNERSEARCH
	XEXT int gline INIT(0);
	X#endif
	X
	Xvoid    sw_init();
	Xvoid    sw_file();
	Xvoid    sw_list();
	Xvoid	decode_switch();
	Xvoid	pr_switches();
	Xvoid	cwd_check();
SHAR_EOF
if test 330 -ne "`wc -c < 'sw.h'`"
then
	echo shar: error transmitting "'sw.h'" '(should have been 330 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'term.h'" '(6879 characters)'
if test -f 'term.h'
then
	echo shar: will not over-write existing file "'term.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'term.h'
	X/* $Header: term.h,v 4.3.1.2 85/05/13 15:52:05 lwall Exp $
	X *
	X * $Log:	term.h,v $
	X * Revision 4.3.1.2  85/05/13  15:52:05  lwall
	X * Declared devtty on TERMIO system.
	X * 
	X * Revision 4.3.1.1  85/05/10  11:41:24  lwall
	X * Branch for patches.
	X * 
	X * Revision 4.3  85/05/01  11:51:36  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	X#ifdef PUSHBACK
	XEXT char circlebuf[PUSHSIZE];
	XEXT int nextin INIT(0);
	XEXT int nextout INIT(0);
	X#ifdef PENDING
	X#ifdef FIONREAD
	XEXT long iocount INIT(0);
	X#ifndef lint
	X#define input_pending() (nextin!=nextout || (ioctl(0, FIONREAD, &iocount),(int)iocount))
	X#else
	X#define input_pending() bizarre
	X#endif lint
	X#else FIONREAD
	Xint circfill();
	XEXT int devtty INIT(0);
	X#ifndef lint
	X#define input_pending() (nextin!=nextout || circfill())
	X#else
	X#define input_pending() bizarre
	X#endif lint
	X#endif FIONREAD
	X#else PENDING
	X#ifndef lint
	X#define input_pending() (nextin!=nextout)
	X#else
	X#define input_pending() bizarre
	X#endif lint
	X#endif PENDING
	X#else PUSHBACK
	X#ifdef PENDING
	X#ifdef FIONREAD	/* must have FIONREAD or O_NDELAY for input_pending() */
	X#define read_tty(addr,size) read(0,addr,size)
	X#ifndef lint
	X#define input_pending() (ioctl(0, FIONREAD, &iocount),(int)iocount)
	X#else
	X#define input_pending() bizarre
	X#endif lint
	XEXT long iocount INIT(0);
	X
	X#else FIONREAD
	X
	XEXT int devtty INIT(0);
	XEXT bool is_input INIT(FALSE);
	XEXT char pending_ch INIT(0);
	X#ifndef lint
	X#define input_pending() (is_input || (is_input=read(devtty,&pending_ch,1)))
	X#else
	X#define input_pending() bizarre
	X#endif lint
	X#endif FIONREAD
	X#else PENDING
	X#define read_tty(addr,size) read(0,addr,size)
	X#define input_pending() (FALSE)
	X#endif PENDING
	X#endif PUSHBACK
	X
	X/* stuff wanted by terminal mode diddling routines */
	X
	X#ifdef TERMIO
	XEXT struct termio _tty, _oldtty;
	X#else
	XEXT struct sgttyb _tty;
	XEXT int _res_flg INIT(0);
	X#endif
	X
	XEXT int _tty_ch INIT(2);
	XEXT bool bizarre INIT(FALSE);			/* do we need to restore terminal? */
	X
	X/* terminal mode diddling routines */
	X
	X#ifdef TERMIO
	X
	X#define crmode() ((bizarre=1),_tty.c_lflag &=~ICANON,_tty.c_cc[VMIN] = 1,ioctl(_tty_ch,TCSETAF,&_tty))
	X#define nocrmode() ((bizarre=1),_tty.c_lflag |= ICANON,_tty.c_cc[VEOF] = CEOF,stty(_tty_ch,&_tty))
	X#define echo()	 ((bizarre=1),_tty.c_lflag |= ECHO, ioctl(_tty_ch, TCSETA, &_tty))
	X#define noecho() ((bizarre=1),_tty.c_lflag &=~ECHO, ioctl(_tty_ch, TCSETA, &_tty))
	X#define nl()	 ((bizarre=1),_tty.c_iflag |= ICRNL,_tty.c_oflag |= ONLCR,ioctl(_tty_ch, TCSETAW, &_tty))
	X#define nonl()	 ((bizarre=1),_tty.c_iflag &=~ICRNL,_tty.c_oflag &=~ONLCR,ioctl(_tty_ch, TCSETAW, &_tty))
	X#define	savetty() (ioctl(_tty_ch, TCGETA, &_oldtty),ioctl(_tty_ch, TCGETA, &_tty))
	X#define	resetty() ((bizarre=0),ioctl(_tty_ch, TCSETAF, &_oldtty))
	X#define unflush_output()
	X
	X#else
	X
	X#define raw()	 ((bizarre=1),_tty.sg_flags|=RAW, stty(_tty_ch,&_tty))
	X#define noraw()	 ((bizarre=1),_tty.sg_flags&=~RAW,stty(_tty_ch,&_tty))
	X#define crmode() ((bizarre=1),_tty.sg_flags |= CBREAK, stty(_tty_ch,&_tty))
	X#define nocrmode() ((bizarre=1),_tty.sg_flags &= ~CBREAK,stty(_tty_ch,&_tty))
	X#define echo()	 ((bizarre=1),_tty.sg_flags |= ECHO, stty(_tty_ch, &_tty))
	X#define noecho() ((bizarre=1),_tty.sg_flags &= ~ECHO, stty(_tty_ch, &_tty))
	X#define nl()	 ((bizarre=1),_tty.sg_flags |= CRMOD,stty(_tty_ch, &_tty))
	X#define nonl()	 ((bizarre=1),_tty.sg_flags &= ~CRMOD, stty(_tty_ch, &_tty))
	X#define	savetty() (gtty(_tty_ch, &_tty), _res_flg = _tty.sg_flags)
	X#define	resetty() ((bizarre=0),_tty.sg_flags = _res_flg, stty(_tty_ch, &_tty))
	X#ifdef LFLUSHO
	X#ifndef lint
	XEXT int lflusho INIT(LFLUSHO);
	X#else
	XEXT long lflusho INIT(LFLUSHO);
	X#endif lint
	X#define unflush_output() (ioctl(_tty_ch,TIOCLBIC,&lflusho))
	X#else
	X#define unflush_output()
	X#endif LFLUSHO
	X#endif TERMIO
	X
	X#ifdef TIOCSTI
	X#ifdef lint
	X#define forceme(c) ioctl(_tty_ch,TIOCSTI,Null(long*))	/* ghad! */
	X#else
	X#define forceme(c) ioctl(_tty_ch,TIOCSTI,c) /* pass character in " " */
	X#endif lint
	X#else
	X#define forceme(c)
	X#endif
	X
	X/* termcap stuff */
	X
	X/*
	X * NOTE: if you don't have termlib you'll either have to define these strings
	X *    and the tputs routine, or you'll have to redefine the macros below
	X */
	X
	X#ifdef HAVETERMLIB
	XEXT char *BC INIT(Nullch);		/* backspace character */
	XEXT char *UP INIT(Nullch);		/* move cursor up one line */
	XEXT char *CR INIT(Nullch);		/* get to left margin, somehow */
	XEXT char *VB INIT(Nullch);		/* visible bell */
	XEXT char *CL INIT(Nullch);		/* home and clear screen */
	XEXT char *CE INIT(Nullch);		/* clear to end of line */
	X#ifdef CLEAREOL
	XEXT char *CM INIT(Nullch);		/* cursor motion -- PWP */
	XEXT char *HO INIT(Nullch);		/* home cursor -- PWP */
	XEXT char *CD INIT(Nullch);		/* clear to end of display -- PWP */
	X#endif CLEAREOL
	XEXT char *SO INIT(Nullch);		/* begin standout mode */
	XEXT char *SE INIT(Nullch);		/* end standout mode */
	XEXT int SG INIT(0);		/* blanks left by SO and SE */
	XEXT char *US INIT(Nullch);		/* start underline mode */
	XEXT char *UE INIT(Nullch);		/* end underline mode */
	XEXT char *UC INIT(Nullch);		/* underline a character, if that's how it's done */
	XEXT int UG INIT(0);		/* blanks left by US and UE */
	XEXT bool AM INIT(FALSE);		/* does terminal have automatic margins? */
	XEXT bool XN INIT(FALSE);		/* does it eat 1st newline after automatic wrap? */
	XEXT char PC INIT(0);		/* pad character for use by tputs() */
	XEXT short ospeed INIT(0);	/* terminal output speed, for use by tputs() */
	XEXT int LINES INIT(0), COLS INIT(0);	/* size of screen */
	XEXT int just_a_sec INIT(960);			/* 1 sec at current baud rate */
	X					/* (number of nulls) */
	X
	X/* define a few handy macros */
	X
	X#define backspace() tputs(BC,0,putchr) FLUSH
	X#define clear() tputs(CL,LINES,putchr) FLUSH
	X#define erase_eol() tputs(CE,1,putchr) FLUSH
	X#ifdef CLEAREOL
	X#define clear_rest() tputs(CD,LINES,putchr) FLUSH	/* PWP */
	X#define maybe_eol() if(erase_screen&&can_home_clear)tputs(CE,1,putchr) FLUSH
	X#endif CLEAREOL
	X#define underline() tputs(US,1,putchr) FLUSH
	X#define un_underline() tputs(UE,1,putchr) FLUSH
	X#define underchar() tputs(UC,0,putchr) FLUSH
	X#define standout() tputs(SO,1,putchr) FLUSH
	X#define un_standout() tputs(SE,1,putchr) FLUSH
	X#define up_line() tputs(UP,1,putchr) FLUSH
	X#define carriage_return() tputs(CR,1,putchr) FLUSH
	X#define dingaling() tputs(VB,1,putchr) FLUSH
	X#else
	X  ????????		/* up to you */
	X#endif
	X
	XEXT int page_line INIT(1);	/* line number for paging in print_line (origin 1) */
	X
	Xvoid	term_init();
	Xvoid	term_set();
	X#ifdef PUSHBACK
	Xvoid	pushchar();
	Xvoid	mac_init();
	Xvoid	mac_line();
	Xvoid	show_macros();
	X#endif
	Xchar	putchr();	/* routine for tputs to call */
	Xbool	finish_command();
	Xvoid	eat_typeahead();
	Xvoid	settle_down();
	X#ifndef read_tty
	X    int		read_tty();
	X#endif
	Xvoid	underprint();
	X#ifdef NOFIREWORKS
	X    void	no_sofire();
	X    void	no_ulfire();
	X#endif
	Xvoid	getcmd();
	Xint	get_anything();
	Xvoid	in_char();
	Xint	print_lines();
	Xvoid	page_init();
	Xvoid	pad();
	Xvoid	printcmd();
	Xvoid	rubout();
	Xvoid	reprint();
	X#ifdef CLEAREOL
	Xvoid	home_cursor();
	X#endif CLEAREOL
SHAR_EOF
if test 6879 -ne "`wc -c < 'term.h'`"
then
	echo shar: error transmitting "'term.h'" '(should have been 6879 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'util.h'" '(842 characters)'
if test -f 'util.h'
then
	echo shar: will not over-write existing file "'util.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'util.h'
	X/* $Header: util.h,v 4.3 85/05/01 11:51:58 lwall Exp $
	X *
	X * $Log:	util.h,v $
	X * Revision 4.3  85/05/01  11:51:58  lwall
	X * Baseline for release with 4.3bsd.
	X * 
	X */
	X
	XEXT bool waiting INIT(FALSE);		/* are we waiting for subprocess (in doshell)? */
	XEXT int len_last_line_got INIT(0);
	X			/* strlen of some_buf after */
	X			/*  some_buf = get_a_line(bufptr,buffersize,fp) */
	X
	X/* is the string for makedir a directory name or a filename? */
	X
	X#define MD_DIR 0
	X#define MD_FILE 1
	X
	Xvoid	util_init();
	Xint	doshell();
	Xchar	*safemalloc();
	Xchar	*saferealloc();
	Xchar	*safecpy();
	Xchar	*safecat();
	Xchar	*cpytill();
	Xchar	*instr();
	X#ifdef SETUIDGID
	X    int		eaccess();
	X#endif
	Xchar	*getwd();
	Xvoid	cat();
	Xvoid	prexit();
	Xchar	*get_a_line();
	Xchar	*savestr();
	Xint	makedir();
	Xvoid	setenv();
	Xint	envix();
	Xvoid	notincl();
	Xchar	*getval();
	Xvoid	growstr();
	Xvoid	setdef();
SHAR_EOF
if test 842 -ne "`wc -c < 'util.h'`"
then
	echo shar: error transmitting "'util.h'" '(should have been 842 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

