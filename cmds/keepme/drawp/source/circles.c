
/*--------------------------------------------------------------------*/
/*                                                         circles.c  */
/*--------------------------------------------------------------------*/

/* $Header: circles.c,v 1.3 90/03/03 18:00:03 charles Locked $ */
/* $Source: /server/usr/users/charles/world/drawp/RCS/source/circles.c,v $ */

/* This file implements drawing requests for anything of a circluar   */
/*   or elliptical nature by converting them to arcs using 32 bit     */
/*   sine/cosine look-up tables.                                      */

/*--------------------------------------------------------------------*/
/*                                                      Header flies  */
/*--------------------------------------------------------------------*/

#include <stddef.h>
#include <stdlib.h>
#include "private.h"

/*--------------------------------------------------------------------*/
/*                                                 Useful definition  */
/*--------------------------------------------------------------------*/

# define shi(a) (sineTable[a].hi)
# define slo(a) (sineTable[a].lo)

# define mulBySine(x,a) ((x*shi(a))>>(16-Bf))+((x*slo(a))>>(32-Bf))

/*--------------------------------------------------------------------*/
/*                                           Look-ahead declarations  */
/*--------------------------------------------------------------------*/

DpSubPixel_t *flattenArcPos 
   (   int cx, int cy,
       int xs, int ys,
       int sa, int ra,
       int *sz,
       DpSubPixel_t *pnts,
       int stp
    );

DpSubPixel_t *flattenArcNeg 
    (  int cx, int cy,
       int xs, int ys,
       int sa, int ra,
       int *sz,
       DpSubPixel_t *pnts,
       int stp
    );

/*--------------------------------------------------------------------*/
/*                                                dpGiveArcSize(...)  */
/*--------------------------------------------------------------------*/

int dpGiveArcSize ( int xs, int ys,
                    int sa, int ra
                  )
/* Compute an upper limit for the number of points which would be     */
/*   generated by the routine 'dpFlattenArc'. The meaning of the      */
/*   parameters are trhe same as for 'dpFlattenArc'                   */
{  int stp,i,r;

   /* Ignore sa: */
   sa = 0;
   
   /* Now to work out the step angle required:                         */
   r=xs; if(r<ys) r=ys;
   for(stp=1,i=0; arcThresholds[i]>r; stp*=2,i++);
   if((i--,stp/=2)==0) stp=1,i=0;
   
   return (ra/stp)+2;
}

/*--------------------------------------------------------------------*/
/*                                                 dpFlattenArc(...)  */
/*--------------------------------------------------------------------*/

void dpFlattenArc ( int  cx, int  cy,
                    int  xs, int  ys,
                    int  sa, int  ra,
                    DpSubPixel_t *pnts, int *sz
                  )
/* This function flattens an arc into a list of points on the surcface */
/*   of the arc, choosing enough points to stay within the maximum     */
/*   error limit. The point array where the points should be stored is */
/*   at <pnts> and <*sz> is the offset in that array where the first   */
/*   point should be stored. On exit <*sz> should point to the next    */
/*   location in the array where the next point should be stored.      */
/* Enough points should be allocated in the array for the points to be */
/*   stored, this can be acheived with the function 'dpGiveArcSize'    */
/* The elliptical arc which is flattened has the following parametric  */
/*   equation:                                                         */
/* x = cx + cos(t+sa)*xs ; y = cy + sin(t+sa)*ys                       */
/* as t goes from 0 (up or down) to ra.                                */
/* ra is negative or posotive in the range -360 degrees .. +360 degrees*/
/*  and if it is outside this range, it is truncated.                  */
/* Note that sx,sy,cx and cy are in units of 1/Accuracy and that the   */
/*   points generated are also in units of 1/Accuracy.                 */
/* Note that sa and ra are both specified in units of (1/Angles)       */
/*   degrees, ie. appropriate units for loking up sine values in the   */
/*   look-up table.                                                    */
{  int stp,i,r;

   /* Get sa in the correct range:                                    */
   sa %= (360*Angles);
   if(sa<0) sa+=360*Angles;
   
   /* Now to work out the step angle required:                         */
   r=xs; if(r<ys) r=ys;
   for(stp=1,i=0; arcThresholds[i]>r; stp*=2,i++);
   if((i--,stp/=2)==0) stp=1,i=0;
   
   /* Now to branch to the appropriate flattening sub-routine:  */
   if(ra<0) flattenArcPos(cx,cy,xs,ys,sa, ra,sz,pnts,stp);
   else     flattenArcNeg(cy,cy,xs,ys,sa,-ra,sz,pnts,stp);
}

/*--------------------------------------------------------------------*/
/*                                                flattenArcPos(...)  */
/*--------------------------------------------------------------------*/


DpSubPixel_t *flattenArcPos ( int cx, int cy,
                              int xs, int ys,
                              int sa, int ra,
                              int *sz,
                              DpSubPixel_t *pnts,
                              int stp
                             )
/* This function deals with the case for dpFlattenArc where the       */
/*    subtended angle is posotive.                                    */
/* <stp> is the step angle to use in terms of the internal sine table */
/*   angle representation, and sa and ra are also in those angle      */
/*   units, (*sz) must be incremented for each point plotted, the     */
/*   first point must be placed at offset *sz in the <pnts> array.    */
/* ra is posotive and the arc is drawn anti-clockwise from the start  */
/*   position                                                         */
{  int i;

   i = *sz;
   if(ra>360*Angles) ra=360*Angles;
   
   while(1)
   {  while(sa<90*Angles)
      {  pnts[i].x = cx + mulBySine(xs,90*Angles-sa);
         pnts[i].y = cy + mulBySine(ys,sa);
         i++; if(ra==0) break;
         if((sa+=stp,ra-=stp)<0) sa+=ra,ra=0;
      }
      while(sa<180*Angles)
      {  pnts[i].x = cx + mulBySine(-xs,sa-90*Angles);
         pnts[i].y = cy + mulBySine(ys,180*Angles-sa);
         i++; if(ra==0) break;
         if((sa+=stp,ra-=stp)<0) sa+=ra,ra=0;
      }
      while(sa<270*Angles)
      {  pnts[i].x = cx + mulBySine(-xs,270*Angles-sa);
         pnts[i].y = cy + mulBySine(-ys,sa-180*Angles);
         i++; if(ra==0) break;
         if((sa+=stp,ra-=stp)<0) sa+=ra,ra=0;
      }
      while(sa<360*Angles)
      {  pnts[i].x = cx + mulBySine(xs,sa-270*Angles);
         pnts[i].y = cy + mulBySine(-ys,360*Angles-sa);
         i++; if(ra==0) break;
         if((sa+=stp,ra-=stp)<0) sa+=ra,ra=0;
      }
      sa -= 360*Angles;
   }
   *sz = i;
}

/*--------------------------------------------------------------------*/
/*                                                flattenArcNeg(...)  */
/*--------------------------------------------------------------------*/

DpSubPixel_t *flattenArcNeg ( int cx, int cy,
                              int xs, int ys,
                              int sa, int ra,
                              int *sz,
                              DpSubPixel_t *pnts,
                              int stp
                             )
/* This function deals with the case for dpFlattenArc where the       */
/*    subtended angle is negative.                                    */
/* <stp> is the step angle to use in terms of the internal sine table */
/*   angle representation, and sa and ra are also in those angle      */
/*   units, (*sz) must be incremented for each point plotted, the     */
/*   first point must be placed at offset *sz in the <pnts> array.    */
/* ra is posotive and the arc is drawn clockwise from the start       */
/*   position                                                         */
{  int i;

   i = *sz;
   if(ra>360*Angles) ra=360*Angles;
   
   while(1)
   {  while(sa>=270*Angles)
      {  pnts[i].x = cx + mulBySine(xs,sa-270*Angles);
         pnts[i].y = cy + mulBySine(-ys,360*Angles-sa);
         i++; if(ra==0) break;
         if((sa-=stp,ra-=stp)<0) sa-=ra,ra=0;
      }
      while(sa>=180*Angles)
      {  pnts[i].x = cx + mulBySine(-xs,270*Angles-sa);
         pnts[i].y = cy + mulBySine(-ys,sa-180*Angles);
         i++; if(ra==0) break;
         if((sa-=stp,ra-=stp)<0) sa-=ra,ra=0;
      }
      while(sa>=90*Angles)
      {  pnts[i].x = cx + mulBySine(-xs,sa-90*Angles);
         pnts[i].y = cy + mulBySine(ys,180*Angles-sa);
         i++; if(ra==0) break;
         if((sa-=stp,ra-=stp)<0) sa-=ra,ra=0;
      }
      while(sa>=0*Angles)
      {  pnts[i].x = cx + mulBySine(xs,90*Angles-sa);
         pnts[i].y = cy + mulBySine(ys,sa);
         i++; if(ra==0) break;
         if((sa-=stp,ra-=stp)<0) sa-=ra,ra=0;
      }
      sa += 360*Angles;
   }
   *sz = i;
}

