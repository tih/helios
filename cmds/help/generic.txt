#000001
*p Welcome to Helios Help Version 2
*p Use the arrow keys to select one of the options below and then press RETURN to complete your selection.  To exit Help, type Q or select "Quit".
*p
*L General enquiry
*p
*L Table of contents
*p
*L Helios Help tutorial
#000002
*p
Welcome to Helios Help Version 2.
By using Helios Help, you can find and display
reference information on
most aspects of the Helios parallel operating system.
*p
Help is interactive; it always
provides you with
an opportunity to request further actions by presenting
you with a number of highlighted boxes for you to select.
The ones on this page are Forward, Go back, and Quit. Type G,
or select Go back, to see what happens. Re-select the tutorial and
press SPACEBAR for more information.
*N
Notice that you could have achieved the same effect by selecting Forward
or by pressing the F key.
*p
Although Help always gives you an opportunity to select
Quit to get out, the other actions you can select will depend on
the reference information being displayed. You
will now notice that you have Back as well as Forward; this is because you
are on the second screen and can review the first screen if you wish.
Select Back to review and then select Forward twice to continue this tutorial.
*N
Information can be displayed in two ways, one of these types of
display is known as
a %stitle list%s. A title list contains all the titles associated with the
topic you have requested. Each title will have a highlighted
box that you can select for further information.
By presenting you with a title list, Help can give you a
quick overview of a large number of possible choices for you to review and
choose between.
The second of the two types of display is %sreference entry text%s.
*p
If you wish to try out both types of display, Go Back to the beginning and
select "Table of contents". Help will then list all the topics
it currently holds information on. Move the cursor until it points at
"Helios command" and then press RETURN. The title list that Help will then
display in response to this selection will show
all the commands in the current version of Helios. To display the reference
entry text for a particular command,
move the cursor until it is pointing at the command you are interested
in and then press RETURN.
*N
In the "Table of Contents", one more search option is available. If you wish to look for a particular function or topic within one of the title groups in the table of contents list, move the cursor to the title group of interest and press 's'. You will be prompted for a search term to be used within the selected group - any matching items in other groups will be excluded from the search.
*p
Other keys worth remembering are :
*l ^L (CTRL-L)
*t Resize and refresh screen
*l ESC (Escape)
*t Same as Go back, but can be used to cancel search term entry
*p
For more information on the help system, search for %shelp%s.
#
*n @\Helios command
*P Assigns values to shell variables
*F @ <name>=<expression> ; @ <name>[<index>]=<expression>
*D The %b@%b command comes in two variations. The first is
used to set the entire value of a shell variable, the second just to set a
particular word of a variable. In the first variation %b@%b evaluates
%sexpression%s and assigns the result to the shell variable %sname%s. If
%sname%s already exists, its value is replaced by the new value. If
%sname%s does not exist it will be created with the new value. The second
variation assigns the value of %sexpression%s to the %sindex%sth word of
%sname%s, leaving all other words of the variable unchanged. This second
variation requires the shell variable %sname%s to exist and to contain at
least %sindex%s words; otherwise an error will occur. Here are two
examples, one for each variation:
*c=@ i=$i + 2
*p increments the shell variable `i' by 2. Because of the way the shell
breaks the command line into words, it is always advisable to surround
each element of the expression by spaces, though it is not essential for
elements which are metacharacters. The second example:
*c=@ path[2]=/helios/bin
*p sets the second word of the shell variable `path' to be `/helios/bin'.
*p Finally, %b@%b with no argument displays all the currently set shell
variables, though most people use %bset%b to do this.
*p If %sexpression%s contains any metacharacters then it must be enclosed
in parentheses.
*q Shell commands
*q @
*q Shell variables, assigning
*x printenv
*x set
*x setenv
#
*n Abort\System library
*P Aborts operations on the given object or stream
*I <syslib.h>
*F WORD Abort ( Object *object ) ; WORD Abort ( Stream *stream );
*A object - Pointer to Object structure
*A stream - Pointer to Stream structure
*R Error code.
*D This function aborts all operations on %sobject%s or
%sstream%s. See %bLocate()%b for a full listing of the structures referred
to here.
*x abort\000006
*x Locate
*q Abort operations on object
*q Object structure
*q Stream structure
*q Data structures
*p CAUTION: the action of %bAbort()%b is drastic and should only be used in
exceptional circumstances
#
*n abort\C library function
*q abort
*P Causes a program to terminate
*q Causing a program to terminate
*q Forcing a program to terminate
*q Terminating a program
*I <stdlib.h>
*F void abort(void);
*D %babort()%b causes a program to abort execution. It calls
the %bexit()%b function to flush output streams, close open streams, and
so forth, and gives the value SIGABRT to the signal handler, to show that
the program signal handler has terminated abnormally.
*p For example, suppose you have a program called check:
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=int main(argc, argv)
*c=int argc;
*c=char *argv[ ];
*c={
*c=FILE *stream;
*c=if ((stream = fopen(argv[argc-1],"r")) == NULL)
*c=    {
*c=     fprintf(stderr, "Cannot open file %s\n", argv[argc-1]);
*c=     abort( );
*c=    }
*c=}
*p The command line:
*c=check non_existent_file
*p has the output
*c=Cannot open file non_existent_file
*c=Abort( abnormal termination )
*p the second line of output being provided by the signal handler.
*q signal handler
*q abort
*x Abort
*x exit\000189
*x signal\000563
#
*n abort\Posix library function
*P Causes an abnormal termination of a program
*I <stdlib.h>
*F void abort( void );
*D %babort()%b causes a program to abort execution. It calls
the %bexit()%b function to flush output streams, close open streams, and
so forth, and gives the value SIGABRT to the signal handler, to show that
the program signal handler has terminated abnormally.
*p For example, suppose you have a program called check:
*c=int main(argc, argv)
*c=int argc;
*c=char *argv[ ];
*c={
*c=FILE *stream;
*c=if ((stream = fopen(argv[argc-1],"r")) == NULL)
*c=    {
*c=     fprintf(stderr, "Cannot open file %s\n", argv[0],argv[argc-1]);
*c=     abort( );
*c=    }
*c=}
*p The command line:
*c=check non_existent_file
*p has the output
*c=Cannot open file non_existent_file
*c=Abnormal termination (for example, abort() function)
*p The second line of output being provided by the signal handler.
*q signal handler
*q Causing a program to terminate
*q Forcing a program to terminate
*q Terminating a program
*q Abnormal termination - see abort
*q Aborting a program - see abort
*q exit
*x Abort
*x abort\000005
*x exit\000191
*x _exit
*x wait
#
*n AbortPort\System library
*P Aborts any exchanges on the given port
*I <message.h>
*F WORD AbortPort ( Port port, Word code );
*A port - Descriptor for the port
*A code - Return code
*R Error code.
*D This function aborts any exchanges on the specified port.
Any process waiting on the port will continue and the given code will be
returned from %bGetMsg()%b or %bPutMsg()%b.
*x PutMsg
*x GetMsg
*q Abort exchanges on port
#
*n abs\C library function
*P Calculates the absolute value of an integer
*I <stdlib.h>
*F int abs(int j);
*A j - An integer.
*R the absolute value of its argument
*E If the result cannot be represented the behaviour of %babs()%b is
undefined.
*D %babs()%b calculates the absolute value of a given integer.
abs(j), therefore, calculates the absolute value of integer %sj%s.
*x fabs
*x labs
*q abs
*q Calculating the absolute value of an integer
*q Absolute value of an integer, calculate the
*q Integer's absolute value, calculate
#
*n Accelerate\System library
*P Speeds up execution by using fast internal memory
*I <nonansi.h> ; <memory.h>;
*F word Accelerate(Carrier *mem, VoidFnPtr fn, WORD args_size,
...);
*A mem - Pointer to on-chip memory
*A fn - Function to be accelerated
*A args_size - Size of argument vector in bytes
*A ... - Argument vector
*R Error code.
*D You may use the %bAccelerate()%b routine to run a
computationally-intensive function, with its stack in the fast on-chip
memory, to obtain some improvement in execution speed. The on-chip memory
is a resource managed by the system, and you can only access it by way of
the system routine %bAllocFast()%b.
*c=#include <nonansi.h>
*c=#include <task.h>
*c=#include <memory.h>
*c=
*c=extern void function(WORD);
*c=
*c=int main(void)
*c={ Carrier *mem;
*c=
*c=if ((mem = AllocFast(1500, &MyTask->MemPool)) == (Carrier *) NULL)
*c=     function(100);/* no fast memory available */
*c=else
*c=     Accelerate(mem, function, sizeof(WORD), 100);
*c=}
*p Note that for the C40 if the AccelerateCode() and Accelerate()
functions are both used inside of the same function, then the
AccelerateCode() function may not appear to work.  What happens is that
the C compiler caches the function pointer passed as an argument to
AccelerateCode() so that when the same pointer is used in the call to
Accelerate() it is the cached value (pointing into slow RAM) which is
used rather than the new value for the pointer (pointing into fast RAM).
In order to avoid this effect the Accelerate() function should be called
from a separate function from AccelerateCode().
*x AllocFast
*x AccelerateCode
*q Speeding up execution
*q Fast RAM
*q Fast internal memory
*k C40
#
*n AccelerateCode\System library
*P Places code into the processor's fast RAM to improve execution speed
*I <nonansi.h>
*F word AccelerateCode(VoidFnPtr function);
*A function - code to be placed
*R Error code.
*D The entire module containing the referenced function is
copied into the processor's fast RAM. Following this call any call to the
given function will execute the fast RAM copy. Since the entire module is
copied, and there is only a very limited quantity of fast RAM available,
the required function should be kept a small as possible, and compiled on
its own. A further speedup may be obtained by using Accelerate to execute
the procedure on a fast RAM stack.
*p Obviously there is a certain cost associated with calling
AccelerateCode, and it is only worth doing for a procedure which will be
called frequently, and which is computationally intensive.
*p Note that for the C40 the module containing the call to
AccelerateCode() and the module containing the code to be accelerated
must have been compiled with the -Fd C compiler option.
*p Note that for the C40 if the AccelerateCode() and Accelerate()
functions are both used inside of the same function, then the
AccelerateCode() function may not appear to work.  What happens is that
the C compiler caches the function pointer passed as an argument to
AccelerateCode() so that when the same pointer is used in the call to
Accelerate() it is the cached value (pointing into slow RAM) which is
used rather than the new value for the pointer (pointing into fast RAM).
In order to avoid this effect the Accelerate() function should be called
from a separate function from AccelerateCode().
*x Accelerate
*q Fast RAM
*q AccelerateCode
*k C40
#
*n accept\Posix library function
*P accepts a socket connection
*I <sys/socket.h>;<sys/types.h>
*F int accept( int fd, struct sockaddr *addr, int *len);
*A fd - file descriptor
*A addr - pointer to address of connecting socket
*A len - address length
*R -1 on error; on success, returns a non-negative integer, the
descriptor for the accepted socket.
*E
*l [EBADF]
*t The descriptor is invalid
*l [ENOTSOCK]
*t The descriptor references a file, not a socket
*l [EOPNOTSUPP]
*t The referenced socket is not of type SOCK_STREAM
*l [EFAULT]
*t %saddr%s is not a writable part of the user address space
*l [EWOULDBLOCK]
*t The socket is marked non-blocking and no connections are present to be
accepted.
*D This function is basically identically to the BSD Unix
version of %baccept%b: it extracts the first connection on a list of
pending connections; if none pending, it blocks until one is present.
*p The structure %ssockaddr%s is used by the kernel to store addresses:
*c=struct sockaddr{
*c=       u_short sa_family  /* address family */
*c=       char sa_data[14]   /* up to 14 bytes of direct address */
*c=};
*p Valid address families are as follows:
*f AF_UNSPEC\0\unspecified
*f AF_UNIX \1\local to host (pipes, portals)
*f AF_HELIOS\1\local to host (pipes, ports)
*f AF_INET \2\internetwork: UDP, TCP, etc.
*q accept
*x bind
*x connect
*q BSD compatibility, Berkeley
#
*n access\Posix library function
*P Checks file accessibility
*I <posix.h> ; <unistd.h>
*F int access( char *path, int amode );
*A path - Pointer to file's pathname
*A amode - File access mode
*R If access is permitted, %baccess()%b returns zero; otherwise,
it returns a value of -1 and sets errno to one of the following codes to
indicate the error that occurred.
*E
*l [EACCES]
*t Permission bits of the file mode deny access or deny search permission
on a component of the pathname prefix.
*l [EINVAL]
*t The value of %samode%s is not a valid value.
*l [ENOENT]
*t %spath%s either points at a file that does not exist or it points at an
empty string.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [EROFS]
*t Write access requested for a file in read-only file system.
*l [ENAMETOOLONG]
*t The %spath%s argument exceeds the maximum path length in PATH_MAX.
*D This function tests the access mode of a given file. The
argument %spath%s indicates the file whose mode is to be checked.
%samode%s contains a bit pattern that is used to check the accessibility
of the file.
*p The value of %samode%s is the bitwise inclusive OR of the access modes
to be checked.
*l Constant
*t Action
*l R_OK
*t Tests for read permission
*l W_OK
*t Tests for write permission
*l X_OK
*t Tests for execute permission
*l F_OK
*t Tests for file existence
*x chmod\000075
*x stat
*q Access modes
*q File accessibility, check for
#
*n Access-matrix\General interest
*P Holds access categories
*D Stored with each object is an access matrix. It is a
four-by-eight-bit matrix in which the rows correspond to the four
categories v, x, y and z. These categories are a generalisation of the
owner/group/everyone mechanism where v corresponds to the owner and z to
everyone. These interpretations are merely a convention, the categories
may be assigned by an object's creator in whatever way he sees fit. The
columns of the matrix correspond to the access mask rights, so setting a
bit at the intersection of a row and column confers that right upon that
category of client. When a path is being followed through the naming
network a current mask is maintained, which is derived initially from a
capability. Whenever a directory is encountered, the current mask is
replaced by one that consists of the bitwise OR of the rows of the
directory's matrix for which the old mask had bits set.
*p The interpretation of the bits in the access mask is up to the server,
but the following conventions should be applied. Usually, all objects have
Delete and Alter bits which, if set, allow the object to be deleted and
its access matrix to be altered. Files have Read, Write and Execute bits.
In addition to Read and Write bits, directories have bits corresponding to
the four access categories (v, x, y and z). Processors are also protected
by this mechanism: when a user is allocated a processor, he is passed a
capability containing the right to execute programs in that processor.
Other users will have their access mask restricted by the naming system to
exclude that right. Similarly, when a task is created, the creator
receives a capability that allows him to destroy, debug or interrupt that
task.
*q Access matrices
*q Protection mechanism
*x Capability
*x Protection
#
*n Acknowledge\System library
*P Acknowledges receipt of an event
*I <syslib.h> ; <ioevent.h>;
*F void Acknowledge(Stream *stream, WORD counter);
*A stream - Stream to the device
*A counter - Word indicating which event is to be acknowledged
*D %bAcknowledge()%b should be used by an event handler
whenever the device sending the events indicates that an acknowledgement
is desired, by sending a message with function code EventRc_Acknowledge.
The counter argument should be extracted from one of the events that came
with the message. There is no way of detecting whether or not an
acknowledgement succeeded. The assumption is that if the acknowledgement
failed for one reason or another then the device will simply request
another acknowledgement with its next message.
*x EnableEvents
*x NegAcknowledge
*q Event handling
#
*n acos\C library function
*P Calculates the arc cosine of the argument
*I <math.h>
*F double acos(double x);
*A x - A number in the range [-1..+1]
*R the arc cosine of %sx%s in the range [0..pi] radians
*E A domain error occurs if %sx%s is not in the range [-1..+1]. In
this case errno is set to EDOM.
*D %bacos()%b calculates the arc cosine of an argument whose
value is a number in the range -1 to +1. It returns the result of this
calculation as an angle with a value in the range 0 to pi.
*q acos
*q Calculate arc cosine of argument
*q Arc cosine - see acos
*x cos
#
*n AddAttribute\System library
*P Modifies a set of device attributes
*I <attrib.h>
*F void AddAttribute( Attributes attr, Attribute item);
*A attr - Pointer to an Attributes structure
*A item - Attribute to be added to the set
*D This function adds an attribute to a set of Attributes
obtained by a call to %bGetAttributes()%b. Note that the change does not
affect the behaviour of the device or Stream until a call to
%bSetAttributes()%b has been made.
*p You cannot add two or more attributes at one time. Each attribute must
be added with a separate call to %bAddAttribute()%b.
*x SetAttributes
*x SetAttributes
*x GetAttributes
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Attribute handling
*q Device attribute handling
#
*n AddHead\System library
*P Adds the given node to the head of the given list
*I <queue.h>
*F void AddHead ( List *list, Node *node );
*A list - Pointer to List structure
*A node - Pointer to Node structure
*R Nothing
*D This function adds the %snode%s to the head of %slist%s.
%slist%s points to the List structure:
*c=typedef struct {
*c=        struct Node     *Head;   /* list head pointer      */
*c=        struct Node     *Earth;  /* NULL pointer           */
*c=        struct Node     *Tail;   /* list tail pointer      */
*c=} List;
*p and %snode%s points to the Node structure:
*c=typedef struct {
*c=        struct Node     *Next;   /* next item in list      */
*c=        struct Node     *Prev;   /* previous item in list  */
*c=} Node;
*x AddTail
*q Add node to head of list - see AddHead
*q Node, add to head of list - see AddHead
*q Head of list, add node to - see AddHead
*q List structure
*q Node structure
#
*n addint\System library
*P Generates unique names in servers
*I <servlib.h>
*F word addint(char *s, int word);
*A s - pointer to character string
*A word - positive integer value
*D %baddint()%b adds the string corresponding to the decimal
value of %sword%s to the string indicated by %s*s%s. This function is used
by some servers to generate unique names. Note that it is not possible to
add a value of zero with this routine.
*q addint
*q Unique name, generate
*q Names, generate
*q Generating unique names
#
*n AddTail\System library
*P Adds the given node to the tail of the given list
*I <queue.h>
*F void AddTail ( List *list, Node *node );
*A list - Pointer to List structure
*A node - Pointer to Node structure
*R Nothing
*D %bAddTail()%b adds the %snode%s to the tail of %slist%s.
*x AddHead
*q Add node to tail of list - see AddTail
*q Node, add to tail of list - see AddTail
*q Tail of list, add node to - see AddTail
#
*n AdjustBuffers\System library
*P Manages a list of data buffers
*I <servlib.h>
*F bool AdjustBuffers(List *list, word start, word end, word
bufsize);
*A list - pointer to list of data buffers
*A start - start of buffer
*A end - end of buffer
*A bufsize - size of buffer
*D %bAdjustBuffers%b works in conjunction with
%bGetReadBuffer%b and %bGetWriteBuffer%b to manage a list of %bBuffer%b
structures. %bAdjustBuffers%b is used to manage the allocation and
deletion of %bBuffer%b structures to the list. The first argument to
%bAdjustBuffers%b is the address of a list of %bBuffer%b structures; the
last argument is the size of the buffers. The remaining two arguments are
the position of the first byte in the buffer list and the position of the
last+1 byte. %bAdjustBuffers%b will add and/or remove buffers on the list
to provide buffering for all the bytes between these two values. The value
of %sstart%s is commonly zero, but any value less than or equal to %send%s
is permitted, allowing servers to maintain a moving buffer window.
*q AdjustBuffers
*q GetWriteBuffer
*q GetReadBuffer
*x GetWriteBuffer
*x GetReadBuffer
#
*n Alarm\System library
*P Sets an alarm timer
*I <syslib.h>
*F WORD Alarm ( Word seconds );
*A seconds - Seconds until alarm
*R Time left of previous alarm
*D %bAlarm()%b sets an alarm which will go off after the given
number of seconds. If there is a previous alarm pending at the time this
function is called, the time until that alarm is due to go off is
returned; otherwise zero is returned. Only one alarm is allowed per Task.
When the alarm expires, a SIGALARM signal is delivered to the Task.
*q Set alarm timer
*q Timer for alarm, set - see Alarm
#
*n alarm\Posix library function
*P Signals the calling task after a specified number of seconds
*I <signal.h>
*F unsigned int alarm (unsigned int sec);
*A sec - Number of real time seconds. If 0, previous %balarm()%b
calls will be cancelled
*R Zero, if no previous %balarm()%b request is in existence;
otherwise it returns the amount of time remaining in the calling task's
alarm clock from the previous %balarm()%b request
*D %balarm()%b tells the alarm clock of the calling task to
send the signal SIGALARM to the calling task after the number of real time
seconds specified by %ssec%s have elapsed.
*p Processor scheduling delays may result in the task failing to handle the
signal until after the specified time period.
*p You cannot stack alarm requests; successive calls of %balarm()%b reset
the calling task's alarm clock.
*x exec
*x pause
*x signal\000564
*q Alarm call
*q Clock
*q Signalling calling task after a specified number of seconds
*q Calling task - signalling after a specified number of seconds
*q Processor scheduling delays
*q Scheduling delays
#
*n alias\Helios command
*P Creates or display aliases
*F alias [<name> [<wordlist>]]
*D The %balias%b shell command with no arguments displays all
the currently set-up aliases. If you specify the single argument %sname%s,
%balias%b displays whatever alias exists for that name, if any. When you
specify a %swordlist%s of one or more words after %sname%s, %balias%b sets
%sname%s to be the alias for %swordlist%s. If an alias already exists for
%sname%s then that alias is replaced with the new alias. For example,
*c=alias fred 'ls -l'
*p makes `fred' an alias for `ls -l', which means that from now on whenever
you use `fred' as a command, `ls -l' will be substituted in its place.
*p %sname%s may be any word at all, including any already existing command
name. Thus, for example, the following command:
*c=alias glob echo
*p redefines the built-in command %bglob%b to do exactly the same as
%becho%b. (The shell does not allow %balias%b or %bunalias%b to be
aliased, however.) It is even possible to redefine commands in terms of
themselves. For example,
*c=alias ls 'ls -l'
*p redefines the command %bls%b so as to always use the `-l' option. You
may therefore customise the shell to suit your particular requirements.
*p If you dislike a Helios command name and wish to use a more familiar
equivalent, you can use %balias%b to enable you to do so. For example,
*c=alias DIR ls
*p enables you to use DIR to list your directories.
*q Shell commands
*q alias, create or display
*q Creating aliases
*q Displaying aliases
*x unalias
#
*n Alias-server\General interest
*P Allows the user to assign alternative names to directories
*F /helios/lib/alias <newname> <dir>
*D If you wish to refer to a directory by another name, you
can: the alias server allows you to give a directory whatever alternative
name you like. This feature is useful if you wish to map the Helios
directory structure onto that of another operating system with which you
are more familiar. Superficially, its effect is similar to a symbolic
link. However, symbolic links only work on filing systems that support
them, such as the Helios filing system or the RAM disc.
*p New names should be assigned as a background task. You can do this from
the shell by appending the metacharacter & after the command syntax given
above. Alternatively, you can execute it by using the %brun%b command in
the startup file, %sinitrc%s.
*p For example, if you are used to /etc being at the top level of your
filing system, you could use
*c=/helios/lib/alias etc /helios/etc &
*p to produce the same effect. In other words, if you then typed
*c=ls /etc
*p the contents of /helios/etc would be listed.
*x Server
*x Background-tasks
#
*n AllocFast\System library
*P Allocates memory from the processor's on-chip RAM
*I <memory.h>
*F Carrier *AllocFast( word size, Pool *pool );
*A size - Size of memory to allocate
*A pool - Pointer to pool that is to receive the allocated block
*R Pointer to a fast-RAM carrier structure, or NULL
*D This function allocates memory from the processor's
on-chip fast RAM. The result of a successful allocation is a pointer to a
fast RAM carrier structure:
*c=struct Carrier {
*c=      mptr      *Addr;   /* base address of on-chip ram */
*c=      word       Size;   /* size of on-chip ram         */
*c=};
*p Since on-chip RAM is a scarce resource, programs should only allocate as
much as they need, and free it as soon as possible.
*p Memory allocated by %bAllocFast()%b can be freed with %bFreeMem()%b, using the returned fast-RAM Carrier pointer.
*q Allocate memory from on-chip RAM
*q Memory allocation - see also AllocFast, C40CAddress
#
*n AllocLink\System library
*P Reserves a link for direct use
*I <link.h>
*F word AllocLink( word linkno );
*A linkno - Number of the link that is to be allocated
*R Zero if link was allocated
*D This function reserves the link for direct access. Direct
access to a link is not possible unless this function is executed
successfully first. Only links which are in DUMB mode may be reserved, the
mode of a link may be changed with the %bConfigure()%b function. While it
is possible to use the link channels directly after this call, it is
recommended that the kernel routines %bLinkIn()%b and %bLinkOut()%b be
used.
*p Note: in the C40 implementation of Helios, %bAllocLink()%b allocates the
DMA Engine corresponding to the link number for personal use.
*x Configure
*x LinkIn
*x LinkOut
*x Reconfigure
*x FreeLink
*q Reserve link for direct use
*q Link, reserve for direct use
*q Dumb link mode
*q Link mode, dumb - see Dumb link mode
#
*n AllocMem\System library
*P Allocates a block of memory from the system pool
*I <memory.h>
*F byte *AllocMem ( int size, Pool *pool );
*A size - Size of memory block in bytes
*A pool - Pointer to the destination memory pool
*R Pointer to allocated memory or NULL if memory full
*D This function allocates memory from the system pool.
Programs should normally use the system library routines %bMalloc()%b and
%bFree()%b.
*x Free
*x Malloc
*x FreePool
*x InitPool
*x AllocFast
*q Allocating a block of memory
*q Memory allocation - see also AllocMem
#
*n ASCII\General interest
*P American Standard Code for Information Interchange
*D ASCII coded character set defines 128 characters, including
graphic characters and control characters, represented by 7-bit binary
values (0-127 decimal).
*p Here is a summary of the ASCII control characters, giving their decimal
value, hexadecimal value, definition and representation (using ^ for
CTRL):
*c= 00 $00 nul ^@   01 $01 soh ^A   02 $02 stx ^B
*c= 03 $03 etx ^C   04 $04 eot ^D   05 $05 enq ^E
*c= 06 $06 ack ^F   07 $07 bel ^G   08 $08 bs  ^H
*c= 09 $09 tab ^I   10 $0a nl  ^J   11 $0b vt  ^K
*c= 12 $0c np  ^L   13 $0d cr  ^M   14 $0e so  ^N
*c= 15 $0f si  ^O   16 $10 dle ^P   17 $11 dc1 ^Q
*c= 18 $12 dc2 ^R   19 $13 dc3 ^S   20 $14 dc4 ^T
*c= 21 $15 nak ^U   22 $16 syn ^V   23 $17 etb ^W
*c= 24 $18 can ^X   25 $19 em  ^Y   26 $1a sub ^Z
*c= 27 $1b esc ^[   28 $1c fs  ^\   29 $1d gs  ^]
*c= 30 $1e rs  ^^   31 $1f us  ^_   32 $20 sp
*c=127 $7f del
*p This is a list of the printable ASCII characters, including each
character's decimal and hexadecimal values:
*c= 32 $20          33 $21  !       34 $22  "
*c= 35 $23  #       36 $24  $       37 $25  %
*c= 38 $26  &       39 $27  '       40 $28  (
*c= 41 $29  )       42 $2a  *       43 $2b  +
*c= 44 $2c  ,       45 $2d  -       46 $2e  .
*c= 47 $2f  /       48 $30  0       49 $31  1
*c= 50 $32  2       51 $33  3       52 $34  4
*c= 53 $35  5       54 $36  6       55 $37  7
*c= 56 $38  8       57 $39  9       58 $3a  :
*c= 59 $3b  ;       60 $3c  <       61 $3d  =
*c= 62 $3e  >       63 $3f  ?       64 $40  @
*c= 65 $41  A       66 $42  B       67 $43  C
*c= 68 $44  D       69 $45  E       70 $46  F
*c= 71 $47  G       72 $48  H       73 $49  I
*c= 74 $4a  J       75 $4b  K       76 $4c  L
*c= 77 $4d  M       78 $4e  N       79 $4f  O
*c= 80 $50  P       81 $51  Q       82 $52  R
*c= 83 $53  S       84 $54  T       85 $55  U
*c= 86 $56  V       87 $57  W       88 $58  X
*c= 89 $59  Y       90 $5a  Z       91 $5b  [
*c= 92 $5c  \       93 $5d  ]       94 $5e  ^
*c= 95 $5f  _       96 $60  `       97 $61  a
*c= 98 $62  b       99 $63  c      100 $64  d
*c=101 $65  e      102 $66  f      103 $67  g
*c=104 $68  h      105 $69  i      106 $6a  j
*c=107 $6b  k      108 $6c  l      109 $6d  m
*c=110 $6e  n      111 $6f  o      112 $70  p
*c=113 $71  q      114 $72  r      115 $73  s
*c=116 $74  t      117 $75  u      118 $76  v
*c=119 $77  w      120 $78  x      121 $79  y
*c=122 $7a  z      123 $7b  {      124 $7c  |
*c=125 $7d  }      126 $7e  ~      127 $7f  del
*p A listing of the ASCII set can be obtained with the %bascii%b command.
*x ascii
#
*n ascii\Helios command
*P Displays the ASCII table
*F ascii
*D The %bascii%b command displays the ascii table in two
parts: the first part comprising the ASCII control characters, the second
part comprising the printable ASCII characters.
*p A listing of the information returned by %bascii%b can be found under
ASCII.
*q ascii (command)
*q ASCII table, display
*x ASCII
#
*n asctime\C library function
*P Converts the values in a tm structure to an ASCII string
*I <time.h>
*F char *asctime(const struct tm *timeptr);
*A %stimeptr%s - A pointer to the time structure to be converted
*R a pointer to the ASCII string.
*D %basctime()%b converts the values in the %stimeptr%s
structure to a string in the form:
*p Thu Nov 05 18:19:01 1987
*c=*/ Displays the current time */
*c=#include <time.h>
*c=#include <stdio.h>
*c=
*c=struct tm *now;
*c=time_t clck;
*c=
*c=int main(void)
*c={
*c=  time(&clck);            /* Get the current time in seconds  */
*c=  now = localtime(&clck); /* Convert time to a structure (tm) */
*c=  printf("The time is: %s\n", asctime(now));
*c=}
*x ASCII
*x ascii
*x mktime
*x ctime
*q asctime
*q Convert values in tm structure to ascii string
*q Values in tm structure, convert to ascii string
*q tm structure values, convert to ascii string
*q Ascii string - from tm structure values
#
*n asin\C library function
*P Calculates the arc sine of the argument
*I <math.h>
*F double asin(double x);
*A x - A number in the range [-1..+1]
*R the arc sine of %sx%s in the range [-pi/2..+pi/2] radians.
*E A domain error occurs if %sx%s is not in the range [-1..+1]. In
this case errno is set to EDOM.
*D %basin()%b calculates the arc sine of its argument, whose
value is a number in the range -1 to +1. It then returns the result of
this calculation as an angle with a value in the range -pi/2 to +pi/2.
*q asin
*q Calculate arc sine of argument
*q Arc sine - see asin
*x sin
#
*n Assembling\General interest
*P Assembling and linking programs
*D Under Helios on Transputers, the assembling and linking of programs is
done with the %basm%b command.  Under Helios on the C40, the assembling
of programs is done with the %bas%b command.
*p Assembler format consists of a sequence of processor-type specific
instructions and assembler directives and can be summarized as follows:
*l Comments:
*t -- <comment to end of line>
*l Instructions:
*t <name> <operand expression> | <instruction>
*l Directives:
*t <name> <arguments>
*p Assembler input may be in free format, with instructions and directives
separated by spaces, newlines, semicolons or commas. The range of possible
separators is provided for compatibility with other assemblers.
*p Labels may be of any length. A code label may be defined in the usual
way by following it with a colon. Any label that begins with .. is
considered a temporary label and is suffixed with an identifier that is
unique to the current input file.
*p There are two label spaces: code and data. Code labels are defined as
described above, data labels are defined by the DATA directive. Code and
data labels may not be mixed in the same expression. Labels may be local
to a module or globally available to all modules. By default, all labels
are local, but can be converted to global availability with the GLOBAL
directive.
*p Operand expressions may consist of either labels or numbers, combined
with the binary operators (*, /, +, -, &, |) the shift operators (< and
>), and the unary operators (- and ~). The usual operator precedence rules
apply; precedence can be overruled by the use of parentheses. The special
label %smodnum%s corresponds to the current module number, and the unary
operator @, when applied to a label, yields its defining module. The
appearance of a label as an operand of the @ operator implies that it is
defined as GLOBAL in this or some other module.
*p The directives are as follows:
*l %sALIGN%s
*t Causes the location of the next byte generated to be aligned on the next
word boundary.
*l %sBLKB%s %s<size> [,<expr>...]%s
*t Generates a block of %ssize%s bytes. If the expression list is given,
the bytes are initialised with the given values; otherwise they are
initialised to zero. If too few expressions are given the remainder of the
block is initialised to zero, and if too many are given the remainder are
ignored.
*l %sBLKW%s %s<size> [,<expr>...]%s
*t Generates a block of %ssize%s words. (Otherwise, it is like BLKB.)
*l %sBYTE%s %s<expr> [,<expr>...]%s
*t Generates a sequence of bytes that takes on the values of succeeding
expressions. In addition, an expression may be a string enclosed in quotes
and containing the usual C escapes, in which case the characters of the
string are assigned to consecutive bytes of memory.
*l %sCOMMON%s %s<symbol> <n>%s
*t Declares a common data area with the given name and given size. The
assembler allows you to have several common statements with the same name;
if the statements have different sizes, the assembler uses the largest
one.
*l %sDATA%s %s<symbol> <n>%s
*t Defines %ssymbol%s as a data symbol with size %sn%s in the current
module's data section.
*l %sGLOBAL%s %s<symbol>%s
*t Makes the symbols available outside the current module. This is achieved
by moving from a private module symbol table to a global one. It may be
applied to both code and data symbols.
*l %sINIT%s
*t Defines the word that is to be used to chain initialisation routines
together.
*l %sMODULE%s %s<n>%s
*t Defines the start of the new module. If %sn%s is positive, it is
allocated to that slot in the module. If %sn%s is -1, the assembler
allocates a free slot to the module.
*l %sSIZE%s %s<n>%s
*t Forces the next instruction to be %sn%s bytes long.
*l %sWORD%s %s<expr> [,<expr>...]%s
*t Generates a sequence of words containing the values of the given
expressions.
*p To save disc space, and to make the reading of input files faster, the
Helios assemblers have a tokenised assembler format. This format
is equivalent to a text assembler file with all white space removed,
directive and direct function names reduced to one byte tokens, and any
constant instruction and data reduced to sequences of bytes. It can be
either generated directly by a compiler, or through the %s-p%s option of
the assembler.
*p All tokens are bytes greater than 127, so tokenised and untokenised
assembler may be mixed, even in the same file. The tokens are as follows:
*l 0x80...0x8f
*t direct functions
*l 0xe1
*t blkb
*l 0xe2
*t blkw
*l 0xe3
*t init
*l 0xe4
*t align
*l 0xe5
*t word
*l 0xe6
*t byte
*l 0xe7
*t module
*l 0xe8
*t global
*l 0xe9
*t data
*l 0xea
*t common
*l 0xeb
*t size
*p In addition, the code 0xd5 is followed by a single byte count and that
number of bytes of data. The value 0xd8 is also followed by one byte count
and represents that number of bytes containing zero.
*p See also the AMPP manual.
*x asm
*q Assembling
*k Transputer
*k C40
#
*n assert\C library function
*P Identifies failed functions
*I <assert.h>
*F void assert(int expression);
*A expression - A number describing the action to be taken
*R no value
*D %bassert()%b is a debugging macro. If it is called with
%sexpression%s equal to zero, then it writes an error message to standard
error, describing the function, file and line where %bassert()%b was
called. %bassert()%b then calls the %babort()%b function.
*p If %sexpression%s is non-zero, no action is taken.
*c=#include <stdio.h>
*c=#include <assert.h>
*c=
*c=float divide (float a, float b)
*c={
*c=  assert(b != 0.0);
*c=  return a/b;
*c=}
*c=
*c=float res;
*c=
*c=int main(void)
*c={
*c=  res = divide(1.0,2.0);
*c=  printf("1.0 divided by 2.0 is: %f\n", res);
*c=  res = divide(1.0,0.0);
*c=  printf("1.0 divided by 0.0 is: %f\n", res);
*c=  return 0;
*c=}
*c=
*c=/*
*c=*  Output:
*c=*         1.0 divided by 2.0 is : 0.500000
*c=*         *** assertion failed: b = 0.0, file assert.c, line 6
*c=*         Abort( abnormal termination)
*c=*
*c=*/
*x abort\000005
*q assert
*q Identifying failed functions
#
*n atan\C library function
*P Calculates the arc tangent of the argument.
*I <math.h>
*F double atan(double x);
*A x - A number
*R the arc tan of %sx%s in the range [-pi/2..+pi/2] radians.
*D %batan()%b calculates the arc tangent of its argument. It
returns the result of this calculation as an angle with a value in the
range -pi/2 to +pi/2 radians.
*x atan2
*x tan
*q atan
*q Calculate arc tangent
*q Arc tangent - atan
#
*n atan2\C library function
*P Calculates the arc tangent of y/x
*I <math.h>
*F double atan2(double y, double x);
*A y - divisor value
*A x - dividend value
*R the arc tangent of %sy%s/%sx%s in the range [-pi..+pi] radians.
*E A domain error occurs if %sx%s and %sy%s are zero. In this case
errno is set to EDOM.
*D %batan2()%b calculates the arc tangent of the ratio of the
arguments %sy%s/%sx%s. It returns the result of this calculation as an
angle with a value in the range -pi to +pi radians.
*q atan2
*q Calculate arc tangent
*q Arc tangent - atan or atan2
#
*n atexit\C library function
*P Specifies a function to be called when the program ends
*I <stdlib.h>
*F int atexit(void (*func)(void));
*A func - A pointer to the function to be called.
*R zero if %batexit()%b is successful and non-zero if it is not
*D %batexit()%b records that the function pointed to by
%sfunc%s is to be called (without arguments) at normal termination of the
program.
*p At least 32 functions can be recorded for future execution. They will be
called in reverse order of their being recorded (that is, last in, first
out).
*c=#include <stdlib.h>
*c=#include <stdio.h>
*c=
*c=void first_exit(void)
*c={
*c=  printf("First_exit called on exit\n");
*c=}
*c=
*c=void second_exit( void )
*c={
*c=  printf("Second_exit called on exit\n");
*c=}
*c=
*c=int main( void )
*c={
*c=  atexit(second_exit);
*c=  atexit(first_exit);
*c=  printf(About to exit from program\n");
*c=  return 0;
*c=}
*c=/*
*c=*  Output:
*c=*
*c=*         About to exit program
*c=*         First_exit called on exit
*c=*         Second_exit called on exit
*c=*
*c=*/
*x exit\000189
*q atexit
*q Specifying function to be called when program ends
*q Function to be called when program ends, specify
*q Calling function when program ends
*q Program termination
*q Termination of program
#
*n atexit\Posix library function
*P Specifies the function to be called when the program ends
*I <stdlib.h>
*F int atexit(void (*func)(void));
*A func - Pointer to the function to be called
*R zero if %batexit()%b is successful and non-zero if it is not
*D %batexit()%b records that the function pointed to by
%sfunc%s is to be called (without arguments) at normal termination of the
program.
*p At least 32 functions can be recorded for future execution. They will be
called in reverse order of their being recorded (that is, last in, first
out).
*q Specifying function to be called when program ends
*q Function to be called when program ends, specify
*q Calling function when program ends
*q Program termination
*q Termination of program
*x atexit\000036
#
*n atob\Helios command
*P Converts 7-bit ASCII files to binary
*F atob
*D The partner to this command, %bbtoa%b, converts its binary
input into standard seven-bit ASCII format, suitable for transferring
through mail systems and modems. %batob%b then converts these ASCII files
back into their original binary form. %batob%b uses three different
checksums to verify that the file has been correctly converted and has not
been corrupted.
*p %bbtoa%b and %batob%b are both filters, so you should pipe in their
input and redirect their output; for example,
*c=cat fred.txt | atob >fred.bin
*p converts the text file `fred.txt' back into its original binary form in
`fred.bin'.
*x btoa
*q atob
*q Converting 7-bit ASCII files to binary
*q ASCII to binary conversion
#
*n atof\C library function
*P Converts a string of characters to a double
*I <stdlib.h>
*F double atof(const char *nptr);
*A nptr - A pointer to the string to be converted
*R the converted value.
*E If the string cannot be converted, %batof()%b returns 0. If the
conversion would overflow or underflow, the behaviour is undefined.
*D %batof()%b converts the string pointed to by %snptr%s to a
double precision floating point number. %batof()%b expects the string to
consist of:
*p 1. Leading white space (optional).
*p 2. Plus or minus sign (optional).
*p 3. Sequence of decimal digits, which may contain a decimal point.
*p 4. An (optional) exponent consisting of an 'E' or 'e' followed by an
optional sign and a string of decimal digits.
*p 5. One or more unrecognised characters (including the null string
terminating character).
*p %batof()%b ignores the leading white space, and converts all the
recognised characters. If there is no decimal point or exponent part in
the string, a decimal point is assumed after the last digit in the string.
*p The string is invalid if the first non-space character in the string is
not one of the following characters: + - . 0 1 2 3 4 5 6 7 8 9
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=
*c=int main(void)
*c={
*c= char *array;
*c= double x;
*c=
*c= array = "  -4235.120E-3";
*c= x = atof(array);
*c= printf("Float = %f\n", x);
*c=
*c= array = "  -735492.45";
*c= x = atof(array);
*c= printf("Float = %e\n", x);
*c=
*c=}
*c=
*c=/*
*c=
*c= Output:
*c=        Float = -4.235120
*c=        Float = -7.354920e+005
*c=
*c=*/
*x atoi
*x atol
*x strtod
*q atof
*q Convert character string to double precision fp number
*q Character string to double precision fp number, convert
*q Double precision fp number - from character string
*q Floating point number (double) - convert from character string
#
*n atoi\C library function
*P Converts a string to an int
*I <stdlib.h>
*F int atoi(const char *nptr);
*A nptr - A pointer to the string to be converted
*R the converted value
*E If the string cannot be converted, %batoi()%b returns 0.
*p If the conversion would overflow or underflow, the behaviour is
undefined.
*D %batoi()%b converts the string pointed to by %snptr%s to an
integer. %batoi()%b expects the string to consist of:
*p 1. Leading white space (optional).
*p 2. A plus or minus sign (optional).
*p 3. A sequence of decimal digits.
*p 4. One or more unrecognised characters (including the null string
terminating character).
*p %batoi()%b ignores the leading white space, and converts all the
recognized characters.
*p The string is invalid if the first non-space character in the string is
not one of the following characters: + - 0 1 2 3 4 5 6 7 8 9
*c=#include <stdlib.h>
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c= char *array;
*c= int x;
*c=
*c= array = "  -4235";
*c= x = atoi(array);
*c= printf("Integer is: %d\n", x);
*c=
*c= array = "  -735492 and some rubbish text";
*c= x = atoi(array);
*c= printf("Integer is: %d\n", x);
*c=}
*c=
*c=/*
*c=*  Output:
*c=*         Integer is: = -4235"
*c=*         Integer is: = -735492"
*c=*
*c=*/
*x atof
*x atol
*x strtol
*q atoi
*q Convert string to int
*q String to int, convert
*q Int - convert from string
#
*n atol\C library function
*P Converts a string to a long int
*I <stdlib.h>
*F long int atol(const char *nptr);
*A nptr - A pointer to the string to be converted
*R the converted value
*E If the string cannot be converted, %batoi()%b returns 0. If the
conversion would overflow or underflow, the behaviour is undefined.
*D %batol()%b converts the string pointed to by %snptr%s to a
long integer. %batol()%b expects the string to consist of:
*p 1. Leading white space (optional).
*p 2. A plus or minus sign (optional).
*p 3. A sequence of decimal digits.
*p 4. One or more unrecognised characters (including the null string
terminating character).
*p %batol()%b ignores the leading white space, and converts all the
recognized characters.
*p The string is invalid if the first non-space character in the string is
not one of the following characters: + - 0 1 2 3 4 5 6 7 8 9
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=
*c=int main()
*c={
*c= char *array;
*c= long l;
*c=
*c= array = "  -735492.45";
*c= l = atol(array);
*c= printf("Long = %ld\n", l);
*c=}
*c=
*c=/*
*c=    Output:
*c=           "Long = -735492"
*c=*/
*x atof
*x atoi
*x strtod
*x strtol
*q atol
*q Convert string to long int
*q String to long int, convert
*q Long int - convert from string
#
*n Automatic-server\General interest
*P Loads automatically from disc when first accessed
*D An automatic server is one which is loaded automatically
from disc when it is first accessed. Such servers include the fifo server,
the pipe server, the RAM disc server and the Null device.
#
*n Background-tasks\General interest
*P Task that runs in the background, freeing the shell for the
user to issue more commands
*F <command> &
*D A user can easily achieve multiprocessing by running a task
in the background while at the same time freeing the interactive shell for
the execution of further commands. Tasks are usually run in the foreground
unless specifically run as background tasks. Background tasks can be run
from the shell by appending the metacharacter & after the command; for
example,
*c=jobs &
*p runs the %bjobs%b command as a background task.
*p Some commands, such as %bremote%b, have options that enable them to be
run in the background.
*q Background-tasks
*x remote
*q remote
*q jobs
*q Tasks, background
#
*n Backup\General interest
*P Keeps a copy of essential information
*D The term %sbackup%s is used to refer to the physical medium
on which an essential item of information has been placed: removable disc,
cartridge tape, and so on. It is also used to refer to the action of
copying the information on to the physical storage medium (for example, to
%sbackup%s your data, or %sbacking up%s your data).
*q Data, keeping copies of
*q Backup
#
*n basename\Helios command
*P Removes any prefix or suffix from a given pathname string
*F basename <string> [<suffix>]
*D %bbasename%b strips a string down to a `basename'; that is,
if the string %sstring%s contains one or more forward slash characters
(/), %bbasename%b will delete all the characters up to and including the
last slash (equivalent to the characters making up the directory part of a
pathname) and then return the reduced string (equivalent to the filename
at the end of a pathname) to the standard output.
*p If you specify the optional %ssuffix%s string, and that suffix string
matches the characters at the end of %sstring%s, %bbasename%b will return
%sstring%s without those last few characters. For example,
*c=basename fred/bill.c
*p returns
*c=bill.c
*p whereas
*c=basename fred/bill.c .c
*p returns
*c=bill
*p When the last character of %sstring%s is a slash, or when %ssuffix%s is
identical to %sstring%s after the removal of any prefix characters,
%bbasename%b will return a blank line (%s<newline>%s) to the standard
output.
*q basename
*q Deleting string prefixes
*q Deleting string suffixes
*q Suffix removal
*q Prefix removal
*q Stripping directory names from pathnames
*q Stripping suffixes from filenames
*q Slashes in strings
*k Filename delimiters
*k Pathname delimiters
*x dirname
#
*n bind\Posix library function
*P Binds a name to a socket
*I <sys/socket.h>;<sys/types.h>
*F int bind(int fd, struct sockaddr *addr, int len);
*A fd - file descriptor
*A addr - pointer to socket address
*A len - address length
*R -1 on failure; 0 if the bind is successful.
*E %serrno%s set to:
*l [EBADF]
*t %sfd%s is not a valid descriptor
*l [ENOTSOCK]
*t %sfd%s is not a socket
*l [EADDRNOTAVAIL]
*t %saddr%s is not available
*l [EADDRINUSE]
*t %saddr%s is already in use
*l [EINVAL]
*t Socket already bound
*l [EACCES]
*t %saddr%s may not be accessed
*l [EFAULT]
*t The name is invalid
*D This function is basically identical to the BSD Unix
version of %bbind%b: it assigns a name to an unnamed socket. Sockets
created with %bsocket%b have no name assigned to them; %bbind%b can name
these sockets.
*q bind
*x accept
*x connect
*x listen
*x socket
*q BSD compatibility, Berkeley
#
*n bison\Helios command
*P A compiler compiler
*F bison [-dry] <grammar>
*D %bbison%b is a public domain version of the Unix command
%byacc%b. It converts context-free grammar into a set of tables for
parsing. Full documentation can be found on the Unsupported Software disc.
*q yacc
*q bison
*k Parsing
*k Context-free grammar conversion
*x flex
#
*n BootLink\System library
*P Bootstraps a processor through a link
*I <link.h> ; <config.h>
*F WORD BootLink( word linkno, void *image, Config *config, word
confsize);
*A linkno - Number of link to boot through
*A image - Pointer to system image to boot
*A config - Pointer to configuration structure
*A confsize - Size of configuration
*R Error code
*D This function causes the given Helios system image to be
booted through the given link. If the image pointer is NULL the currently
executing system is used. The configuration is passed to the running
system when it has started. The link must be configured to be in
INTELLIGENT mode. This function is present for the use of the network
server and should not normally be called by user programs.
*x EnableLink
*x Reconfigure
*q Network server
*q Bootstrap processor through a link
*q Processor, bootstrap through a link
*q Intelligent link mode
*q Link mode, intelligent - see Intelligent link mode
#
*n break\Helios command
*P Terminates a %bforeach%b or %bwhile%b loop prematurely
*F break
*D The %bbreak%b shell command enables you to break out of a
%bforeach%b or %bwhile%b loop. The currently executing loop is terminated
prematurely and execution resumes after the %bend%b command. For example,
*c=% foreach x (1 2 3)
*c=? echo x = $x
*c=? break
*c=? end
*p will echo the single line `x = 1', and then terminate the loop. Because
of the way it is implemented, any further commands on the same line will
be executed. %bbreak%b is most commonly used in conjunction with the
%bif%b or %bswitch%b commands, where it conditionally terminates loops.
For example,
*c=% set i=1
*c=% while (1)
*c=? if ($i >= 10) break
*c=? echo $i
*c=? @ i=$i + 1
*c=? end
*p counts from 1 to 9.
*q Shell commands
*q break
*q Terminating a loop prematurely
*q Loop, terminating a
*x foreach
*x while
*x foreach
*x while
#
*n breaksw\Helios command
*P Terminates a %bswitch%b statement
*F breaksw
*D The %bbreaksw%b shell command causes execution to break out
of the body of a %bswitch%b command and resume after the %bendsw%b
command. It is used to terminate command sequences introduced by %bcase%b
and %bdefault%b commands. See the description of %bswitch%b for an example
of the use of %bbreaksw%b.
*q Shell commands
*x case
*x default
*x endsw
*x switch
#
*n bsearch\C library function
*P Searches a sorted array for a given object
*I <stdlib.h>
*F void *bsearch(const void *key, const void *base, size_t nmemb,
size_t size, int (*compar)(const void *, const void *));
*A key - A pointer to the object to be matched
*A base - A pointer to the start of the array
*A nmemb - The number of objects in the array
*A size - The size of the array objects
*A compar - A pointer to the comparison function
*R a pointer to the object if found; otherwise %bbsearch()%b
returns a null pointer. If more than one object in the array matches the
key, it is not defined which one the return value points to.
*D %bbsearch()%b searches the array pointed to by %sbase%s for
an object which matches the object pointed to by %skey%s. The array
contains %snmemb%s objects of %ssize%s bytes.
*p The objects are compared using the comparison function pointed to by
%scompar%s. This function must return an integer less than, equal to, or
greater than zero, depending on whether the first argument to the function
is considered to be less than, equal to, or greater than the second
argument.
*p The base array must already be sorted in ascending order (according to
the comparison performed by the function pointed to by %scompar%s).
*c=/*
*c= Receives a list of arguments from the terminal,
*c= and searches them for the string "findme".
*c=*/
*c=
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=#include <string.h>
*c=
*c=int search_compare(char** arg1, char** arg2)
*c={
*c=  return(strncmp(*arg1, *arg2, strlen(*arg1)));
*c=}
*c=
*c=int sort_compare(char** arg1, char** arg2)
*c={
*c=  return(strcmp(*arg1, *arg2));
*c=}
*c=int st_compare( const void* arg1, const void* arg2)
*c={
*c=  return sort_compare( arg1, arg2 );
*c=}
*c=int se_compare( const void* arg1, const void* arg2)
*c={
*c=  return search_compare( arg1, arg2 );
*c=}
*c=int main(int argc, char** argv)
*c={
*c=  char **result;
*c=  char *key = "findme";
*c=
*c=  /* Sort the command line arguments, according to the
*c=   * string comparison in sort_compare.
*c=   */
*c=  qsort(argv, argc, sizeof(char *), st_compare);
*c=
*c=  /* Find the argument starting with the string in key */
*c=  result = (char **)bsearch((void *)&key, (void *)argv, (size_t)argc,
*c=                            sizeof(char *), search_compare);
*c=  if (result)
*c=      printf("\n'%s' found\n", *result);
*c=  else
*c=      printf("\n'%s' not found\n", key);
*c=}
*x qsort
*q bsearch
*q Searching sorted array
*q Sorted array, search
#
*n btoa\Helios command
*P Converts binary files to 7-bit ASCII
*F btoa
*D %bbtoa%b converts its binary input into standard seven-bit
ASCII format, suitable for transferring through mail systems and modems.
%batob%b, the partner to this command, converts these ASCII files back
into their original binary form. Note that you should expect an increase
in the region of 30%%-40%% in the size of the binary file when it is
converted into ASCII.
*p %bbtoa%b and %batob%b are both filters, so you should pipe in their
input and redirect their output; for example,
*c=cat fred.bin | btoa > fred.txt
*p converts the binary file `fred.bin' into the ASCII text file `fred.txt'.
*x atob
*q Binary to ASCII conversion
*q Files, converting binary to ASCII
*q btoa
#
*n bytblt\System library
*P Performs a 2-dimensional block copy
*I <nonansi.h>
*F void bytblt(byte *source, byte *dest, word sourceix, word
destix, word sstride, word dstride, word length, word width, word op);
*A source - Pointer to source array
*A dest - Pointer to destination array
*A sourceix - Index into source array
*A destix - Index into destination array
*A sstride - Stride of source array (distance between one row of
the array and the next row)
*A dstride - Stride of destination array
*A length - Number of rows to copy
*A width - Width of each row
*A op - Operation code.
*D If supported by the processor in hardware,
this function presents an interface to the
2-dimensional block move instructions. %ssource%s and %sdest%s point to
2-dimensional arrays of bytes with strides %ssstride%s and %sdstride%s
respectively. %ssourceix%s and %sdestix%s indicate the starting points in
these arrays of a block %slength%s by %swidth%s bytes. %sop%s indicates
how the source block is to be moved into the destination block: 0 = all
bytes, 1 = non-zero bytes only, 2 = zero bytes only.
*p Note that if your processor does not support the 2-dimensional block
move instruction then this routine will perform the same action by
software. In this case only operation code 0 is supported.  The T800
transputer is currently the only processor which is supported by Helios
which supports the two-dimensional block move instruction in hardware.
*q 2D
*q 2-dimensional block copy
*q Two-dimensional block copy
*q Block copy, 2-dimensional
#
*n cache\Helios command
*P Loads and retains a program module in memory
*F cache [ -m <machine> ] program
*D %bcache%b prevents a loaded %sprogram%s from being
unloaded. It does not actually load the program module: if %sprogram%s is
not already loaded, it will be loaded when it is next used.
*p Using the %bcache%b command is preferable to keeping a command on the
RAM disc, because the program must be copied from RAM disc into memory in
order for it to be executed. Whereas %bcache%b retains the module in
memory as an executable object. You can identify which modules are loaded
by listing %s/loader%s (with %bls%b).
*p %bcache%b uses the environment variable PATH to locate the program. For
example,
*c=cache cc
*p causes the C compiler to be made resident in the current processor.
Notice that you must have sufficient free memory for this to work.
*p The %s-m%s option allows you to specify a particular processor,
%smachine%s, whereupon the program is made resident there rather than the
current processor.
*x ls
*q cache
*q Resident programs
*q Loaded programs, retaining
*q RAM disc, keeping commands in
#
*n cal\Helios command
*P Produces a calendar for the given year or month
*F cal [<month>] <year>
*D The %bcal%b command produces a calendar for %syear%s. If
%smonth%s is also specified, %bcal%b produces a calendar for that month
only. The arguments are defined as follows:
*l %smonth%s
*t a positive integer in the range 1-12
*l %syear%s
*t a positive integer
*p An error is returned if you specify a negative integer or a %smonth%s
number greater than 12 (for example, =cal 13 -90). If you specify the year
to be 91, you will get a calendar for the year 91AD, and not for 1991. To
get the calendar for 1991, you must remember to specify the year in full.
*p Notice that this command is not in Posix.
*q Calendar production
*q cal
*x date
#
*n CallException\System library
*P Calls a task's exception handler
*I <task.h>
*F void CallException( Task *task, word code);
*A task - Pointer to task structure
*A code - Exception code
*R Nothing
*D %bCallException()%b calls the exception routine pointed to
by the Task structure in the context of the Task. The routine is called
with the standard calling convention, being passed the task's module
table, the exception code and a pointer to the exception data as
arguments. This is primarily for use by the Processor Manager.
*q Process manager
*q Exception handler
*x SetException
*x SendSignal
#
*n calloc\C library function
*P Allocates memory space for an array of items and initialises
the space to zeros.
*I <stdlib.h>
*F void *calloc(size_t nmemb, size_t size);
*A nmemb - The number of items in the array to be allocated
*A size - The size of the array items
*R a pointer to the allocated space if the allocation is
successful; otherwise %bcalloc()%b returns a null pointer.
*D %bcalloc()%b allocates space in memory for an array
containing %snmemb%s items, where each item is %ssize%s bytes long. The
allocated memory is initialised to zeros.
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=
*c=int main( void )
*c={
*c=  int i;
*c=  char *dyn_array;   /*  Dynamically assign a vector */
*c=
*c=  dyn_array = (char *)calloc(5000, sizeof(char));
*c=  if (dyn_array == NULL)
*c=  {
*c=    printf("Error in dynamic allocation\n"); abort();
*c=  }
*c=  for (i = 0; i < 5000; ++i)
*c=    dyn_array[i] = 'x';
*c=}
*x free
*x malloc
*x realloc
*q calloc
*q Memory space, allocate
*q Allocating memory space
#
*n Capability\General interest
*P Protects resources; a system of "tickets" that allow or deny
certain rights of access to the holder.
*D Capabilities provide a means of protection for resources. A
capability encodes a client's access rights to a particular object. Each
capability is 64 bits long and is divided into two fields, an 8-bit
cleartext access mask and a 56-bit validator. The validator consists of a
check value and the access mask encrypted together to protect the
capability against forgery. Whenever an object is created a new encryption
key is chosen and stored with it. The creator's access rights are
encrypted with this key and the capability returned. Later, when the
client performs an operation on the object, the capability must accompany
the request. The validator is decrypted with the stored key and, if the
check value is correct, the server can be confident that the encrypted
mask is correct. The bitwise AND of this and the cleartext access mask is
performed and the resulting bits used to determine the access rights. This
allows the rights of the capability to be restricted either by the client
or by any intermediate servers; note that is is not possible to use this
feature to achieve greater privilege than the encrypted mask would allow.
If the security of an object is compromised, all capabilities for it may
be revoked by causing the server to choose a new encryption key. This
encryption mechanism is based on that used in Amoeba [Tanenbaum81,86].
*p The interpretation of the bits in the access mask is up to the server.
All objects usually have Delete and Alter bits which, if set, allow the
object to be deleted and its access matrix to be altered. Files have Read,
Write and Execute bits. Directories (including name tables), have, besides
Read and Write, bits corresponding to four categories: V, X, Y and Z.
Processors are also protected with this mechanism: when a user is
allocated a processor he is passed a capability containing the right to
execute programs in that processor. Other users have their access mask
restricted by the naming system to exclude that right. Similarly, when a
task is created, the creator receives a capability that allows him to
destroy, debug, or interrupt that task.
*p Stored within each object is an access matrix, a four-by-eight-bit
matrix in which the rows correspond to the four categories, V, X, Y and Z.
These categories are a generalisation of the owner/group/everyone
mechanism, where V corresponds to the owner and Z to everyone. These
interpretations are merely a convention, the categories may be assigned by
an object's creator in whatever way he sees fit. The columns of the matrix
correspond to the access mask rights, so setting a bit at the intersection
of a row and column confers that right upon that category of client. When
a path is being followed through the naming network a current mask is
maintained, which is derived initially from a capability. Whenever a
directory is encountered the current mask is replaced by one that consists
of the bitwise OR of the rows of the directory's matrix for which the old
mask had bits set. A more formal description of this mechanism may be
found in [Wilkes79].
*p Filing system capabilities are long lived, and may be stored in files,
directories, or written into programs. Once a user has validated himself
to the system by conventional means, he obtains a capability for his home
directory which contains further capabilities for those objects he is
allowed to access. There is no superuser, privilege comes from possessing
capabilities with more access rights than other users. It is possible for
no one user to have full access to everything.
*q Capabilities
*q Protection
*x Client-server-model
#
*n case\Helios command
*P Introduces a label in %bswitch%b
*F case <label>: <command>... breaksw
*D %bcase%b is a shell command which introduces an eventuality
(or `case') and its dependent %scommand(s)%s in a %bswitch%b statement.
The %bbreaksw%b command simply marks the end of the %scommands%s and
ensures that execution resumes after %bendsw%b. See the description of
%bswitch%b for more detail.
*q Shell commands
*q case
*q Shell script commands
*x breaksw
*x default
*x endsw
*x switch
#
*n cat\Helios command
*P Catenates and prints files
*F cat [-nsvbte] [<file> ...]
*D The command name %bcat%b is a truncated version of the word
catenate, which means: link items together in a chain. The %bcat%b command
reads information, which can be typed in directly at the keyboard or taken
from a given file or files, and `prints' it to the standard output, which
in most cases will be your VDU screen. If you specify more than one
%sfile%s, then %bcat%b reads each one in sequence, links them together in
the same order, and displays the result. For example, if you type:
*c=cat firstfile
*p it displays the file `firstfile', and if you type:
*c=cat firstfile secondfile
*p it links together the files `firstfile' and `secondfile' and then
displays them as one continuous piece of text. However, if you type:
*c=cat firstfile secondfile > thirdfile
*p it catenates the files `firstfile' and `secondfile' and sends the
results of its concatenation to the file `thirdfile' instead of to the
screen.
*p If you omit %sfile%s, %bcat%b reads directly from the standard input,
which in most cases is the keyboard. To complete your input to %bcat%b,
you must give an explicit end-of-file. Consider the following example:
*c=% cat<RETURN>
*c=mary had<RETURN>
*c=mary had
*c=a little lamb<RETURN>
*c=a little lamb
*c=CTRL-D
*c=%
*p where `%%' is the prompt, <RETURN> indicates where you press the RETURN
key, `mary had' and `a little lamb' are lines sent to %bcat%b and read
into its line buffer, and the control combination CTRL-D is the
end-of-file marker.
*p The string `-' may be used where a file name is expected to read from
the standard input. In this way input from the keyboard can be
interspersed with data read from files.
*p The options available are as follows:
*l -n
*t Prefix each output line with its associated number. If the -b option is
used with -n, blank lines are not numbered.
*l -s
*t Squash multiple blank lines, so that a maximum of one line can separate
filled lines in the output.
*l -v
*t Display control and 8-bit (meta) characters. For example, CTRL-Z is
displayed as caret-Z. Metacharacters are displayed as %bM-%b followed by
the character without its top (8th) bit set. To display tabs as caret-I,
you should use the -t option in conjunction with -v.
*l -e
*t Display $ at the end of each output line (that is, wherever\n is
found).
*l -b
*t Prefix each non-blank output line with its associated number (equivalent
to -nb).
*l -t
*t Display control combinations, 8-bit metacharacters, and tabs as
caret-%sC%s, M-%sC%s, and caret-I (equivalent to -vt).
*x cp
*x more
*q cat
*q CTRL-D
*q End-of-file marker
*k Concatenate files
*q Joining files
*q Displaying files
*k Catenate files
*q Concatenating files
*q Files, catenate
*q Printing files
*q Files, print
#
*n cd\Helios command
*P Changes the shell's current working directory
*F cd [<name>]
*D The %bcd%b shell command, when given with no argument,
changes your current working directory to be your home directory (that is,
the directory specified by the shell variable `home').
*p For example, if user `charles' types:
*c=cd
*p his current working directory changes to his home directory ${home},
such as `/helios/usr/charles'.
*p If you specify the optional %sname%s, %bcd%b looks for a directory with
that name and then makes it your new current working directory. Unless you
include a `/', `./' or `../' as part of %sname%s, %bcd%b looks to see if
%sname%s is a subdirectory of your current directory. If you do not
include any of the above characters as part of %sname%s, and %sname%s is
not a subdirectory of your current directory, then %bcd%b checks each
component of the shell variable `cdpath' to see if it has a subdirectory
called %sname%s.
*p Remember that /%sname%s indicates that %sname%s is a subdirectory of the
root, ./%sname%s indicates that %sname%s is a subdirectory of the current
directory, and ../%sname%s indicates that %sname%s is a subdirectory of
the directory above the current one.
*q Change the current working directory
*q Current working directory, change
*q Working directory, change
*q Home directory
*q home
*q Root directory
*q cdpath
*q cd
*q Changing directory
*x chdir\000071
*x dot
*x dot-dot
#
*n CDL\General interest
*P The Component Distribution Language allows the user to specify
a task force.
*D The CDL language allows the user to specify a task force.
It can be used to describe all the component tasks in that task force; the
various communication paths between them (that is, the pipes to be
created); and particular requirements of individual tasks within the task
force. The user can specify task forces of an arbitrary topology. Normally
the task force is completely independent of the size and topology of the
processor network. Helios takes care of mapping the task force onto the
available resources. However, should the user so wish, part or all of the
mapping can be done by hand, modifying the CDL script appropriately if the
network changes.
*p The CDL language provides a mechanism for constructing networks of tasks
and pipes. Various standard parallel programming algorithms are supported,
such as pipelines, rings and farms. Any language, including C and FORTRAN,
can be used to write the programs, because all that is required for
inter-task communication is standard input and output on the pipes.
*p See the the %sCDL Guide%s, included with %sThe Helios Operating%s
%sSystem%s, for further details.
*x cdl
#
*n cdl\Helios command
*P Runs the CDL compiler
*F cdl [<option>...] <source> [<argument>...]
*q CDL script
*q Task Force Manager
*D This command invokes the CDL compiler. It takes a single
CDL source file (called a CDL script) and produces a CDL object file which
can be interpreted by the Task Force Manager. The default action of
%bcdl%b is to pipe the resulting object code directly into the Task Force
Manager, thus immediately running the described Task Force. Options are
available to produce a CDL object file. Note, if the first line of your
CDL script is as follows:
*c=#! /helios/bin/cdl
*p you can then invoke the CDL compiler upon this file from the Shell
simply by using the name of the script as if it were a command, in a
similar manner to the way Shell scripts are invoked.
*p The list of arguments following the input filename is passed unchanged
into the CDL compiler, and can be accessed from the script via special
dollar ($) macros.
*p Options that are currently available are as follows:
*l Option
*t Description
*l %b-i%b
*t Send listing to screen.
*l %b-l%b%s <filename>%s
*t Send a listing to the named file.
*l %b-n%b
*t Parse only. Do not produce an object file.
*l %b-c%b
*t Compile and send output to stdout.
*l %b-o%b%s <filename>%s
*t Compile and send output to named file. The space before %sfilename%s is
not essential.
*q cdl
*q Component Distribution Language (CDL)
*q Shell script
*q Dollar macros ($)
*q $ - dollar macros
*q CDL compiler
*q Compiler, CDL
*x CDL
#
*n cdobj\Posix library function
*P Returns current directory object
*I <unistd.h>
*F Object *cdobj(void);
*D Returns the Helios Object for the current directory
maintained by the Posix library.
*x fdstream
*x sopen
*x getenviron
*q Helios posix extensions
*q cdobj
#
*n cdobj\System library
*P Returns a pointer to the current directory object
*I <syslib.h>
*F Object *cdobj (void)
*R A pointer to the current directory object
*D %bcdobj()%b returns a pointer to the current directory
object. This can then be used as the context object in %bOpen()%bs,
%bLocate()%bs, and so on.
*q Current directory object, return pointer to
*q Open
*q Locate
#
*n ceil\C library function
*P Calculates the smallest integer which is not less than the
argument
*I <math.h>
*F double ceil(double x);
*A x - A number
*R the smallest integer (expressed as a double) which is not less
than %sx%s.
*D %bceil()%b calculates the smallest integer which is not
less than %sx%s.
*x floor
*q ceil
*q Calculates smallest integer =< argument
#
*n cf_getispeed\Posix library function
*P Returns the input baud rate
*I <termios.h>
*F int cf_getispeed (struct termios *t);
*A t - Pointer to a %stermios%s structure of which only the
%scflag%s field is manipulated
*R The current input baud rate on successful completion;
otherwise, it returns -1 and sets errno to indicate the error that
occurred.
*D This function returns the input baud rate stored in the
%scflag%s field pointed at by %st%s.
*p %bNote:%b the Posix termios structure corresponds exactly to the Helios
Attributes structure.
*p The input and output baud rates are stored in the field %scflag%s of the
%stermios%s structure. The following values may be supported:
*l Value
*t Description
*l B0
*t Hang up
*l B50
*t 50 baud
*l B75
*t 75 baud
*l B110
*t 110 baud
*l B134
*t 134 baud
*l B150
*t 150 baud
*l B200
*t 200 baud
*l B300
*t 300 baud
*l B600
*t 600 baud
*l B1200
*t 1200 baud
*l B1800
*t 1800 baud
*l B2400
*t 2400 baud
*l B4800
*t 4800 baud
*l B9600
*t 9600 baud
*l B19200
*t 19,200 baud
*l B38400
*t 38,400 baud
*p Notice that B0 terminates the connection. A value of B0 means that modem
lines will no longer be asserted, which usually serves to disconnect the
line.
*x cf_getospeed
*x cf_setispeed
*x cf_setospeed
*q Input baud rate
*q Terminal interface
*q Baud rate
*q termios mechanism
*q Attributes mechanism
*q Output baud rate
#
*n cf_getospeed\Posix library function
*P Returns the output baud rate
*I <termios.h>
*F int cf_getospeed (struct termios *t);
*A t - Pointer to a %stermios%s structure containing only the
field %scflag%s.
*R The current output baud rate on successful completion;
otherwise, it returns -1 and sets errno to indicate the error that
occurred.
*D This function returns the output baud rate stored in the
%scflag%s field pointed at by %st%s.
*x cf_setospeed
*x cf_getispeed
*x cf_setispeed
*x cf_setospeed
*q Terminal interface
*q Output baud rate
*q Baud rate
#
*n cf_setispeed\Posix library function
*P Sets the input baud rat.
*I <termios.h>
*F int cf_setispeed (struct termio *t, int speed);
*A t - Pointer to %stermios%s structure containing only the
%scflags field%s
*A speed - Terminal baud rate
*R The current input baud rate on successful completion;
otherwise, it returns -1 and sets errno to indicate the error that
occurred.
*D This function sets the input baud rate stored in the field
%scflag%s to the value of the argument %sspeed%s. If the value is set to
zero, the input baud rate will be specified by the value of the output
baud rate.
*p The %scflag%s field describes the hardware control of the terminal.
*q Terminal control
*q Baud rate
*q Terminal interface
*q Input baud rate
*q Baud rate
*x cf_getispeed
*x cf_getospeed
*x cf_setospeed
#
*n cf_setospeed\Posix library function
*P Sets the output baud rate
*I <termios.h>
*F int cf_setospeed (struct termios *t, int speed);
*A t - Pointer to %stermios%s structure containing only the
%scflag field%s
*A speed - Terminal baud rate
*R The current output baud rate on successful completion;
otherwise it returns and sets errno to indicate the error that occurred
*D This function sets the output baud rate stored in the field
%scflag%s to the value of the argument %sspeed%s. If the value is set to
zero, the input baud rate will be specified by the value of the output
baud rate (see %bcf_setispeed()%b).
*p The input and output baud rates are stored in the field %scflag%s of the
%stermios%s structure (see %bcf_getispeed()%b for a list of possible
values).
*q Output baud rate
*q Baud rate
*q Terminal interface
*q Input baud rate
*x cf_getospeed
*x cf_setispeed
*x cf_getispeed
#
*n chdir\Helios command
*P Changes the current working directory
*F chdir [<name>]
*D %bchdir%b is a synonym of %bcd%b.
*x cd
*q chdir
*q Shell command
*q Changing directory
#
*n chdir\Posix library function
*P Changes the current directory
*I <posix.h> ; <unistd.h>
*F int chdir(char *path);
*A path - Pointer to directory pathname
*R 0, if successful; otherwise it returns -1 and sets errno to
indicate the error.
*E
*l [ENOTDIR]
*t Component of %spath%s is not a directory.
*l [ENOENT]
*t Named directory does not exist or %spath%s is too long.
*D This function causes the directory identified by %spath%s
to become the current working directory. The directory pathname is a
Unix-style pathname: a null-terminated character string that starts with
an optional slash (/), followed by zero or more directory names separated
by slashes, optionally followed by a filename. A pathname that does not
have a leading slash is assumed to be in the current working directory.
*p If %bchdir()%b fails, the current working directory remains unchanged.
*q chdir
*q Pathname
*q Change current directory
*q Current directory, change
*q Directory - change current
*x getcwd
#
*n CheckMask\System library
*P Checks given mask allows the given access
*I <servlib.h>
*F int CheckMask(AccMask mask, AccMask access);
*A mask - access mask
*A access - access matrix
*R 1 on success; 0 on failure.
*D %bCheckMask()%b checks that %smask%s allows the access
%saccess%s. It does this by ensuring that the bitwise AND of the two masks
is equal to %saccess%s. Notice that the bits set in the mode passed in
open requests are in the same positions as the equivalent access control
bits, so that the open mode may be used directly by in %bCheckMask()%b.
*q CheckMask
*q Access, check masks for
#
*n chmod\Helios command
*P Alters the access matrix of an object
*F chmod [vxyz] [+|-|=] [rwefghvxyzda] <file>
*D You use %bchmod%b to alter the access matrices of objects
within servers such as the file server and the ram disc server, which can
use protection. The command line is made up of a sequence of %smatrix modifiers%s, and %sobject names%s. A %smatrix modifier%s starts with a
%scategory letter%s, which is followed by an %soperator%s and then
finally, there is an %saccess letter specification%s. The %scategory letter%s will be one of the following letters: %bv%b, %bx%b, %by%b, or
%bz%b. (The letter %bv%b is the symbol for the rights of the owner, %bz%b
is for public rights, and %bx%b and %by%b are for friends.) As the
operator, you would need to tell your system how you wish to combine the
new %saccess mask%s with the existing one, for the category you are
working on. The example below shows you how to do this.
*l +
*t Adds the new mask to the current mask
*l -
*t Deletes the new mask from the current mask
*l =
*t Replaces the current mask with the new mask
*p To specify the access mask, you give the letters which stand for the
access rights. You can give them in any order you like. The matrix changes
that you specify will affect all the subsequent objects in the argument
list. Some more modifiers may also appear, and the effect they will have
will be combined with that of previous modifiers. The access matrix of an
object will only be changed if the %sclient%s has %salter rights%s to that
object.
*p Imagine, for example, that you have a file called %sfred%s which you
wish to make inaccessible to the %spublic%s, while keeping it available to
all other %sclients%s. You could use the following command:
*c=chmod v-w x-w y-w z-rw fred
*p Now, imagine that you have a directory called %sadm%s, you wish to make
it inaccessible to all clients except those with %bx%b %saccess rights%s.
You could use the following:
*c=chmod v= x=rwvxyzda y= z= adm
*q Access mask
*q Ram disc server
*q Access-matrix, alter
*q chmod
*x Protection
*x Access-matrix
*x refine
*q File server
#
*n chmod\Posix library function
*P Changes file modes
*I <sys/types.h> ; <sys/stat.h>
*F int chmod(char *path, mode_t mode);
*A path - Pointer to file pathname
*A mode - Bit pattern containing file mode
*R If successful, it returns a value of zero; otherwise it returns
a value of -1 and sets the variable errno to one of the values below to
indicate the error that occurred. A return value of -1 means that the file
mode remains unchanged.
*E
*l [EACCES]
*t Search permission denied for a component of the pathname prefix.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [ENOENT]
*t %spath%s either points at an empty string or the given file does not
exist.
*l [EPERM]
*t The effective user ID does not match the file owner and the calling task
does not have the correct privileges.
*l [EROFS]
*t The given file is on a read-only file system.
*l [ENAMETOOLONG]
*t The length of %spath%s is greater than PATH_MAX.
*D %bchmod()%b checks the file modes of a given file. If the
calling task has the right privileges, %bchmod()%b sets the access
permission part of the file's mode according to the bit pattern in
%smode%s (see %bumask()%b for a list of file permission bit masks set in
<sys/stat.h>).
*p %bchmod()%b also affects the time-related fields in %sstruct stat%s, as
follows:
*l Field
*t Action
*l st_atime
*t Not affected
*l st_ctime
*t Updated
*l st_mtime
*t Not affected
*p These times, where applicable, are set to when %bchmod()%b was
successfully executed on the file indicated by %spath%s. Files on
read-only file systems remain unaffected by this function.
*q chmod
*q Change file mode - see chmod
*q File mode, change - see chmod
*x mkdir\000403
*x mkfifo
*x stat
#
*n chown\Posix library function
*P Changes file owner and group
*I <unistd.h> ; <posix.h>
*F int chown (char *path, uid_t owner, uid_t group);
*A path - pointer to pathname of file
*A owner - user id of file owner
*A group - group id of file
*D This function is present in the system, but is not
currently supported.
*q chown
#
*n clear\Helios command
*P Clears the current window
*F clear
*D This command clears the current window. On a system without
windows the entire screen is cleared.
*q Clear window
*q clear
*q Clear screen
*q Screen, clearing
*q Window, clearing
#
*n clearerr\C library function
*P Clears the error and end-of-file indicators for a file stream
*I <stdio.h>
*F void clearerr(FILE *stream);
*A stream - A pointer to a file stream
*R no value.
*D %bclearerr()%b clears the error and end-of-file indicators
for a file stream. The only other way of clearing the indicators is by
calling %brewind()%b.
*x rewind
*q clearerr
*q Clear error
*q Error, clear
*q Clear eof indicators for file stream
*q Eof indicators, clear
#
*n Client-server-model\General interest
*P The basic model on which Helios is based.
*D Like many modern operating systems, the Helios operating
system is based on the client-server model. This technique divides tasks
into client tasks, which require resources, and server tasks, which
control access to those resources.
*p Consider, for instance, a file server and a window server. A client task
sends a message to the file server requesting that a file be opened. The
reply to the message will be either a failure or a handle for the open
file. A further message requests that data be read from the opened file
and the reply from the server contains the data requested.
*p In the same way, a window may be opened on the screen by sending the
window server a message requesting a create. The handle returned in the
reply will be used for a subsequent message containing a write request
along with the data to be written.
*p This basic mechanism is widely used for a number of reasons. It is
easily extensible as any new device needs only a well-defined server to be
written in order to provide access to the device. The server is concerned
only with control of access to the resource with which it is associated,
and is hence simpler to write. Servers can be accessed by name, which
again makes it easy to add private servers.
*p Helios uses the client-server model, but allows the clients and the
servers to be situated on different processors. The standard Helios
message passing mechanism works no matter whether the two communicating
tasks are in the same processor, and hence share the same address space,
or are in different processors connected, possibly indirectly, via
processor links. The Helios kernel routes the message through the
intermediate processors until the message is passed to the correct task
within that processor.
*p This means that clients and servers may be evenly distributed throughout
a network of processors. Some servers need to be physically located within
a processor that has certain hardware attached to it; for example, the
file server must be run in the processor attached to the disc. Many other
servers, and nearly all clients, can run in whichever processor is least
busy. This ensures that several processors within a network may be used
even before a parallel program is written.
*q Client-server-model
*x Servers
#
*n clink\Helios command
*q clink, network command
*P Changes a link state by hand
*F clink <link> -e | -d | -p
*D The %bclink%b command can be used to change a link state.
Under Helios links can be in four main states:
*l Not connected.
*t As far as Helios is concerned there is nothing at the other end of this
link and hence it is ignored.
*l Dumb.
*t There is some hardware at the other end of this link, but not a
processor running Helios. The hardware may be an M212 disc controller, a
T212 or T222 with special hardware such as an ethernet connection, or a
32-bit processor running occam, standalone C, or some other
software that does not require Helios.
*l Intelligent.
*t This means that there is a processor at the other end running Helios.
The link is used for distributed searches and hence for communication
within the network. When a link is set to intelligent mode the kernel will
perform a handshake across the link, to ensure that Helios is running at
the other side.
*l Pending.
*t This is a special case of intelligent mode. At some point in the future
there may be a processor running Helios at the other end of this link, and
when that happens the remote processor will send a handshake. Until this
handshake arrives the link will not be used for distributed searches or
for communication.
*p The %bclink%b program is used mainly when booting a network by hand, to
enable cross links. The program must be executed on the processor with the
link to be changed. The first argument specifies the link. The second
argument specifies with should happen to it: %s-e%s sets the link to
intelligent and active; %s-d%s sets the link to dumb; %s-p%s sets the link
to pending.
*q Link state - Not connected
*q Link state - Dumb
*q Link state - Intelligent
*q Link state - Pending
*x dlink
*x elink
*x plink
*x rboot
#
*n clock\C library function
*P Calculates the amount of processor time used
*I <time.h>
*F clock_t clock(void);
*R the time in CLK_TCKs per seconds. If the processor time is not
available or the value cannot be represented, the value of (clock_t)-1 is
returned.
*D %bclock()%b calculates a best approximation to the amount
of processor time used by the program since it started.
*c=#include <time.h>
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=
*c=int main(void)
*c={
*c=  int i,j;
*c=  clock_t start_time, finish_time;
*c=
*c=  start_time = clock()
*c=
*c=  if ( start_time == (clock_t)-1 )
*c=  {
*c=     printf("Couldn't get start time\n");
*c=     abort();
*c=  }
*c=
*c=  for (i = 0; i < 900000; ++i) j = i;
*c=
*c=  finish_time = clock();
*c=
*c=  if ( finish_time == (clock_t)-1)
*c=  {
*c=     printf("Couldn't get finish time\n");
*c=     abort();
*c=  }
*c=
*c=  printf("Time to do loop is %d seconds\n",
*c=          ((int)finish_time - (int)start_time)/CLK_TCK);
*c=}
*c=
*c=/*
*c=*  Output:
*c=*
*c=*         Time to do loop is 3 seconds
*c=*
*c=*/
*x mktime
*x asctime
*x ctime
*x localtime
*x strftime
*x difftime
*x time\000642
*x gmtime
*q clock
*q Calculate amount of processor time used
*q Time (processor)
*q Processor time used, calculate amount of
#
*n Close\System library
*P Closes a stream or object
*I <syslib.h>
*F WORD Close ( Stream *stream ) | WORD Close ( Object *object );
*A stream - Pointer to Stream structure
*A object - Pointer to Object structure
*R Error code on failure; zero on success.
*D %bClose()%b closes the supplied object or stream and
returns the data structure to the free pool. (For a listing of the
structures, see %bLocate()%b and %bOpen()%b.)
*q Stream structure
*q Close stream
*q Close object
*x close
*x Open
*x Locate
*x Create
#
*n close\Posix library function
*P Closes an open file.
*I <posix.h> ; <unistd.h>
*F int close(int fd);
*A fd - File descriptor
*R Zero on the successful completion of the function; A value of
-1 on the failure of the function. On failure, errno is set to indicate
the error.
*E
*l [EBADF]
*t %sfd%s is not a valid active file descriptor.
*l [EINTR]
*t %bclose()%b was terminated early by a signal.
*D %bclose()%b removes the file descriptor indicated by %sfd%s
from the per-task object reference table and unlocks all outstanding
record locks owned by the task on the file descriptor. %b_exit()%b
automatically closes all the file descriptors associated with a task;
however, %bclose()%b is necessary for programs that use many descriptors
because there is a limit to the number of active file descriptors per
task.
*p When %bclose()%b has closed all the file descriptors associated with a
particular pipe or FIFO special file, any data remaining in the pipe or
FIFO will be lost.
*q Close open file
*q Open file - close
*x Close
*x creat
*x dup
*x exec
*x _exit
*x fcntl
*x pipe
*x open
#
*n closedb\Posix library function
*P Closes a text database file
*I <netdb.h>
*F void closedb(int mode);
*A mode - behaviour mode
*D This function closes an open text database file. The mode
determined the function's exact behaviour. If the mode is zero the
database file is closed regardless of the value of the stayopen flag. If
the mode is non-zero the database is closed only if the stayopen flag is
false.
*q closedb
*x scandb
*x opendb
#
*n CloseDevice\System library
*P Closes down a device
*I <device.h>
*F word CloseDevice(DCB *dcb);
*A dcb - pointer to device control block
*R Non-zero on error; zero on success.
*D A device which has been created with OpenDevice should be
shut down with CloseDevice. This allows it to relinquish any resources it
holds and to return all pending device requests. This routine calls the
Close function in the DCB and then releases its claim on the device code.
When the device close function returns it should have freed the DCB and
all other resources; when CloseDevice returns the code of the device may
have been unloaded.
*q CloseDevice
*q Device control block - dcb
#
*n closedir\Posix library function
*P Closes the given directory stream
*I <sys/types.h> ; <dirent.h> ; <limits.h>
*F int closedir (DIR *dir);
*A dir - Directory pointer to a directory stream
*R If successful, %bclosedir()%b returns zero; otherwise, it
returns -1 and sets errno to indicate the error.
*E
*l [EBADF]
*t %sdir%s does not refer to an open directory stream.
*D Type DIR is defined in the header file <dirent.h>. It
represents an ordered sequence of directory entries, known as a directory
stream.
*p %bclosedir()%b closes the directory stream referred to by %sdir%s. If it
closes the stream successfully, it returns a value of zero. In the event
of an error, it returns -1 and sets errno to indicate the error.
*q Directory operations
*q Directory stream, close
*q Close directory stream
*x opendir
*x readdir
*x rewinddir
#
*n cmp\Helios command
*P Compares two input files
*F cmp [-ls] <file1> <file2>
*D %bcmp%b is a simple file comparison command that notes
where two files' contents differ, or outputs a message proclaiming them to
be identical. You may enter a lone `-' in place of one of the filenames.
This forces %bcmp%b to read the file from its standard input (stdin).
*p %bcmp%b usually outputs just the line number and character position
where the files differed, but when the -l option is used, every character
that differs between the two files is output, along with its offset from
the start and its hexadecimal value. Because of this, -l should only be
used where you expect only a small number of differences between the two
files, otherwise its output can be voluminous.
*p The -s option makes %bcmp%b work in silent mode, with only errors being
printed.
*p %bcmp%b returns a zero error status if the files are identical.
*x diff
*q cmp
*q Comparing files
*q Comparing files
*q Files, comparing
*q stdin
*q Standard input
#
*n Command\General interest
*P Instruction to perform a particular action
*D A %scommand%s is a directive issued by the user to the
system. Commands issued to Helios from the standard input (keyboard) are
interpreted by the current shell. Commands can be executable files, held
in %s/helios/bin%s or in any of the directories set up with the shell
variable %spath%s, built-in shell commands or user-defined %sshell scripts%s.
*q Commands
*x Shell
#
*n Compiling\General interest
*D Unlike Unix where the command cc can be used to compile,
assemble and link programs, Helios provides the general purpose command
%bc%b which helps create programs. This command will compile or assemble
any known Helios language, including all the correct libraries needed for
that language.
*p See the entry on the %bc%b command for more details.
*q Compiling
*x asm
*x c
*x cc
#
*n compress\Helios command
*P Compresses files
*F compress [-dfvc] [-b bits] <file> [<file>...]
*D %bcompress%b finds common substrings in its input and
replaces them with variable length codes. It can therefore decrease the
overall file size of the output file(s) where there is any degree of
repetition in the contents of the input file(s).
*p %bcompress%b reads in the input file(s), compresses them, writes them
out, adding a new filename extension of `.z' (even if an extension already
exists), and then deletes the original files. If no input files exist, it
compresses stdin and sends the compressed output to stdout. Under host
filing systems that use filename extensions, you should rename your file
without an extension before executing %bcompress%b.
*l %bOption%b
*t %bDescription%b
*l %b-d%b
*t Decompresses the `.z' file. It reads in the compressed `.z' file and
outputs the uncompressed file minus its `.z' extension. Note that the
input file is then deleted.
*l %b-f%b
*t Forces the generation of an output file (even if a file with the same
name exists), and a `.z' file (even if the compressed output file is
larger than the original).
*l %b-c%b
*t Forces output to be sent to the standard output device (stdout) instead
of to a file.
*l %b-b%b
*t Limits the maximum number of bits to use for the variable length codes.
*l %b-v%b
*t Places %bcompress%b into verbose mode, and prints out compression
statistics for each file.
*q compress
*q Compressing files
*q File compression
#
*n Configuration-file\General interest
*F <name> = <definition>
*P Informs the I/O server of the current hardware configuration
*D The I/O server must be informed about the configuration of
the hardware being used. It takes its information from a file called the
configuration file during start up. The default configuration file is the
file %shost.con%s in the current directory, but an alternative may be
specified from the command line, if necessary.
*p Entries in the %shost.con%s file take the form of a name followed by an
equals sign (=) and then the current setting for that name. Standard entry
names used by the configuration file include the following although not
all need to be set:
*f host\box\message_limit
*f system_image\transputer_memory\Helios_directory
*f repeat_interval\repeat_delay \bootfile
*f root_processor\link_base\reset_timeout
*f analyse_timeout\floppies\default_rs232
*f COM3_base\COM4_base\COM5_base
*f COM6_base\COM7_base\default_centronics
*f default_printer\\
*p For further details, see your guide to the I/O server.
#
*n Configure\System library
*P Reconfigures a single processor link
*I <config.h> ; <link.h>
*F word Configure(LinkConf newconf);
*A newconf - link configuration to be used
*R Zero on success; error code on failure.
*D This kernel function is used to reconfigure a single
processor link. It should be used in preference to %bReconfigure()%b. The
link given by the %bId%b field of the %bLinkConf%b structure is
reconfigured to either Intelligent or Dumb mode depending on the %bMode%b
field, if it is already in the given mode, %bConfigure%b has no effect.
When switching from Intelligent to Dumb mode the link is put into Dead
state, otherwise the link is put into the state given in %bnewconf%b. Note
that the %bFlags%b field of %bnewconf%b is ignored.
*q Configure
*q Reconfigure
*x AllocLink
*x Reconfigure
#
*n connect\Posix library function
*P Initiates a connection on a socket
*I <sys/socket.h>;<sys/types.h>
*F int connect(int fd, struct sockaddr *addr, int len);
*A fd - file descriptor
*A *addr - pointer to socket address
*A len - address length
*R If successful, returns 0; otherwise, returns -1 and sets
%serrno%s.
*D This function is basically identical to the BSD Unix
version of %bconnect%b; it attempts to make a connection to another
socket.
*q connect
*x accept
*x bind
*q BSD compatibility, Berkeley
#
*n continue\Helios command
*P Terminates the current iteration of a %bwhile%b or %bforeach%b
loop
*F continue
*D This shell command enables you to stop executing the
current iteration of a %bwhile%b or %bforeach%b loop. Execution of the
loop continues at the next iteration. Because of the way it is implemented
any further commands on the same line will be executed. It is most
commonly used in conjunction with the %bif%b or %bswitch%b commands, thus
conditionally terminating the iteration. For example,
*c=% foreach x (1 2 3)
*c=? if ($x == 2) continue
*c=? echo x = $x
*c=? end
*p displays the two lines `x = 1' and `x = 3', skipping the %becho%b
command on the second iteration.
*q while
*q foreach
*q continue
*q Terminating loops
*q Loop termination
*q Shell scripts
*q Shell command
*x break
*x foreach
*x while
#
*n Control-characters\General interest
*P Combination of CONTROL and any other key
*F CTRL-<character key> ; ^<character key>
*D Control characters (ASCII 0-31 and 127) are produced by
pressing the CONTROL key (CTRL or CNTL) at the same time as another
character key. These key combinations are variously written as CTRL-D or
^d, for CONTROL key plus the D key. Caret (^) is often used to stand for
CONTROL; but in the Helios documentation, CTRL is the preferred synonym.
*p Control characters are usually used to to affect the transmission or
processing of text. For instance, to cancel an active foreground task, you
might press CTRL-C and to stop and restart output to the screen, you can
press CTRL-S and CTRL-Q. Most screen editors accept control characters as
text processing commands.
#
*n Cooked\General interest
*P Term meaning processed input
*D Cooked means processed. A program reading from the standard
input (stdin) will, under normal circumstances, receive %scooked%s
%sinput%s. This means that any control key sequences, backspaces, deletes,
and so on have already been processed before the program receives the
input. If a program is receiving cooked input then it will only see a line
of this input after the user has pressed RETURN (that is, the program
cannot receive individual characters as they are typed). The opposite of
cooked is %sraw%s input.
*q Control key sequences
*q CTRL
*q Backspace
*q Delete
*q Pre-processed input
*q Del
*x Raw
#
*n cookie\Helios command
*P Prints amusing or apt comments on life, as found in a fortune
cookie
*F cookie
*D Full documentation can be found on the Unsupported Software
disc.
#
*n CopyObject\System library
*P Makes a copy of an object structure
*I <syslib.h>
*F Object *CopyObject( Object *source );
*A source - Object to be copied
*R Pointer to copy of object, or NULL.
*D This function copies the object given as argument. If the
object has the %bClose()%bable flag set, it is not copied since this
indicates that the controlling server wants to know how many references it
has.
*x Refine
*x NewObject
*x Close
*q Object structure, copy
#
*n CopyStream\System library
*P Makes a copy of a stream
*I <syslib.h>
*F Stream *CopyStream(Stream *stream);
*A stream - stream to copy
*R copy of stream
*D This function generates a copy of the given stream. If the
stream contains a reply port, this will be re-allocated for the new
stream. This function does not generate a new open request to the server,
so both streams will share the same resources in the server. However,
since the mutual exclusion semaphore and the reply port are now
duplicated, it should be possible for two processes to access the stream
simultaneously, if the server supports this.
*q CopyStream
*x NewStream
*x ReOpen
#
*n cos\C library function
*P Calculates the cosine of the argument
*I <math.h>
*F double cos(double x);
*A x - A number in radians.
*R the cosine of %sx%s
*D %bcos()%b calculates the cosine of its argument whose value
is a number given in radians.
*q cos
*q Calculate cosine
*q Cosine - see cos
*x acos
*x sin
#
*n cosh\C library function
*P Calculates the hyperbolic cosine of the argument
*I <math.h>
*F double cosh(double x);
*A x - A number.
*R the hyperbolic cosine of %sx%s
*E A range error will occur if %sx%s is so large that %bcosh()%b
would result in an overflow. In this case %bcosh()%b returns the value
HUGE_VAL (with the same sign as the correct value of the function) and
errno is set to ERANGE.
*D %bcosh()%b calculates the hyperbolic cosine of %sx%s.
*q cosh
*q Calculates hyperbolic cosine
*q Hyperbolic cosine - see cosh
*q Cosine (hyperbolic) - see cosh
#
*n cp\Helios command
*P Copies files
*F cp [-ir] <source> [<source>...] <destination>;
*D %bcp%b stands for `copy'. The command enables you to make
new files or directories without altering the original source file(s) or
directories in any way.
*p At the simplest level, you give two arguments: the name of the original
file to be copied (the %ssource%s) and the name of the file to be the new
copy (the %sdestination%s). If a file already exists with the same name as
the destination then the contents of that file is deleted. To avoid this
happening accidentally, you should use the -i option. This option makes
%bcp%b run interactively, which means that it will ask you to confirm if
you really wish to overwrite an existing file.
*p If the destination refers to a directory, you can copy more than one
source file, or subdirectory to it. Each of the files or subdirectories
listed is copied into the target directory, using their original name. For
example, assuming `fred' is a directory and `new' is not,
*c=cp oldfile fred/new
*p copies the contents of the file `oldfile' into a new file `fred/new';
whereas,
*c=cp oldfile fred
*p copies the contents of the file `oldfile' into a new file
`fred/oldfile'.
*p If you try to copy directories with %bcp%b, you will get a warning
reminding you to use the -r option (any other files specified will still
be copied). The -r option recursively copies the directory, and any files
and further subdirectories it may contain, into the destination directory.
If this destination directory does not exist, it will be created.
*q cp
*q Files, copying
*q Copying files and directories
*x mv
#
*n _cputime\System library
*P Obtains the time elapsed since system start-up
*I <nonansi.h>
*F WORD_cputime(void)
*R The time elapsed since system startup in units of 10
milliseconds.
*D The %b_cputime()%b routine allows the program to read the
system clock.
*p %bNote:%b The system clock overflows every 76 hours.
*q System Clock
*q Overflow of system clock
*q Clock overflow
*q Elapsed time since system start-up, obtain
*q Time elapsed since system start-up, obtain
*q System start-up, obtain elapsed time since
*x clock
*x times
#
*n creat\Posix library function
*P Creates a new file or to truncates an existing file
*I <sys/types.h> ; <sys/stat.h> ; <fcntl.h>
*F int creat(char *path, mode_t mode);
*A *path - Pointer to name of existing file
*A mode - File access mode
*R A value >=0 if writing permitted; otherwise, returns a negative
value indicating the error that occurred.
*D This function creates a new file, or rewrites an existing
file, called %sname%s and opens it for writing, returning its file
descriptor, %sfd%s. If the file does not exist, creat creates the file
with mode %smode%s; if it exists, it truncates its length to 0 while
keeping its mode and owner unchanged.
*c=creat (path, mode);
*p is equivalent to
*c=open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
*q Create new file
*q New file - create
*q File, create new
*q Truncate existing file
*q Existing file, truncate
*q File, truncate
*x close
*x open
*x write\000693
#
*n Create\System library
*P Creates an object of the given type
*I <syslib.h>
*F Object *Create( Object *context, char *name, int type, int
infosize, BYTE *info)
*A context - Pointer to context.
*A name - Pointer to name of object.
*A type - Object type.
*A infosize - Size of structure in bytes.
*A info - Pointer to structure of %sinfosize%s bytes.
*R Pointer to an Object structure, if successful; otherwise, it
returns NULL.
*D %bCreate()%b creates an object of the given type. The
server may reject the request if the type is not one that it supports.
%sinfo%s is a pointer to a structure of %sinfosize%s bytes which contains
any further information needed to create the object. If successful,
%bCreate%b returns a pointer to an Object structure representing the
object created. Otherwise, %bCreate()%b returns NULL, and %bResult2()%b
may be used on the context object to obtain the error code.
*p Valid object types are as follows:
*f Type_Stream\Type_File\Type_Fifo
*f Type_Task \Type_Link\Type_Name
*f Type_CacheName\Type_Directory\Type_LTaskForce
*f Type_TaskForce\Type_Program \Type_Module
*f Type_Private\\
*q Types - Object
*q Object types
*q Create object
*q Result2
#
*n Crypt\System library
*P Encrypts or decrypts, in place, the given data
*I <servlib.h>
*F void Crypt(bool encrypt, Key key, byte *data, word size);
*A encrypt - boolean expression
*A Key - 32-bit number
*A data - pointer to data buffer containing data to be encrypted
*A size - amount of data
*D %bCrypt()%b takes a 32-bit random number and uses it as a
base to encrypt or decrypt the specified data. (Replaces the original
%bcrypt()%b, described in earlier Helios documentation.)
*q Crypt
#
*n cshrc\General interest
*P Tailors a user's shell
*D When you start up a new shell, it looks in your home
directory for the special file %scshrc%s. This file contains a number of
commands to tailor a new shell to your requirements. It defines, for
instance, the values it should use by default and the aliases you always
use. Here is an example cshrc:
*c=set history=20
*c=set savehist=20
*c=alias h history
*c=alias ls ls -F
*c=set path=(/loader /helios/bin .)
*q cshrc
*q Shell, setting up a new
*x Shell
*x loginrc
#
*n ctags\Helios command
*P Creates tag database for stevie
*F ctags [<file>...]
*D %bctags%b is a public domain version of the Unix %bctags%b
command, for use with %bstevie%b.
*p Given a list of filenames, %bctags%b will create a database of
file/location tags for function names and defined macros. The -t option of
%bstevie%b can then be used to find and edit the file within which a
tagged reference is located.
*p Full documentation can be found on the Unsupported Software disc.
*x stevie
#
*n ctermid\Posix library function
*P Generates a terminal pathname
*I <posix.h> ; <unistd.h>
*F char *ctermid (char *s);
*A s - Pointer to a string that refers to the controlling
terminal of the current task
*R If %ss%s is a NULL pointer, it stores the string in an internal
static area, the contents of which may be overwritten at the next call to
%bctermid()%b, and the address of which is returned; otherwise, it assumes
that %ss%s points to a character array; it places the string in this array
and returns the value of %ss%s.
*p %bctermid()%b may return an empty string if the pathname for the
controlling terminal cannot be found.
*D %bctermid()%b generates a string that, when used as a
pathname, refers to the controlling terminal for the current task.
*p If %bctermid()%b returns a pathname, access to the file is not
guaranteed.
*x ttyname
*q Terminal pathname
#
*n ctime\C library function
*P Converts the value in the timer to a string
*I <time.h>
*F char *ctime(const time_t *timer);
*A timer - A pointer to a location containing a time
*R a pointer to a string describing the local time
*D %bctime()%b is equivalent to:
*c=asctime (localtime(timer));
*p It converts the value pointed to by %stimer%s to a tm structure, and
then writes the contents of the structure into a string in the form:
*c=Thu Nov 05 18:19:01 1990
*x localtime
*x gmtime
*x asctime
*x strftime
*x clock
*x difftime
*x mktime
*x time\000642
*q ctime
*q Convert value in timer to string
*q Timer value - convert to string
#
*n Current-directory\General interest
*P Contains the files and subdirectories you are currently working
with
*D This directory is also known as the %scurrent%s %sworking%s
%sdirectory%s. It is the directory in which you are currently set (see
%bcd%b), where, for example, you can use a %srelative pathname%s to refer
to a subdirectory. A relative pathname is a pathname not starting with a
forward slash "/". The system always searches the current directory for
pathnames without a leading forward slash.
*q Current-directory
*q Current working directory
*q Directory, current working
*q Relative pathname
*q Filing system naming hierarchy
*x cd
*x Pathname
#
*n cuserid\Posix library function
*P Gets the user name associated with the current task
*I <posix.h> ; <unistd.h>
*F char *cuserid (char *s);
*A s - Pointer to a character array
*R If %ss%s is a NULL pointer, the result is generated in an area
that may be static, the address of which is returned. If the login name
cannot be found, it returns NULL. If %ss%s is not a NULL pointer,
%bcuserid()%b returns %ss%s. If the login name cannot be found, the null
character `\0' is placed at %s*s%s.
*D %bcuserid()%b returns a name associated with the user of
the current task. That is to say, it returns a character representation of
the login name of the owner of the current task. It returns an empty
string if it cannot locate a name.
*p %bcuserid()%b may use the %bgetpwnam()%b function. This means that the
results of a call to either routine may be overwritten by a subsequent
call to the other routine.
*q User name, get - see cuserid
*q Get user name - see cuserid
*q Current task user name - get
*q cuserid
*q getpwnam
*x getlogin
*x getuid
*x getpwent
*x getpwuid
*x getpwnam
#
*n daemon\General interest
*P Carry out scheduling or maintenance
*D Daemon (pronounced %sdemon%s) is a Unix term for a special
task that runs (usually in the background) without responding to terminal
interrupts. Its major use is for garbage collection, scheduling or general
maintenance jobs. Under Helios, most daemons are known as servers.
*q Daemon
*q Terminal interrupt response
*q Servers
#
*n date\Helios command
*P Prints or changes the system date and time
*F date [-q] [<date>] [<time>]
*D %bdate%b without arguments prints the current date and time
to the standard output, which is by default your screen. With arguments,
it may be used to change the current date and/or time.
*p %bdate%b with %s-q%s gives a message indicating the format desired for
the date and time stamps, followed by a prompt so that you can type in the
new date and time if desired. Alternatively, you may give %bdate%b the new
date or the new time, or both, on the command line.
*p The date stamp takes the form DD-MMM-YY (for example, 23-Jun-88). The
year is optional. Alternatively you can use `tomorrow', `today',
`yesterday' or `Monday', `Tuesday', ... `Sunday' to specify the day. The
time stamp takes the form HH:MM:SS, with the seconds being optional.
*p The following examples illustrate the use of this command:
*c=% date
*c=Date : Thu Oct 25 17:03:31 1990
*c=% date tomorrow 9:00
*c=Date : Fri Oct 26 9:00:00 1990
*c=% date Sunday
*c=Date : Sun Oct 28 9:00:12 1990
*c=% date -q
*c=Please type new system date and time : DD-MMM-YY HH:MM:SS
*c=? 23-Oct 17:04:00
*c=Date : Thu Oct 23 17:04:00 1990
*c=%
*p %bNote:%b Not all Helios systems allow you to change the date. In
particular, if Helios is hosted by a Unix machine where the date is
maintained by the host, you will find it is not possible to change the
date.
*q date
*q Date
*q Time
*x cal
#
*n DecodeCapability\System library
*P Converts a capability into string form
*I <syslib.h>
*F char *DecodeCapability(char *s, Capability *cap);
*A s - pointer to string
*A cap - pointer to capability to be decoded
*D This function converts a capability into a string of
seventeen characters plus a null terminator. The first character is '@',
the remaining sixteen are an ascii-hex representation of the 64-bit
capability, the string is terminated with a null byte. This feature allows
capabilities to be stored as normal text in programs, command files and
shell variables.
*q @
*q Null terminator
*q Ascii
*q Capability, storing as text
*q DecodeCapability
*x EncodeCapability
#
*n DecodeMask\System library
*P Decodes access mask into a character string
*I <protect.h> ; <syslib.h>
*F string DecodeMask (string str, AccMask mask, string bitchars);
*A str - destination string
*A mask - access mask to decode
*A bitchars - character set
*D This function decodes an eight bit access mask into an
eight character string which reflects its value. For bit %bi%b in the
mask: if it is clear then %bstr[i]%b is set to '-', if it is set then
%bstr[i]%b is set to the value of %bbitchars[i]%b. Note that %bstr[8]%b
will NOT be set to '\0'. A set of strings for %bbitchars%b for the common
types will be found in <protect.h>. Thus the matrix 0x87 if decoded using
%bDirChars%b will give the string "rwv----a".
*q DecodeMask
#
*n DecodeMatrix\System library
*P Converts a matrix into a character string
*I <protect.h> ; <syslib.h>
*F void DecodeMatrix (string str, Matrix matrix, word type);
*A str - destination string
*A matrix - access matrix
*A type - object type
*D This function converts a 32-bit access matrix into a
35-byte string plus a zero terminator. Each of the four 8-bit access masks
is decoded using %bDecodeMask%b and separated by colons in the order v, x,
y, z. The bottom four bits of %stype%s are used to select an appropriate
character set for decoding the masks. Thus the matrix 0x21134BC7 if
decoded with %stype%s %s=%s %sType_Directory%s will give the string
"rwv---da:rw-x--d-:rw--y---:r-----z--".
*x DecodeMask
*q DecodeMatrix
#
*n default\Helios command
*P Labels the default case in a shell script %bswitch%b statement
*F default : <command>... breaksw
*D The shell command %bdefault%b introduces a command, or
sequence of commands, to be executed if all of the preceding %bcase%bs in
the same %bswitch%b statement fail.
*p It is important to remember that %bdefault%b must come after all the
cases in the %bswitch%b statement. Because the shell reads each line
sequentially, if it finds a %bdefault%b before the last %bcase%b, it will
execute the default %scommand%s as it won't know that there are further
cases to try.
*q Shell commands
*q default
*q switch
*q Shell script command
*x breaksw
*x case
*x switch
#
*n Default-search-path\General interest
*P Defines usual sequence of directories to search for a command
*D Defines the sequence of directory prefixes to apply to a
command. The default search path is defined by the environment variable
%sPATH%s and the shell variable %spath%s. The usual order of search is
first your working directory, then /helios/bin.
*q Default search path
*q Search path, default
*q Relative directory name
*q Directory name, relative
*q PATH environment variable
*q Environment variable, PATH
*q PATH environment variable
*q Shell variable, path
*x Environment
#
*n Delay\System library
*P Waits for a given number of microseconds
*I <syslib.h>
*F void Delay( word time );
*A time - Time to sleep in microseconds.
*D This function suspends the current process for the given
number of microseconds. The maximum delay time is approximately 35
minutes. You may find the macro OneSec useful. For example,
*c=Delay(10 * OneSec)
*p waits for ten seconds. (OneSec is #defined in the helios.h header file.)
*x sleep\000573
*x GetMsg
*q Maximum delay time
*q OneSec
*q Wait a specified number of microseconds
*q sleep
#
*n Delete\System library
*P Deletes the named object
*I <syslib.h>
*F WORD Delete ( Object *object, STRING name );
*A object - Pointer to context object
*A name - Name of target object
*R Error code on failure; zero on success
*D This function deletes the object named %sname%s relative to
the context of %sobject%s. It only succeeds if the object is not in use
and the application has sufficient access to the object.
*x Locate
*q Object structure
*q Object, remove
*q Delete object
#
*n DES_CFB\System library
*P DES stream encryptor
*I <syslib.h>
*F void DES_CFB(bool encrypt, char *key, char *text, int size);
*A encrypt - en/decrypt control
*A key - 64 bit encryption key
*A text - text to en/decrypt
*A size - length of text
*D This function uses the DES algorithm in Cifer FeedBack
mode. The text is an array of bytes of the give size which is en/decrypted
in place. The key is interpreted as described under DES_ECB().
*p The encryption technique is as follows: the DES algorithm is first used
to encrypts a 64 bit block of zeros with the key. The least significant
byte of this block is then exclusive-ored with the first byte of the text
to form the first byte of the encrypted text. This byte is also shifted
into the eight most significant bits of the 64 bit block of zeroes. This
new block is now encrypted and the least significant byte exclusive-ored
with the next byte in the text, to form the next byte of crypt-text and
the next byte to shift into the block. This is repeated for the entire
block.
*p Decryption is similar the the above procedure except that the byte to be
shifted into the block is extracted before the exclusive-or operation
rather than after. Note that in both case the DES algorithm is being used
in encrypt mode only, and is being used as a source of random bytes to
combine with the text. By shifting the encrypted text into the block on
each cycle, this sequence can be made to depend on the value of the data
being encrypted.
*p Because a complete cycle of the DES algorithm is performed for each byte
of the text, this can take a long time to encrypt a large array of data.
*q DES_CFB
*x DES_ECB
*x DES_KeySchedule
*x DES_Inner
#
*n DES_ECB\System library
*P DES block encryptor
*I <syslib.h>
*F void DES_ECB(bool encrypt, char *key, char *text);
*A encrypt - en/decrypt control
*A key - 64 bit encryption key
*A text - 64 bit text to en/decrypt
*D This function uses the DES algorithm in Electronic Code
Book mode to en/decrypt a single 64 bit block of text. For the purposes of
the algorithm the least significant bit of text[0] is bit 1 of the input
block, the least significant bit of text[1] is bit 9, and so on. The key
is similarly ordered, and although the most significant bits are
theoretically used for parity, this is not checked. The text is
en/decrypted in place.
*q DES_ECB
*x DES_CFB
*x DES_KeySchedule
*x DES_Inner
#
*n DES_Inner\System library
*P DES encryptor
*I <syslib.h>
*F void DES_Inner(bool encrypt, uword *source, uword *dest, uword *ks);
*A encrypt - direction control
*A source - clear(cifer) text to be encrypted(decrypted)
*A dest - destination for cifer(clear) text
*A ks - key schedule generated by DES_KeySchedule
*D This function cycles the DES algorithm once, encrypting the
contents of %bsource%b into %bdest%b using the keyschedule supplied. For
the purposes of the algorithm the least significant bit of source[0] is
bit 1 of the input block, the most significant bit of source[1] is bit 64
of the input block, and similarly for %sdest%s. This definition is
different from that given in DES_ECB, here the organization is by words
rather than by bytes, and although these happen to be identical in the
case of the transputer and C40, they may not be on other architectures,
where some byte swapping may be required.
*q DES_Inner
*x DES_KeySchedule
*x DES_ECB
*x DES_CFB
#
*n DES_KeySchedule\System library
*P Generates DES key schedule
*I <syslib.h>
*F void DES_KeySchedule(uword *key, uword *ks);
*A key - 64 bit encryption key
*A ks - destination for schedule
*D Together with DES_Inner this function gives access to the
inner interfaces of the DES algorithm. This function takes a 64 bit DES
key and manufactures from it the sixteen 48 bit blocks of the key
schedule. These blocks are placed in ks, which must point to an array of
32 words. Key block n occupies all of ks[(n-1)*2] and the least
significant 16 bits of ks[(n-1)*2+1]. Note that the key here is an array
of two words, not 8 bytes, see the comments in DES_Inner about this. The
only real use for ks is as an argument to DES_Inner, if a lot of data is
to be encrypted with the same key, it is more efficient to generate the
key schedule just once and apply DES_Inner.
*q DES_KeySchedule
*x DES_Inner
*x DES_ECB
*x DES_CFB
#
*n device.h header file\General interest
*P Provides a machine independent device interface
*F #include <device.h>
*D This Helios system header provides a machine-independent
device interface. It is not intended to be a full-blown device system, no
provision is made here for multiple clients, or for making the device
accessible to more than one client. Sharing the device between clients,
and converting to a General Server Protocol (GSP) interface is the job of
the device's client which should generally be a Helios server of some
sort.
*p The header file includes a definition for the structures Device, DCB
(device control block), DevReq (generic device request), SerialReq (serial
device request), DiscReq (disc device request), FormatReq (format cylinder
request, EventInfoReq (eventing device get/set info - for example, mouse
sensitivity, resolution etc.), EventReq (eventing device request: a number
of these requests should be passed to the device, one returned each time
an event occurs), NetDevReq (network device requests), NetInfo,
NetInfoReq, FileSysInfo, VolumeInfo, Partition DiscDevInfo, DriveInfo
PartitionInfo, SerialInfo, Line, EventInfo, and InfoNode. It also defines
related macros.
*p Helios device drivers are designed to encapsulate only hardware specific
details. For example, the Helios file system is designed as a hardware
independent server. It loads one of various different device drivers to
access the actual hardware (that is, to read and write disc sectors).
#
*n df\Helios command
*P Displays the amount of disc space used and free
*F df <pathname>
*D This command prints usage information about the disc unit
on which the specified pathname exists. The information includes the
amount of space used and the amount remaining free. For example,
*c=df .
*p prints the amount of space free on the current drive, whereas
*c=df /a
*p displays the information for disc drive `a', and df/helios displays the
usage of /helios:
*c=% df /helios
*c=Size (Kb)          Used(Kb)         Available(Kb)
*c=20708              19070            1630
*q df
*q Disc space report
#
*n diag_ns\Helios command
*P Enables debugging options in the Network Server
*F diag_ns
*F diag_ns redirect > logfile
*F diag_ns revert
*F diag_ns most
*F diag_ns all
*F diag_ns none
*D the Network Server is one of the most important components
of Helios. It is responsible for booting the network, maintaining the
network in a sensible state, and allocating processors to users.
Occasionally the behaviour of the Network Server may be different from
what the user expects, for example it may refuse to allocate a processor
for no immediately obvious reason. To help the user work out what is going
on, the Network Server contains a number of built-in debugging options
which can be enabled and disabled dynamically with the %bdiag_ns%b
command.
*p If the diag_ns command is invoked without any arguments then it will
display a simple menu for the available debugging options. Each option may
be enabled or disabled by pressing a single key. A help option is
available to give details of what each option does. Please note that the
debugging options and the messages produced are not fixed, and may well
change between versions of Helios.
*p By default, the Network Server will send its diagnostics to its standard
output stream, typically the error logger or a console window. If a lot of
debugging options are enabled then this may not be satisfactory, and it
may be better to redirect the output to a file or to the error logger
device /logger. This may be achieved by
*c=diag_ns redirect > /logger
*p that is, giving the diag_ns command a single option, redirect, and using
the shell redirection facilities to specify a particular destination.
*p Once debugging has finished it may be desirable to force the Network
Server to revert to its default logging destination. This can be achieved
by giving the diag_ns command a single option, revert.
*p It is possible to enable the most common debugging options without
having to go through the menu, by giving diag_ns the single argument most.
Similarly, all debugging options can be enabled by giving the single
argument all, and they can be disabled by giving the single argument none.
*q /logger
*q Redirection
*q Debugging
*q Network server
*x diag_sm
*x diag_tfm
#
*n diag_tfm\Helios command
*P Enables debugging options in a Task Force Manager
*F diag_tfm
*F diag_tfm redirect > logfile
*F diag_tfm revert
*F diag_tfm most
*F diag_tfm all
*F diag_tfm none
*D The Taskforce Manager is one of the most important
components of Helios. It is responsible for administering domains of
processors on behalf of a user, and for running programs and taskforces
for that user. Occasionally the behaviour of the Taskforce Manager may be
different from what the user expects, for example it may refuse to run a
taskforce for no immediately obvious reason. To help the user work out
what is going on, the Taskforce Manager contains a number of built-in
debugging options which can be enabled and disabled dynamically with the
%bdiag_tfm%b command.
*q diag_tfm
*p If the %bdiag_tfm%b command is invoked without any arguments then it
will display a simple menu for the available debugging options. Each
option may be enabled or disabled by pressing a single key. A help option
is available to give details of what each option does. Please note that
the debugging options and the messages produced are not fixed, and may
well change between versions of Helios.
*p By default, the Taskforce Manager will send its diagnostics to the
user's login window. If a lot of debugging options are enabled then this
may not be satisfactory, and it may be better to redirect the output to a
file or to the error logger device /logger. This may be achieved by
*c=diag_tfm redirect > /logger
*p that is, giving the diag_tfm command a single option, redirect, and
using the shell redirection facilities to specify a particular
destination.
*p Once debugging has finished it may be desirable to force the Taskforce
Manager to revert to its default logging destination, the login window.
This can be achieved by giving the diag_tfm command a single option,
revert.
*p It is possible to enable the most common debugging options without
having to go through the menu, by giving diag_tfm the single argument
most. Similarly, all debugging options can be enabled by giving the single
argument all, and they can be disabled by giving the single argument none.
*q /logger
*x diag_ns
*x diag_sm
#
*n diff\Helios command
*P Compares two files
*F diff [-bic] <file1> <file2>
*D %bdiff%b compares the lines within the two files %sfile1%s
and %sfile2%s and displays those lines which are different. Notice that
%sfile1%s or %sfile2%s may refer to a directory, in which case, %bdiff%b
uses the file in the directory with the same name as the other argument.
Either file, but not both, can be replaced by `-', in which case the
remaining file is compared against stdin.
*p The major difference between %bcmp%b and %bdiff%b is that %bcmp%b tells
you the point where the files differ (A B differ: char 135, line 5),
%bdiff%b displays the mismatched lines for each file, prefixing each line
with a < or > to indicate which file the line came from. For example, if
file A contains the text of this command summary and file B contains a
slightly different version of the same, a line in A that fails to match
one at the same position in B is displayed as:
*c=<Options for diff:
*p whereas the corresponding line in B appears as:
*c=>Here are the options for diff:
*p each set of such differences is prefixed by a range of lines in file A,
a difference type, and a range of lines in file B. The ranges are either a
comma-separated pair of line numbers or a single line number. The
difference type essentially indicates what change needs to be made to file
A to turn it into file B. The difference types are:
*l a
*t Add the following set of lines from file B to file A
*l d
*t Delete the following set of lines from file A
*l c
*t Change the following set of lines from file A for the following set of
lines from file B.
*p Options for %bdiff%b are as follows:
*l Option
*t Description
*l %b-b%b
*t Ignore trailing spaces and tabs, and treat all other sequences of tabs
and spaces as a single space.
*l %b-i%b
*t Don't distinguish between cases in comparisons. For example, Inmos is
equivalent to both INMOS and inmos.
*l %b-c%b
*t Output several lines of context around each change, so that you can
locate the position of the change easily.
*x cmp
*q diff
*q Comparing files
*q Files, comparison of
#
*n difftime\C library function
*P Calculates the difference between two times
*I <time.h>
*F double difftime(time_t time1, time_t time0);
*A time1 - A time
*A time0 - Another time
*R the difference, in seconds, between %stime1%s and %stime0%s.
*D %bdifftime()%b calculates the difference in time between
%stime1%s and %stime0%s (%stime1%s - %stime0%s).
*c=#include <time.h>
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   int i, j;
*c=   time_t start_time, finish_time;
*c=   time_t(&start_time);
*c=   for (i = 0; i < 500000; ++i) j = i;
*c=   time_t(&finish_time);
*c=   printf("Loop time is %e\n", difftime(finish_time, start_time));
*c=}
*c=/*  Output:
*c= *         Loop time is 2.000000e+00
*c= */
*x time\000642
*x ctime
*x localtime
*x strftime
*x clock
*x mktime
*q difftime
*q Calculate the difference between two times
*q Difference between two times, calculate
*q Time difference, calculate
#
*n dirname\Helios command
*P Removes the filename component from a pathname string
*F dirname <string>
*D %bdirname%b is the opposite of %bbasename%b. Given a
pathname string, it returns the directory component (the pathname string
minus its filename component). In other words, %bdirname%b deletes the
last slash in the given pathname string through to the end of the string.
For example,
*c=dirname /helios/bin/help
*p would return
*c=/helios/bin
*p If you specify a string without any delimiters (slashes), %bdirname%b
returns a dot (.), meaning the current directory.
*q basename
*q dirname
*q Dot
*x basename
*x dot
#
*n dirs\Helios command
*P Prints the directory stack
*F dirs
*D %bdirs%b enables you to display the current directory
stack. It prints the stack with the top-of-stack (the current directory)
to the left. The directory stack may be manipulated with the commands
%bpopd%b and %bpushd%b.
*q Shell commands
*q dirs
*q Printing the directory stack
*q Directory stack, printing the
*x popd
*x pushd
#
*n DirServer\System library
*P Services stream requests for open directories
*I <servlib.h>
*F void DirServer(ServInfo *servinfo, MCB *m, Port reqport);
*A servinfo - pointer to server information in ServInfo structure
*A m - pointer to message control block
*A reqport - port to be used
*D %bDirServer()%b services stream requests for open
directories. If while handling an Open the target turns out to be a
directory then %bDirServer()%b may be called to service subsequent read
requests. It only returns when the directory has been closed.
*q DirServer
*x Dispatch
#
*n Dispatch\System library
*P Acts as a dispatcher for servers
*I <servlib.h>
*F void Dispatch(DispatchInfo *info);
*A info - pointer to information to be dispatched
*D A server normally consists of a dispatcher process, which
receives requests on the server's request port and spawns a worker process
to deal with it. The ServLib routine %bDispatch()%b implements this,
taking a pointer to a DispatchInfo structure:
*c=struct DispatchInfo{
*c=       DirNode        *Root;            /* root of server */
*c=       Port            ReqPort;         /* request port */
*c=       word            SubSys;          /* subsystem code */
*c=       char           *ParentName;      /* name of root's parent directory */
*c=       DispatchEntry   PrivateProtocol; /* escape for non-GSP functions */
*c=       DispatchEntry   FnTab[IOCFns];   /* function jump table */
*c=} DispatchInfo;
*p The dispatcher awaits messages on the request port, validates that they
are GSP protocol and then spawns off a subprocess to deal with the
request. The subprocess locates the context object, if present, and then
calls one of the functions in the function table according to the message
function code.
*p The functions are all called with a single argument, a pointer to a
ServInfo structure:
*c=struct ServInfo{
*c=DispatchInfo  *DispatchInfo; /* DispatchInfo struct */
*c=MCB           *m;            /* MCB of request */
*c=DirNode       *Context;      /* original context object */
*c=ObjNode       *Target;       /* the target object */
*c=bool          TargetLocked;  /* Target locked? */
*c=word          FnCode;        /* request fn code */
*c=jmp_buf       Escape;        /* error/escape jump buffer */
*c=char          Pathname[IOCDataMax];  /* current object pathname */
*c=} ServInfo;
*p The server library supplies default functions for the following
operations: Link, Locate, ObjInfo, Protect, Refine, Rename, Revoke and
SetDate.
*q GSP
*q Message Control Block (MCB)
*q General Server Protocol
*q DispatchInfo
*q Dispatch
*x DoLink
*x DoLocate
*x DoObjInfo
*x DoProtect
*x DoRead
*x DoRefine
*x DoRename
*x DoRevoke
*x DoSetDate
#
*n div\C library function
*P Calculates the quotient and remainder of a division
*I <stdlib.h>
*F div_t div(int numer, int denom);
*A numer - The numerator
*A denom - The denominator
*R a structure of type %sdiv_t%s which consists of the quotient
and remainder.
*E If the result cannot be represented the behaviour of %bdiv()%b is
undefined.
*D %bdiv()%b calculates the quotient and remainder formed by
dividing the numerator %snum%s by the denominator %sdenom%s.
*x ldiv
*q div
*q Calculating the quotient and remainder of a division
*q Quotient and remainder of a division, calculate
*q Division - calculate quotient and remainder of
#
*n dlink\Helios command
*q dlink, network command
*P Disables a link
*F dlink <processor> <link>
*D As set out in the description of %bclink%b, a Helios link
can be in one of four states:
*l Not connected.
*t As far as Helios is concerned there is nothing at the other end of this
link and hence it is ignored.
*l Dumb.
*t There is some hardware at the other end of this link, but not a
processor running Helios. The hardware may be an M212 disc controller, a
T212 or T222 with special hardware such as an ethernet connection, or a
32-bit processor running occam, standalone C, or some other software
that does not require Helios.
*l Intelligent.
*t This means that there is a processor at the other end running Helios.
The link is used for distributed searches and hence for communication
within the network. When a link is set to intelligent mode the kernel will
perform a handshake across the link, to ensure that Helios is running at
the other side.
*l Pending.
*t This is a special case of intelligent mode. At some point in the future
there may be a processor running Helios at the other end of this link, and
when that happens the remote processor will send a handshake. Until this
handshake arrives the link will not be used for distributed searches or
for communication.
*p The %bclink%b command can be used to change a link state, by running it
on the appropriate processor; this is useful in the absence of a Network
Server. However, in a multi user environment it may not work. If the
processor concerned is not currently in the user's domain, it may not be
possible to run a program there. Instead there are other commands which
interact with the Network Server to achieve the same thing. The %bdlink%b
command takes two arguments: a processor name and a link number. It is
used to disable a link. For example,
*c=dlink /02 3
*p disables link 3 on processor /02. Other commands - %belink%b, %bplink%b,
and %blstatus%b - can be used to change the mode of a link and examine its
current state.
*x clink
*x elink
*x plink
*x lstatus
#
*n DoLink\System library
*P Implements a handler for Link() requests
*I <servlib.h>
*F void DoLink(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoLink()%b implements a handler for the IOC function
%bLink()%b. If a server had no need of any special handling of this
function, a pointer to the function may be installed in the DispatchInfo
function table.
*q DirServer
*q Link
*q IOC
*q DoLink
*q DispatchInfo
*x Dispatch
#
*n DoLocate\System library
*P Implements a handler for the IOC function Locate()
*I <servlib.h>
*F void DoLocate(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoLocate()%b implements a handler for Locate(). If a
server has no need of any special handling of this function, a pointer to
the function may be installed in the DispatchInfo function table.
*q DirServer
*q Locate
*q DoLocate
*x Dispatch
#
*n domain\Helios command
*P Modifies or examines a user's domain
*F domain get <processor description(s)>
*F domain free <processor description(s)> | all
*F domain book <processor description(s)> | all
*F domain cancel <processor description(s)> | all
*F domain preload [C | Fortran]
*F domain info
*F domain monitor [<interval>]
*F domain help
*F domain list
*F domain show
*F domain lock
*F domain unlock
*D The %bdomain%b command can be used to change a user's
current domain of processors. Helios runs a program, (the Task Force
Manager), for every user currently logged in to a network. This program
maintains a domain of processors and is responsible for executing the
user's applications in that domain. The Task Force Manager will obtain
additional processors from the central pool when required, and will
release them again when they become free. The %bdomain%b command can be
used to modify or examine a user's current domain.
*p The command
*c=domain get
*p is used to add more processors to the user's domain. The command takes
two forms. First it is possible to get one or more processors by giving
their names, for example:
*c=domain get /00 /01 /02 /03 /04 /05 /06 /07
*p Alternatively, it is possible to describe the processors required by
using a template. A typical template might be:
*c=domain get "8{ processor T800 }"
*p This means that the user wants to obtain eight T800s, if possible.
Templates allow processor types, memory sizes, and attributes to be
specified. Attributes should match the attributes defined in the network
resource map; for example:
*c=domain get "{ memory 0x100000 }"
*c=domain get "{ processor T425; attrib 30MHz }"
*p Recognized processor types are T800, T414, T425 and T400. The first
command would attempt to get any processor with at least one megabyte of
memory. The second command would get any T425 with the attribute 30MHz,
which must be given in the resource map. Please note the use of quotes
around the template, to prevent the shell from interpreting any of the
characters inside. The exact syntax for the templates is given below.
*p When allocating processors using templates, usually more than one
processor is required. This can be done by prefixing the template with a
count.
*c=domain get "10{memory 0x100000 }"
*p This command would attempt to get 10 processors with at least one
megabyte of memory apiece.
*p The %bdomain free%b command is used to return processors back to the
system pool. It takes two forms. The first form explicitly lists the
processors to free, for example:
*c=domain free /00 /01 /02 /03
*p The second form can be used to free all the processors in the user's
domain, apart from the one running the user's task force manager.
*c=domain free all
*p It is not possible to use templates for the %bfree%b command, only for
the %bget%b command. The %bfree%b command will fail for a processor if any
application is currently running on that processor, including the
%bdomain%b %bfree%b command, or if the processor is currently in native
mode.
*p The %sbook%s option is used to reserve one or more processors. The Task
Force Manager will not attempt to execute further user applications on
those processors, but programs can still be executed explicitly. For
example, the user might execute the following commands:
*c=domain get /01
*c=domain book /01
*c=remote -d 01 /helios/lib/fs raw
*p Like %bfree%b, %bbook%b can be given the argument %sall%s, which
reserves all the processors in the user's domain.
*p This causes the Task Force Manager to allocate processor 01 and prevents
it from automatically running programs there. Next the filing system is
run on that processor. The result is that the filing system will be the
only application to run on that processor, and can use all of the
processor's memory.
*p The %scancel%s option is used to cancel a booking, and is the inverse
operation to %bbook%b. It allows the Task Force Manager to run programs in
those processors again. Like %bbook%b and %bfree%b, this command takes a
list of processors as arguments.
*c=domain cancel /01 /02 /03
*p Like %bbook%b and %bfree%b, %bcancel%b can accept the argument %sall%s,
which cancels the booking of all the processors in the user's domain.
*p  When running large taskforces a significant part of the time taken
    to load the taskforce is taken by the need to load various resident
    libraries into all the processors. If a suitable domain of processors
    has been pre-allocated then it is possible to pre-load the libraries
    needed by C or Fortran programs before running the taskforce. To achieve
    this, use the command
*c=domain preload
*p  The %bdomain info%b and %bdomain monitor%b commands can be used
    to display performance information about the various processors in the
    current domain. For each processor the command displays the current
    CPU load and memory usage, both as a percentage and in the form of
    a horizontal bar, as well as the total amount of memory.
    The %b|%b character at the end of each bar
    indicates the maximum load measured during the run of the program.
*p  The %binfo%b option gives a snapshot of the current load in the
    user's domain of processors. The %bmonitor%b option runs continuously
    until the user explicitly exits the program, and displays a menu at
    the bottom of the screen. The menu options are as follows:
*l  arrow keys
*t  The up and down arrow keys can be used to select
    a particular processor. The currently selected processor will be
    displayed in inverse video.
*l  First
*t  for large networks where there are too many processors to
    display on one screen, this option can be used to move back to the first
    processor.
*l  Last
*t  This moves directly to the last processor in the domain.
*l  Next
*t  This moves to the next page of processors.
*l  Prev
*t  This moves to the previous page of processors.
*l  Tag
*t  This can be used to `tag' the current processor. With large
    networks it may be desirable to select a small number of processors and display
    information about only those processors. This is possible by the tagging
    mechanism. Tagged processors are marked with an asterisk.
*l  Untag
*t  This can be used to remove the tag on the current processor.
*l  Display tagged
*t  Normally this causes the program to show only those
    processors which have been tagged. It can also be used to switch back
    to normal mode.
*l  Examine
*t  This option can be used to display information about the
    current processor. It gives details of processor type, memory, connectivity,    any programs that are currently running, and any code that is currently
    loaded.
*l  Map
*t  This option can be used to run the %bmap%b
    program on the current processor, if additional performance information
    is required.
*l  Run map
*t  This option can be used to create a new window and
    run a %bmap%b program on the current processor in that window.
    %bmap%b program and the %bmonitor%b will continue running
    independently.
*l  !
*t  This can be used to run a sub-shell. When the user exits from
    that shell the monitor resumes.
*l  + and -
*t  These options can be used to increase or decrease the
    sampling rate. By default the program will take a sample every two seconds.
*l  ?
*t  This option gives on-line help about the various options.
*l  Quit
*t  This is used to exit the program.
*p The command
*c=domain list
*p gives a short list of all the processors in the user's domain.
*p The command
*c=domain show
*p Gives some detailed information about all the processors in the user's
domain, including processor type, memory size, and any connections to
other processors inside the user's domain. Connections to processors
outside the user's domain will be shown as external connections.
*p The command
*c=domain lock
*p locks the current domain. It stops the Task Force Manager from
requesting new processors from the free pool, and it stops processors
being returned to the system pool. While a domain is locked the Task Force
Manager will cease interacting with the Network Server.
*p The command
*c=domain unlock
*p unlocks the user's domain, allowing the Task Force Manager to obtain
more processors from the free pool when required, and allowing it to
return processors to the free pool when they are not used any more.
*q Locking the current domain
*q System pool
*q Free pool
*q domain, network command
*q domain command: info option
*q book
*q domain command: book option
*q Reserving processors
*q domain command: cancel option
*q Task force manager
*q Processor pool
*q domain command: get option
*q domain command: preload option
*q Processor allocation
*q Memory size
*q Attributes
*q domain command: help option
*q User's processors, list
*q Information about user's processors
*q Processor type
*q Memory size
*q Connections between processors
*x network
*x Task-Force-Manager
#
*n DoObjInfo\System library
*P Implements a handler for the IOC function ObjInfo()
*I <servlib.h>
*F void DoObjInfo(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoObjInfo()%b implements a handler for %bObjInfo()%b. If
a server has no need for any special handling of this function then a
pointer to the function may be installed in the DispatchInfo function
table.
*x Dispatch
*q DirServer
*q DoObjInfo
#
*n DoProtect\System library
*P Implements a handler for the IOC function Protect()
*I <servlib.h>
*F void DoProtect(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoProtect()%b implements a handler for %bProtect()%b. If
a server has no need of any special handling of this function, a pointer
to the function may be installed in the DispatchInfo function table.
*x Dispatch
*q DirServer
*q DoProtect
#
*n DoRead\System library
*P Handles a read request
*I <servlib.h>
*F word DoRead(MCB *m, Buffer *(*GetBuffer)(), void *info);
*A m - read request
*A GetBuffer - buffer supply procedure
*A info - pointer to information to be read
*D %bDoRead()%b handles a read request. The arguments to this
function are the read request containing the (possibly updated) position
and size, a buffer supply procedure and an argument to be passed to this
procedure. In %bDoRead%b, whenever some data is to be sent to the client,
the buffer supply procedure is called with the file position required and
the argument supplied to %bDoRead%b. The result of this procedure is a
pointer to a %bBuffer%b structure containing the data at the given file
position. The procedure %bGetReadBuffer%b is supplied by the server
library and works in conjunction with %bAdjustBuffers%b to manage a
%bBuffer%b list.
*q DoRead
*x AdjustBuffers
*x GetReadBuffer
*x GetWriteBuffer
*x DoWrite
#
*n DoRefine\System library
*P Implements a handler for the IOC function Refine()
*I <servlib.h>
*F void DoRefine(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoRefine()%b implements a handler for %bRefine()%b. If a
server has no need for any special handling of this function, a pointer to
the function may be installed in the DispatchInfo function table.
*x Dispatch
*q DirServer
*q DoRefine
#
*n DoRename\System library
*P Implements a handler for the IOC function Rename()
*I <servlib.h>
*F void DoRename(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoRename()%b implements a handler for %bRename()%b. If a
server has no need of any special handling of this function, a pointer to
the function may be installed in the DispatchInfo function table.
*x Dispatch
*q DirServer
*q DoRename
#
*n DoRevoke\System library
*P Implements a handler for the IOC function Revoke()
*I <servlib.h>
*F void DoRevoke(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoRevoke()%b implements a handler for Revoke(). If a
server has no need of any special handling of this function, a pointer to
the function may be installed in the DispatchInfo function table.
*q DoRevoke
*x Dispatch
#
*n DoSetDate\System library
*P Implements a handler for the IOC function SetDate()
*I <servlib.h>
*F void DoSetDate(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bDoSetDate()%b implements a handler for SetDate(). If a
server has no need of any special handling of this function, a pointer to
the function may be installed in the DispatchInfo function table.
*x Dispatch
*q DirServer
*q DoSetDate
#
*n dot\General interest
*P Special filename used for the current directory
*D This is a special filename, consisting of just the dot
character `.' (that is, a period or fullstop), which is used to denote the
current directory.
*q dot
*x rmdir\000505
*x cd
*x dot-dot
#
*n dot-dot\General interest
*P Special filename used for the parent directory of the current
directory
*D The double dot is a special filename, consisting of two dot
characters `..' (that is, two periods or fullstops), which is used to
denote the directory immediately above the current directory. For example,
*c=cd ..
*p moves you up one level in the directory hierarchy and sets your new
current directory to the previous parent directory.
*q dot-dot
*q Double dot (..) - see dot-dot
*x dot
*x cd
*x rmdir\000505
#
*n DoWrite\System library
*P Handles a write request
*I <servlib.h>
*F word DoWrite(MCB *m, Buffer *(*GetBuffer)(), void *info);
*A m - write request
*A GetBuffer - buffer supply procedure
*A info - argument to be passed
*D %bDoWrite()%b handles a write request. The arguments to
this function are the write request containing the (possibly updated)
position and size, a buffer supply procedure and an argument to be passed
to this procedure. %bDoWrite%b is the inverse of %bDoRead%b.
*q DoWrite
*q DoRead
*x DoRead
#
*n Driver\General interest
*P Controls a hardware device.
*D A driver is a piece of code used to interact with some item
of hardware. The aim of device drivers is to isolate hardware-independent
and hardware-specific code. The hardware-independent code usually takes
the form of a server, such as the Helios file server. This server loads a
second piece of code, the device driver, to perform low level interaction
with the hardware; for example, to read and write sectors off a disc.
*p The Helios concept of device drivers is rather different from the Unix
one. The Helios combination of server and device driver is similar to the
Unix device driver, but is usually more flexible.
*q Servers
*q Device drivers
*q Drivers
#
*n du\Helios command
*P Gives the size in Kilobytes for the given file(s)
*F du [-s] [-a] [<pathname>...]
*D %bdu%b returns the number of Kbytes in all the
%spathname%ss listed. If %spathname%s is a directory, %bdu%b also lists
the size of each subdirectory within that directory. Symbolic links are
counted as files and contribute to the size totals. If no %spathname%s is
given, %bdu%b uses the current directory. All sizes are rounded up to the
nearest Kbyte.
*p The options accepted by this command are as follows:
*l -s
*t Summary: gives just the total number of Kbytes for each %spathname%s
specified
*l -a
*t All: gives a full entry for each file recursively below %spathname%s for
each %spathname%s specified
*p For example, if your current directory holds two subdirectories, fred
and bill, and a number of other small files then the following command
line:
*c=du
*p might return something like this:
*c=1200 fred/
*c=22400 bill/
*c=37998 .
*p and
*c= du -a bill
*p might return:
*c=960 bill/letter
*c=240 bill/test
*c=1200 bill
*q Size of file, return
*q File size in Kbytes, return
*q du
*x ln
#
*n dump\Helios command
*P Obtains a hexadecimal version of the code in a given file
*F dump <file>
*D This command displays the contents of a %sfile%s as
hexdecimal numbers. Output goes by default to the standard output (usually
the screen).
*q dump
*q Print hexadecimal dump of file
*q Hexadecimal dump of file, print
#
*n dup\Posix library function
*P Allocates another file descriptor for an open file.
*I <posix.h> ; <unistd.h>
*F int dup(int fd);
*A fd - A valid file descriptor
*R If successful, %bdup()%b returns a file descriptor; otherwise,
it returns a value of -1 and sets the variable errno to indicate the error
that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EMFILE]
*t If the function was allowed to continue, the number of open file
descriptors would exceed the maximum allowed by OPEN_MAX.
*D This function allocates a file descriptor to an open file.
%bdup()%b provides an alternate interface to that provided by %bfcntl()%b
using F_DUPFD. For example, the call
*c=fid = dup (fd);
*p is equivalent to
*c=fid = fcntl (fd, F_DUPFD, 0);
*x close
*x fcntl
*x open
*q Allocate another file descriptor for open file
*q Duplicate file descriptor - see dup, dup2
*q File descriptor (open file) - see also dup, dup2
*q Open file descriptor - see also dup, dup2
*x pipe
*x dup2
*x creat
#
*n dup2\Posix library function
*P Allocates another file descriptor for an open file
*I <posix.h> ; <unistd.h>
*F int dup2( int fd, int fd2 );
*A fd - A valid descriptor of an existing object.
*A fd2 - A valid descriptor of a new object.
*R If successful, %bdup2()%b returns a file descriptor; otherwise,
it returns a value of -1 and sets the variable errno to indicate the
error.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor or %sfd2%s is out of range.
*l [EMFILE]
*t If the function was allowed to continue, the number of open file
descriptors would exceed the maximum allowed by OPEN_MAX.
*D This function duplicates an existing object descriptor,
%sfd%s, to a new object descriptor, %sfd2%s. The object referred to by the
descriptor %sfd%s is shared by a new descriptor, %sfd2%s. If that
descriptor is already in use, it is first deallocated as if a %bclose()%b
had been done. Both descriptors then refer to the same object sharing the
file pointer and access mode.
*p %bdup2()%b, like %bdup()%b, provides an alternate interface to that
provided by %bfcntl()%b using F_DUPFD. For example, the call
*c=fid = dup2 (fd, fd2);
*p is equivalent to
*c=fid = fcntl (fd, F_DUPFD, fd2);
*p except for the following: if %sfd2%s is not a valid file descriptor, it
is not closed; if %sfd%s is valid and equal to %sfd2%s, it returns %sfd2%s
without closing it.
*q Allocate another file descriptor for open file
*x dup
*x fcntl
*x close
*x open
*x pipe
*x fcntl
#
*n echo\Helios command
*P Displays a specified word or words to stdout
*F echo [-n] <wordlist>
*D %becho%b displays %swordlist%s to the standard output
(usually the screen). %swordlist%s may be one or more words, separated by
spaces and terminated with a newline. The newline is also echoed unless
you specify the optional -n option.
*c=echo Mary had a little lamb<RETURN>
*p for instance, appears as
*c=Mary had a little lamb
*c=%
*p where `%%' is the usual prompt, whereas
*c=echo -n Mary had a little lamb<RETURN>
*p displays the same but without echoing %snewline%s:
*c=Mary had a little lamb%
*p Notice that %becho%b displays %swordlist%s unless you use one of the
redirection metacharacters to redirect the output elsewhere. For example,
*c=echo Mary had a little lamb > nursery
*p sends `Mary had a little lamb' to the file `nursery' rather than to
stdout.
*p Of course, there is little use for %becho%b when typing shell command
lines directly into the terminal (except for sending messages to a diary
file, for example). The main use of %becho%b is in shell scripts. Within a
shell script, you can use this command to report back what is happening to
the screen, to ask for more data to be typed in, and so on.
*q Shell commands
*q Shell scripts
*q echo
*q Repeating text
*x glob
#
*n ed\Helios command
*P Text editor
*F ed [-] [<file>]
*D %bed%b is a public domain version of the standard Unix text
editor, %bed%b. Full documentation can be found on the Unsupported
Software disc.
#
*n Editor\General interest
*P Enables you to review and alter text files.
*D See emacs for default editor. The public domain version of
vi (view), stevie, can be used instead if you are used to that editor.
*q Editing
*x emacs
#
*n egrep\Helios command
*P Searches for a pattern in given files or stdin
*F egrep [-cilnv] [-e] <pattern> [<file>...]
*D %begrep%b is closely related to the commands %bfgrep%b and
%bgrep%b. %begrep%b searches the given input for lines matching
%spattern%s, where %sfile%s is the pathname of the text file to be
searched and %spattern%s consists of a C-language-like regular expression.
If no %sfile%s is specified, %begrep%b will use the standard input
(stdin). All matching lines are copied to the standard output (stdout)
unless redirected elsewhere.
*p The options are as follows:
*l -c
*t Prints a count of the lines matching %spattern%s
*l -i
*t Ignores the case of any text in matching %spattern%s
*l -l
*t Prints the filename(s) of the file(s) matching %spattern%s
*l -n
*t Prints the line number of the line matching %spattern%s
*l -v
*t Prints lines NOT matching %spattern%s
*l -e
*t Introduces a pattern starting with a `-'
*q egrep
*q Searching for patterns
*q Pattern matching
*x fgrep
*x grep
*x Expressions
#
*n elink\Helios command
*q elink, network command
*P Enables a link
*F elink <processor> <link>
*D As set out in the description of %bclink%b, a Helios link
can be in one of four states:
*l Not connected.
*t As far as Helios is concerned there is nothing at the other end of this
link and hence it is ignored.
*l Dumb.
*t There is some hardware at the other end of this link, but not a
processor running Helios. The hardware may be an M212 disc controller, a
T212 or T222 with special hardware such as an ethernet connection, or a
32-bit processor running occam, standalone C, or some other software that
does not require Helios.
*l Intelligent.
*t This means that there is a processor at the other end running Helios.
The link is used for distributed searches and hence for communication
within the network. When a link is set to intelligent mode the kernel will
perform a handshake across the link, to ensure that Helios is running at
the other side.
*l Pending.
*t This is a special case of intelligent mode. At some point in the future
there may be a processor running Helios at the other end of this link, and
when that happens the remote processor will send a handshake. Until this
handshake arrives the link will not be used for distributed searches or
for communication.
*p The %bclink%b command can be used to change a link state, by running it
on the appropriate processor; this is useful in the absence of a Network
Server. However, in a multi user environment it may not work. If the
processor concerned is not currently in the user's domain, it may not be
possible to run a program there. Instead there are other commands which
interact with the Network Server to achieve the same thing.
*p The %belink%b command takes two arguments: a processor name and a link
number. It is used to enable the link. Hence the command
*c=elink /02 3
*p is intended to have the same effect as
*c=remote 02 clink 3 -e
*p Other similar commands - %bdlink%b, %bplink%b, and %blstatus%b - can be
used to change the mode of a link and examine its current state.
*x clink
*x dlink
*x plink
*x lstatus
#
*n else\Helios command
*P Marks the beginning of an optional sequence within an %bif%b
*F if <body> ; else ; <body of else> ; endif
*D The %belse%b shell command is used in conjunction with the
%bif%b command to mark the start of the sequence of commands to be
executed if the `if' expression evaluates to zero.
*q Shell commands
*k Shell scripts
*q else
*x if
#
*n emacs\Helios command
*P Runs the MicroEMACS editor
*q MicroEMACS editor
*q Editor, MicroEMACS
*q Text editor, MicroEMACS
*F emacs [<filename>]
*D This command enters the MicroEMACS editor, the default
screen editor. The optional %sfilename%s is the name of an existing file
that you wish to edit. If you give the command %bemacs%b without
specifying %sfilename%s, MicroEMACS creates a new, untitled file.
*p MicroEMACS allows you to use a named area of memory, called a buffer. A
memory buffer can contain zero or more characters of text. You may have
more than one buffer in use at any one time, and you can switch between
them whenever you wish.
*p Each memory buffer is associated with the name of a file. This means
that if you read in the contents of a memory buffer from another file, or
if you write the contents of a memory buffer to another file, then its
associated filename will also appear on the status line at the bottom of
the screen.
*p You can get on-line help from within the editor by pressing the ESC key
and then typing a question mark (ESC+?).
*p For further infomation on running this editor, read the guide to the
MicroEmacs editor supplied with the Helios Operating System.
*q emacs
*k Memory buffer
*q MicroEmacs
*q Editing files
*x more
*x setenv
#
*n Empty-directory\General interest
*P Describes a directory containing no links, other than for `dot'
and `dot-dot'
*D Usually, a directory will contain a number of objects that
associate a filename with a file. You may have more than one of these
objects, directory entries or links, that refer to one filename (see
%bln%b). An empty directory is a condition where the only directory
entries are for the special names `dot' and `dot-dot'.
*q Empty directory
*q Filename links
*q Directory entries
*x ln
*x dot
*x dot-dot
#
*n Empty-string\General interest
*P Describes a character array whose first element is NULL
*D An empty string is a character array whose first element is
NULL. It is also known as a %sNull string%s.
*q Null string
*q Empty string
#
*n EnableEvents\System library
*P Obtains control over a particular type of input/output event
*I <syslib.h> ; <ioevents.h>
*F Port EnableEvents( Stream *stream, WORD type );
*A stream - Stream to the device
*A type - Event to be enabled
*R Message port; NullPort indicates failure.
*D This function forms part of the Helios event mechanism. To
receive event messages from a device you must enable the event, using an
open Stream to the device and specifying the type of event to enable such
as Event_Mouse. The events are all provided in the header file
<ioevents.h>. The function returns a message port to which the device will
send event messages. The device will continue sending event messages to
this port until the stream is closed, or until the event is disabled, or
until some other task or process enables the same event.
%bEnableEvents()%b may be used to disable events by using 0 as the type of
event.
*q Event handling
*q I/O event handling
*x NegAcknowledge
*x Acknowledge
#
*n EnableLink\System library
*P Enables a link for message passing
*I <link.h>
*F WORD EnableLink( word linkno );
*A linkno - Link to be enabled
*R Error code on failure; zero on success.
*D This function causes the given link to be enabled for
message passing. The link should connect two processors which have already
been booted via other means. Like %bBootLink()%b, this function is present
mainly for the use of the network server.
*q Enable link for message passing
*q Message passing, enable link for
*q Link, enable - see EnableLink
*q Network server
*x BootLink
#
*n EncodeCapability\System library
*P Converts string to capability
*I
*F char *EncodeCapability(char *s, Capability *cap);
*A s - string to encode
*A cap - destination capability
*D The first seventeen characters of string %bs%b should have
been created by %bDecodeCapability%b and should consist of an '@'
character followed by sixteen bytes of ascii-hex. These bytes are
converted back into a capability.
*x DecodeCapability
*q EncodeCapability
#
*n EncodeMatrix\System library
*P Converts a string representation of a matrix into binary form
*I <syslib.h> ; <protect.h>
*F Matrix EncodeMatrix( string str, word type );
*A str - String representation of matrix.
*A type - Type of matrix owner
*R Encoded matrix.
*D The string representation of a matrix consists of the
access masks for the V, X, Y and Z categories listed in order separated by
colons; for example,
*c=darw:arw:rw:r
*q Access-matrix
*q Access mask
#
*n end\Helios command
*P Terminates a command flow construct
*F foreach | while ; <body of loop> ; end
*D The %bend%b shell command is used to terminate the body of
%bforeach%b or %bwhile%b loop commands.
*q Shell commands
*q Terminating loops
*q end
*k Shell scripts
*x foreach
*x while
#
*n endif\Helios command
*P Terminates an %bif%b statement
*F if ( <expression> ) then ; <body of if> ; endif
*D The %bendif%b shell command is used to terminate the body
of %bif%b statements.
*q Shell commands
*q Terminating loops
*q endif
*k Shell scripts
*x else
*x if
#
*n endsw\Helios command
*P Terminates a %bswitch%b statement
*F switch ; <body of switch> ; endsw
*D The %bendsw%b shell command terminates the body of a
%bswitch%b statement.
*q Shell commands
*q switch
*q Terminating switch statements
*q endsw
*k Shell scripts
*x breaksw
*x case
*x default
*x switch
#
*n environ\Posix library function
*P Initialised as a pointer to an array of character pointers to
environment strings
*I <posix.h>
*F char **environ;
*A **environ - pointer to an array of character pointers to
environment strings
*D %benviron%b is an external variable initialised as a
pointer to an array of character pointers to environment strings. This
array is terminated by a Null pointer. The functions %bexecl()%b,
%bexecv()%b, %bexeclp()%b, and %bexecvp()%b take the environment for the
new process image from the %benviron%b variable in the calling process.
*q environ
#
*n Environment\General interest
*P Defines the conditions in which your commands will execute
*D The environment variables are a set of defined variables
that describe the conditions in which your commands will execute. For
example, the PATH environment variable sets up your default search path,
the TERM environment variable sets up your terminal's characteristics, the
EDITOR environment variable sets up your default editor (see %bmore%b),
and so on. Environment variables can be set up with %bsetenv%b and removed
with %bunsetenv%b. The login shell will find your default set in the file
%s.login%s or %sloginrc%s.
*p A full list of environment variables is given in the Helios Shell
document in the Helios Operating System manual.
*q Default search path
*q Environment
*q USER environment variable
*q Environment variable, USER
*q PATH environment variable
*q Environment variable, PATH
*q EDITOR environment variable
*q Environment variable, EDITOR
*q HOME environment variable
*q Environment variable, HOME
*q SHELL environment variable
*q Environment variable, SHELL
*q TERM environment variable
*q Environment variable, TERM
*x more
*x setenv
*x unsetenv
#
*n errno\Posix library function
*P Holds the error number of the error provoked by the last
function to set it
*I <errno.h> <posix.h>
*F int errno;
*D %berrno%b is an external variable whose value is an error
number. Most functions set errno on failure.
*p If a function provokes more than one error, errno will be set to the
error number of one of these errors; it is not defined which one.
*p The following table lists all the error numbers recognized by Helios,
their corresponding symbolic names and the actual error to which they
refer. Notice that you should always use the symbolic names in programs if
you wish your code to be portable; the names are standard and are used for
all systems that are compatible with the Posix standard 1003.1, but the
error numbers are specific to this implementation of the system (see the
%serrno.h%s header file).
*f Error number\Symbolic name\Error
*f 0\EZERO\No error
*f 1\E2BIG\Arg list too long
*f 2\EACCES\Permission denied
*f 3\EAGAIN\Resource temporarily unavailable
*f 4\EBADF\Bad file number
*f 5\EBUSY\Resource busy
*f 6\ECHILD\No child processes
*f 7\EDEADLK\Resource deadlock would occur
*f 8\EDOM\Domain error
*f 9\EEXIST\Already exists
*f 10\EFAULT\Bad address
*f 11\EFBIG\File too large
*f 12\EINTR\Interrupted system call
*f 13\EINVAL\Invalid argument
*f 14\EIO\Input/output error
*f 15\EISDIR\Wrong operation applied to directory
*f 16\EMFILE\Too many open files
*f 17\EMLINK\Too many links
*f 18\ENAMETOOLONG\Filename too long
*f 19\ENFILE\Too many open files in system
*f 20\ENODEV\No such device
*f 21\ENOENT\No such file or directory
*f 22\ENOEXEC\Exec format error
*f 23\ENOLCK\No locks available
*f 24\ENOMEM\Not enough memory space
*f 25\ENOSPC\No space left on device
*f 26\ENOTDIR\Not a directory
*f 27\ENOTEMPTY\Directory not empty
*f 28\ENOTTY\Inappropriate I/O operation
*f 29\ENXIO\No such device or address
*f 30\EPERM\Operation not permitted
*f 31\EPIPE\Broken pipe
*f 32\ERANGE\Result too large
*f 33\EROFS\Read only file system
*f 34\ESPIPE\Invalid seek
*f 35\ESRCH\No such process
*f 36\EXDEV\Improper link
*p The following table lists the BSD-compatible extensions which have been
added to Helios. These mostly refer to sockets.
*f Error number\Symbolic name\Error
*f 37\EWOULDBLOCK\Operation will block
*f 38\EINPROGRESS\Operation now in progress
*f 39\EALREADY\Operation already in progress
*f 40\ENOTSOCK\Socket operation on non-socket
*f 41\EDESTADDRREQ\Destination address required
*f 42\EMSGSIZE\Message too long
*f 43\EPROTOTYPE\Protocol wrong type for socket
*f 44\ENOPROTOOPT\Bad protocol option
*f 45\EPROTONOSUPPORT\Protocol not supported
*f 46\ESOCKTNOSUPPORT\Socket type not supported
*f 47\EOPNOTSUPP\Operation not supported on socket
*f 48\EPFNOSUPPORT\Protocol family not supported
*f 49\EAFNOSUPPORT\Address family not supported
*f 50\EADDRINUSE \Address already in use
*f 51\EADDRNOTAVAIL\Cannot assign requested address
*f 52\ENETDOWN\Network is down
*f 53\ENETUNREACH\Network is unreachable
*f 54\ENETRESET \Network dropped connection on reset
*f 55\ECONNABORTED\Software caused connection abort
*f 56\ECONNRESET \Connection reset by peer
*f 57\ENOBUFS\No buffer space available
*f 58\EISCONN\Socket is already connected
*f 59\ENOTCONN\Socket is not connected
*f 60\ESHUTDOWN\Cannot send after shutdown
*f 61\ETIMEDOUT\Connection timed out
*f 62\ECONNREFUSED\Connection refused
*f 63\EHOSTDOWN\Host is down
*f 64\EHOSTUNREACH\No route to host
*f 64\MAX_PERROR \Maximum posix error code
*q Error numbers
*q errno
*q Error messages
*q Symbolic names of errors
*q Errors, symbolic names of
#
*n Error-logger device\General interest
*P Provides a destination for debugging information
*F /logger
*D Text sent to the /logger device is diverted to a file, the
I/O server window, or both. The default output destination is the screen,
but this can be changed by including the entry %slogging_destination%s
within the %shost.con%s file. If you are on a PC-hosted system, you can
alter the current destination by pressing CTRL-SHIFT-L; this sequence
makes the I/O server cycle between the available options. All information
sent to a file goes to %s/helios/logfile%s by default, although you can
specify a different filename by altering the %slogfile%s entry in the
%shost.con%s file.
*p /logger is used by all programs that call the system function call
%bIOdebug()%b.
*p %bNote:%b CTRL-SHIFT-L is PC specific. If you have a SUN-hosted system,
you can click the mouse on a button. On some systems (for example, the
miniserver system), logging can only go to the screen. The whole manner
error logging is essentially machine specific.
*q host.con
*q Configuration-file
*q Debugging information
*q Devices
#
*n ErrorMsg\System library
*P Returns an error message to the given reply port
*I <servlib.h>
*F void ErrorMsg(MCB *mcb, word err);
*A mcb - pointer to MCB
*A err - error code
*D %bErrorMsg()%b returns an error message to the reply port
given in the MCB. The error code is ORed with the FnRc field already
contained in the MCB. This operation corrupts the MCB.
*q ErrorMsg
#
*n Errors\General interest
*P Error reporting
*D Helios reports errors in two ways: either as a Posix error
code, or as a Helios error. Posix error codes are small integers as
defined by the Posix standard. Helios errors are 32-bit numbers divided
into fields which identify different parts of the error:
*c=1 CC SSSSS GGGGGGGG EEEEEEEEEEEEEEEE
*p The Cs indicate the class of the error (that is, 01 for Warning, 10 for
Error, and 11 for Fatal error), the Ss indicate the subsystem identifier,
the Gs indicate the general error code, and the Es indicate the specific
or object error code.
*p Both types of error may be decoded using the Helios fault library or the
Helios command %bfault%b. For further details on Helios error codes, you
could also look at the code.h header file.
*q Error construction
*q Faults
*x fault
#
*n eval\Helios command
*P Evaluates and executes specified arguments in the shell
*F eval <arg> [<arg>...]
*D The %beval%b shell command executes commands generated by
command or variable substitution. It reads in the argument(s) (%sarg%s) as
input to the shell and then executes the result according to the context
of the current shell. In other words, it allows for the re-evaluation of
variables. Here is a simple example:
*c=%set fred=\$bill
*c=%echo $fred
*c=$bill
*c=%set bill=hello
*c=%eval echo $fred
*c=hello
*q Shell commands
*q eval
*k Shell variable substitution
*k Shell command substitution
*q Re-evaluation of variables
*k Executing shell commands generated by substitution
#
*n exec\Helios command
*P Executes a command in place of the shell
*F exec <command>
*D The %bexec%b shell command terminates the shell and
executes %scommand%s in its place. If you have previously created another
shell, you can select that shell and continue working; otherwise, if no
other shell exists for you to select, you will be left shell less.
However, on most systems, if the shell that is terminated is your login
shell then the current session will terminate and another login will
appear, thereby enabling you to log in again for a new session.
*p Notice that %bexec%b does not use the `path' variable.
*q Shell commands
*q exec
*q Executing commands
*q Terminating the shell
#
*n execl\Posix library function
*P Executes a file
*I <posix.h> ; <unistd.h>
*F int execl (char *path, ... );
*A path - Pointer to the pathname that identifies the new task
image file.
*R If successful, there is no return; the new task image overlays
the calling task image. If it fails, it returns the value -1 and sets
errno to indicate the error.
*E
*l [E2BIG]
*t The number of bytes used by the argument list and environment list of
the new task image is greater than the limit set.
*l [EACCES]
*t Search permission is denied for a directory included in the path prefix
of the new task image file, the new file is not a regular file, or the new
task image file refuses to give execution permission.
*l [ENOENT]
*t One or more components of the path name of the new task image file do
not exist.
*l [ENOEXEC]
*t The new task image file has access permission, but not in the proper
format.
*l [ENOTDIR]
*t A component of the path prefix of the new task image is not a directory.
*l [ENAMETOOLONG]
*t The length of %spath%s or %sfile%s is greater than the limit set.
*l [ENOMEM]
*t There is not enough memory available for the new task image.
*D %bexecl()%b is a member of the %bexec()%b family of
functions. It replaces the current task image with a new task image. This
new image is constructed from a regular, executable file called the new
task image file.
*p If this call results in a C program being executed, then it should be
entered as a C language procedure call as follows:
*c=extern char **environ;
*c=int main (argc, argv)
*c=int argc;
*c=char **argv;
*p where %sargc%s is the argument count (>=1), %sargv%s is an array of
character pointers to the arguments, and %senviron%s is an array of
character pointers to the environment strings.
*p The arguments specified by a program with one of the %bexec()%b
functions are passed on to the new task image in the corresponding
%bmain()%b arguments.
*p %bexecl()%b takes its environment from the variable %senviron%s.
*p The number of bytes available for the combined argument and environment
lists of the new task is set to ARG_MAX.
*p File descriptors that are open in the calling task image remain open in
the new task image, except those whose close-on-exec flag FD_CLOEXEC is
set (see %bfcntl()%b). For those file descriptors that remain open, the
file pointer is unchanged.
*p File locks held by a task are not affected by the %bexec()%b family of
functions.
*p Signals set to the default action (SIG_DFL) in the calling task image
are set to the default action in the new task image. Signals set to be
ignored (SIG_IGN) by the calling task are set to be ignored by the new
task image. Signals set to be caught by the calling task, however, are set
to the default action in the new task image (see %bsignal()%b).
*p If the set-user-ID mode bit of the new task image file is set (see
%bchmod()%b), the effective user id of the new task image is set to the
owner ID of the new task image file. In the same way, if the set-group-ID
mode bit of the new task image file is set, then the effective group ID of
the new task image is set to the group ID of the new task image file. The
real user ID, real group ID, and supplementary group IDs of the new task
image remain the same as those of the calling task image. If
HELIOS_SAVED_IDS is defined, the effective user ID and effective group ID
of the new task will be saved (as %ssaved%s %sset-user-ID%s and %ssaved%s
%sset-group-ID%s) for use by the %bsetuid()%b function.
*p The new task image also inherits at least the following attributes from
the calling task image: task ID; parent task ID; task group ID; tty group
ID; time left until an alarm clock signal (see %balarm()%b); current
working directory; root directory; file mode creation mask (see
%bumask()%b); %stms_utime%s, %stms_stime%s, %stms_cutime%s, and
%stms_cstime%s (see %btimes()%b).
*q times
*q signal
*q New task image
*q Task file locks
*q fcntl
*q execl
*q File locks
*q exec
*q New task image - inherited attributes
*q chmod
*x alarm
*x chmod\000075
*x execle
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*x fcntl
*x signal\000564
*x stat
*x times
*x umask
*x vfork
*q Executing a file
*q File execution
*q exec
*q execl
*q New task image
*q exec
*q New task image file
*q Task image file
*q main()
#
*n execle\Posix library function
*P Execute a file
*I <posix.h> ; <unistd.h>
*F int execle (char *path,...);
*A path - Pointer to the pathname that identifies the new task
image file.
*D %bexecle()%b is a member of the %bexec()%b family of
functions. For a full description of the action of this family, see
%bexecl()%b.
*q New task image
*q exec
*x alarm
*x chmod\000075
*x execl
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*x fcntl
*x signal\000564
*x stat
*x times
*x umask
*x vfork
*q Executing a file
*q File execution
*q New task image
#
*n execlp\Posix library function
*P Executes a file
*I <posix.h> ; <unistd.h>
*F int execlp (char *file,...);
*A file - Pointer to the new task image file. If %sfile%s does
not contain a slash (/) character, its path prefix is obtained by
searching the directories passed as the environment variable PATH.
*D %bexeclp()%b is a member of the %bexec()%b family of
functions. See %bexecl()%b for further details.
*q exec
*x alarm
*x chmod\000075
*x execl
*x execle
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*x fcntl
*x signal\000564
*x stat
*x times
*x umask
*x vfork
*q Executing a file
*q File execution
#
*n ExecProcess\System library
*P Launches a process prepared by %bNewProcess()%b
*I <process.h>
*F void ExecProcess(void *args, word logpri);
*A args - result of NewProcess()
*A logpri - logical priority level
*D Launches a process prepared via the %bNewProcess()%b
function. This function is only of use to systems programmers.
*q ExecProcess
*x RunProcess
*x NewProcess
#
*n Execute\System library
*P Executes a program on the processor controlled by the given
manager.
*I <syslib.h>
*F Object *Execute ( Object *controller, Object *name )
*A controller - Pointer to processor manager or Task Force
Manager.
*A name - Object pointer for program to be run.
*R Object structure for the new task or NULL if an error occurred.
*D This function runs a program under the Task Force Manager
or on the processor controlled by the specified processor manager. If the
controller field is NULL, %bExecute()%b executes the program locally. (See
%bLocate()%b for an example of the Object structure.)
*q Locate
*q Object structure
*q Program, execute
#
*n execv\Posix library function
*P Executes a file
*I <posix.h> ; <unistd.h>
*F int execv (char *path, char **argv);
*A path - Pointer to the pathname that identifies the new task
image file.
*A argv - An array of character pointers to the arguments.
*D %bexecv()%b is a member of the %bexec()%b family of
functions. See %bexecl()%b for a fuller description of the action of this
family.
*p %bexecv()%b takes its environment from the variable %senviron%s.
*q Executing a file
*q File execution
*x execl
*x execle
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*q exec
*q New task image file
*q Task image file
#
*n execve\Posix library function
*P Executes a file
*I <posix.h> ; <unistd.h>
*F int execve (char *path, char **argv, char **envv);
*A path - Pointer to the pathname that identifies the new task
image file.
*A argv - An array of character pointers to null-terminated
strings, the last member of which is a NULL pointer. These strings make up
the argument list available to the new task image. The value in argv[0]
should point to a filename that is associated with the task being started
by %bexecve()%b.
*A envv - Array of character pointers to null-terminated strings
that make up the environment of the new task image. It is terminated by a
NULL pointer.
*D %bexecve()%b is a member of the %bexec()%b family of
functions. For a fuller description of the action of this family, see
%bexecl()%b.
*q Executing a file
*q File execution
*q exec
*x alarm
*x chmod\000075
*x execl
*x execle
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*x fcntl
*x signal\000564
*x stat
*x times
*x umask
#
*n execvp\Posix library function
*P Executes a file
*I <posix.h> ; <unistd.h>
*F int execvp (char *file, char **argv);
*A file - Pointer to the new task image file. If %sfile%s does
not contain a slash (/) character, its path prefix is obtained by
searching the directories passed as the environment variable PATH.
*A argv - An array of character pointers to null-terminated
strings, the last member of which is a NULL pointer. These strings make up
the argument list available to the new task image. The value in argv[0]
should point to a filename that is associated with the task being started
by %bexecve()%b.
*D %bexecvp()%b is a member of the %bexec()%b family of
functions. See %bexecl()%b for further details.
*q exec
*q Executing a file
*q File execution
*x alarm
*x chmod\000075
*x execl
*x execle
*x execv
*x execve
*x execlp
*x execvp
*x _exit
*x fcntl
*x signal\000564
*x stat
*x times
*x umask
#
*n Exit\System library
*P Terminates a task
*I <syslib.h>
*F void Exit ( WORD code );
*A code - Termination code
*R Does not return.
*D This function terminates a task. It returns all resources
and applies %bClose()%b to all associated streams. It calls %bAbort()%b on
all objects and streams before freeing them. If you mix Helios C Library
calls with Helios calls, you should use the C Library %bexit()%b function
in preference to %bExit()%b. This is to ensure that open file are flushed
and closed.
*q Terminate task
*q Task, terminate - see Exit
*q Close
*q Abort
*q C library calls
*q exit
*q Exit
*x exit\000189
*x Abort
*x Close
#
*n exit\C library function
*P Causes normal program termination
*I <stdlib.h>
*F void exit(int status);
*A status - Specifies the type of exit (success or failure).
*R %bexit()%b does not return.
*D %bexit()%b causes normal program termination. The
termination sequence is as follows:
*p 1. The functions recorded by %batexit()%b are called in reverse order.
*p 2. All open output streams are flushed.
*p 3. All open streams are closed.
*p 4. All files created by %btmpfile%b are removed.
*p 5. Control is returned to the host environment.
*p The value of %sstatus%s affects the type of termination. If %sstatus%s
is zero or equal to EXIT_SUCCESS a successful termination is performed. If
%sstatus%s is equal to EXIT_FAILURE an unsuccessful termination is
performed.
*x atexit\000036
*x Exit
*q exit
*q Termination of program
*q Program termination
#
*n exit\Helios command
*P Exits the shell
*F exit [ <expression> ]
*D The %bexit%b command allows you to exit the shell. If you
give the optional expression, %sexpression%s, %bexit%b exits with the
value of that expression; otherwise, if you give %bexit%b on its own, it
exits with the value of the shell variable %sstatus%s. For example,
*c=exit 1
*p exits the shell with 1 as its return code.
*q exit
*q Shell commands
*q Leaving the shell
*q Terminating the shell
#
*n exit\Posix library function
*P Causes a normal program termination
*I <stdlib.h>
*F void exit(int status);
*A status - Specifies the type of exit (success or failure).
*R Nothing
*D %bexit()%b causes normal program termination. The
termination sequence is as follows:
*l 1.
*t Call the functions recorded by %batexit()%b in reverse order.
*l 2.
*t Flush all open output streams.
*l 3.
*t Close all open streams.
*l 4.
*t Return control to the host environment.
*p The value of %sstatus%s affects the type of termination. If %sstatus%s
is zero or equal to EXIT_SUCCESS a successful termination is performed. If
%sstatus%s is equal to EXIT_FAILURE an unsuccessful termination is
performed.
*q atexit
*q Termination of program
*q Program termination
*x Exit
#
*n _exit\Posix library function
*P Terminates the calling task with certain consequences
*I <posix.h> ; <unistd.h>
*F void _exit(int code);
*A code - Specifies the type of exit (success or failure)
*R %b_exit()%b cannot return to its caller.
*D %b_exit()%b terminates the calling task. The consequences
of this function are as follows, regardless of the reason for the
termination:
*l 1.
*t All open file descriptors in the calling task are closed.
*l 2.
*t If the parent task of the calling task is executing a %bwait()%b, the
calling task's termination is reported to the parent and the low order 8
bits of %scode%s are made available to it.
*l 3.
*t If the parent task is not executing a %bwait()%b, the exit %scode%s code
is saved for returning to the parent task whenever it executes a
subsequent %bwait()%b.
*l 4.
*t The termination of a parent task does not affect its children; they are
not terminated.
*q Termination of program
*q Program termination
*x exit\000191
*x abort\000006
*x close
*x wait
#
*n exp\C library function
*P Calculates the exponential function of the argument
*I <math.h>
*F double exp(double x);
*A x - A number
*R the exponential function of %sx%s.
*E A range error occurs if the result of raising e to the power of
%sx%s would cause overflow. In this case %bexp()%b returns the value
HUGE_VAL (with the same sign as the correct value of the function) and
errno is set to ERANGE.
*D %bexp()%b calculates the value of the constant e
(2.71828...) raised to the power of %sx%s.
*q exp
*q Calculates exponential
*q Exponential - see exp
#
*n Expressions\General interest
*P Similar to C language regular expressions
*D A number of shell built-in commands can take expressions as
arguments. These expressions may be constructed using arithmetic and
logical operators which are similar to those used in the C programming
language.
*p In the following list the order of operator precedence increases from
left to right, with square brackets indicating groups of operators of
equal precedence:
*c=|| && | ^ & [== != =~ !~] [<= >= < >] [<< >>] [+ -] [* / %] ! ~ [( )]
*p In cases where operators of the same precedence occur several times,
they are evaluated left to right.
*p Here is a full list of valid operators:
*l Operator
*t Description
*l %b||%b
*t logical OR
*l %b|%b
*t bitwise OR
*l %b^%b
*t bitwise eXclusive OR (XOR)
*l %b&&%b
*t logical AND
*l %b&%b
*t bitwise AND
*l %b==%b
*t equivalent
*l %b!=%b
*t not equivalent
*l %b=~%b
*t tests for match with specified pattern
*l %b!~%b
*t tests for no match with specified pattern
*l %b!%b
*t logical NOT
*l %b~%b
*t bitwise NOT
*l %b<=%b
*t less than or equal to
*l %b>=%b
*t greater than or equal to
*l %b<%b
*t less than
*l %b>%b
*t greater than
*l %b>>%b
*t shift right
*l %b<<%b
*t shift left
*l %b+%b
*t addition
*l %b-%b
*t subtraction
*l %b/%b
*t division
*l %b*%b
*t multiplication
*l %b%%%b
*t modulus
*q Expressions
*q Operator precedence
*q Precedence of arithmetic/logical operators
*q || logical OR operator
*q | bitwise OR operator
*q ^ bitwise XOR operator
*q && logical AND operator
*q & bitwise AND operator
*q == test for equivalence
*q != test for non-equivalence
*q =~ operator
*q !~ operator
*q ! logical NOT operator
*q ~ bitwise NOT operator
*q <= operator
*q >= operator
*q < less than operator
*q > greater than operator
*q Shift right operator
*q >> shift right operator
*q Shift left operator
*q << shift left operator
*q + addition operator
*q - subtraction operator
*q / division operator
*q %% modulus operator
*q * multiplication operator
*x Wildcards
#
*n fabs\C library function
*P Calculates the absolute value of a floating point number
*I <math.h>
*F double fabs(double x);
*A x - A number
*R the absolute value of the argument.
*D %bfabs()%b calculates the absolute value of %sx%s.
*q fabs
*q Calculate absolute value of floating point number
*q Floating point number, absolute value of
*q Absolute value of floating point number - see fabs
#
*n false\Helios command
*P Generates a FALSE condition
*F false
*D The %bfalse%b command returns the status value FALSE
(non-zero) from a dummy program to say that it has failed. It is mainly
used in Shell scripts.
*p %bfalse%b is the converse of %btrue%b.
*q false
*q Shell scripts
*x true
#
*n Fault\System library
*P Searches the fault database
*I <fault.h>
*F void Fault(word code, char *msg, word msize);
*A code - error code
*A msg - pointer to message buffer
*A msize - size of message buffer
*D This function searches the standard fault database in
%s/helios/etc/faults%s. The %scode%s argument is an error code. If the
value of this argument is less than zero it is interpreted as a Helios
error code. A code greater than or equal to zero is treated as a Posix
error code or a Helios function code. %smsg%s and %smsize%s specify the
message buffer and its size. The error message is added into this buffer
as a null-terminated string, which is truncated if it is too big to fit in
a buffer of %smsize%s.
*p A fault database is an ASCII file that is organized into lines. Any line
beginning with a # is ignored. Numerical values may be given in decimal or
in hex, where they are preceded by 0x. A line beginning with a ! is a
class description: the first field is the class name, the second a mask
indicating the bits that class occupies and the third optional field gives
the C header prefix. A class ends with a line containing just !!.
*p Within a class, each line consists of a code name, a code value, and an
optional message string. If the message string is not present, the code
name is used.
*q Error messages
*q Error codes
*q Hex values
*q Fault
*q Fault database, search
#
*n fault\Helios command
*P Interprets return codes
*F fault [<code>] ...
*D The %bfault%b command provides an English error message for
each Helios or Posix error code specified as an argument. If no arguments
are provided %bfault%b decodes the value of the shell variable `error'.
*q Shell commands
*q fault
*q Error messages
*q Error codes
#
*n Fault-library\General interest
*P Provides a database of error codes and their meanings
*D The fault library contains a number of routines for
searching a fault database for matching fault and error codes. The Helios
function call %bFault()%b searches the standard fault database in
%s/helios/etc/faults%s; alternatively, you can use the Posix functions
%bfdbopen()%b %bfdbrewind()%b, %bfdbfind()%b and %bfdbclose()%b.
*p A fault database is an ASCII file organized in lines. Lines beginning
with a # are ignored. Numerical values may be given in hex or in decimal;
hex values must be preceded by 0x. Lines beginning with a ! character
introduce a class description: the first field contains the class name,
the second a mask indicating the bits that class occupies and the third,
optional field specifies the C header prefix. A class description ends
with a line containing just !!.
*q Fault library
*q Fault database
*x fault
*x Fault
*x fdbopen
*x fdbclose
*x fdbrewind
*x fdbfind
*x Error-logger
#
*n fclose\C library function
*P Closes a file stream
*I <stdio.h>
*F int fclose(FILE *stream);
*A stream - A pointer to the file stream
*R zero if the close was successful and non-zero if it was not.
*D %bfclose()%b closes the file stream pointed to by
%sstream%s. The stream and any associated buffers are flushed. Any buffer
which was allocated by the I/O system is deallocated. Buffer data which is
waiting to be written is sent to the host environment for writing to the
file. Buffer data which is waiting to be read is ignored. All open files
are closed when %bexit()%b is called.
*q exit
*q I/O system
*q fclose
*q Closing a file stream
*q File stream - closing
*q Stream - closing
*x fopen
#
*n fcntl\Posix library function
*P Controls open files
*I <sys/types.h> ; <unistd.h> ; <fcntl.h>
*F int fcntl (int fd, int cmd,...);
*A fd - File descriptor of an open file
*A cmd - Constant defined in <fcntl.h> (see below)
*R A value that depends on the value of %scmd%s on successful
completion: if %scmd%s is F_DUPFD, it returns a new file descriptor; if
%scmd%s is F_GETFL, it returns the value of the file status flags and
access modes; if %scmd%s is any other valid value, it returns a value
other than -1. On failure, it returns -1 and sets errno to indicate the
error that occurred.
*E
*l [EACCES]
*t %scmd%s is F_SETLK, the type of lock (l_type) is a shared lock (F_RDLCK)
or exclusive lock (F_WRLCK), and the segment of a file to be locked is
already exclusive-locked by another task, or the type is an exclusive lock
and the segment of a file to be locked is already shared-locked or
exclusive-locked by another task.
*l [EBADF]
*t %sfd%s is not a valid file descriptor, the lock type is `shared' and
%sfd%s is not open for reading, or the lock type is `exclusive' and %sfd%s
is not open for writing.
*l [EINTR]
*t %scmd%s is F_SETLKW and the function was interrupted by a signal.
*l [EINVAL]
*t %scmd%s is F_DUPFD and %sarg%s is negative or greater than or equal to
OPEN_MAX, or %scmd%s is F_GETLK, F_SETLK, or F_SETLKW and the data %sarg%s
points to is not valid, or %sfd%s refers to a file that does not support
locking.
*l [EMFILE]
*t %scmd%s is F_DUPFD and OPEN_MAX file descriptors are currently in use by
this task.
*l [EDEADLK]
*t %scmd%s is F_SETLKW and a deadlock condition has occurred.
*D This function provides control over open files. The file to
be controlled is specified by the file descriptor %sfd%s. The value
returned by %bfcntl()%b depends on the value of the argument %scmd%s.
Valid values for %scmd%s are defined in the header file <fcntl.h> as
follows:
*f F_DUPFD\1\Duplicate file descriptor
*f F_GETFD \2\Get file descriptor flags
*f F_GETLK\4\Get record locking info
*f F_SETFD \4\Set file descriptor flags
*f F_GETFL\5\Get file status flags
*f F_SETFL \6\Set file status flags
*f F_SETLK\7\Set record locking info
*f F_SETLKW\8\Set record locking info and wait
*p Valid file access modes are defined to be as follows:
*f O_RDONLY\0x0001\Open for read only (file access mode)
*f O_WRONLY\0x0002\Open for write only (file access mode)
*f O_RDWR \0x0003\Open for read and write (file access mode)
*f O_CREAT\0x0100\Create file if file does not exist
*f O_EXCL\0x0200\Return error if file exists
*f O_TRUNC\0x0400\Truncate file size to 0
*f O_NONBLOCK\0x0800\No blocking
*f O_APPEND \0x1000 \Append each write (move pointer to EOF)
*f O_NOCTTY\0x4000\No controlling terminal
*f O_ACCMODE\0x0003\Mask for file access modes
*p Valid file descriptor flags are:
*f FD_MASK\0x0000ffff\bits that can be set by the user
*f FD_CLOEXEC\0x00008000\close file on exec()
*f FD_ALLOC \0x00010000\file descriptor allocated
*q File control
*q Open file control
*x close
*x exec
*x open
*x creat
*x signal\000564
#
*n fdbclose\System library
*P Closes a private fault database
*I <fault.h>
*F void fdbclose(FDB *fdb);
*A fdb - pointer to private fault database
*D This low-level procedure closes the fault database
indicated by %sfdb%s.
*x fdbopen
*x fdbfind
*x fdbrewind
*x Fault
*q fdbclose
*q Fault database, close
#
*n fdbfind\System library
*P Searches the private fault database for an entry
*I <fault.h>
*F int fdbfind(FDB *fdb, char *class, word code, char *text, int
tsize);
*A fdb - pointer to private fault database
*A class - name of fault class to be searched
*A code - error code to be searched for
*A text - pointer to error message buffer
*A tsize - size of error message buffer
*D This low-level procedure searches the fault database
indicated by %sfdb%s for error %scode%s in class %sclass%s (only bits of
value %scode%s that match the fault class entry's mask field are
compared). The last two arguments describe a buffer. The message
corresponding to the code will be concatenated onto the end of the
existing buffer contents, but only if the remaining space in the buffer is
large enough.
*x fdbopen
*x fdbclose
*x fdbrewind
*x Fault
*q fdbfind
#
*n fdbopen\System library
*P Opens a private fault library
*I <fault.h>
*F FDB *fdbopen(string name);
*A name - filename
*E Returns NULL.
*D This low-level procedure attempts to open the file
specified as %sname%s as a fault database.
*x fdbclose
*x fdbrewind
*x fdbfind
*x Fault
*q fdbopen
#
*n fdbrewind\System library
*P Repositions the search point in a private fault library
*I <fault.h>
*F void fdbrewind(FDB *fdb);
*A fdb - pointer to fault library
*D The fault database can only be searched forwards, therefore
you must use this low-level procedure to reset the search point to the
start of the file.
*x fdbclose
*x fdbopen
*x fdbfind
*x Fault
*q fdbrewind
*q Rewind fault database
#
*n fdstream\Posix library function
*P Returns a Helios stream corresponding to a file descriptor
*I <unistd.h>
*F Stream *fdstream(int fd);
*A fd - file descriptor
*D The Helios Stream corresponding to the given file
descriptor is returned, or NULL if the descriptor is invalid. Note that
the same Stream may be referenced by several different file descriptors.
*x sopen
*x svopen
*x getenviron
*q fdstream
*q Helios posix extensions
#
*n feof\C library function
*P Tests the state of the end-of-file indicator
*I <stdio.h>
*F int feof(FILE *stream);
*A stream - A pointer to a file stream
*R zero if the end-of-file indicator is clear, and non-zero if it
is set.
*D %bfeof()%b tests the state of the end-of-file indicator for
the file stream %sstream%s. It returns zero if the end-of-file indicator
is clear, and non-zero if it is set.
*x ferror
*q feof
*q Test state of eof indicator
*q Eof indicator, test state of
#
*n ferror\C library function
*P Tests the state of the file error indicator
*I <stdio.h>
*F int ferror(FILE *stream);
*A stream - A pointer to a file stream
*R zero if the end-of-file indicator is clear, and non-zero if it
is set.
*D %bferror()%b tests the state of the error indicator for the
file stream %sstream%s. It returns zero if the error indicator is clear,
and non-zero if it is set.
*x perror
*x feof
*q ferror
*q Test state of file error indicator
*q File error indicator, test state of
*q Error indicator - file
#
*n fflush\C library function
*P Flushes an output stream
*I <stdio.h>
*F int fflush(FILE *stream);
*A stream - A pointer to the stream to be flushed
*R a non-zero value if a write error occurred.
*E If a write error occurs, %bfflush()%b returns a non-zero value.
*D If %sstream%s points to an output stream, %bfflush()%b
causes any outstanding data for the stream to be written to the file. If
%sstream%s points to an input stream, %bfflush()%b undoes the effect of
any preceding %bungetc()%b operation on the stream.
*x ungetc
*q I/O
*q fflush
*q Flushing an output stream
*q Output stream - flushing
#
*n fgetc\C library function
*P Reads a character from a file stream
*I <stdio.h>
*F int fgetc(FILE *stream);
*A stream - A pointer to a file stream
*R the next character from the file stream.
*E If the next character is the end-of-file character, or a read
error occurs, %bfgetc()%b returns EOF.
*D %bfgetc()%b returns the next character from the opened file
identified by the file stream pointer %sstream%s, and moves the read/write
position for the file stream as appropriate.
*x fgets
*x fputc
*x getc
*q fgetc
*q Read character from file stream
*q Character, read from file stream
*q File stream, read character from
#
*n fgetpos\C library function
*P Gets the position of the read/write file pointer
*I <stdio.h>
*F int fgetpos(FILE *stream, fpos_t *pos);
*A stream - A pointer to a file stream
*A pos - A pointer to a location where the read/write file
pointer can be stored
*R zero if the operation was successful; non-zero on failure.
*E If the operation was unsuccessful, %bfgetpos()%b returns a
non-zero value.
*D %bfgetpos()%b stores the position of the read/write pointer
of the file stream %sstream%s in the location pointed to by %spos%s. This
information is in a form usable by the %bfsetpos()%b function.
*x fsetpos
*q fgetpos
*q Get position of read/write file pointer
*q Position of read/write file pointer, get
*q Read/write file pointer, get position of
*q File pointer, get position of
#
*n fgets\C library function
*P Reads a line from a file stream
*I <stdio.h>
*F char * fgets(char *s, int n, FILE *stream);
*A s - A pointer to a buffer to receive the string
*A n - The size of the array
*A stream - A pointer to a file stream
*R %ss%s if successful. If end-of-file is encountered before a
character is read, or a read error occurs, %bfgets()%b returns null.
*E %bfgets()%b returns null if end-of-file is encountered before a
character is read, or a read error occurs.
*D %bfgets()%b reads a string of a maximum (n - 1) characters
from the file stream identified by %sstream%s. %bfgets()%b stops reading
when it encounters a newline character or an end-of-file character. A
string terminating character is written into the array after the last
character read. The newline character forms part of the string.
*x fgetc
*x fputs
*x gets
*q fgets
*q Read line from file stream
*q Line, read from file stream
*q File stream, read line from
#
*n fgrep\Helios command
*P Searches a file for a given text string
*F fgrep [-vnhifpxecls] <string> <file list>
*D This command searches through all the files in %sfile list%s for the specified %sstring(s)%s. When %bfgrep%b finds a line
containing the %sstring%s it prints the name of the file and that line.
The command is normally used in conjunction with wild card matching; for
example,
*c=fgrep EC_Warn /helios/include/*.h
*p locates all the header files containing the text `EC_Warn'.
*p %bfgrep%b is a fast but simple version of the more complex command
%bgrep%b. The options available are as follows:
*l Option
*t Description
*l %b-v%b
*t Print all lines in the file, except the ones that contain %sstring%s.
*l %b-n%b
*t Print the number of the line where %sstring%s was matched.
*l %b-h%b
*t Don't print the filename(s) of the source file when a matched line is
output.
*l %b-i%b
*t Ignore the case of %sstring%s in comparisons. For example, `occam' would
be matched with `Occam' and `OCCAM'.
*l %b-f%b
*t Take a list of strings to search for from the following file. For
example,
*d fgrep -f string-file src-file
*t searches the `src-file' for occurrences of the strings supplied in the
`string-file'. The strings should be separated by newlines.
*l %b-p%b
*t Display the %sstring%s that was actually matched with the line being
displayed. This option is useful when used in conjunction with -f.
*l %b-x%b
*t Print only the lines in the source files that completely match the whole
%sstring%s. Note that you can quote the string to search for, enabling you
to include spaces and tabs in the %sstring%s to search for. For example,
*d fgrep -x 'find only these lines' src-file
*t displays only the lines in the file with the text `find only these
lines'. Note that quoted strings can be used generally, not just with the
-x option.
*l %b-e%b
*t Used to allow following %sstring%s to start with a `-' character. For
example,
*d fgrep -e --argv src-file
*t would search for --argv in `src-file', rather than giving you an unknown
option error.
*l %b-c%b
*t Just print a count of the lines that matched the %sstring%s.
*l %b-l%b
*t Just print the filenames of the files that had a match with %sstring%s.
*l %b-s%b
*t Silent mode. This option stops all output from %bfgrep%b, apart from
error messages. However, as %bfgrep%b always passes an exit code back when
it completes and this is automatically stored in the shell variable
`status', you can use it in shell scripts.
*p Status is returned as follows: if you have at least 1 match, then status
is 0; if no matches occurred, then status is 1; otherwise, if status
equals 2, an error occurred during the %bfgrep%b.
*x grep
*x egrep
*x find
*q fgrep
*q Searching for text string
*q Pattern matching
*q Finding text string
#
*n Fifo-server\General interest
*P Supports inter-task communication.
*F /fifo
*D The fifo server is a standard Helios server which
understands and interprets the message protocol (GSP). It provides a way
of communicating between tasks. In many ways it is similar to the pipe
server, except that it buffers the data in memory. This means that the
receiving task need not be ready to read the data when the sending task
writes it. Although it is not as efficient as the pipe mechanism, it does
allow sequential tasks to act as if they were parallel, storing
intermediate results from the first task until the second one is ready to
read them.
*q Servers
*q Message protocol
*q GSP
*q General Server Protocol
*x Pipe-server
#
*n File-descriptor\General interest
*P Identifies an open file for file access
*D A file descriptor, usually indicated by %sfd%s in calls, is
a non-negative integer that is unique within a task. It is used to
indicate open files for the purpose of file access.
*q File descriptor
*q fd - see File descriptor
#
*n fileno\Posix library function
*P Returns the integer file descriptor associated with %sstream%s
*I <stdio.h>
*F int fileno (FILE *stream);
*A stream - Pointer to data stream.
*R A file descriptor if successful; otherwise, it returns -1.
*D This function returns the integer file descriptor
associated with %sstream%s.
*q File descriptor
*x open
#
*n find\Helios command
*P Finds and lists files that match the given expression
*F find <pathname>...[<boolean operand expression>]
*D %bfind%b recursively descends the directory from each
%spathname%s specified, evaluating the %sboolean operand expression%s, and
lists the filenames of files for which the expression is TRUE.
*p The %sboolean operand expression%s can be composed of a combination of
commands and operands, or just commands or operands on their own. The
commands are executed if the operands evaluate to TRUE for a given file.
*p The operands accepted by %bfind%b are as follows:
*l -name %spattern%s
*t TRUE if the filename matches %spattern%s.
*l -links %sn%s
*t TRUE if the file has %sn%s links.
*l -size %sn%s [%sc%s]
*t TRUE if the file size in bytes, when divided by a predefined value and
rounded up to the next integer, is %sn%s; or TRUE if the file size is
%sn%s bytes when %sc%s is also specified.
*l -atime %sn%s
*t TRUE if the difference between the file access time and the current time
is %sn%s days.
*l -mtime %sn%s
*t TRUE if the difference between the file modification time and the
current time is %sn%s days.
*l -type %sc%s
*t TRUE if the file is of type %sc%s, where %sc%s can be d (directory), p
(FIFO), or f (file).
*l -newer %sfile%s
*t TRUE if the file has been modified more recently than the modification
time of %sfile%s
*l !%sexpression%s
*t unary NOT
*l %sexpression%s -o %sexpression%s
*t OR
*l ( %s<expression>%s )
*t TRUE if %sexpression%s is true.
*l ( %s<expression1>%s %s<expression2>%s)
*t TRUE if %sexpression1%s AND %sexpression2%s are true.
*p The commands accepted by %bfind%b are as follows:
*l -exec %scommand%s %s[%s %sarg...%s %s]%s
*t TRUE if %scommand%s returns zero. { } or - can be used to mean the
current pathname. The command must be terminated with\;
*l -ok %scommand%s %s[arg...]%s
*t Similar to -exec, but asks you to confirm execution from stdin; if not
executed, returns FALSE.
*l -print
*t (the default) always returns TRUE; writes current pathname to stdout.
*l -cont
*t Asks you to confirm continuation after first occurrence located
*p The operands and commands accepted by %bfind%b are a subset of those in
the Posix specification.
*q find
*q Pattern matching
*x fgrep
*x grep
*x egrep
#
*n find_file\Posix library function
*P Locates a file in the command path
*I <unistd.h>
*F void find_file(char *path, char *file)
*A path - destination name buffer
*A file - name of file
*D Scans the directories listed in the PATH environment
variable for the named file. The result will be the complete pathname of
the file in path. This routine is used internally by execvp and execlp.
*x execvp
*x execlp
*q find_file
#
*n findns\Helios command
*q findns, network command
*P Finds a Network Server in the network
*F findns <network>
*D Several of the networking commands require the name of a
Network Server or Session Manager. If the network has just one Network
Server and Session Manager the names %s/ns%s and %s/sm%s are unambiguous.
However, if there are several connected networks (for example, several
workstations linked together but not merged into a larger network), these
names become ambiguous. Under these circumstances the %bfindns%b and
%bfindsm%b commands can be used to locate the correct servers.
*p Users should be aware that the %bfindns%b and %bfindsm%b commands may
involve searching through the network.
*x findsm
*x findtfm
#
*n findsm\Helios command
*q findsm, network command
*P Finds a Session Manager in the network
*F findsm <network>
*D Several of the networking commands require the name of a
Network Server or Session Manager. If the network has just one Network
Server and Session Manager the names %s/ns%s and %s/sm%s are unambiguous.
However, if there are several connected networks (for example, several
workstations linked together but not merged into a larger network), these
names become ambiguous. Under these circumstances the %bfindns%b and
%bfindsm%b commands can be used to locate the correct servers.
*p Users should be aware that the %bfindns%b and %bfindsm%b commands may
involve searching through the network.
*x findns
*x findtfm
#
*n findtfm\Helios command
*q findtfm, network commands
*P Finds the name of the user's Task Force Manager
*F findtfm <user>
*D Although %bfindtfm%b is similar to %bfindns%b and
%bfindsm%b, which find a particular server in the network, it is slightly
different. It differs from these two commands because Task Force Managers
exist for every user rather than having one per network. The findtfm
command takes a single argument (the name of the user), and then outputs
the name of that user's Task Force Manager. For example, the command
*c=findtfm bart
*p might produce the output
*c=/BartNet/00/bart
*x findns
*x findsm
#
*n flex\Helios command
*P Lexical analyser
*F flex [-bdfipstvFILT -c[efmF] -s<skeleton_file>] [<filename>]
*D %bflex%b is a public domain version of the Unix command
%blex%b. Full documentation can be found on the Unsupported Software disc.
#
*n floor\C library function
*P Calculates the largest integer that is not greater than the
argument
*I <math.h>
*F double floor(double x);
*A x - A number
*R the largest integer (expressed as a double) that is not greater
than %sx%s.
*D %bfloor()%b calculates the largest integer which is not
greater than %sx%s.
*x ceil
*q floor
*q Calculate largest integer not greater than the argument
*q Calculate largest integer => argument
#
*n fmod\C library function
*P Calculates the floating point remainder of x/y
*I <math.h>
*F double fmod(double x, double y);
*A x - The dividend
*A y - The divisor
*R (with the same sign as %sx%s) the floating point remainder of
%sx%s/%sy%s. If %sy%s is zero the result is %sx%s.
*D %bfmod()%b calculates the floating point remainder of
%sx%s/%sy%s.
*q fmod
*q Calculate floating point remainder of x/y
*q Floating point - remainder of x/y
#
*n fopen\C library function
*P Opens a file
*I <stdio.h>
*F FILE *fopen(const char *filename, const char *mode);
*A filename - The name of the file to be opened
*A mode - A string that specifies the mode in which the file is
to be opened
*R a file pointer to the stream associated with the newly opened
file. %bfopen()%b returns a null pointer if it cannot open the file.
*E If a file opened for reading does not exist, %bfopen()%b returns
a null pointer.
*D %bfopen()%b opens the file named by the string pointed to
by %sfilename%s, according to the %smode%s string.
*p The following are valid mode strings:
*l Mode
*t Description
*l "r"
*t Opens a text file for reading.
*l "w"
*t Opens a text file for writing. If the file already exists it is
truncated to zero length. If the file does not exist, it is created.
*l "a"
*t Opens a text file for appending. If the file does not exist, it is
created.
*l "rb"
*t Opens a binary file for reading.
*l "wb"
*t Opens a binary file for writing. If the file already exists it is
truncated to zero length. If the file does not exist, it is created.
*l "ab"
*t Opens a binary file for appending. If the file does not exist, it is
created.
*l "r+"
*t Opens a text file for reading and writing.
*l "w+"
*t Creates a text file for reading and writing. If the file exists, it is
truncated to zero length.
*l "a+"
*t Opens a text file for reading, and writing at the end of the file. If
the file does not exist, it will be created.
*l "r+b"
*t Opens a binary file for reading and writing.
*l "rb+"
*t Opens a binary file for reading and writing (alternative).
*l "w+b"
*t Creates a binary file for reading and writing. If the file exists, it is
truncated to zero length.
*l "wb+"
*t Creates a binary file for reading and writing (alternative). If the file
exists, it is truncated to zero length.
*l "a+b"
*t Opens a binary file for reading, and writing at the end of the file. If
the file does not exist, it will be created.
*l "ab+"
*t Opens a binary file for reading, and writing at the end of the file
(alternative). If the file does not exist, it will be created.
*p If a file is opened with a "%s+%s" in the mode string (opened for
update), you can read from and write to the file. However, you must call
%bfflush()%b, %bfseek()%b, %bfsetpos()%b or %brewind()%b in between
reading to, and writing from, the file (or vice versa).
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=  FILE *stream;
*c=  stream = fopen("data.dat","r");
*c=
*c=  if (stream == NULL)
*c=      printf("Can't open data.dat file for read\n");
*c=  else
*c=      printf("data.dat opened for read\n");
*c=}
*x fclose
*x fflush
*x freopen
*x fseek
*x fsetpos
*x rewind
*q fopen
*q Open file
*q File - open
*q Mode strings
#
*n foreach\Helios command
*P Set a given variable to each member of a given list in turn
*F foreach <name> ( <wordlist> ) ; <body> ; end
*D The %bforeach%b shell command sets the variable %sname%s to
the first member of %swordlist%s and executes the sequence of commands in
the %sbody%s until it finds a matching %bend%b command. It then sets
%sname%s to the next member of %swordlist%s and executes the %sbody%s
until it finds %bend%b. It then repeats this loop for each successive
member of %swordlist%s. Notice that the wordlist can contain strings as
well as words; each string is treated as a separate word in the list.
*p You may use the shell's built-in commands %bcontinue%b and %bbreak%b
with %bforeach%b: %bcontinue%b to continue the nearest enclosing loop and
%bbreak%b to terminate the sequence prematurely. Unless you give one of
these two commands, the sequence executes until it comes to the %bend%b.
*p When you type in a %bforeach%b command at the terminal, the shell
prompts you with `?' for each line of the body before executing any of
them. The usual command line editing facilities are available. Here is a
simple example:
*c=% foreach x (one two three)
*c=? echo $x
*c=? end
*c=one
*c=two
*c=three
*c=%
*p You type in the first line and it prompts you with `?'. You then type in
the next line `echo $x', which requests that each successive value of `x'
be displayed. It prompts you again and you terminate the sequence with an
%bend%b command. %bforeach%b then executes, displaying each value of `x'
from the wordlist.
*p Notice that both %bforeach%b and %bend%b must appear alone on separate
lines for this command to work.
*q Shell commands
*q foreach
*x end
#
*n Fork\System library
*P Creates and runs a new process
*I <nonansi.h>
*F WORD Fork(WORD stacksize, VoidFnPtr fn, WORD args_size, ...);
*A stacksize - The amount of stack needed by the new process
*A fn - The function the process executes
*A args_size - The size of the argument vector in bytes
*A ... - The arguments to the process
*R %bFork%b returns 0 if there is insufficient memory to run the
new process, non-0 to indicate success.
*D %bFork()%b is used to create and run a new process. It
allocates space for the new process's stack, copies the arguments to the
initial stack frame, and activates the new process. The new process runs
on the same processor as the parent, and as part of the same task. The
process must exit by returning from its initial function %sfn%s, when the
stack space used by the process is freed automatically. Note that the
%sarg_size%s parameter should be a multiple of 4.
*c=#include <nonansi.h>
*c=#define STACK_SIZE 10000
*c=
*c=extern void function(int,char);
*c=
*c=void
*c=call_function(int val, char letter)
*c={
*c=          Fork(STACK_SIZE, function,
*c=             sizeof(val) + sizeof(letter),
*c=             val, letter);
*c=}
*q Create new process - see also Fork
*q Run new process - see also Fork
#
*n FormOpenReply\System library
*P Initialises the reply message buffer for Open, Locate or Create
*I <servlib.h>
*F void FormOpenReply(MsgBuf *rep, MCB *mcb, ObjNode *obj, word
flags, char *pathname);
*A rep - pointer to reply message buffer
*A mcb - pointer to message control block of request
*A obj - pointer to object node
*A flags - flag
*A pathname - pointer to character string (pathname of target)
*D %bFormOpenReply()%b initialises the reply message buffer
with a reply message appropriate for an Open, Locate or Create request.
*q FormOpenReply
#
*n fpathconf\Posix library function
*P Gets value of configurable file system variables
*I <unistd.h> ; <posix.h>
*F int fpathconf(int fd, int name);
*A fd - file descriptor of an open file
*A name - variable in question
*R %bfpathconf()%b returns the variable value for the specified
file or directory. For example, %sfpathconf(fd,NAME_MAX)%s should return
the maximum length of a filename. If %sname%s is invalid, %bfpathconf()%b
returns -1. If %sname%s has no limit for %spath%s, it returns -1 but does
not set/reset the value of errno. Other errors return -1 and set errno.
*E Sets errno and returns -1 for the following errors:
*l [EINVAL]
*t Invalid argument. The value of %sname%s is not valid.
*l [EBADF]
*t Not a valid file descriptor.
*l [EACCES]
*t Permission denied.
*l [ENAMETOOLONG]
*t Filename too long. Pathname exceeds limit set for [NAME_MAX]
*l [ENOENT]
*t No such file or directory.
*l [ENOTDIR]
*t Not a directory. Pathname prefix is not a directory.
*D %bfpathconf()%b is similar to %bpathconf()%b. It enables
you to find out the current value of a configurable variable associated
with a particular file or directory. Where in %bpathconf()%b the file or
directory is specified by a pointer to its pathname, in %bfpathconf()%b it
is specified by the %sfd%s argument. As in %bpathconf()%b, the variable in
question is indicated by the %sname%s argument. The variables supported,
their symbolic names and their values are listed in %s<limits.h>%s, but
here is a quick reminder:
*f %bVariable%b\%bValue of%b %sname%s\%sint%s
*f [LINK_MAX] \_PC_LINK_MAX\1
*f [MAX_CANON]\_PC_MAX_CANON\2
*f [MAX_INPUT]\_PC_MAX_INPUT\3
*f [NAME_MAX]\_PC_NAME_MAX \4
*f [PATH_MAX]\_PC_PATH_MAX\5
*f [PIPE_BUF]\_PC_PIPE_BUF\6
*f [POSIX_CHOWN_RESTRICTED]\_PC_CHOWN_RESTRICTED\7
*f [POSIX_NO_TRUNC]\_PC_NO_TRUNC\8
*f [POSIX_VDISABLE]\_PC_VDISABLE\9
*x pathconf
*q fpathconf
#
*n fprintf\C library function
*P Writes a formatted string to a file
*I <stdio.h>
*F int fprintf(FILE *stream, const char *format, ...);
*A stream - A pointer to an output file stream
*A format - An array of characters specifying the format
*A ... - Subsequent arguments to the format string
*R the number of characters written, or a negative value if an
output error occurs.
*E Returns a negative value if an output error occurs.
*D %bfprintf()%b writes the string pointed to by %sformat%s to
the file stream %sstream%s. When %bfprintf()%b encounters a percent sign
%% in the string, it expands the corresponding argument into the format
defined by the format tokens after the %%.
*p The format tokens consist of the following items:
*p 1. Flags (optional).
*l %b-%b
*t Causes the output to be left-justified in its field.
*l %b+%b
*t Causes the output to start with a '+' or '-'.
*l
*t (a blank space) causes the output to start with a space if positive, and
a minus sign if negative.
*l %b#%b
*t Causes: an octal number to begin with 0, a hex number to begin with 0x,
a floating point number to contain a decimal point and retain trailing
zeros.
*p 2. Minimum width (optional). The width is an integer constant, defining
the minimum number of characters displayed. If the width begins with a
zero, extra columns will be padded with zeros, otherwise extra columns are
padded with spaces. If the integer constant is replaced by an asterisk
('*'), an int argument supplies the width.
*p 3. Precision (optional). The precision is a decimal point followed by an
integer constant which defines: the maximum number of characters to be
written in an 's' conversion; the number of digits to appear after the
decimal point in an 'e', 'E' or 'f' conversion; the maximum number of
significant digits for a 'g' or 'G' conversion; the minimum number of
digits to appear in a 'd', 'o', 'u', 'x' or 'X' conversion. If the integer
constant is replaced by an asterisk ('*'), an int argument supplies the
precision.
*p 4. Type specifier (optional).
*l %bh%b
*t Specifies that a following 'd', 'o', 'u', 'x' or 'X' conversion applies
to a (unsigned) short int, and a following 'n' conversion applies to a
pointer to a short int.
*l %bl%b
*t Specifies that a following 'd', 'o', 'u', 'x' or 'X' conversion applies
to a (unsigned) long int, and a following 'n' conversion applies to a
pointer to a long int.
*l %bL%b
*t Specifies that a following 'e', 'E', 'f', 'g' or 'G' conversion applies
to a long double.
*p 5. A single conversion character.
*l %bd%b
*t The int argument is converted to signed decimal format.
*l %bo%b
*t The int argument is converted to unsigned octal format.
*l %bu%b
*t The int argument is converted to unsigned decimal format.
*l %bx%b
*t The int argument is converted to unsigned hexadecimal format, using the
letters 'a' to 'f'.
*l %bX%b
*t The int argument is converted to unsigned hexadecimal format, using the
letters 'A' to 'F'.
*l %bf%b
*t The double argument is converted to the decimal format xxx.xxxx. The
number of characters after the decimal point is equal to the precision.
The default precision is six.
*l %be%b, %bE%b
*t The double argument is converted to the decimal format x.xxxxe+/-xx. The
exponent is introduced with the conversion character. The number of
characters after the decimal point is equal to the precision. The default
precision is six.
*l %bg%b, %bG%b
*t The double argument is converted to an 'f' format if the exponent is
less than -4 or greater than the precision. Otherwise 'g' is equivalent to
'e', and 'G' is equivalent to 'E'. Trailing zeros are removed from the
result.
*l %bc%b
*t The int argument is written as a single character.
*l %bs%b
*t Characters are written from the string pointed to by the argument, up to
the string terminating character.
*l %bp%b
*t The void pointer argument is converted to a hex format.
*l %bn%b
*t The number of characters written so far will be put into the integer
pointed to by the argument.
*l %b%%%b
*t The %% character is written.
*p Each token acts on the equivalent argument, that is, the third token
relates to the third argument after the format string. There must be a
single argument for each token. If the token or its equivalent argument is
invalid, the behaviour is undefined.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c= int i = 99;
*c= int count = 0;
*c= double fp = 1.5e5;
*c= char *s = "a sequence of characters";
*c= char nl = '\n';
*c= FILE *stream;
*c=
*c= if ( (stream = fopen("data.dat", "w")) == NULL)
*c=     printf("Error opening data.dat for write\n");
*c=  else
*c= {
*c=      count = count + fprintf(stream, "This is %s%c", s, nl);
*c=      count = count + fprintf(stream, "%d\n%f\n", i, fp);
*c=      printf("Number of characters written to file was: %d\n", count);
*c=  }
*c=}
*x fscanf
*x printf
*q fprintf
*q Write formatted string to file
*q Formatted string - write to file
*q String format
#
*n fputc\C library function
*P Writes a character to a file stream
*I <stdio.h>
*F int fputc(int c, FILE *stream);
*A c - The character to be written.
*A stream - A pointer to a file stream.
*R the character written if successful. If a write error occurs,
%bfputc()%b returns EOF.
*E %bfputc()%b returns EOF if a write error occurs.
*D %bfputc()%b converts %sc%s to an unsigned char, writes it
to the output stream pointed to by %sstream%s, and moves the read/write
position for the file stream as appropriate.
*x fgetc
*x putc
*q fputc
*q Write character to file stream
*q Character, write to file stream
*q File stream, write character to
#
*n fputs\C library function
*P Writes a string to a file stream
*I <stdio.h>
*F int fputs(const char *s, FILE *stream);
*A s - A pointer to the string to be written.
*A stream - A pointer to a file stream.
*R zero if successful, and non-zero if unsuccessful.
*E %bfputs()%b returns non-zero if unsuccessful.
*D %bfputs()%b writes the string pointed to by %ss%s to the
file stream %sstream%s. The write does not include the string terminating
character.
*x fputc
*q fputs
*q Write string to file stream
*q String, write to file stream
*q File stream, write string to
#
*n fread\C library function
*P Reads records from a file
*I <stdio.h>
*F size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
*A ptr - A pointer to a buffer that the records are read into.
*A size - The size of an individual record.
*A nmemb - The maximum number of records to be read.
*A stream - A pointer to a file stream.
*R the number of records read. This may be less than %snmemb%s if
an error or end-of-file occurs. %bfread()%b returns zero if %ssize%s or
%snmemb%s is zero.
*E %bfread()%b returns zero if %ssize%s or %snmemb%s is zero.
*D %bfread()%b reads %snmemb%s records of length %ssize%s from
the file stream %sstream%s into the array pointed to by %sptr%s. The
read/write file pointer is incremented by the number of characters read.
*p The records would normally have been written to the file by
%bfwrite()%b.
*c=#include <stdio.h>
*c=
*c=FILE *stream;
*c=
*c=int main( void )
*c={
*c=   int i;
*c=   int numout, numin;
*c=   int buf[10];
*c=
*c=   /* Write 10 integers to the file data.dat */
*c=   stream = fopen("data.dat", "w+b");
*c=   if (stream == NULL)
*c=       printf("Error opening data.dat for binary write\n");
*c=   else
*c=   {
*c=       for (i = 0; i < 10; ++i) buff[i] = i * i; /* Put values in buff */
*c=       numout = fwrite((char *)buff, sizeof(int), 10, stream);
*c=       printf("Number of integers written to the file was: %d\n", numout);
*c=   }
*c=
*c=   fclose(stream);
*c=
*c=   /* Read 10 integers from the file data.dat */
*c=   stream = fopen("data.dat", "r+b");
*c=   if (stream == NULL)
*c=      printf("Error opening data.dat for binary write\n");
*c=   else
*c=   {
*c=      numin = fread((char *)buff, sizeof(int), 10, stream);
*c=      printf("Number of integers read from file was: %d\n", numin);
*c=      for (i = 0; i < 10; ++i)
*c=          printf("Int %d is %d\n", i, buff[i]);
*c=   }
*c=}
*x ferror
*x feof
*x fwrite
*q fread
*q Read records from file
*q Records, read from file
*q File, read records from
#
*n Free\System library
*P Releases a memory block back to the task pool
*I <syslib.h>
*F WORD Free ( void *mem );
*A mem - Pointer to memory block
*R Zero on success; otherwise, on failure, an error code to
indicate the error that occurred.
*D This function returns the given block to the task's pool
for re-allocation.
*x free
*x Malloc
*q Release memory to task pool
*q Memory, release to task pool
#
*n free\C library function
*P Frees an area of memory
*I <stdlib.h>
*F void free(void *ptr);
*A ptr - A pointer to the area of memory to be freed.
*E The behaviour of %bfree()%b is undefined if %sptr%s does not
match any of the pointers previously returned by %bcalloc()%b,
%bmalloc()%b, or %brealloc()%b, or if the space has already been freed by
a call to %bfree()%b or %brealloc()%b.
*D %bfree()%b frees the area of memory pointed to by %sptr%s
if it has been previously allocated by %bcalloc()%b, %bmalloc()%b, or
%brealloc()%b.
*c=#include <stdlib.h>
*c=#include <stdio.h>
*c=
*c=int main(void)
*c={
*c=   int *array;
*c=
*c=   array = (int *)malloc(1000);
*c=   if (array ==NULL)
*c=      printf("Couldn't allocate memory for array\n");
*c=   else
*c=   {
*c=      free(array);
*c=      printf("Allocated and deallocated memory for array\n");
*c=   }
*c=}
*x Free
*x calloc
*x malloc
*x realloc
*q free
*q Freeing an area of memory
*q Memory - free
#
*n FreeLink\System library
*P Releases a link from direct use
*I <link.h>
*F WORD FreeLink( word linkno );
*A linkno - Link to be released
*R Error code
*D This function releases a link from direct access. It should
only be called on a link which has been previously reserved with
%bAllocLink()%b.
*q AllocLink
*x LinkIn
*x LinkOut
*q Release link from direct use
*q Link, release from direct use
#
*n FreeMem\System library
*P Releases a memory block to the system pool
*I <memory.h>
*F void FreeMem ( void *mem );
*A mem - Pointer to memory block.
*D This function returns memory to the system free pool. It
should not normally be used by programs.
*q Free pool, return memory to - see FreeMem
*x Free
*x Malloc
*q Release memory to system pool - see FreeMem
*q Memory, release to system pool - see FreeMem
#
*n FreeMemStop\System library
*P Frees Kernel-allocated memory and halts process
*I <memory.h>
*F void FreeMemStop(void *mem);
*A mem - memory to free
*R does NOT return
*D This function releases a block of memory allocated by
AllocMem() and halts the process. It is used by FreeStop().
*q FreeMemStop
*x FreeStop
#
*n FreePool\System library
*P Releases an entire memory pool back to the system
*I <memory.h>
*F WORD FreePool( Pool *pool );
*A pool - Pointer to memory pool to be freed.
*R Error code
*D This function returns all the memory contained in a memory
pool to the system.
*x InitPool
*x AllocMem
*x AllocFast
*x FreeMem
*q Release entire memory pool back to system
*q Memory pool, release - see FreePool
#
*n FreePort\System library
*P Releases a given port and invalidates its port descriptor
*I <syslib.h>
*F WORD FreePort ( Port port );
*A port - Port descriptor
*R Error code
*D This function releases the specified port back to the
system pool. This port must have been previously allocated with a call to
%bNewPort()%b.
*x NewPort
*q NewPort
*q Port handling functions
*q Release port - see FreePort
*q Invalidate port descriptor - see FreePort
*q Kernel functions
#
*n FreeStop\System library
*P Frees memory and halts a process
*I <syslib.h>
*F void FreeStop(void *mem);
*A mem - memory to free
*R Does NOT return
*D This function frees the given memory block and halts the
process. It is used to free the memory block containing the stack of the
calling process in a race free way. The memory must have been allocated by
Malloc().
*q FreeStop
*x Free
*x Malloc
#
*n freopen\C library function
*P Closes an open file, and re-opens it in a given mode
*I <stdio.h>
*F FILE *freopen(const char *filename, const char *mode, FILE *stream);
*A *filename - The name of the file to be opened.
*A *mode - A string which specifies the mode in which the file is
to be opened.
*A *stream - A pointer to a file stream.
*R the value of %sstream%s. This is associated with the newly
opened file. %bfreopen()%b returns a null pointer if it cannot open the
file.
*E If a file opened for reading does not exist, %bfreopen()%b
returns a null pointer.
*D %bfreopen()%b attempts to close the file associated with
the file stream %sstream%s. %bfreopen()%b then opens the file named by the
string pointed to by %sfilename%s, and associates the file with the file
stream %sstream%s. The file is opened according to the %smode%s string.
*p The following are valid mode strings:
*p Mode - Description
*l "r"
*t Opens a text file for reading.
*l "w"
*t Opens a text file for writing. If the file already exists it is
truncated to zero length. If the file does not exist, it is created.
*l "a"
*t Opens a text file for appending. If the file does not exist, it is
created.
*l "rb"
*t Opens a binary file for reading.
*l "wb"
*t Opens a binary file for writing. If the file already exists it is
truncated to zero length. If the file does not exist, it is created.
*l "ab"
*t Opens a binary file for appending. If the file does not exist, it is
created.
*l "r+"
*t Opens a text file for reading and writing.
*l "w+"
*t Creates a text file for reading and writing. If the file exists, it is
truncated to zero length.
*l "a+"
*t Opens a text file for reading, and writing at the end of the file. If
the file does not exist, it will be created.
*l "r+b"
*t Opens a binary file for reading and writing.
*l "rb+"
*t Opens a binary file for reading and writing (alternative).
*l "w+b"
*t Creates a binary file for reading and writing. If the file exists, it is
truncated to zero length.
*l "wb+"
*t Creates a binary file for reading and writing. If the file exists, it is
truncated to zero length (alternative).
*l "a+b"
*t Opens a binary file for reading, and writing at the end of the file. If
the file does not exist, it will be created.
*l "ab+"
*t Opens a binary file for reading, and writing at the end of the file. If
the file does not exist, it will be created (alternative).
*p If a file is opened with a "%s+%s" in the %smode%s string (opened for
update), you can read from and write to the file. However, you must call
%bfflush()%b, %bfseek()%b, %bfsetpos()%b or %brewind()%b in between
reading to, and writing from, the file (or vice versa). %bfreopen()%b is
normally used for redirecting the stdin, stdout and stderr streams.
*c=#include <stdio.h>
*c=
*c=FILE *stream;
*c=
*c=int main( void )
*c={
*c=  /* assign stdout to a named file */
*c=  printf("This text goes to stdout\n");
*c=
*c=  stream = (FILE *)freopen("data.dat", "w", stdout);
*c=  if (stream == NULL)
*c=     printf("Couldn't freopen stdout to data.dat\n");
*c=  else
*c=  {
*c=     printf("This text goes to data.dat\n");
*c=     fclose(stream);
*c=  }
*c=}
*x fopen
*q freopen
*q Close open file
*q Re-open file in a given mode
*q Modes
*q I/O
#
*n frexp\C library function
*P Separates a floating point number into its mantissa and
exponent
*I <math.h>
*F double frexp(double value, int *exp);
*A value - The floating point number.
*A exp - A pointer to the int into which the exponent is put.
*R the mantissa part of value. The mantissa is returned in the
range [0.5 ... 1]. The exponent is stored in the int pointed to by
%sexp%s.
*D %bfrexp()%b separates the floating point number value into
its mantissa and exponent. The exponent is stored in the int pointed to by
%sexp%s. The mantissa is returned by the function.
*p If x is the value returned by %bfrexp()%b and y is the exponent stored
in %sexp%s then:
*c=value = x * 2**y
*p If value is zero then both x and y will be zero.
*c=#include <math.h>
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   double x;
*c=   double mantissa;
*c=   int exponent;
*c=
*c=   x = 3.141;
*c=   mantissa = frexp(x,&exponent);
*c=   printf("x = %f, mantissa = %f, exponent = %d\n", x, mantissa, exponent);
*c=}
*c=/*
*c= *   Output:
*c= *
*c= *          x = 3.141, mantissa = 0.785250, exponent = 2
*c= *
*c= */
*x ldexp
*q frexp
*q Separate floating point into mantissa and exponent
*q Floating point - separate into mantissa and exponent
*q Floating point - see also frexp
#
*n fscanf\C library function
*P Reads formatted input from a file stream.
*I <stdio.h>
*F int fscanf(FILE *stream, const char *format, ...);
*A stream - An input file stream.
*A format - A format string.
*A ... - Subsequent arguments to the format string.
*R the number of inputs which have been successfully converted. If
an end-of-file character occurred before any conversions took place,
%bfscanf()%b returns EOF.
*E If an end-of-file character occurred before any conversions took
place, %bfscanf()%b returns EOF. Other failures cause termination of the
procedure.
*D %bfscanf()%b matches the data read from the input stream
%sstream%s to the specifications set out by the format string. The format
string can include white space, ordinary characters, or conversion tokens.
*p 1. Whitespace causes the next series of white space characters read to
be ignored.
*p 2. Ordinary characters in the format string cause the characters read to
be compared to the corresponding character in the format string. If the
characters do not match, conversion is terminated.
*p 3. A conversion token in the format string causes the data sequence read
in to be checked to see if it is in the specified format. If it is, it is
converted and placed in the appropriate argument following the format
string. If the data is not in the correct format, conversion is
terminated.
*p The conversion tokens consist of the following items:
*p 1. Token signifier
*l %s%%%s
*p 2. Assignment suppressor (optional).
*l %s*%s
*t causes the data sequence to be read in, but not assigned to an argument.
Tokens using '*' should not have a corresponding argument in the argument
list.
*p 3. Maximum width (optional). The width is an integer constant, defining
the maximum number of characters to be read.
*p 4. Type specifier (optional).
*l %sh%s
*t specifies that a following 'd', 'n', 'o', 'u', or 'x' conversion applies
to a (unsigned) short int.
*l %sl%s
*t specifies that a following 'd', 'n', 'o', 'u' or 'x' conversion applies
to a (unsigned) long int, and a following 'e', 'f' or 'g' conversion
applies to a double.
*l %sL%s
*t specifies that a following 'e', 'f' or 'g' conversion applies to a long
double.
*p 5. A single conversion character.
*l %sd%s
*t expects a (signed) decimal integer. Requires a pointer to an integer as
the corresponding argument.
*l %si%s
*t expects a (signed) integer constant. Requires a pointer to an integer as
the corresponding argument.
*l %so%s
*t expects a (signed) octal integer (optionally preceded by an 0). Requires
a pointer to an integer as the corresponding argument.
*l %su%s
*t expects a unsigned decimal integer. Requires a pointer to an unsigned
integer as the corresponding argument.
*l %sx%s
*t expects a (signed) hex integer (optionally preceded by an 0x or 0X).
Requires a pointer to an integer as the corresponding argument.
*l %se%s, %sf%s, %sg%s
*t expects a (signed) floating point character in the following format: 1.
a plus or minus sign (optional); 2. a sequence of decimal digits, which
may contain a decimal point; 3. an exponent (optional) consisting of an
'E' or 'e' followed by an optional sign and a string of decimal digits.
Requires a pointer to a double as the corresponding argument.
*l %ss%s
*t expects a string. Requires a pointer to an array large enough to hold
(size of the string + 1) characters as the corresponding argument.
*l %s[%s
*t signifies the start of a scan set: [set] expects a string made up of the
characters included between the square brackets; [^set] expects a string
made up of characters which are not included between the square brackets.
The right bracket character can be included in the match set by placing it
immediately after the [ or the [^. Requires a pointer to an array large
enough to hold (size of the string + 1) characters as the corresponding
argument.
*l %sp%s
*t expects a hexadecimal string. Requires a pointer to a void pointer as
the corresponding argument.
*l %sn%s
*t the number of characters received so far will be put into the integer
pointed to by the argument. This does not increment the assignment count
returned.
*l %s%%%s
*t matches the %% character.
*p Each token acts on the equivalent argument, that is, the third token
relates to the third argument after the format string. There must be a
single conversion sequence received for each token. If the token is
invalid, the behaviour is undefined.
*p Any mismatch between the token format and the data received causes an
early termination of %bfscanf()%b.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   FILE *stream;
*c=   int numin;
*c=   int numout;
*c=   float fp;
*c=   int i;
*c=
*c=   /* Create a file containing a number of items */
*c=   stream = fopen("data.dat", "w");
*c=
*c=   if (stream == NULL)
*c=      printf("Couldn't open data.dat for write\n");
*c=   else
*c=   {
*c=      numout = fprintf(stream, "%f %d", 3.141, 1024);
*c=      printf("Number of characters written: %d\n", numout);
*c=   }
*c=
*c=   fclose(stream);
*c=
*c=   /* Read a number of items from the file */
*c=   stream = fopen("data.dat", "r");
*c=   if (stream == NULL)
*c=      printf("Couldn't open data.dat for read\n");
*c=   else
*c=   {
*c=      numin = 0;
*c=      numin = numin + fscanf(stream, "%f", &fp);
*c=      numin = numin + fscanf(stream, "%d", &i);
*c=      printf("Number of fields read: %d\n", numin);
*c=      printf("Items read were: %f, %d\n",fp, i);
*c=   }
*c=}
*c=
*c=/*   Output:
*c= *
*c= *          Number of characters written: 13
*c= *          Number of fields read: 2
*c= *          Items read were: 3.141000, 1024
*c= */
*x fprintf
*q fscanf
*q Read formatted input from file stream
*q Formatted input from file stream, read
*q File stream - read formatted input from
#
*n fseek\C library function
*P Sets the read/write file pointer to a specified offset in a
file stream
*I <stdio.h>
*F int fseek(FILE *stream, long int offset, int whence);
*A stream - A pointer to a file stream.
*A offset - The distance the read/write pointer is moved.
*A whence - The start position for the read/write pointer.
*R non-zero if called incorrectly, otherwise %bfseek()%b returns
zero.
*E %bfseek()%b returns non-zero if called incorrectly.
*D %bfseek()%b is used to move the read/write position pointer
of a file to a specified offset within the file stream %sstream%s. The
offset is measured from a position defined by %swhence%s:
*p 1. SEEK_SET is the start of the file stream.
*q SEEK_SET
*p 2. SEEK_CUR is the current position in the file stream.
*q SEEK_CUR
*p 3. SEEK_END is the end of the file stream.
*q SEEK_END
*p If the file stream is a text stream, the offset should either be zero,
or %swhence%s should be set to SEEK_SET, and %soffset%s should be a value
returned by a previous call to %bftell()%b.
*p %bfseek()%b clears the end-of-file indicator for %sstream%s and will
undo the effects of an %bungetc()%b operation. The file stream may be both
read from and written to after %bfseek()%b has been called, provided it
has been opened in an appropriate mode.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   FILE *stream;
*c=   int result;
*c=   stream = fopen("data.dat", "w+");
*c=
*c=   if (stream == NULL)
*c=      printf("Couldn't open data.dat for write\n");
*c=   else
*c=   {
*c=      fprintf(stream,"%s","123456789");
*c=
*c=      /* Reset to beginning of file */
*c=      result = fseek(stream, 0L, SEEK_SET);
*c=
*c=      if (result)
*c=         printf("Couldn't do fseek\n");
*c=      else
*c=         printf("First char in file is: %c\n", getc(stream));
*c=
*c=      /* Reset to beginning of file */
*c=      result = fseek(stream, 0L, SEEK_SET);
*c=
*c=      /* Move to third byte in file */
*c=      result = fseek(stream, 2L, SEEK_CUR);
*c=
*c=      if (result)
*c=         printf("Couldn't do fseek\n");
*c=      else
*c=         printf("Third char in file is: %c\n", getc(stream));
*c=
*c=      /* Move to last byte in file */
*c=      result = fseek(stream, -1L, SEEK_END);
*c=
*c=      if (result)
*c=         printf("Couldn't do fseek\n");
*c=      else
*c=         printf("Last char in file is: %c\n", getc(stream));
*c=   }
*c=}
*q fseek
*q Set read/write file pointer
*q Read/write file pointer, set
*q File stream, set file pointer to offset in
*q fsetpos
*q ftell
*q ungetc
#
*n fsetpos\C library function
*P Sets the read/write file pointer to an %sfpos_t%s value
obtained from %bfgetpos()%b
*I <stdio.h>
*F int fsetpos(FILE *stream, const fpos_t *pos);
*A stream - A pointer to a file stream.
*A pos - A pointer to a location containing the new value of the
read/write file pointer.
*R zero if the operation was successful, and non-zero on failure.
*E If the operation was unsuccessful, %bfsetpos()%b returns a
non-zero value.
*D %bfsetpos()%b sets the read/write position pointer of the
file stream %sstream%s to the value in %spos%s, which should contain a
value previously returned by %bfgetpos()%b.
*p %bfsetpos()%b clears the end-of-file indicator for the stream and will
undo the effects of an %bungetc()%b operation. The file stream may be both
read from and written to after %bfsetpos()%b has been called, provided it
has been opened in an appropriate mode.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   FILE *stream;
*c=   fpos_t filepos;
*c=   char ch;
*c=
*c=   stream = fopen("data.dat","r");
*c=   if (stream == 0)
*c=     printf("Couldn't open data.dat for read\n");
*c=   else
*c=   {
*c=      ch = getc(stream);
*c=      printf("First char in file is '%c'\n",ch);
*c=
*c=      /*
*c=       * Remember: getc() advances file pointer, so it now points
*c=       * to the second character in the file.
*c=       */
*c=
*c=      if (fgetpos(stream,&filepos) != 0)
*c=        printf("Error with fgetpos\n");
*c=
*c=      ch = getc(stream);
*c=      printf("Second char in file is '%c'\n",ch);
*c=      ch = getc(stream);
*c=      printf("Third character in file is '%c'\n",ch);
*c=
*c=      if (fsetpos(stream,&filepos) !=0)
*c=        printf("Error with fsetpos\n");
*c=
*c=      ch = getc(stream);
*c=      printf("Reset file pointer and read second char which is '%c'\n",ch);
*c=    }
*c=}
*x ungetc
*x fgetpos
*x fseek
*q fsetpos
*q Set position of read/write file pointer
*q Position of read/write file pointer, set
*q Read/write file pointer, set position of
*q File pointer, set position of
#
*n fstat\Posix library function
*P Reads and returns a file's status
*I <sys/types.h> ; <sys/stat.h>
*F int fstat(int fd, struct stat *buf);
*A fd - File descriptor
*A *buf - Pointer to a %sstat%s structure defined in <sys/stat.h>
*R 0, if successful; otherwise, it returns -1 and sets an error
code to indicate the error.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*D This function finds and returns information about an open
file. It holds the information about the file in the structure pointed at
by %sbuf%s. The stat structure is as follows:
*c=struct stat
*c={
*c=      /* the following fields correspond exactly to */
*c=      /* those in a Helios ObjInfo structure */
*c=       long    st_type;
*c=       long    st_flags;
*c=       long    st_matrix;
*c=       char    st_name[32];
*c=       uid_t   st_uid;     /* server's account id */
*c=       off_t   st_size;    /* file size */
*c=       time_t  st_ctime;
*c=       time_t  st_atime;
*c=       time_t  st_mtime;
*c=       /* the value of st_mode is made up from the values of */
*c=       /* st_type and st_matrix */
*c=        mode_t  st_mode;
*c=       /* the following fields may be present, but are all zeroed */
*c=        ino_t   st_ino;
*c=        dev_t   st_dev;
*c=        dev_t   st_blksize;
*c=        /* dev_t  st_rdev removed, this is BSD compatible */
*c=        nlink_t st_nlink;
*c=        uid_t   st_gid;
*c=};
*q Read and return file status
*q File status, read and return
*x stat
#
*n ftell\C library function
*P Gives the position of the read/write pointer in the file stream
*I <stdio.h>
*F long int ftell(FILE *stream);
*A stream - A pointer to a file stream.
*R the current value of the read/write position indicator for the
file stream %sstream%s, and -1 on error.
*E %bftell()%b returns -1 on error.
*D %bftell()%b returns the current value of the read/write
position indicator for the file stream %sstream%s. The value is measured
from the beginning of the file.
*p The value returned by %bftell()%b may be used by the %bfseek()%b
function.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   FILE *stream;
*c=   char ch;
*c=
*c=   stream = fopen("data.dat", "w+");
*c=   if (stream == NULL)
*c=      printf("Couldn't open data.dat for write\n");
*c=   else
*c=   {
*c=      fprintf(stream,"%s","123456789");
*c=      rewind(stream);
*c=      printf("Position before first getc is: %ld\n",ftell(stream));
*c=      ch = getc(stream);
*c=      printf("Position after first getc is: %ld\n",ftell(stream));
*c=      ch = getc(stream);
*c=      printf("Position after second getc is: %ld\n",ftell(stream));
*c=   }
*c=}
*x fseek
*q ftell
*q Give position of read/write pointer
*q Position of read/write pointer
*q Read/write pointer, position of in file stream
*q File stream - position of read/write pointer in
#
*n fwrite\C library function
*P Writes records from an array into a file
*I <stdio.h>
*F size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
*A ptr - A pointer to a buffer that the records are read from.
*A size - The size of an individual record.
*A nmemb - The maximum number of records to be written.
*A stream - A pointer to a file stream.
*R the number of records written. This may be less than %snmemb%s
if a write error occurs.
*E %bfwrite()%b returns zero if %ssize%s or %snmemb%s is zero.
*D %bfwrite()%b writes %snmemb%s records of length %ssize%s
from the array pointed to by %sptr%s into the file stream %sstream%s. The
read/write file pointer is incremented by the number of characters
written.
*x fread
*q fwrite
*q Write records from array into file
*q Records - write from array into file
*q Array - write records from - into file
*q File - write records into - from array
#
*n gawk\Helios command
*P Pattern scanner
*F gawk <prog> [<file>]...
*F gawk -f <pfile> [<file>]...
*D %bgawk%b is the public domain version of the Unix %bawk%b.
If you have used %bawk%b, you should have little difficulty in using
%bgawk%b. Basically, %bgawk%b takes commands from stdin or from a file
%spfile%s and applies them to the lines in the given input %sfile%s, or to
each file in turn if more than one input file is given. The command
program structure is a sequence of statements of the form:
*c=pattern {action}
*p Each line of input is matched in turn against the pattern. Where the
pattern matches, %bgawk%b applies the associated action.
*p Full documentation can be found on the Unsupported Software disc.
*q awk
*q gawk
#
*n General Server Protocol\General interest
*P Provides a standard protocol used by all system servers
*D The General Server Protocol, or GSP as it is more generally
known, is the communication protocol supported by all system servers.
Requests within this protocol have a control vector structure that
references the current directory of the context object, the pathname, the
offset of the name in the pathname to be used next and the capability
encoding the client's access rights to the context object. If necessary,
additional, request specific, parameters may be added to the end of this
standard structure.
*q Communication primitives
*x Capability
*x Servers
#
*n GetAccess\System library
*P Attempts to decrypt capability with given key to gain access
*I <servlib.h>
*F word GetAccess(Capability *cap, Key key);
*A cap - pointer to a capability
*A key - key
*D %bGetAccess()%b attempts to decrypt the given capability
with the given key. If the key is valid, its cleartext access mask is
ANDed with the encrypted mask. If the capability fails to decrypt, a value
FALSE is returned; otherwise, it returns TRUE.
*q GetAccess
#
*n GetAttributes\System library
*P Obtains the current set of attributes for a device
*I <attrib.h>
*F WORD GetAttributes(Stream *stream, Attributes *attr);
*A stream - Stream to the device specified
*A attr - Pointer to an Attributes structure.
*R Error code.
*D This function obtains the current attributes associated
with a Stream or device. It uses the Attributes structure defined in
<attrib.h>:
*c=typedef struct Attributes {
*c=        WORD    Input;
*c=        WORD    Output;
*c=        WORD    Control;
*c=        WORD    Local;
*c=        short   Min;
*c=        short   Time;
*c=} Attributes;
*x SetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Device attribute handling
*q Attribute handling - see also Device attribute handling
*q Attributes structure
#
*n getc\C library function
*P Gets a character from a file
*I <stdio.h>
*F int getc(FILE *stream);
*A stream - A pointer to a file stream.
*R the next character from the file stream.
*E If the next character is the end-of-file character, or a read
error occurs, %bgetc()%b returns EOF.
*D %bgetc()%b is a macro which returns the next character from
the opened file identified by the file stream pointer, and moves the
read/write position for the file stream as appropriate.
*p %bgetc%b is implemented as a macro and therefore may carry out multiple
evaluations of its argument.
*x fgetc
*x getchar
*x putc
*q getc
*q Get character from file
*q Character - get from file
*q File, get character from
#
*n getchar\C library function
*P Reads a character from standard input
*I <stdio.h>
*F int getchar(void);
*R the next character from the standard input stream.
*E If the next character is the end-of-file character, or a read
error occurs, %bgetchar()%b returns EOF.
*D %bgetchar()%b returns the next character from the standard
input file stream, and moves the read/write position for the file stream
as appropriate.
*x getc
*x fgetc
*q getchar
*q Read character from standard input
*q Character - read from standard input
*q Standard input, read character from
#
*n GetContext\System library
*P Used by dispatcher to locate and check the context object of a
GSP message
*I <servlib.h>
*F DirNode *GetContext(ServInfo *servinfo);
*A servinfo - pointer to server information
*D %bGetContext()%b is only really useful if you wish to write
your own dispatcher for use in a Helios server. The dispatcher makes use
of this function to locate and check the context object of a General
Server Protocol (GSP) message.
*p Note that the ServInfo structure has changed a little from that
described in earlier documentation:
*c=struct ServInfo{
*c=       DispatchInfo     *DispatchInfo;  /* DispatchInfo struct  */
*c=       MCB              *m;             /* MCB of request	   */
*c=       DirNode          *Context;       /* original context object */
*c=       ObjNode          *Target;        /* the target object	   */
*c=       bool             TargetLocked;   /* Target locked ?	   */
*c=       word             FnCode;         /* request fn code	   */
*c=       jmp_buf          Escape;         /* error/escape jump buffer*/
*c=       char             Pathname[IOCDataMax]; /* current object pathname */
*c=} ServInfo;
*q DirServer
*q GSP
*q General Server Protocol
*q GetContext
#
*n getcwd\Posix library function
*P Gets the current working directory pathname
*I <posix.h> ; <unistd.h>
*F char *getcwd(char *buf, int size);
*A buf - Pointer to character array
*A size - Size of character array in bytes
*R If successful, %bgetcwd()%b returns %sbuf%s. If unsuccessful,
it returns a NULL pointer and sets the errno variable to indicate the
error that occurred.
*E
*l [EINVAL]
*t %ssize%s is zero.
*l [ERANGE]
*t %ssize%s is greater than zero, but less than the length of the pathname.
*D This function copies the pathname of the current working
directory to the character array pointed at by the argument %sbuf%s, which
is of size %ssize%s. If all goes well, %bgetcwd()%b returns %sbuf%s.
*q getcwd
*x chdir\000072
*q Working directory pathname, get - see getcwd
*q Current working directory pathname, get - see getcwd
*q Pathname of current working directory, get - see getcwd
#
*n GetDate\System library
*P Gets the current system date and time
*I <syslib.h>
*F Date GetDate ( void );
*R The current system time.
*D This function returns the current system time in seconds
since 00:00:00 GMT on January 1st, 1970.
*x SetDate
*q Get current system date and time
*q Current system date and time, get
*q System date and time, get
*q Date and time, get
*q Time, system
*q Date, system
#
*n getegid\Posix library function
*P Gets effective group id
*I <unistd.h>
*F uid_t getegid ( void );
*R effective group id
*D See setuid() for a description of the Helios emulation of
user and group ids.
*x setuid
#
*n GetEnv\System library
*P Receives an environment transmitted by %bSendEnv()%b
*I <syslib.h> ; <environ.h>
*F WORD GetEnv( Port port, Environ *env );
*A port - port from which the environment is to be received
*A env - structure to be filled with environment
*R Error code
*D See %bSendEnv()%b for a description of the use of
%bGetEnv()%b.
*x getenv\000261
*x SendEnv
#
*n getenv\C library function
*P Searches an environment list for a matching string
*I <stdlib.h>
*F char *getenv(const char *name);
*A name - A pointer to the string to be matched.
*R a pointer to the matched string in the environment list. If the
string to be matched is not found, a null pointer is returned.
*D %bgetenv()%b searches an environment list for the string
pointed to by %sname%s.
*p %bgetenv()%b gets from the host environment options set by the user or
shell (for example, the terminal type).
*c=#include <stdlib.h>
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   char *envvar;
*c=   envvar = getenv("PATH");
*c=   if (envvar == NULL)
*c=      printf("PATH variable not set\n");
*c=   else
*c=      printf("PATH is : %s\n",envvar);
*c=}
*c=
*c=/*
*c= * Output:
*c= *
*c= *         PATH is : /loader:/helios/bin
*c= *
*c= */
*x GetEnv
*x getenv\000262
*q getenv
*q Search environment list for matching string
*q Environment list - search for matching string
*q Matching string in environment list, search for
*q String, search for matching - in environment list
#
*n getenv\Posix library function
*P Searches and accesses the environment list
*I <posix.h> ; <unistd.h>
*F char *getenv (const char *name);
*A name - Pointer to a value in the environment list.
*R If successful, it returns a pointer to a value that is equal to
%sname%s; otherwise, it returns a NULL pointer.
*D %bgetenv()%b searches the environment list for a string of
the form %sname=value%s and returns a pointer to %svalue%s, if such a
string is present. If %sname%s cannot be found, %bgetenv()%b returns a
NULL pointer.
*x GetEnv
*x getenv\000261
*q Environment list - search
*q Environment list - access
*q Environment list - see also getenv
#
*n getenviron\Posix library function
*P Gets program environment structure
*I <unistd.h>
*F Environ *getenv(void);
*D Returns a pointer to the environment structure obtained by
the posix library from GetEnv(). This allows the program to access the
extra Objects passed.
*p This structure should be regarded as READ-ONLY since it is used to build
the environment for programs run via execl() etc.
*q getenviron
*q Helios posix extensions
*x GetEnv
*x execl
#
*n geteuid\Posix library function
*P Gets effective user id
*I <posix.h> ; <unistd.h>
*F uid_t geteuid ( void );
*R effective user id
*D See setuid() for a description of the Helios emulation of
user and group ids.
*x setuid
#
*n GetFileSize\System library
*P Gets the size of the file
*I <syslib.h>
*F WORD GetFileSize ( Stream *stream );
*A stream - Pointer to Stream
*R Size of file
*D This function returns the size of the file in bytes. In the
case of pipes or sockets, %bGetFileSize()%b returns the amount of data
waiting to be read from the stream. (See %bOpen()%b for an example of the
Stream structure.)
*x SetFileSize
*q Stream structure
*q Get size of file
*q File size, get
*q Size of file, get
#
*n getgid\Posix library function
*P Gets real group id
*I <posix.h> ; <unistd.h>
*F gid_t getgid ( void );
*R Real group id
*D See setuid() for a description of the Helios emulation of
user and group ids.
*x setuid
#
*n getgroups\Posix library function
*P Gets access group set
*I <unistd.h>
*F int getgroups ( int setsize, gid_t *list );
*A setsize - size of array
*A list - array to hold groupids
*R number of ids placed in array, always zero
*D Intended to return the set of supplementary group ids
stored by some Unix system; under Helios this routine always returns zero.
*x setuid
#
*n gethostid\Posix library function
*P Gets a unique identifier for the current host processor
*I <sys/socket.h>;<sys/types.h>
*F int gethostid( void );
*D This function is basically identical to the BSD Unix
version of %bgethostid%b; it returns the internet address of the current
machine. This will only work if the tcpip server is running.
*q gethostid
*q tcpip server
*q BSD compatibility, Berkeley
#
*n gethostname\Posix library function
*P Gets the name of the current host processor
*I <sys/socket.h>;<sys/types.h>
*F int gethostname(char *name, int namelen);
*A name - pointer to name array
*A namelen - size of name array
*R 0 if successful; otherwise, returns -1.
*E %serrno%s set to:
*l [EFAULT]
*t name or namelen invalid
*D This function is basically identical to the BSD Unix
version of %bgethostname%b; it returns the name of the current host
processor. Note that %bgethostname()%b only works if the tcpip server is
running.
*q gethostname
*q tcpip server
*q BSD compatibility, Berkeley
#
*n GetInfo\System library
*P Gets any special state information associated with the stream
*I <syslib.h>
*F WORD GetInfo( Stream *stream, byte *info );
*A stream - Pointer to stream structure
*A info - Buffer for information
*R Error code, or the number of bytes in the %sinfo%s buffer.
*D This function obtains any special state information
associated with a stream. In many cases this is a null function, but for
devices such as console streams this is used to get the stream attributes.
This performs similar operations to certain Unix ioctl calls.
*x SetInfo
*q ioctl
*q Special state information
#
*n GetInputSpeed\System library
*P Determines the current input speed associated with a device
*I <attrib.h>
*F WORD GetInputSpeed( Attributes *attr );
*A attr - Pointer to an Attributes structure.
*R The input speed
*D This function extracts the current input speed from a set
of attributes obtained by a previous call to %bGetAttributes()%b.
*x SetAttributes
*x GetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Input speed
*q Changing baud rate
*q Device attribute handling
#
*n getlogin\Posix library function
*P Gets the user name associated with the current task
*I <posix.h> ; <unistd.h>
*F char *getlogin ( void );
*R A string that contains the login name of the user associated
with the current task. This points to static data that can be overwritten
by each call. If it fails to find a user name, it returns a %sNULL%s
pointer.
*D %bgetlogin()%b returns a pointer to a string containing the
user login name associated with the current task. If it cannot locate a
name, it returns an empty string.
*x cuserid
*x getpwent
*x getpwuid
*x getpwnam
*q User name, get - see getlogin
*q Get user name - see getlogin
#
*n GetMsg\System library
*P Receives a message into the message control block
*I <message.h>
*F WORD GetMsg ( MCB *mcb );
*A mcb - Message control block
*R Error code
*D This function receives a message into the message control
block:
*c=typedef struct {
*c=        MsgHdr     MsgHdr;      /* message header buffer      */
*c=        word       Timeout;     /* message timeout            */
*c=        word       *Control;    /* pointer to control buffer  */
*c=        byte       *Data;       /* pointer to data buffer     */
*c=} MCB;
*p %bGetMsg()%b is used with %bPutMsg()%b to effect message passing between
processes. The timeout is in microseconds, a timeout value of -1 will
cause %bGetMsg()%b to wait forever (the effect of a timeout of <-1 is
undefined). A call to %bGetMsg()%b may be terminated either by the arrival
of a message, the expiry of the timeout, or %bAbortPort()%b being called
by another process.
*p %bNote:%b The kernel only checks for timeouts once every second, so
%bGetMsg()%b cannot be used with fine grain timeouts.
*q MCB structure
*q Message control block structure
*q GetMsg
*q PutMsg
*x Abort
*x NewPort
*x PutMsg
*q Message control block structure
*q Receive message into mcb
*q Get message
*q Message, get
*q Message control block (MCB)
*q MCB - see also message control block
#
*n GetOutputSpeed\System library
*P Determines the current output speed associated with a device
*I <attrib.h>
*F WORD GetOutputSpeed( Attributes *attr );
*A attr - Pointer to an Attributes structure.
*R The output speed
*D This function extracts the current output speed from a set
of attributes obtained by a previous call to %bGetAttributes()%b.
*x SetAttributes
*x GetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Changing baud rate
*q Output speed
*q Device attribute handling
*q Attribute handling
#
*n getpeername\Posix library function
*P Gets the name of a connected peer
*I <sys/socket.h>;<sys/types.h>
*F int getpeername(int fd, struct sockaddr *name, int *namelen);
*A fd - file descriptor
*A name - pointer to name array
*A namelen - size of name array (in bytes)
*R 0 if the call succeeds; otherwise, returns -1.
*E
*l [EBADF]
*t Not a valid descriptor
*l [ENOTSOCK]
*t %sfd%s is a file, not a socket
*l [ENOTCONN]
*t The socket is not connected
*l [ENOBUFS]
*t Insufficient resources available
*l [EFAULT]
*t %sname%s points to invalid address space
*D This function is basically identical to the BSD Unix
version of %bgetpeername%b; it returns the name of a peer connected to the
socket represented by %sfd%s.
*q getpeername
*q BSD compatibility, Berkeley
#
*n getpgrp\Posix library function
*P Gets process group id
*I <unistd.h>
*F pid_t getpgrp(void);
*D Since Helios does not support process groups in the Unix
sense, this routine returns -1 and sets errno to EINVAL.
*q getpgrp
*x setpgid
*x setsid
#
*n getpid\Posix library function
*P Gets process id
*I <unistd.h>
*F int getpid(void);
*D Returns the process id of the current process. Since Helios
does not implement a global process id space, process ids are only local
to a particular task. Under normal circumstances this routine will return
42. If called between a vfork() and a call to exec...() or _exit() it will
return the value which will be returned from the parents vfork().
*q getpid
*x vfork
*x getppid
#
*n GetPortInfo\System library
*P Gets information about the given port
*I <message.h>
*F word GetPortInfo(Port port, PortInfo *info);
*A port - port
*A info - pointer to information
*D This kernel call fills in the PortInfo structure with
information about the port, %sport%s. The information supplied depends on
the port type. For Local ports only the Type, Cycle, Age and Owner field
are valid. For surrogate ports the Surrogate field contains the port for
which this is a surrogate, and the Link field contains the link.
*q GetPortInfo
#
*n getppid\Posix library function
*P Returns parent process id
*I <unistd.h>
*F int getppid(void);
*D Under normal circumstances this call will return 41, if
called between a vfork() and a call to exec...() or _exit() it will return
42.
*q getppid
*x vfork
*x getpid
#
*n GetPriority\System library
*P Returns the logical priority level of the process
*I <process.h>
*F word GetPriority(void);
*D This function returns the logical priority level of the
process.
*q GetPriority
*x SetPriority
#
*n GetPriRange\System library
*P Returns the lowest physical priority level available
*I <process.h>
*F word GetPriRange(void);
*D This function returns the lowest physical priority
available. The highest physical priority is zero. The number of process
levels available in this implementation is therefore: GetPriRange() + 1.
*q GetPriRange
*x SetPriority
#
*n GetProgramInfo\System library
*P Waits on the given stream for program status change information
*I <syslib.h>
*F WORD GetProgramInfo ( Stream *stream, WORD *info, WORD timeout
);
*A stream - Pointer to program execution stream
*A info - Pointer to a buffer into which the status update
information will be copied.
*A timeout - Update timeout (-1 = forever)
*R Program status or error, where `status' equals the global
status of all program components.
*D This function waits for the given time for status update
information to be returned by the program. The buffer provided must
include a single %sWORD%s entry for each component of the program.
*p The status information returned for each component will be one of the
following: PS_Terminate, PS_Suspend, PS_Restart, PS_Status.
*x InitProgramInfo
*q Program status information - see also GetProgramInfo
#
*n getpwent\Posix library function
*P Reads the next entry on the password database
*I <pwd.h> ; <sys/types.h>
*F struct passwd *getpwent( void );
*R NULL
*D This function has been removed from POSIX 1003.1-1988 since
it constitutes a potential security loophole.
*x getpwuid
*x getpwnam
*q Password database
*q Password database, get next entry
*q Get next entry on password database
#
*n getpwnam\Posix library function
*P Searches the password database from start to %sname%s
*I <pwd.h>
*F struct passwd *getpwnam(char *name);
*A name - Login name
*R A pointer to an object of type %sstruct%s %spasswd%s containing
an entry from the password database; a NULL pointer on failure or to
indicate end of database. Return values may point to static data that is
overwritten on each call.
*D This function searches the password database from the start
of the database and continues until it finds a value matching %sname%s or
it encounters the end of the database. It returns a pointer to an object
of type %sstruct%s %spasswd%s containing an entry from the password
database.
*q Password database
*x getpwuid
#
*n getpwuid\Posix library function
*P Searches the password database from start to %suid%s
*I <pwd.h>
*F struct passwd *getpwuid(uid_t uid);
*A uid - User ID
*R A pointer to an object of type %sstruct%s %spasswd%s containing
an entry from the password database; a NULL pointer on failure or to
indicate end of database. Return values may point to static data that is
overwritten on each call.
*D This function searches the password database from the start
of the database and continues until it finds a value matching %suid%s or
it encounters the end of the database. It returns a pointer to an object
of type %sstruct passwd%s containing an entry from the password database.
*q Password database
*x getpwnam
#
*n GetReadBuffer\System library
*P Reads from a list of Buffer structures
*I <servlib.h>
*F Buffer *GetReadBuffer(word pos, List *list);
*A pos - first byte to be read
*A list - pointer to buffer list
*D %bGetReadBuffer%b works in conjunction with
%bAdjustBuffers%b and %bGetWriteBuffer%b to manage a list of Buffer
structures.
*q GetReadBuffer
*q GetWriteBuffer
*q AdjustBuffers
*x AdjustBuffers
*x GetWriteBuffer
#
*n GetReady\System library
*P Tests whether a port is ready for reception
*I <message.h>
*F WORD GetReady( Port port );
*A port - Port to test
*R Error code, or zero if the port is ready for a GetMsg() call.
*D This function tests whether a port is ready for reception.
It returns zero if a call to %bGetMsg()%b on this port would complete
immediately. If a non-zero result is returned the process would be blocked
in %bGetMsg()%b. A non-zero return code is also returned if the port is
invalid.
*x PutReady
*q GetMsg
*q Port ready for reception - see GetReady
#
*n gets\C library function
*P Gets a line from standard input
*I <stdio.h>
*F char *gets(char *s);
*A s - A pointer to a buffer that is to receive the string.
*R %ss%s if successful. If end-of-file is encountered before a
character is read, or a read error occurs, %bgets()%b returns a null
pointer.
*E %bgets()%b returns a null pointer, if end-of-file is encountered
before a character is read, or a read error occurs.
*D %bgets()%b reads a string from the standard input file
stream. %bgets()%b stops reading when it encounters a new-line character
or an end-of-file character. Any new-line character is discarded. A string
terminating character is written into the array after the last character
read.
*x fgets
*q gets
*q Get line from standard input
*q Line - get from standard input
*q Standard input - get line from
#
*n getsockname\Posix library function
*P Gets socket name
*I <sys/socket.h>;<sys/types.h>
*F int getsockname(int fd, struct sockaddr *name, int *namelen);
*A fd - file descriptor
*A name - pointer to name array
*A namelen - size of name array
*R zero, or -1 on error.
*D This function is basically identical to the BSD Unix
version of %bgetsockname%b; it returns the current name for the socket.
*q getsockname
*x bind
*x socket
*q BSD compatibility, Berkeley
#
*n getsockopt\Posix library function
*P Gets socket options
*I <sys/socket.h>;<sys/types.h>
*F int getsockopt(int fd, int level, int optname, char *optval, int *optlen);
*A fd - file descriptor
*A level - socket, system or ioctl level number
*A optname - option name
*A optval - address for option value
*A optlen - length of buffer
*R zero, or -1 on error.
*D This function is basically identical to the BSD Unix
version of %bgetsockopt%b; it returns the options set for the given
socket.
*p Here are the level numbers %bgetsockopt()%b can apply to a socket, the
system and an ioctl control device:
*f SOL_SOCKET\0xffff\options for socket level
*f SOL_SYSTEM\0xfff0\options for system level
*f SOL_IOCTL\0xfff1\options for ioctl level
*q getsockopt
*x setsockopt
*q BSD compatibility, Berkeley
#
*n GetTarget\System library
*P Follows the request path from context object to obtain target
*I <servlib.h>
*F ObjNode *GetTarget(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*R Target object or null on failure
*D %bGetTarget()%b locates the actual target object for a
request. It does this by following the %sPathname%s of a previously
located context object. Whenever a handling function is called, the
context object must already have been located. The handler must therefore
call %bGetTarget()%b to locate the actual target. As it follows the path
it updates the AccMask field of the request capability to reflect the
current access rights; if these rights ever become zero a suitable error
occurs. An error also occurs if the name proves to be invalid.
*p Note that the ServInfo structure has changed a little from that
described in earlier documentation:
*c=struct ServInfo{
*c=       DispatchInfo     *DispatchInfo;  /* DispatchInfo struct  */
*c=       MCB              *m;             /* MCB of request	   */
*c=       DirNode          *Context;       /* original context object */
*c=       ObjNode          *Target;        /* the target object	   */
*c=       bool             TargetLocked;   /* Target locked ?	   */
*c=       word             FnCode;         /* request fn code	   */
*c=       jmp_buf          Escape;         /* error/escape jump buffer*/
*c=       char             Pathname[IOCDataMax]; /* current object pathname */
*c=} ServInfo;
*q DirServer
*q GetTarget
*x GetTargetObj
*x GetTargetDir
*x GetContext
#
*n GetTargetDir\System library
*P Locates the parent directory of the target object
*I <servlib.h>
*F DirNode *GetTargetDir(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bGetTargetDir()%b locates the parent directory of the
request's target object. It is used by Delete, Create and Rename requests,
all of which need to manipulate directory entries.
*p A number of changes have been made to the server library since earlier
versions of the documentation. Objects are now locked by
%bGetTargetDir()%b. In most cases this is transparent, except that a call
to %bUnlockTarget()%b must now be added before the %sdo_open%s dispatch
loop.
*p Note also that the ServInfo structure has changed a little from that
described in earlier documentation:
*c=struct ServInfo{
*c=       DispatchInfo     *DispatchInfo;  /* DispatchInfo struct  */
*c=       MCB              *m;             /* MCB of request	   */
*c=       DirNode          *Context;       /* original context object */
*c=       ObjNode          *Target;        /* the target object	   */
*c=       bool             TargetLocked;   /* Target locked ?	   */
*c=       word             FnCode;         /* request fn code	   */
*c=       jmp_buf          Escape;         /* error/escape jump buffer*/
*c=       char             Pathname[IOCDataMax]; /* current object pathname */
*c=} ServInfo;
*q DirServer
*q Delete
*q Create
*q Rename
*q UnlockTarget
*q GetTargetDir
*x GetTarget
*x GetTargetObj
#
*n GetTargetObj\System library
*P Locates a request's target object
*I <servlib.h>
*F ObjNode *GetTargetObj(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bGetTargetObj()%b locates the target object of a request.
%bGetTargetDir()%b must already have been called for this function to work
correctly; otherwise, %bGetTarget()%b should be called.
*p A number of changes have been made to the server library since earlier
versions of the documentation. Objects are now locked by
%bGetTargetObj()%b. In most cases this is transparent, except that a call
to %bUnlockTarget()%b must now be added before the %sdo_open%s dispatch
loop.
*p Note that the ServInfo structure has changed a little from that
described in earlier documentation:
*c=struct ServInfo{
*c=       DispatchInfo     *DispatchInfo;  /* DispatchInfo struct  */
*c=       MCB              *m;             /* MCB of request	   */
*c=       DirNode          *Context;       /* original context object */
*c=       ObjNode          *Target;        /* the target object	   */
*c=       bool             TargetLocked;   /* Target locked ?	   */
*c=       word             FnCode;         /* request fn code	   */
*c=       jmp_buf          Escape;         /* error/escape jump buffer*/
*c=       char             Pathname[IOCDataMax]; /* current object pathname */
*c=} ServInfo;
*q DirServer
*q UnlockTarget
*q GetTarget
*q GetTargetDir
*x GetTarget
*x GetTargetDir
*q GetTargetObj
#
*n gettimeofday\Posix library function
*P Returns the current "wall clock" time
*I <sys/time.h> ; <sys/types.h>
*F int gettimeofday (struct timeval *tv, struct timezone *tz );
*A tv - pointer to overall time
*A tz - pointer to local timezone information
*R zero, or -1 on error.
*D %bgettimeofday()%b finds the time in seconds and
microseconds since the dawn of time (midnight, January 1, 1970) and sets
the timezone values in the structure %sstruct%s %stimezone%s, from which
the current local time can be computed.
*p The time structures in %ssys/time.h%s
*c=struct timeval {
*c=      unsigned long  tv_sec;
*c=      long           tv_usec;
*c=};
*c=
*c=struct timezone {
*c=       int        tz_minuteswest;
*c=                  /* minutes west of Greenwich */
*c=       int        tz_dsttime;
*c=                  /* type of DST correction */
*c=};
*p This function was included for compatibility with BSD.
*q gettimeofday
*x time\000643
#
*n getuid\Posix library function
*P Gets the user id
*I <unistd.h>
*F uid_t getuid(void);
*R user id
*D See setuid() for a description of the Helios emulation of
user and group ids.
*x setuid
*x cuserid
*x geteuid
#
*n GetWriteBuffer\System library
*P Writes to a list of Buffer structures
*I <servlib.h>
*F Buffer *GetWriteBuffer(word pos, List *list);
*A pos - starting point for write
*A *list - pointer to list of data buffers
*D %bGetWriteBuffer%b works in conjunction with
%bAdjustBuffers%b and %bGetReadBuffer%b to manage a list of Buffer
structures.
*q GetReadBuffer
*q GetWriteBuffer
*q AdjustBuffers
*x AdjustBuffers
*x GetReadBuffer
#
*n glob\Helios command
*P Displays a given wordlist to stdout
*F glob <wordlist>
*D This shell command is similar to %becho%b. It differs from
%becho%b in that it does not allow `\' escapes in %swordlist%s and it
displays input words, which are separated by blank spaces in %swordlist%s,
separated by the null character. This means that the words in %swordlist%s
are run together as one continuous flow of characters and appear as one
line of output with no reflection of the terminating RETURN. For instance,
*c=% glob mary had a little lamb<RETURN>
*p where %% is the prompt, would appear as:
*c=maryhadalittlelamb%
*p If\%s<newline>%s is given within %swordlist%s, the shell indicates an
error but reflects a space:
*c=%glob mary had a\<RETURN>
*c=little lamb<RETURN>
*c=maryhada littlelamb%
*p Notice that if you give %swordlist%s as a string, the blank spaces
between the individual words are reflected, as is the newline after the
backslash, but the final RETURN is not reflected:
*c=% glob 'mary had a\<RETURN>
*c=little lamb'<RETURN>
*c=mary had a
*c=  little lamb%
*p As with %becho%b, this command is often used within a shell script.
*q Shell scripts
*q Shell commands
*q glob
*x echo
#
*n gmake\Helios command
*P Maintains program groups
*F gmake [-f <makefile>] [<opt>...] [<macro>...] <file>...
*D This command is the Gnu version of the %bmake%b command.
Full documentation can be found on the Unsupported Software disc.
*x make
#
*n gmtime\C library function
*P Converts Greenwich Mean Time (GMT) into a tm structure format.
*I <time.h>
*F struct tm *localtime(const time_t *time);
*A time - pointer to a location containing a time value
*R a pointer to a tm calendar structure, containing the value of
time in a broken down form.
*D %bgmtime%b breaks down a time value of type %stime_t%s at
location %stime%s into year, month, day, hour, minutes, seconds and so on
which it saves in the internally maintained %stm%s structure. For example:
*c=/* Prints the current GMT date and time */
*c=
*c=#include <time.h>
*c=#include <stdio.h>
*c=
*c=int main()
*c={
*c= time_t current;
*c= struct tm *calendar;
*c=
*c= time(&current);
*c= calendar = gmtime(&current);
*c= printf ("\n Date and time = %s\n", asctime(calendar));
*c=}
*x asctime
*x ctime
*x strftime
*x clock
*x difftime
*x localtime
*x mktime
*x time\000642
*q gmtime
#
*n goto\Helios command
*P Goes to a specified point and continues execution
*F goto <word>
*D The %bgoto%b command takes %sword%s and expands it to
produce a string of the form `label'. The shell then rewinds its input as
far as it can, searching for a command line of the form `label:' (which
may be preceded by blanks or tabs). In the case of the shell taking input
from a file, the shell will rewind to the start of the file. For
interactive input the shell keeps a record of up to the last 100 lines
entered and will rewind to the start of this. Once it has found a line
which matches this form, it continues execution immediately after that
line. %bgoto%b is a good example of a built-in shell command which you
would commonly use in a shell script rather than from the terminal.
*p The following example:
*c=label:
*c=      set value=$<
*c=      if ($value !~ [0-9]) goto label
*p can be roughly translated as `If you enter any value other than 0, 1, 2,
3, 4, 5, 6, 7, 8, or 9, then go back to label:' (that is, in this case,
`repeat the loop').
*q Shell commands
*q goto
*q Shell scripts
*x foreach
*x if
*x switch
#
*n grep\Helios command
*P Searches a file for a given text pattern
*F grep [-v] [-n] [-s] [-e] <pattern> <file list>
*D This command searches through all the files in %sfile list%s for occurrences of %spattern%s. The action of %bgrep%b depends on
the flags given.
*p If no flags are given %bgrep%b looks for all lines containing
%spattern%s, and for each line which matches it prints the name of the
file followed by the contents of the line.
*p If the %b-v%b flag is given %bgrep%b prints all the lines that don't
match %spattern%s.
*p If the %b-n%b flag is given %bgrep%b includes a line number after the
file name.
*p If the %b-s%b flag is given %bgrep%b works silently, printing nothing.
It does, however, set a return code which can be tested in a shell script
to determine whether a set of files contains the specified pattern.
*p The %b-e%b flag introduces the pattern which is to be matched. Normally
this flag can be omitted as the pattern is assumed to be the next item; it
is only needed when the pattern starts with a `-'.
*p The %sfile list%s is a list of files, normally produced by the shell
wild card expansion, which can also include the file name `-' to represent
the standard input, stdin. stdin is also used if the file list is empty.
*p The %spattern%s consists of a string where some of the characters have
special meanings. The special characters are used to match characters
other than themselves although they can be treated as normal characters by
preceding them by a backslash `\'. The characters and their actions are
listed below.
*l caret
*t Matches the start of a line.
*l $
*t Matches the end of a line.
*l .
*t Matches any single character.
*l [ ]
*t Matches one of the set of characters contained within them. For
instance,
*l [abc]
*t matches either `a', `b' or `c'. A range of characters can be specified
by using a `-' character, so that, for example, any lower case letter is
specified by [a-z].
*l *
*t Matches zero or more occurrences of the preceding pattern.
*l +
*t Matches one or more occurrences of the preceding pattern.
*l ?
*t Matches one occurrence of the preceding pattern.
*l |
*t Divides two alternative patterns, either of which may match.
*l ()
*t Used to enclose a pattern. Thus a(b|c)d matches abd or acd while
(ab)|(cd) matches ab or cd.
*p Many of these characters also have special meaning to the shell. It is
normally best to enclose the entire pattern in single quotes (` ') which
stops the shell from acting on them.
*p The command %bfgrep%b is a smaller and faster version of grep which may
be used when %spattern%s is a simple string.
*x fgrep
*x egrep
*x find
*q Pattern matching
*k Searching for pattern match
*k Finding pattern
*q grep
#
*n head\Helios command
*P Displays the beginning of a file
*F head [-b<n>] [-l<n>] [-n<n>] [-<n>] <file>...
*D %bhead%b is the converse of %btail%b: it displays the first
part of a file. The default amount displayed is 10 lines. You can alter
the number of lines %bhead%b displays by specifying the number of lines
you need after the hyphen. For example,
*c=head -15 fred
*p displays the first 15 lines of the file `fred'. You can give head more
than one file, in which case it displays the first part of each file in
succession. %bhead%b will display the same number of lines for each of the
files listed. In other words,
*c=head -15 tom dick harry
*p displays the first 15 lines of the file `tom', the first 15 of `dick'
and then the first 15 of `harry'.
*p %bhead%b also accepts the options %s-b%s, %s-l%s and %s-n%s. %b-b%s
specifies the number %sn%s to be in blocks and %s-l%s specifies it to be
in lines; %s-n%s specifies the number of lines or blocks of output, where
lines is the default.
*p %bhead%b is particularly useful for having a quick look at a file if
you've forgotten what is there; it is much quicker than running %bmore%b.
*q head
*q Displaying first part of file
*x tail
#
*n Helios hierarchical naming scheme\General interest
*P Provides a graded series of directly accessible named items.
*F [/<cluster>]/<processor>[/<device>|/<server>|/<dir>/<file>]
*D Helios provides a single hierarchical structure for named
items. These named items include processor clusters, individual
processors, devices, servers, directories and files. To the user, the
structure is identical to a Unix-style directory structure, with the name
levels separated by forward slashes (/<name>/<name>).
*p On startup, certain named items will already be set up and visible.
These preloaded items include, for instance, /tasks, which exists on each
processor's name table. Other items, such as /ram, exist but are only
visible once they have been accessed. Finally, some items (for example,
aliases) do not exist unless they are loaded by the user.
*p These named items in the hierarchy respond to a range of Helios commands
(including, for instance, %bls%b, %brm%b, and %bcd%b). If you wish to find
out about the files in a directory, you can use the %bls%b command in the
usual way. An information request goes to the server and the information
you are interested in is ultimately displayed via your standard output
device (text window). Similarly, you can list information on any pipes
that are currently open by typing 'ls /pipe', and on the tasks that are
currently running by typing 'ls /tasks', and so on.
*p To list the cluster(s) of processors at the top level, you simply type
'ls /'. You can examine the contents of one of these clusters by typing a
slash followed by the name of the cluster you are interested in; for
example, 'ls /netA'. Again, you can look more closely at one of the
processors in cluster netA by typing, for example, 'ls /netA/00'. By
listing /00 you will find all the servers running on that processor.
*p You need not necessarily know where a server is running as Helios will
find it for you. Some servers run on all processors and some may only run
on one. For example, there should be a /tasks on every processor. If you
wish to list the tasks running on a particular processor, you would have
to name the processor when referring to /tasks (for example, 'ls /00/tasks'
would produce a different listing from 'ls /01/tasks'; 'ls /tasks' would
just find the task on the processor on which ls was running).
*q Hierarchical structure
*x Processor
*x Server
#
*n Helios server\General interest
*P The root of the Helios system file structure
*F /helios
*D The helios server is the root of the helios system file
structure. This server is usually provided by the I/O server and is usually
mapped directly on to a subdirectory with the same name somewhere on the
host machine.
*x I/O-server
*x Server
#
*n Heliosno\System library
*P Extracts the underlying Helios Stream from a C stream
*I <nonansi.h> ; <stdio.h.>
*F Stream *Heliosno(FILE *Cfile);
*A *Cfile - A pointer to a C stream
*R The corresponding Helios Stream
*D Every C stream is based on a Helios Stream. When the C
library %bfopen()%bs a file to return a %sFILE *%s pointer, the library
does an %bOpen%b returning a Helios Stream pointer, which is stored inside
the FILE structure. The routine %bHeliosno()%b extracts this pointer,
allowing the programmer to use Helios routines on it.
*c=#include <stdio.h>
*c=#include <nonansi.h>
*c=#include <attrib.h>
*c=
*c=int main(void)
*c={ Stream *Helios_stream = Heliosno(stdin);
*c=  Attributes attr;
*c=  WORD fnrc;
*c=
*c=  if ((fnrc = GetAttributes(Helios_stream, &attr)) < 0)
*c=    { printf("Unable to obtain stdin attributes : %x.\n", fnrc); exit(1);
*c=    }
*c=
*c=  RemoveAttribute(&attr, ConsoleEcho);
*c=
*c=  if ((fnrc = SetAttributes(Helios_stream, &attr)) < 0)
*c=    { printf("Unable to set stdin attributes : %x.\n", fnrc); exit(1);
*c=    }
*c=}
*q Extract underlying Helios Stream from C stream
*q Helios Stream, extract from C stream
#
*n help\Helios command
*P Provides interactive on-line explanation of Helios commands,
calls, terms, and so on
*F help [-eao] [<keyword>...]
*D At its simplest level, %bhelp%b provides a straight-forward
on-line reference manual. It is, however, capable of far more than this:
it can act like an encyclopaedia, enabling you to browse from topic to
topic, following cross reference links; it can also allow you to question
the database directly, and in your own words.
*p The %bhelp%b utility is simple to use.  Any highlighted text can be selected. To make a selection, move the screen cursor until it is directly over the
highlighted text you are interested in and then press the RETURN key
(Enter key).
*p The top level of %bhelp%b is the first screen displayed when you give
the command without a qualifying %skeyword%s. This screen gives a brief
introduction to Helios Help and the provides you with a choice of looking
at the Help tutorial, listing the Contents page, or entering in a query.
If you select the tutorial, you will be given a simple introduction to
using Helios Help. By selecting Table of Contents, you will be given a
list of the different sorts of reference material currently held by Help
(for example, Helios commands, System library functions, and so on). Any
of the items listed here can be selected. On selecting one of these items
(for instance, Helios commands), you will be given another list, this time
containing all the captions associated with all the entries of that type
(that is, all the Helios commands). You can then select whatever command
you are interested in (this one, for example, will appear as a highlighted
box followed by the title %bhelp%b), whereupon Help will display the
reference entry associated with that command. Some entries contain cross
references (after the text %bSee also%b). To look at a cross reference
entry, move the cursor until it is pointing at the reference you wish to
look at and then press RETURN.
*p If you are not sure where to find out a particular item of information,
you should select %bGeneral enquiry%b. You can then interrogate the
database in your own words. The response you get may not be quite what you
intended: the English language is not exact and %bhelp%b is only a dumb
information retrieval system.
*p %bhelp%b entries have an underlying similarity of layout: they all have
an entry title, an entry type subject title, a brief explanation of the
topic covered by the entry, and a fuller description of the topic. Where
applicable, they may also contain a formal description of the syntax. An
entry may also have cross references to other entries. These cross
references are highlighted and can be selected by the user (see above).
*p The optional %skeyword%s argument can be any text string that you
consider might match a topic covered by %bhelp%b. The string could be a
simple English sentence; for example, %bhelp%b how do I compile something.
If you specify a keyword that makes a good match with an entry title, then
%bhelp%b displays that entry. If %bhelp%b finds a number of entries, all
of which match the keyword(s) equally well, then it displays a caption
list of the entry titles it has found for you to make your own choice. In
cases where %skeyword%s fails to make any sort of match, the message
%bsorry, nothing found%b appears on the screen. The best thing to do then
is to invoke %bhelp%b without any qualifying keyword. You can then
redefine your enquiry or simply browse through the %bTable of Contents%b
looking for inspiration!
*p Once you are familiar with the ideas behind the help system, there are some command line options to allow you to control the way that help behaves. The %b-e%b option instructs help to search for exact matches in the document titles only. This mode of operation is similar to UNIX %bman%b operation. If you are used to the UNIX method, try aliasing man to 'help -e'.
*p The %b-a%b option instructs help to use multiple search terms to %srefine%s a search rather than broaden it. The %b-o%b option does the opposite and is help's default mode of operation. For an idea of the difference between these modes, try:
*l help -a string copy
*p and
*l help string copy
*p Environment Variables
*p The help database normally resides in the `lib' directory on your system. Should you need to access a database elsewhere on the system (or even on another system), the environment variable %bHELP_DBPATH%b can be set to tell %bhelp%b where the database is located. For example:
*l setenv HELP_DBPATH /helios/users/guest/mylib
*q help
*q On-line documentation
*k Information retrieval
*k Database
*x alias
*x setenv
#
*n history\Helios command
*P Displays a list of past events and to enable their repetition
*F history [-r] [<n>]
*D This shell command displays a list of previous events
(known as the `history list'). If you give the command without
qualification, the shell lists the maximum number of events that it holds
on the list, with the earliest command at the beginning of the list and
the latest command at the end. The shell variable `history' defines the
maximum size of the list (a default of 20 is normally set-up in `cshrc').
Each event in the list has an associated number, which is allocated in
ascending order from the first to the last (that is, if the last event is
numbered %sx%s, the penultimate event is %sx%s-1, the one before that is
(%sx%s-1)-1, and so on back through the list). These numbers appear to the
left of the event.
*p You can specify the decimal integer %sn%s to ensure that only the last
%sn%s events appear. For example, suppose you type the command line:
*c=history 4
*p it might provoke something like the following history list:
*c=101 cd doc
*c=102 ls -l
*c=103 more chapter1
*c=104 history 4
*p The -r option enables you to reverse the order in which the shell
displays the list. In other words, it gets you a list that has the latest
event as the first item and the earliest event as the last one. For
example,
*c=history -r 4
*p produces the following list:
*c=104 history -r 4
*c=103 more chapter1
*c=102 ls -l
*c=101 cd doc
*p You can also edit the history list and substitute a command from the
list for the current command. A full explanation of this can be found in
the %sHelios Shell%s document in the %sHelios Operating System%s manual.
*q history
*q Event list
*q History event list
*q Shell commands
#
*n Hydra\General interest
*P Service allowing I/O server to access one or more processor
links
*D This is a program, sometimes called the link daemon, that
runs on certain Unix machines to provide a service which allows the I/O
server to access one or more processor links, either locally or across
the network. Depending on the hardware, the Hydra daemon will normally
allow access to one or more processor links (sites) on a single board
from any user who can run the I/O server, either locally or across the
network.
*q Sites
*q Network
*q Accessing processor links
*q Link daemon
*x Hydramon
*x I/O-server
#
*n Hydramon\General interest
*P Monitors and changes the actions of the Hydra link daemon
*D This is a small program that can be used by administrators
to monitor and change the actions of the link daemon, Hydra. When the
program is run it gives a menu of possible actions to be taken, such as
seeing which links (sites) are in use.
*q links
*q sites
*x Hydra
#
*n I/O-processor\General interest
*P Provides the input/output service
*F /IO
*D The I/O processor runs the I/O server. To examine the IO
processor, type 'ls /IO'.
*q I/O-server
*x I/O-server
#
*n I/O-server\General interest
*P Makes the host processor act like a processor running Helios
*D The I/O server causes the host processor (if there is one)
to behave as if it were a processor running Helios; in particular, it
emulates a number of Helios servers inside the host computer. These
servers depend on the facilities offered by the host. On a PC, for
example, they support the following devices: the discs A, B, and C; the
RS232 and Centronics ports; the mouse; the clock; the keyboard, and so on.
*p The I/O server is run at the beginning of a session by typing 'server'
while set in the helios directory on the host.
*q I/O server
*q Helios server
#
*n id\Helios command
*P Returns user and group identifier information to the standard
output (stdout)
*F id [-g|-u [-nr]] [<user>]
*D The %bid%b command finds and returns user identifier
information (uid) to the standard output. If you specify the optional user
name %suser%s, %bid%b provides information on that user (by default, in
numeric and string form). %bid%b only returns this information, however,
if you have the appropriate privileges.
*p If you do not specify %suser%s, %bid%b finds and returns the user
identifier of the invoking process.
*p %bid%b also attempts to return information on group identifiers (gid).
Helios currently supports zero groups, although this may change; but it
means that any group information returned from %bid%b is not very helpful
at present.
*p The options accepted by this command are as follows:
*l Option
*t Description
*l -g
*t Displays the group id in numeric form, followed by a new line. (Note
that, at present, this option will always display: 0%s<newline>%s.)
*l -u
*t Displays the user id in numeric form, followed by a new line.
*l -n
*t Displays the string associated with a numeric id (user or group) and
then gives a new line. This option is used in conjunction with %b-u%b or
%b-g%b.
*l -r
*t Displays the real id instead of the effective id when used with %b-u%b
or %b-g%b. (At present, Helios does differentiate between effective or
real ids.)
*p Here are some examples that use these options:
*c=% id fred
*p displays:
*c=uid=104(fred) gid=0()
*c=
*p Notice that the group id returns zero and an empty string; this is
because Helios knows about group identifiers, but does not use them.
*c=% id -g fred
*p displays:
*c=0
*c=
*c=% id -g -n fred
*p displays:
*c=<empty string>
*c=% id -u fred
*p displays:
*c=104
*c=
*p being the numeric id associated with the user "fred". Whereas
*c=% id -u -n fred
*p displays:
*c=fred
*c=
*p being the string associated with fred's uid. While
*c=% id -u -r fred
*c=
*p displays:
*c=0
*c=
*p This may change if Helios is altered to differentiate between real and
effective ids.
*q id
*q uid - see id
*q gid - see id
*q User identifier - see also User id
#
*n if\Helios command
*P Executes a command if a given expression evaluates TRUE
*F if (<expression>) <command>
*D The %bif%b command evaluates %sexpression%s and if the
value is TRUE (that is, any non-zero value), it executes %scommand%s,
where %scommand%s is a single command with arguments. Variable
substitution occurs for the whole line in the usual way. If %bif%b
evaluates %sexpression%s and it returns FALSE (zero), then nothing
happens. An example of %bif%b is as follows:
*c=% if ($user == charles) echo Hello Mr Babbage
*p %scommand%s must not be a pipeline, a command list, or a bracketed
command list; it may only be a simple command.
*q Shell commands
*q if
*k Shell scripts
*x if..then..else
#
*n if..then..else\Helios command
*P Executes a command sequence conditionally upon the value of an
expression
*F if (<expression>) then ; <command> ; ... ; else <command> ; ...
; endif
*D The format of the shell %bif..then..else%b construct is
such that %s<command>%s may also be a nested %bif..then..else%b. The
action of an %bif..then..else%b sequence depends on the value of
%sexpression%s. If it evaluates the first %sexpression%s to TRUE (returns
a non-zero value), then it executes the first %scommand%s. If it evaluates
to FALSE (returns zero), it moves on to the first %selse%s and evaluates
its %sexpression%s, if that too fails, it moves on again to the next one
in the sequence, and so on until it finds something it can execute or it
reaches %bendif%b. Execution stops with %bendif%b.
*p Notice that you can have as many %selse if%s steps as you like,
providing any number of alternative actions. The final %selse%s part of
the format is optional, but because it does not require an expression to
be TRUE, you can use it as a catch-all condition.
*p %bendif%b must be on a line by itself.
*q Shell commands
*k Shell scripts
*q if..then..else
*x else
*x endif
*x if
#
*n InitList\System library
*P Initializes the list to empty
*I <queue.h>
*F void InitList ( List *list );
*A list - Pointer to List structure
*R Nothing.
*D This function initializes the List structure to an empty
state. (See %bAddHead()%b for an example of the List structure.)
*q List handling - see also InitList
*q Initialize list to empty
*q List, initialize to empty
*q List structure
*q AddHead
*x AddHead
#
*n InitMCB\System library
*P Initializes an MCB in preparation for marshalling
*I <syslib.h> ; <message.h>
*F void InitMCB( MCB *mcb, byte flags, Port dest, Port reply, word
fnrc );
*A mcb - Pointer to MCB to be initialized
*A flags - Value for MsgHdr.Flags
*A dest - Destination port
*A reply - Reply port
*A fnrc - Value for MsgHdr.FnRc
*D This function initializes the fields of the MCB to the
given values. It zeroes MsgHdr.Co, ContSize, and MsgHdr.DataSize and sets
MCB.Timeout to IOCTimeout.
*q MCB, initialize
*q Marshalling
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalData
*x MarshalCommon
*x MarshalObject
*x MarshalStream
#
*n InitNode\System library
*P Initialises the fields of an ObjNode structure for inclusion in
server directory
*I <servlib.h>
*F void InitNode(ObjNode *o, string name, int type, int flags,
Matrix matrix);
*A o - pointer to ObjNode
*A name - entry name
*A type - entry type
*A flags - flag word
*A matrix - access matrix
*D %bInitNode()%b initialises the fields of an ObjNode
structure prior to its inclusion in a server directory. The object node
structure is as follows:
*c=struct ObjNode {
*c=      Node           Node;           /* link in directory list */
*c=      char           Name[NameMax];  /* entry name */
*c=      word           Type;           /* entry type */
*c=      word           Flags;          /* flag word */
*c=      Matrix         Matrix;         /* access matrix */
*c=      Semaphore      Lock;           /* locking semaphore */
*c=      Key            Key;            /* protection key */
*c=      struct DirNode *Parent;        /* parent directory */
*c=      DateSet        Dates;          /* dates of object */
*c=      word           Account;        /* owning account */
*c=      word           Size;           /* object size */
*c=      List           Contents;       /* whatever this object contains */
*c=                                     /* may be cast to something else */
*c=} ObjNode;
*q InitNode
*q ObjNode
#
*n InitPool\System library
*P Initializes a memory pool
*I <memory.h>
*F WORD InitPool ( Pool *pool );
*A pool - Pointer to a memory pool structure
*R Error code
*D This function initializes the memory pool using the memory
pool structure:
*c=typedef struct {
*c=     Node        Node;       /* queuing node             */
*c=     List        Memory;     /* list of blocks owned     */
*c=     word        Blocks;     /* number of blocks in pool */
*c=     word        Size;       /* total size of pool       */
*c=     word        Max;        /* initial size of pool     */
*c=} Pool;
*q Initialize memory pool - see InitPool
*q Memory pool, initialize - see InitPool
*q Pool structure
*q Memory pool structure
*x AllocMem
*x FreeMem
*x FreePool
#
*n InitProcess\System library
*P Initialises a process for execution
*I <kernel.h>
*F word *InitProcess(word *stack, VoidFnPtr entry, VoidFnPtr exit,
word *display, word nargs);
*A stack - pointer to stack
*A entry - code to be executed
*A exit - return address
*A display - pointer to initialised display passed to call
*A nargs - number of bytes of arguments to be passed
*D This function initialises a process for execution.
%sstack%s points to the top of the memory to be used as the stack.
%sentry%s is the code to be executed in the process. %sexit%s is the
return address for when it returns. %sdisplay%s points to the initialised
display passed to the initial call. %snargs%s is the number of bytes of
arguments to be passed in. The stack is initialised according to the
standard calling conventions and a pointer returned to the space left for
the arguments.
*q InitProcess
#
*n InitProgramInfo\System library
*P Informs the server that the given status information is
required for the program.
*I <syslib.h>
*F WORD InitProgramInfo ( Stream *stream, WORD status );
*A stream - Stream to executing program
*A status - Particular status changes of interest
*R Size of the status vector (words) returned by
%bGetProgramInfo()%b; zero indicates no status available.
*D This function tells the relevant stream server to notify
the client of changes in program status. The status field defines what
particular status changes are of interest. Status requests may include one
or more of the following: PS_Terminate, PS_Suspend, PS_Restart, PS_Status.
PS_Terminate indicates wait for program termination. If PS_Status included
all status changes are reported.
*x GetProgramInfo
*q GetProgramInfo
*q Status information
*q Program status information
*q Server
#
*n initrc\General interest
*P Determines the various servers and programs to be run on
booting
*D The file %binitrc%b is used by Helios as it boots in order
to determine the various servers and other programs which are to be run.
It is important to note that the file is not a shell script (as the shell
is not even running at this time); it is merely a set of instructions for
the Helios initialisation program.
*p Normally the %binitrc%b file is used to start the network manager,
possibly start the X Window System and to spawn one or more invocations of
%blogin%b.
#
*n InitSemaphore\System library
*P Initializes the fields of the semaphore
*I <sem.h>
*F void InitSemaphore ( Semaphore *semaphore, int count );
*A semaphore - Pointer to semaphore to be initialized
*A count - Initial value of semaphore counter
*R Nothing
*D This function initializes the fields of the semaphore and
seeds the count with the value given.
*c=typedef struct {
*c=        word     Count;    /* semaphore counter     */
*c=        word     *Head;    /* head of process list  */
*c=        word     *Tail;    /* tail of process list  */
*c=} Semaphore;
*q Initalize semaphore fields
*q Semaphore fields, initialize
*q Initialize fields of semaphore
*q Fields of semaphore, initialize
*q Semaphore fields, initialize
*q Semaphore structure
*x Signal
*x Wait
#
*n InPool\System library
*P Tests to see if a memory pool contains an address
*I <memory.h>
*F bool InPool( void *mem, Pool *pool);
*A mem - Address to test
*A pool - Pool to test
*R True or False
*D This function tests whether the given memory address lies
within one of the memory blocks which belong to the given memory pool.
*q Memory pool, test for address
*q Check given memory address in memory pool
*q Memory address, check in memory pool
*x InitPool
*x FreePool
#
*n Insert\System library
*P Inserts an object into a directory
*I <servlib.h>
*F void Insert(DirNode *dir, ObjNode *obj, bool dirlocked);
*A dir - pointer to directory node structure
*A obj - pointer to object node structure
*A dirlocked - specifies locking condition
*D %bInsert()%b inserts an object into a directory. Various
fields in both structures are altered to reflect this insertion. The
directory may be locked during this operation to prevent other processes
seeing an inconsistent state.
*q Insert
*x Unlink
#
*n InvalidFn\System library
*P Implements a handler for the IOC function InvalidFn
*I <servlib.h>
*F void InvalidFn(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bInvalidFn()%b implements a handler for the IOC function
InvalidFn. If a server has no need of any special handling of this
function, a pointer to the function may be installed in the DispatchInfo
function table. InvalidFn() generates an error message if particular
operations need to be forbidden.
*p Note that the ServInfo structure has changed a little from that
described in earlier documentation:
*c=struct ServInfo{
*c=       DispatchInfo     *DispatchInfo;  /* DispatchInfo struct  */
*c=       MCB              *m;             /* MCB of request	   */
*c=       DirNode          *Context;       /* original context object */
*c=       ObjNode          *Target;        /* the target object	   */
*c=       bool             TargetLocked;   /* Target locked ?	   */
*c=       word             FnCode;         /* request fn code	   */
*c=       jmp_buf          Escape;         /* error/escape jump buffer*/
*c=       char             Pathname[IOCDataMax]; /* current object pathname */
*c=} ServInfo;
*q DirServer
*q InvalidFn
#
*n IOdebug\System library
*P Provides a debugging facility
*I <nonansi.h>
*F void IOdebug(const char *fmt, ...);
*A *fmt - A format string
*D %bIOdebug()%b is similar to %bprintf()%b, but it performs
its output at a lower level by sending messages directly to your screen
and bypassing all buffering. The data is almost guaranteed to be
displayed, no matter how badly your program is crashing the system. The
format string only supports %%d, %%x, %%s and %%c format escapes, without
any modifiers. It will not, for example, handle the format modifiers of
the %bprintf()%b series of functions.
*p %bNote:%b This function should not be used as a regular output device
since on some systems the messages may be thrown away.
*c=#include <nonansi.h>
*c=
*c=int main(int argc, char **argv)
*c={ IOdebug("main entered with argc==%d\n", argc);
*c=
*c=}
*c=/* Outputs the following message:
*c=
*c=+++ main entered with == x
*c=*/
*q Debugging - see also IOdebug
*q printf
*q IOdebug
*x printf
#
*n IOputc\System library
*P Generates debugging output
*I <nonansi.h>
*F IOputc( char c );
*A c - Character to output
*D This function outputs the single character to the IO
processor's principle output device, bypassing all normal stream I/O
systems. It is intended as a debugging option and is used by
%bIOdebug()%b.
*q Debugging output, generate
*x IOdebug
*x IOputs
#
*n IOputs\System library
*P Generates debugging output
*I <nonansi.h>
*F IOputs( char * s)
*A s - character string to output
*D This function outputs a character string to the IO
processor's principle output device, bypassing all normal stream I/O
systems. It is intended as a debugging option and is used by
%bIOdebug()%b.
*x IOdebug
*x IOputc
#
*n isalnum\C library function
*P Tests a character to see if it is alphanumeric
*I <ctype.h>
*F int isalnum(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is alphanumeric and zero
(false) if it is not.
*D %bisalnum()%b tests whether the character %sc%s is one of
the following alphabetic or numeric characters: 'a' to 'z', 'A' to 'Z', or
'0' to '9'
*x isalpha
*x isdigit
*q isalnum
*q Test character - alphanumeric
*q Alphanumeric characters
*q Alphabetic characters
*q Numeric characters
#
*n isalpha\C library function
*P Tests a character to see if it is alphabetic
*I <ctype.h>
*F int isalpha(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is alphabetic and zero (false)
if it is not.
*D %bisalpha()%b tests whether %sc%s is one of the following
alphabetic characters: 'a' to 'z', or 'A' to 'Z'.
*x isalnum
*x isdigit
*q isalpha
*q Test character - alphabetic
*q Alphabetic characters
#
*n IsAnAttribute\System library
*P Examines a set of device attributes
*I <attrib.h>
*F WORD IsAnAttribute(Attributes *attr, Attribute item);
*A attr - Pointer to an Attributes structure
*A item - Attribute to be checked
*R TRUE or FALSE
*D This function sees whether the attribute specified forms
part of the set of attributes obtained by a call to %bGetAttributes()%b.
*q Device attribute handling
*q Attribute handling
*x SetAttributes
*x GetAttributes
*x AddAttribute
*x RemoveAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
#
*n isatty\Posix library function
*P Tests to see if %sfd%s is a valid file descriptor associated
with a terminal
*I posix.h ; unistd.h
*F int isatty (int fd);
*A fd - File descriptor
*R The value 1, if successful; the value 0, if unsuccessful.
*D %bisatty()%b tests to see if %sfd%s is a valid file
descriptor associated with a terminal. If it is valid, %bisatty()%b
returns the value 1; otherwise, it returns zero.
*q Terminal device name
#
*n iscntrl\C library function
*P Tests to see if a character is a control character
*I <ctype.h>
*F int iscntrl(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a control character and
zero (false) if it is not.
*D %biscntrl()%b tests to see whether %sc%s is a control
character.
*q iscntrl
*q Test character - control character
*q Control character, test for
#
*n isdigit\C library function
*P Tests to see if a character is a decimal digit
*I <ctype.h>
*F int isdigit(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a digit and zero (false) if
it is not.
*D %bisdigit()%b tests whether %sc%s is one of the following
decimal digits: '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'.
*x isalnum
*x isalpha
*q isdigit
*q Test character - decimal digit
*q Decimal digit, test for
*q Digit (decimal), test for
#
*n isgraph\C library function
*P Tests to see if a character is a printable non-space character
*I <ctype.h>
*F int isgraph(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a printable character
(other than space (' ')) and zero (false) if it is not.
*D %bisgraph()%b tests whether %sc%s belongs to the set of
printable characters. For the purposes of this test the space character ('
') is considered to be a non-printable character.
*q Space character ' '
*q isgraph
*q Test character - printable non-space character
*q Printable non-space character, test for
*q Non-space character (printable), test for
*x iscntrl
*x isprint
*x isspace
#
*n islower\C library function
*P Tests to see if a character is a lower-case letter
*I <ctype.h>
*F int islower(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a lower-case letter and
zero (false) if it is not.
*D %bislower()%b tests whether %sc%s is a lower-case letter in
the range: a-z.
*x isupper
*q islower
*q Test character - lower-case letter
*q Lower-case letter, test for
*q Letter (lower-case), test for
#
*n isprint\C library function
*P Tests to see if a character is a printable character (including
space)
*I <ctype.h>
*F int isprint(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is printable and zero (false)
if it is not.
*D %bisprint()%b tests whether %sc%s is a printable character.
Unlike the %bisgraph()%b function, %bisprint()%b considers the space
character (` ') to be printable.
*q Space character
*q isprint
*q Test character - printable character (including space)
*q Printable character (including space), test for
*x isgraph
#
*n ispunct\C library function
*P Tests to see if a character is a punctuation character
*I <ctype.h>
*F int ispunct(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a punctuation and zero
(false) if it is not.
*D %bispunct()%b tests whether %sc%s is a punctuation
character. For the purposes of this test a punctuation is any printable
character other than an alphanumeric or space (` ') character.
*q Alphanumeric characters
*q Space character
*q ispunct
*q Tests character - punctuation character
*q Punctuation character, test for
*x isgraph
*x isprint
*x iscntrl
#
*n isspace\C library function
*P Tests to see if a character is one which affects spacing
*I <ctype.h>
*F int isspace(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a white space character and
zero (false) if it is not.
*D %bisspace()%b tests whether %sc%s belongs to the set of
characters which produce white space. These characters are as follows:
*l
*t Space
*l \f
*t Formfeed
*l \n
*t Newline
*l \r
*t Carriage return
*l \t
*t Horizontal tab character
*l \v
*t Vertical tab character (\v)
*q Vertical tab
*q \v (horizontal tab character)
*q Horizontal tab (\t)
*q \t (horizontal tab character)
*q Carriage return character (\r)
*q \r (carriage return character)
*q Newline character (\n)
*q \n (newline character)
*q Formfeed character (\f)
*q Space character
*q \f (formfeed character)
*q isspace
*q Test character - one which affects spacing
*q Character affecting spacing, test for
*x iscntrl
*x isgraph
*x ispunct
#
*n isupper\C library function
*P Tests to see if a character is an upper-case letter.
*I <ctype.h>
*F int isupper(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is an upper-case letter and
zero (false) if it is not.
*D %bisupper%b is the inverse of %bislower%b. It tests %sc%s
to see if is an upper-case letter in the range: A-Z
*x islower
*q isupper
*q islower
*q Test character - upper-case letter
*q Upper-case letter, test for
*q Letter (upper-case), test for
#
*n isxdigit\C library function
*P Tests to see if a character is a hexadecimal digit
*I <ctype.h>
*F int isxdigit(int c);
*A c - The character to be tested.
*R non-zero (true) if the character is a hexadecimal digit and
zero (false) if it is not.
*D %bisxdigit()%b tests whether %sc%s belongs to the set of
hexadecimal digits. These are as follows: a, b, c, d, e, f, A, B, C, D, E,
F, 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.
*q isxdigit
*q Test character - hexadecimal digit
*q Hexadecimal digit, test for
*q Digit (hexadecimal), test for
#
*n jobs\Helios command
*P Lists active jobs
*F jobs
*D The %bjobs%b shell command displays a list of the currently
active jobs. That is, all the commands executed in the background using
the & operator.
*q Shell commands
#
*n  kill\Helios command
*P  to abort a program
*F  kill [-a] [-SIG] program|job_number|process_id
*F  kill -l
*D  This program allows a user to abort an errant program
    by sending it a signal. The program should be
    identified by a textual string, shell job number or process id, for example:
*c=kill prog1
*c=kill /01/tasks/prog.6
*c=kill %1
*c=kill 42
*p  The program will perform a scan of the current domain or network
    attempting to match the specified name with that of an existing task.
    If more than one task matches the name then %bkill%b will
    report an ambiguity and will not send any signals. The user can then
    run the command again with additional information to resolve the
    ambiguity.
*p  By default the command will send a %bSIGTERM%b signal. An alternative
    signal can be specified by a number or by name, for example:
*c=kill -9 prog
*c=kill -HUP prog
*p  %bkill%b with the %b-l%b option can be used to list the known signals.
*p To kill off all instances of a task, the %b-a%b option can be used, for example:
*c=kill -a worker
*c=kill -9 -a worker
*x signal\000564
*x raise\000470
*q Shell commands
#
*n kill\Posix library function
*P Sends a signal to a task
*I <signal.h>
*F int kill (int pid, int sig);
*A pid - Task ID of task to receive %ssig%s
*A sig - Signal to be sent
*R 0, if successful; otherwise, returns -1 and sets errno.
*E
*l [EINVAL]
*t The value of %ssig%s is not a valid signal number.
*l [EPERM]
*t The task does not have permission to send the signal to any receiving
task.
*l [ESRCH]
*t The task specified by %spid%s cannot be found.
*D %bkill()%b sends a signal to a task or group of tasks
specified by %spid%s. %ssig%s specifies the signal to be sent. The signal
can be one supplied by %s<signal.h>%s or it can be zero. A %ssig%s of zero
is known as a null signal. A null signal means that %bkill()%b does the
error checking as indicated above, but it does not actually send a signal.
A null signal can be used to check the validity of %spid%s.
*p If %spid%s is greater than zero, %ssig%s goes to the task whose task ID
is equal to %spid%s (%spid%s must have been returned from a successful
call to %bvfork()%b).
*q Signalling a task
*x setsid
*x sigaction
*x signal\000564
#
*n KillTask\System library
*P Terminates the execution of a Task
*I <task.h>
*F WORD KillTask( Task *task );
*A task - Pointer to Task structure of task to kill
*R Error code
*D This function terminates execution of the task described by
the Task structure. All processes whose workspace is within a memory block
in the Task's memory pool are removed from the low priority system queues.
Any port which has such a process waiting on it is aborted.
*p %bNote:%b %bKillTask()%b is primarily for use by the Processor Manager,
and must not, under any circumstances, be called directly by user
programs.
*q Terminate task execution - see KillTask
*q Task execution, terminate - see KillTask
*q Processor manager
*x TaskInit
#
*n labs\C library function
*P Calculates the absolute value of a long integer
*I <stdlib.h>
*F long int labs(long int j);
*A j - A long integer.
*R the absolute value of %sj%s as a long int.
*E If the result cannot be represented the behaviour of %blabs()%b
is undefined.
*D %blabs()%b calculates the absolute value of the long int
%sj%s.
*x abs
*q labs
*q Calculating the absolute value of a long integer
*q Long integer - calculating the absolute value of
*q Absolute value of long integer, calculate
#
*n ld\General interest
*P Linking files together
*D Unix users will be familiar with the command ld which is
used to link files together. The Helios system uses the %basm%b command to
act as both an assembler and a linker. Output from %basm%b produced with
the %b-p%b flag can be fed back into %basm%b as often as needed.
*x c
*x asm
#
*n ldexp\C library function
*P Multiplies a floating point number by an integer power of two
*I <math.h>
*F double ldexp(double x, int exp);
*A x - The floating point number.
*A exp - The exponent.
*R the value of: x * 2**exp.
*E A range error will occur if the result of %bldexp()%b would cause
overflow or underflow. In this case errno is set to ERANGE.
*D %bldexp()%b calculates the value of the following:
*c=x * 2**exp
*x frexp
*q ldexp
*q Multiply fp number by integer power of 2
#
*n ldiv\C library function
*P Calculates the quotient and remainder of a long division
*I <stdlib.h>
*F ldiv_t div(long int numer, long int denom);
*A numer - The numerator.
*A denom - The denominator.
*R a structure of type %sldiv_t%s which consists of the quotient
and remainder.
*E If the result cannot be represented the behaviour of %bldiv()%b
is undefined.
*D %bldiv()%b calculates the quotient and remainder formed by
dividing the numerator %snum%s by the denominator %sdenom%s. All values
are long integers.
*x div
*q ldiv
*q Calculating the quotient and remainder of a long division
*q Quotient and remainder of a division, calculate
*q Long division - calculate quotient and remainder of
*q Division, long - calculate quotient and remainder of
#
*n _ldtimer\System library
*P obtain the current value of the system clock
*I <nonansi.h>
*F word _ldtimer (word pri)
*A %spri%s - Transputer implementation: specifies the high-priority
   or low-priory timer
*A %spri%s - C40 implementation: unused
*R the value of the system clock
*D In the Transputer implementation of Helios, %b_ldtimer(0)%b 
   returns the value of system clock in microseconds (using the high-priority
   timer); %b_ldtimer(1)%b returns the value in 64-microsecond units (using 
   the low-priority timer).
*p In the C40 implementation, %b_ldtimer(pri)%b returns the value of the 
   system clock in microseconds, irrespective of the value of %bpri%b.
*x _cputime
#
*n Library\General interest
*P Provides a set of tested routines
*D Helios has two types of library: resident libraries and
scanned libraries.
*p A resident library is normally part of the Helios system or one of the
supported languages. A special slot number is allocated to each resident
library, and the code is placed in the directory /helios/lib. When a
program uses a resident library call, a special 'stub' file is scanned by
the assembler %basm%b acting as a linker. The stub file contains the slot
number and the offset of the code within the resident library module. When
the program is loaded the list of current resident modules is examined,
and if the module is already in memory it is shared by this new program.
If the resident library is not in memory it is automatically loaded from
the /helios/lib directory. It is important to ensure after upgrading
Helios that the stub files and the library modules refer to the same
version.
*p Scanned libraries are the more familiar type of library found under
Unix. A scanned library is constructed by feeding the output from a
compiler through the assembler %basm%b with the %b-p%b flag set. The output
is a Helios binary file, and any number of these can be joined together by
feeding them back into %basm%b again, again setting the %b-p%b flag. The
resulting concatenated file may be used as a scanned library by specifying
it as the argument to the assembler %b-l%b flag.
*q Resident library
*q Scanned library
*q Library, resident
*q Library, scanned
#
*n Licence\General interest
*P Allows you to run Helios on a specified number of processors.
*D There is no limit to the number of processors that Helios
can handle. The standard Helios licence covers the use of Helios on 16
processors. If you are running a large machine, your supplier will usually
provide you with a version of Helios licenced to cover the number of
processors in your machine. If you are building your own system from
building blocks such as TRAMS and TIMS then you must ensure that you purchase
the correct version of Helios for the number of processors you intend to use.
Extended support for further blocks of 16 processors is available from
your local dealer.
*q Processors, number per licence
#
*n Link\System library
*P Establishes a link to the object `to' under the name `from'
*I <syslib.h>
*F WORD Link ( Object *object, STRING from, Object *to );
*A object - Pointer to context object
*A from - Name of new link
*A to - Object to be linked to
*R Error code
*D This function establishes a link to the object %sto%s under
the name %sfrom%s. All links in Helios are symbolic and contain a pathname
for the linked object. Links may therefore be established across filing
systems, and even to non-filing system objects.
*q Establish link to object
*q Link to object
#
*n link\Posix library function
*P Creates a link to a file
*I <posix.h> ; <unistd.h>
*F int link( char *path1, char *path2 );
*A path1 - Pointer to pathname of existing file
*A path2 - Pointer to pathname of the link
*R Zero on completion; otherwise, it returns -1 and sets the
variable errno to indicate the error.
*E
*l [EACCES]
*t A component of the pathname prefix denies search permission, or the
requested link requires writing in a directory with a mode that denies
write permission.
*l [EEXIST]
*t The link named by %spath2%s already exists.
*l [EMLINK]
*t The number of links to the file named by %spath1%s is greater than the
value set by LINK_MAX.
*l [ENOENT]
*t A component of either pathname prefix does not exist; the file named by
%spath1%s does not exist; or either %spath1%s or %spath2%s points to an
empty string.
*l [ENOSPC]
*t The directory that would contain the link cannot be extended.
*l [ENOTDIR]
*t A component of either pathname prefix is not a directory.
*l [EPERM]
*t The file named by %spath1%s is a directory and the system restricts the
linking of directories to tasks with appropriate privileges, and the
calling task does not have these appropriate privileges.
*l [EROFS]
*t The requested link requires writing in a directory on a read-only file
system.
*l [EXDEV]
*t The link named by %spath2%s and the file named by %spath1%s are on
different file systems and the system does not support links between file
systems.
*l [ENAMETOOLONG]
*t Either %spath1%s or %spath2%s corresponds to a string that is is greater
in length than the value associated with PATH_MAX.
*D This function creates a link from %spath2%s to %spath1%s.
%spath1%s must exist and should not be a directory. %spath2%s points to a
pathname corresponding to the pathname of the new directory entry to be
created. %blink()%b creates a new link for the existing file and
increments its link count by one.
*p If %blink()%b fails, no link is created.
*p %blink()%b affects the time-related fields in %sstat struct%s, as
follows:
*l %sst_atime%s
*t Not affected
*l %sst_ctime%s
*t Updated
*l %sst_mtime%s
*t Not affected
*p These times, where applicable, are set to the time %blink()%b was
successfully executed on the file. Files on read-only file systems are not
affected.
*p %bNote:%b This function only works if used with an underlying filing
system that supports links, such as the Helios filing system.
*x unlink
*x rename\000496
*q Create link
#
*n LinkData\System library
*P Returns information about a processor link
*I <link.h>
*F WORD LinkData( WORD linkno, LinkInfo *info );
*A linkno - Link of interest
*A info - Pointer to linkinfo structure
*R Error code
*D This function copies the current state of the link's info
structure out into the buffer supplied. This is primarily used to find the
state of a link in preparation for calling %bReconfigure()%b.
*x Reconfigure
*x Configure
*q Return information about link
*q Link, return information on
#
*n LinkIn\System library
*P Transfers data from a link
*I <link.h>
*F WORD LinkIn( word size, word linkno, byte *buf, timeout );
*A size - Number of bytes to transfer
*A linkno - Link to use
*A buf - Data to transfer
*A timeout - Transfer timeout in microseconds
*R Error code
*D This function transfers data from a link (see %bLinkOut()%b
for details on how to transfer data to a link). An error result is
returned if %slinkno%s is invalid, the link is not in DUMB mode, or the
transfer took more than the given time. The link should have been
previously reserved with %bAllocLink()%b.
*p Although %stimeout%s must be specified in microseconds, Helios converts
this timeout to a multiple of one second, with a minimum timeout of two
seconds.
*x AllocLink
*x FreeLink
*x LinkOut
*q Link dumb mode
*q Dumb link mode
*q Link - transfer data through
*q Data transfer through link
*q Transfer data through link
#
*n LinkOut\System library
*P Transfers data to a link
*I <link.h>
*F WORD LinkOut( word size, word linkno, byte *buf, timeout );
*A size - Number of bytes to transfer
*A linkno - Link to use
*A buf - Data to transfer
*A timeout - Transfer timeout in microseconds
*R Error code
*D This function transfers data to a link (for details on how
to transfer data from a link, see %bLinkIn()%b). An error result is
returned if %slinkno%s is invalid, the link is not in DUMB mode, or the
transfer took more than the given time. The link should have been
previously reserved with %bAllocLink()%b.
*p Although %stimeout%s must be specified in microseconds, Helios converts
this timeouts to a multiple of one second, with a minimum timeout of two
seconds.
*x AllocLink
*x FreeLink
*x LinkIn
*q Transfer data through a link
*q Data transfer through link
*q Link - transfer data through
#
*n listen\Posix library function
*P Listens for connections on a socket
*I <sys/socket.h>;<sys/types.h>
*F int listen(int fd, int len);
*A fd - file descriptor
*A len - queue length
*D This function is basically identical to the BSD Unix
version of %blisten%b; it specifies a queue length for incoming socket
connections. These connections are then accepted by %baccept%b. The
maximum queue length defined for %blisten%b is given by the constant
[SOMAXCONN], which is as follows:
*l SOMAXCONN
*t 5
*q listen
*x accept
*x socket
*q BSD compatibility, Berkeley
#
*n ln\Helios command
*P Makes a symbolic link
*F ln <name1> <name2>
*D This command makes a symbolic link between the existing
file %sname1%s and %sname2%s. You can then use %sname2%s with commands
that take a filename as an argument (you can copy it, edit it, list it,
and so on). However, %sname2%s is not a normal file, it is a named
symbolic link to the file %sname1%s. This means that if you edit
%sname2%s, you actually read in and edit the contents of %sname1%s, as the
system follows the link from %sname2%s to %sname1%s. %sname2%s has no
contents, as such, of its own. When you delete %sname2%s you simply remove
the link. If you delete %sname1%s, %sname2%s still hangs around, but you
cannot make use of it because it is no longer linked to an existing file.
*p The advantage of %bln%b is that it provides a simple method whereby all
the users on a project can share a single file while each appearing to
possess a separate file in their own filespace. It also means that less
room is taken up as the file is only stored once.
*p %sname1%s and %sname2%s may be on the same or on different processors or
devices. The only restriction being that %sname1%s must already exist.
Links must be supported by the filing system, and whereas Helios supports
them, most host filing systems do not.
*p %bNote:%b The syntax for the Helios %bln%b command is different from the
syntax for the Unix ln command. Under Unix, an ln with no modifying flag
is used to make hard links and an ln with a modifying -s flag is used to
make symbolic links.
*q Sharing files
*q Files, sharing
*q jobs
#
*n Load\System library
*P Loads the code image file ready for execution
*I <syslib.h>
*F Object *Load( Object *controller, Object *image );
*A controller - Object structure for the target loader
*A image - Object structure for the image to be loaded
*R Object structure for the program image.
*D %bLoad()%b loads the code image file, making it ready for
execution. %scontroller%s is an Object structure for the target loader. If
%scontroller%s is NULL, the image file is loaded by the local loader.
*x Execute
*q Loading files - see also Execute
*q Task Force Manager
*q Target server
*q Loader
#
*n loaded\Helios command
*P Finds out what code is loaded in the network
*F loaded [[all] | [<user name>] | [<processor>]
*D The %bloaded%b command can be used to find out what code is
loaded in the network. There are various different ways of invoking the
command, to achieve different results.
*p %bloaded%b by itself, without any arguments, lists the code loaded in
all processors inside the user's domain. If the current session does not
involve a Taskforce Manager and hence is not running in a domain,
%bloaded%b by itself will list the code loaded in the current processor.
*p To look at all code loaded in every processor in the network, use the
%sall%s option:
*c=loaded all
*p To look at all code loaded in the domain of a specific user, specify
that user name as the argument:
*c=loaded bart
*p To look at all code loaded in a specific processor, specify the
processor name, preceded by a slash character (/). This character
distinguishes user names and processor names:
*c=loaded /00
#
*n loadpac\Helios command
*P Loads software packages from disc into the Helios system
*F loadpac
*D If you enter this command, you will be presented with a
screen menu from which you can make a selection to do one of the
following:
*p %bview a list of previously installed software packages%b;
*p %bview a list of software packages on disc which are loadable%b;
*p %bload software packages%b;
*p %bremove software packages%b.
*p On making your selection from the menu, you will be given easy to follow
instructions on what to do next in order to carry out your chosen action.
*q loadpac
*q Installing Helios
*q Loading software packages
*q Unloading software packages
*q Removing software packages
*q Installed software packages, listing
*q Software packages on disc, listing
*q Loadable software packages, listing
#
*n localtime\C library function
*P Converts the local time into a tm structure format
*I <time.h>
*F struct tm *localtime(const time_t *timer);
*A timer - A pointer to a location containing a time.
*R a pointer to a tm calendar structure, containing the value of
the timer in a broken down form.
*D %blocaltime()%b is used to convert a time stored in the
value pointed to by %stimer%s to the %stm%s structure format.
*c=/*
*c=  Prints the current date and time in a default format
*c=*/
*c=
*c=#include <time.h>
*c=#include <stdio.h>
*c=
*c=int main(void)
*c={
*c= time_t current;
*c= struct tm *calendar;
*c=
*c= time(&current);
*c= calendar = localtime(&current);
*c= printf ("\n Date and time = %s\n", asctime(calendar));
*c=}
*x mktime
*q localtime
*q Convert local time into tm structure format
*q Local time - convert into tm structure format
*q tm structure format - convert from local time
#
*n Locate\System library
*P Finds the named object and allocates an object structure for it
*I <syslib.h>
*F Object *Locate ( Object *object, STRING name );
*A object - Pointer to context object
*A name - Name of target object
*R Pointer to new object structure or NULL if error.
*D This function obtains an Object structure for the named
object, if possible. You may use %bLocate()%b to test the existence of the
target, or to gain access to it for further operations. Object may be NULL
if %sname%s is absolute. If the named object is a symbolic link, the
object pointer returned will be to the original object, not the link.
*q Symbolic link
*q Object structure
*q Find object and allocate object structure
*q Object - find and then allocate object structure
#
*n log\C library function
*P Calculates the natural logarithm of the argument
*I <math.h>
*F double log(double x);
*A x - A number.
*R the natural log of %sx%s.
*E A domain error occurs if %sx%s is negative. In this case errno is
set to EDOM.
*p A range error occurs if %sx%s is zero. In this case %blog()%b returns
the value HUGE_VAL (with the same sign as the correct value of the
function) and errno is set to ERANGE.
*D %blog()%b calculates the natural (base e) logarithm of
%sx%s.
*x log10
*q log
*q Calculates the natural logarithm
*q Natural logarithm - see log
#
*n log10\C library function
*P Calculates the base-10 logarithm of the argument
*q Logarithm (base e) - see log
*I <math.h>
*F double log10(double x);
*A x - A number.
*R the base ten log of %sx%s.
*E A domain error occurs if %sx%s is negative. In this case errno is
set to EDOM.
*p A range error occurs if %sx%s is zero. In this case %blog10()%b returns
the value HUGE_VAL (with the same sign as the correct value of the
function) and errno is set to ERANGE.
*D %blog10()%b calculates the base 10 logarithm of %sx%s.
*x log
*q log10
*q Calculates the base 10 logarithm
*q Base 10 logarithm - see log10
*q Logarithm (base 10) - see log10
*q Logarithm (natural) - see log
#
*n login\Helios command
*P Creates a new Helios session
*F login [username]
*D The %blogin%b command is the standard way of creating a new
login session under Helios. The command is invoked automatically by the
Helios Session Manager for all windows registered with the Session
Manager, typically via the newuser command. If no user name is specified
on the command line then the program will prompt for one. Otherwise the
program will attempt to create a new session for the specified user, which
may or may not involve typing in a password depending on the system
configuration.
*p The login program works in two different ways. If a Session Manager is
running somewhere in the network, which will usually be the case for all
multi-user systems and for single-user systems where the network contains
more than about three or four processors, then the login program interacts
with the Session Manager to create a full new session. This involves
obtaining a suitable processor from the free pool administered by the
Network Server, and running a Taskforce Manager inside that processor to
administer the user's session and in particular the user's domain of
processors. If no Session Manager is running, which may happen in small
single-user networks, then the login program will simply run a shell on
the current processor.
*p If a Session Manager then a login may fail because there are
insufficient network resources. In particular, if there is no free
processor in the network then it is not possible to run a new Taskforce
Manager and hence the session cannot be created. Under such circumstances
it is possible to login as user info, which causes login to display some
information about which users are currently logged in to Helios and how
many processors are owned by every user. After this information is
displayed another login prompt will be displayed.
*q login
*q Logging in
*q Login termination
*q Login session
*q Login prompt
#
*n loginrc\General interest
*P Sets up commands to be used by login shell
*D The special file %sloginrc%s can be, and usually is, kept
in your home directory. A shell started by Helios, known as the %slogin%s
%sshell%s, will look in your cshrc, execute any commands it may find there
and then look for your loginrc.
*q loginrc
*q Special files
*q Login shell
*q cshrc
*x Shell
*x login
*x cshrc
#
*n logname\Helios command
*P Returns the user's login name
*F logname
*D %blogname%b prints the login name of the user to the
standard output (stdout). This command can be used to find out who
initiated a particular shell.
*p The name returned by %blogname%b should be equivalent to the name
returned by the function %bgetlogin()%b.
*q logname
*q Login name, return
*x getlogin
*x login
#
*n logout\Helios command
*P Terminates a login shell
*F logout
*D This command terminates the shell that was invoked from
%blogin%b.
*q Shell commands
*q Terminating a login shell
*q Login shell termination
*q logout
*x login
#
*n LogToPhysPri\System library
*P Converts logical priorities to physical priority levels
*I <process.h>
*F word LogToPhysPri(word logpri);
*A logpri - logical priority level
*R the physical priority.
*D This function converts logical priorities to physical
priority levels, so that %bPhysProcessLevel%b = %bLogToPhysPri%b 
( %bGetPriority()%b ).
*q LogToPhysPri
*x PhysToLogPri
*x SetPriority
*x SetPriority
#
*n longjmp\C library function
*P Performs a non-local jump to the given environment
*I <setjmp.h>
*F void longjmp(jmp_buf env, int val);
*A env - An array holding the environment to be restored.
*A val - The value to be returned by longjmp.
*R when %blongjmp()%b returns, the effect is as if the
corresponding %bsetjmp()%b had returned the value of %sval%s. If %sval%s
is zero, %bsetjmp()%b returns 1 (this is because %bsetjmp()%b is only
allowed to return zero the first time it is called).
*D %blongjmp()%b performs a non-local jump to the environment
saved in %senv%s, by a previous call to %bsetjmp()%b. It returns in such a
way that, to the program, it appears that the %bsetjmp()%b function has
returned the value %sval%s.
*c=#include <setjmp.h>
*c=#include <stdio.h>
*c=
*c=jmp_buf env1;
*c=
*c=int main(void)
*c={
*c= int a;
*c= extern void exit( int );
*c= extern int subfunction( void );
*c=
*c= switch(a=setjmp(env1))
*c= {
*c=  case 0:  printf("1st time in top level\n");
*c=           break;
*c=  default: printf("longjmp to top level - code %d\n", a);
*c=           exit( 1 );
*c= }
*c= subfunction();
*c=}
*c=
*c=int subfunction(void);
*c={
*c=  /* .....
*c=     ..... */
*c=
*c=    longjmp(env1, 3);
*c=}
*x setjmp
*q longjmp
*q Perform non-local jump to given environment
*q Non-local jump to given environment
*q Jump (non-local) to given environment - see longjmp
#
*n Lookup\System library
*P Searches given directory for named entry
*I <servlib.h>
*F ObjNode *Lookup(DirNode *d, string name, bool dirlocked);
*A d - pointer to directory
*A name - character string
*A dirlocked - boolean expression
*D %bLookup()%b takes the directory indicated by the first
argument and searches it for %sname%s. If %sdirlocked%s is false, the
directory will be locked during the search.
*q Lookup
#
*n ls\Helios command
*P Lists the contents of a directory
*F ls [-acCdFHlmrRtu1] [<filelist>]
*D %bls%b displays an alphabetically sorted list of the
contents of a directory or a set of files. If you omit %sfilelist%s then
%bls%b lists the contents of the current directory. If any arguments are
given, %bls%b determines whether each argument is a file or a directory.
Any files given are simply listed. This is useful in conjunction with
shell wild card expansion. For example,
*c=ls *.c
*p lists all the files ending in `.c' in the current directory.
*p If a directory is given as one of the arguments then the contents of
that directory are listed. For example,
*c=ls /helios/bin
*p displays the contents of the specified directory.
*p The %bls%b command takes a number of options, as indicated below:
*l %b-a%b
*t Includes any files starting with a period `.' which are normally omitted
from a listing.
*l %b-c%b
*t Sorts output in order of file creation. Creation and last access time
may be equivalent to last modification time under some file systems
(MS-DOS, for instance).
*l %b-C%b
*t Forces output to be displayed in columns (that is, to be displayed with
several filenames per line of output). This is the default for normal
output.
*l %b-d%b
*t Treats directories as ordinary files, listing file information instead
of recursing downwards. This option is useful for checking permissions to
directories, using:
*d ls -ld helios
*l %b-F%b
*t Adds a special character to the end of each filename to show its type: /
for directories and @ for links.
*l %b-H%b
*t Lists the usage (format) for %bls%b to help you give your command
correctly.
*l %b-l%b
*t Gives more verbose details about the directory's contents, including the
size and the time of the last change of each file. The resulting list
includes the following six fields:
*d %bType:%b
*t contains various letters that indicate the type of the item: c
(cachename), d (directory), f (file or fifo), m (resident module - loader
only), n (name table entry only), p (program - loader only), t (task -
tasks only), and v (private).
*d %bAccess Mask:%b
*t contains various letters that represent the access mask for the item: r
(read), w (write), e (execute), d (delete), a (alter access mask).
*d %bAccount Id:%b
*t at present, this is always 0.
*d %bFile Size:%b
*t contains the size in bytes.
*d %bDate:%b
*t contains the date of the last modification.
*d %bFilename:%b
*t contains the name of the file, directory, and so forth.
*l %b-m%b
*t Gives the full protection matrix for the current directory or for
%sfilelist%s.
*l %b-r%b
*t Sorts the list of files in reverse order.
*l %b-R%b
*t Lists all the directories in %sfilelist%s recursively. That is, it lists
the contents of any subdirectories within the directories, and the
contents of any subdirectories within the subdirectories, and so on.
*l %b-t%b
*t Sorts output according to the modification time, with the latest at the
top.
*l %b-u%b
*t Sorts output in last access time order.
*l %b-1%b
*t Forces output to be displayed in a single-column list with one filename
per line of output (the default for redirected output).
*x Protection
*x Wildcards
*q ls
*q Listing directories and files
*q Displaying directory and file catalogue
*q Protection matrix, list
*q File types
*q File modification times
*q File access times
*q Access mask, list
#
*n lseek\Posix library function
*P Moves a read/write file pointer
*I <sys/types.h> ; <unistd.h>
*F off_t lseek(int fd, off_t offset, int whence);
*A fd - File descriptor of open file or device
*A offset - Number of bytes offset from beginning of file
*A whence - Symbolic constant indicating pointer position
*R A number of bytes from the beginning of the file, being the
current pointer value. If the function fails, it returns a value that is
((off_t) -1) sets errno to indicate the error that occurred, and leaves
the file pointer in the same position.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t %swhence%s does not have a valid value, or the resulting file would be
invalid.
*l [EINVAL]
*t %sfd%s is associated with a pipe or FIFO special file.
*D This function sets the file pointer associated with the
open file descriptor %sfd%s according to the value of %swhence%s, as
follows:
*l Value
*t Action
*l SEEK_SET
*t Set pointer to %soffset%s bytes
*l SEEK_CUR
*t Set pointer to its current value plus %soffset%s bytes
*l SEEK_END
*t Set pointer to the length of the file plus %soffset%s bytes
*p The symbolic constants SEEK_SET, SEEK_CUR, and SEEK_END are all defined
in the header file %s<unistd.h>%s.
*p Some devices are not able to seek. In which case, the value of the file
pointer is undefined.
*p The result of setting the file pointer beyond the end of the existing
data in the file is filing system dependent.
*p %blseek()%b cannot extend the size of a file.
*q lseek
*q Move file pointer in file
*q File pointer, move
*x dup
*x open
#
*n lstatus\Helios command
*q lstatus, network command
*P Changes a link mode and examines a link's current state
*F lstatus <processor> <link>
*D As set out in the description of %bclink%b, a Helios link
can be in one of four states:
*l Not connected.
*t As far as Helios is concerned there is nothing at the other end of this
link and hence it is ignored.
*l Dumb.
*t There is some hardware at the other end of this link, but not a
processor running Helios. The hardware may be an M212 disc controller, a
T212 or T222 with special hardware such as an ethernet connection, or a
32-bit processor running occam, standalone C, or some other software that
does not require Helios.
*l Intelligent.
*t This means that there is a processor at the other end running Helios.
The link is used for distributed searches and hence for communication
within the network. When a link is set to intelligent mode the kernel will
perform a handshake across the link, to ensure that Helios is running at
the other side.
*l Pending.
*t This is a special case of intelligent mode. At some point in the future
there may be a processor running Helios at the other end of this link, and
when that happens the remote processor will send a handshake. Until this
handshake arrives the link will not be used for distributed searches or
for communication.
*p The %bclink%b command can be used to change a link state, by running it
on the appropriate processor; this is useful in the absence of a Network
Server. However, in a multi user environment it may not work. If the
processor concerned is not currently in the user's domain, it may not be
possible to run a program there. Instead there are other commands which
interact with the Network Server to achieve the same thing.
*p The %blstatus%b command can be used to determine the current state of a
link. It takes two arguments: a processor name and a link number:
*c=lstatus /02 3
*p Other similar commands - %bdlink%b, %belink%b, and %bplink%b - can be
used to change the mode of a link.
*x clink
*x dlink
*x elink
*x plink
#
*n MachineName\System library
*P Obtains the name of the current processor
*I <syslib.h>
*F WORD MachineName( string name );
*A name - Pointer to buffer for name
*R Error code
*D This function obtains the current name of the processor
running this program.
*q Name of current processor, get - see MachineName
*q Current processor name, get - see MachineName
#
*n MachineType\System library
*P Obtains the type of the current processor
*I <syslib.h>
*F WORD MachineType( void );
*R 800 = T800 transputer; 801 = T801 transputer; 805 = T805 transputer;
400 = T400 transputer; 414 = T414 transputer; 425 = T425 transputer;
0x320C40 = TMS320C40 processor .
*D This function returns the current processor type.
*q Type of current processor, get - see MachineType
*q Current processor type, get - see MachineType
#
*n make\Helios command
*k Makefile
*P Maintains program groups
*F make [ -f <makefile> ] [ <option>... ] [<macro>...] <file>...
*D %bmake%b executes commands in %smakefile%s to update one or
more target %sfile%ss, where %sfile%s is usually a program. If you fail to
specify a %smakefile%s with the -f option, %bmake%b uses the file called
`makefile' in your current directory; if you specify %smakefile%s to be
`-', %bmake%b takes its instructions from stdin.
*p %bmake%b carries out the instructions set out in the makefile if it
finds that the dependent file(s) of a target file, as defined in the
makefile, have been altered since the target was last modified, or if it
cannot find the target.
*p A %smakefile%s is a file that contains a sequence of entries each of
which is functionally similar to an if..then..else construct. These
entries define dependencies between a target file or files and other
files, known as `dependent' files or `prerequisite' files. The first line
of an entry is a list of targets, separated by blanks, a colon, then a
list of dependent files also separated by blanks. The line can be extended
with\<newline> if necessary. The next and subsequent lines in the same
entry, or step, contain the shell commands to be carried out if the
dependent file(s) have been modified or the target does not exist. There
must only be one command per line and each command line must begin with a
tab (notice that a blank space made in any other way is not acceptable).
*c=<target-file>... : <dependent-file>...
*c=<  tab             ><command1>
*c=<  tab             ><command2>
*c=<  tab             >...
*c=<  tab             ><commandn>
*p In other words:
*c=If the `last modified' date of <target-file>
*c=  is earlier than that of <dependent-file>, or
*c=If <target-file> does not exist,
*c=Then do <command>s
*p At any point in a makefile you can insert a comment to explain what is
happening. A comment starts with a sharp sign (that is, a `hash' or
`pound' sign), and ends with newline:
*c=# this is a comment
*p Comments are ignored by %bmake%b and are for the benefit of human
readers of the makefile.
*p Here is an example of a makefile that says that the initial target file
`program' depends on the two dependent files `alpha.s' and `beta.s', and
that they in turn are targets that depend on `.c' files and another file
`include':
*c=program: alpha.s beta.s
*c=         asm -v -f /helios/lib/cstart.o alpha.s beta.s -o program
*c=alpha.s: include alpha.c
*c=         cc -t4 alpha.c -s alpha.s
*c=beta.s:  include beta.c
*c=         cc -t4 beta.c -s beta.s
*p A %smakefile%s can also include %smacro%s definitions of the form:
%sname%s %s=%s %svalue%s where the blanks surrounding the equals sign are
optional. Each time you have $(%sname%s) (or $%sname%s for
single-character names), %bmake%b expands %sname%s to its defined
%svalue%s. You can define macros that refer to other macros; however, you
should beware of creating infinitely recursive loops where name1 expands
to name2, name2 expands to name3, name3 expands to name1, and so on around
the loop.
*p %bmake%b recognises a number of special pre-defined macro names that
automatically expand to certain values. These are as follows:
*l %b$*%b
*t Base name of the target (without suffix).
*l %b$@%b
*t Complete target name.
*l %b$<%b
*t Complete dependent name.
*l %b$?%b
*t The names of the files that cause the action and that are younger than
the target. You can set up rules that imply commands for a
target/dependent step that has no explicit commands. These rules, known as
`inference rules', tell %bmake%b how to produce a file with one suffix
from another file with the same simple base name but a different suffix.
For example, if your C files always have the suffix `.c', and your
assembler files always have the suffix `.s', the relationship between the
two types of file is going to remain constant. This means that files with
these suffixes will provoke the same instructions in each case. You can
therefore define a rule for files with these suffixes that sets out the
commands to be followed. This frees you from repeating the actual commands
in the makefile for each step.
*p Before you can define your inference rules, you must specify at the
beginning of the makefile which suffixes you intend to use later in the
file. You specify these suffixes with a .SUFFIXES instruction, listing
each suffix after the .SUFFIXES keyword in the order of their dependency.
Each subsequent .SUFFIXES instruction that lists further suffixes acts as
an extension to the preceding list. An instruction without a qualifying
list of suffixes clears any previously specified list or lists. The syntax
for the .SUFFIXES instruction is as follows: %s.SUFFIXES:%s %s<suffix%s
%slist>%s where %s<suffix%s %slist>%s is something like: .s .c ... .%sx%s.
Thus, when there are no explicit commands for: %sfred.<to>%s %bmake%b
looks down %s<suffix%s %slist>%s for the first .%s<from>%s for which both
a rule for %s.<from>.<to>%s and the file fred.%s<from>%s exist.
*p The other predefined commands, like .SUFFIXES, are as follows: .SILENT
stops lines being echoed; .PRECIOUS prevents files depending on this name
from being deleted after being interrupted; and .IGNORE acts like -i, in
that it ignores any exit codes that may be returned by programs called by
the makefile and allows execution to continue.
*p After specifying your makefile suffix list(s) with .SUFFIXES, you can
set up your inference rules. The syntax of an inference rule is as
follows:
*c= .<dependent-suffix>.<target-suffix>:
*c=            <command1>
*c=            ...
*c=            <commandn>
*p For example, the rule:
*c= .c.s:
*c=            cc -t4  $< -s $@
*p tells %bmake%b to take the inference rule `.c.s' and apply it to the
filenames specified by the special macros $@ and $< (see above).
*p The %soption%ss that you can give are as follows:
*l %b-f%b<%sfilename%s>
*t Use %sfilename%s as the makefile.
*l %b-i%b
*t Ignore exit codes returned by programs that are called by the makefile.
%bmake%b will continue execution of the next lines of the makefile despite
the errors.
*l %b-n%b
*t `Pretend' to make. If you give this option, %bmake%b displays commands
that would be executed by a makefile, but does not actually execute them.
(Except for recursive makes.)
*l %b-p%b
*t Print all macros and targets.
*l %b-q%b
*t Question whether a target is up to date. Return exit status if out of
date.
*l %b-r%b
*t Do not use the built-in inference rules.
*l %b-s%b
*t Make silently; make without displaying each command line as it executes.
*l %b-t%b
*t Touch files instead of making them.
*q make
*x gmake
#
*n Malloc\System library
*P Allocates memory from the task's pool
*I <syslib.h>
*F void *Malloc ( word size );
*A size - Amount of memory to allocate
*R Pointer to the block of memory allocated.
*D This function allocates a block of memory of at least the
given size in bytes. It returns the address of the first available byte;
otherwise, if it cannot allocate any memory, it returns NULL. If the
request cannot be satisfied from the existing heap, a further area of
memory is obtained from the Store Manager and added to the heap. If the
request is very large, then a block is allocated specially from the Store
Manager to satisfy it.
*p A %ssize%s value of -1 causes %bMalloc()%b to return the total free
space available in the heap. A %ssize%s of -2 causes it to return the size
of the largest single free block. If %ssize%s is equal to -3, the result
is the total size of the heap. If %ssize%s is equal to -4, the result is
the percentage of heap that is free.
*p If %ssize%b is zero, the effect is undefined.
*x malloc
*x AllocMem
*x Free
*q Store manager
*q Memory size
*q Heap - total free space available in
*q Memory - largest single free block
*q Allocate memory from task pool
*q Memory, allocate from task pool
*q Memory allocation - see also Malloc
#
*n malloc\C library function
*P Allocates a specified area of memory
*I <stdlib.h>
*F void *malloc(size_t size);
*A size - The space to be allocated.
*R a pointer to the allocated space if the allocation was
successful. Otherwise a null pointer is returned.
*E If there is not enough free space a null pointer is returned.
*D %bmalloc()%b allocates an area of memory of %ssize%s bytes.
The allocated space is not initialised.
*c=int *array1;
*c=
*c= array1 = (int *)malloc(500);
*c=
*c=/*
*c=  Allocates a 500-byte space to the user
*c=*/
*x Malloc
*x calloc
*x free
*x realloc
*q malloc
*q Allocating a specified area of memory
*q Memory allocation
#
*n map\Helios command
*P Displays activity in Helios node
*F map [-m|-l|-p]
*D When you start this command without an argument it displays a help page that
lists all the valid commands. Each command can be selected by a single key
depression, as follows (the commas simply act to separate valid
alternatives):
*l m
*t Display memory
*l l
*t Display links
*l p
*t Display ports
*l q,Q,ESC
*t Terminate map
*l h,H,?
*t Display help page
*l -
*t Halve sample rate
*l +
*t Double sample rate
*l %sany other key%s
*t Resize the display and redraw
*p Once you have chosen one of the three displays methods by typing m, l,
or p, you can get specific help for that display if you type h, H or ?.
*p Alternativly you can use a command line argument to go directly to the
display that you desire.  So for example 'map -m' starts map running with
the memory display. 
*p If you chose the memory display by typing m, you should get a screen
consisting of four fields. The top row displays the total amount of memory
which has been allocated, the amount which is free, and the number of
bytes which each character in the map represents. Along the right-hand
side of the display is a table showing a list of active tasks and a letter
which has been assigned to that task; these letters are then used in the
main map to represent each of the tasks (where uppercase letters indicate
the task's data and lowercase letters indicate the task's code). The main
map occupies the centre of the screen; this shows the allocation of the
system heap. Each character in the map represents a number of bytes which
is specified in the top row of the display. Character positions that are
occupied by a dot (.) represent free memory, # represents memory which has
been allocated to the system, and @ and ? are used to represent
unidentified allocations. All letters which appear in the map show the
amount of memory which has been allocated to a task, and digits represent
shared libraries. At the bottom of the display is a graph showing the
current processor load; the horizontal bar at the end of the graph marks
the maximum load, and = shows the current loading.
*p If you chose the link display, by typing l, then a screen showing the
number, mode, state and link traffic for each link is displayed.
*p If you select the port display, by typing p, a screen showing the status
of the processor's message Ports is displayed.
*q Memory allocation
*q Free memory
*q Port
*q Message port
*q Port activity
*q Link number, mode, state and traffic, show
*q Node activity, displaying
*q map
#
*n _Mark\System library
*P Places a mark in the trace vector
*F void _Mark( void );
*D This function places a mark in the processor's trace
vector. The mark consists of the time at which the mark is made, the
workspace of the calling process, and the address of the instruction
immediately after the call. The trace vector occupies the top 4Kbytes of
any processor running Helios, its address is to be found in the
RootStruct. The state of the trace vector may be examined from the server
post-mortem debugger with the %btrace%b command.
*x _Trace
*q Debug command - trace
*q RootStruct
*q trace debugging command
*q Marking the trace vector
*q Trace vector - mark
#
*n MarshalCap\System library
*P Copies the capability into the control vector
*I <syslib.h> ; <message.h>
*F void MarshalCap( MCB *mcb, Capability *cap );
*A mcb - MCB to be marshalled.
*A cap - Pointer to capability.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalCap()%b routine copies the capability into the control
vector.
*x MarshalInfo
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalData
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Control vector
*q Data vector
*q Marshalling routines
*q Capability
*q Marshalling
*q Message creation
#
*n MarshalCommon\System library
*P Constructs an IOCCommon structure in the control vector
*I <syslib.h> ; <message.h>
*F void MarshalCommon( MCB *mcb, Object *obj, string name );
*A mcb - MCB to be marshalled.
*A obj - Pointer to Object structure.
*A name - NULL-terminated string.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalCommon()%b routine constructs an IOCCommon structure in the
control vector, taking into account the possibilities that the object and
name pointers may be NULL. It also deals with the cases of an empty name
string, or one which specifies an absolute path name.
*x MarshalInfo
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalData
*x MarshalDate
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Control vector
*q IOCCommon structure
*q Data vector
*q Marshalling
*q Message creation
#
*n MarshalData\System library
*P Copies the given buffer into the data vector.
*I <syslib.h> ; <message.h>
*F void MarshalData( MCB *mcb, word size, byte *data );
*A mcb - MCB to be marshalled.
*A size - Data vector size.
*A data - Data vector to be marshalled.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalData()%b routine copies the given buffer into the data
vector.
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalInfo
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Control vector
*q Data vector
*q Marshalling
*q Message creation
#
*n MarshalDate\System library
*P Copies the given date into the control vector
*I <syslib.h> ; <message.h>
*F void MarshalDate( MCB *mcb, Date date );
*A mcb - MCB to be marshalled.
*A date - Date.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalDate()%b routine copies the given date into the control
vector.
*x MarshalData
*x MarshalInfo
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Date
*q Control vector
*q Data vector
*q Marshalling routines
*q Control vector
*q Marshalling
*q Message creation
#
*n MarshalInfo\System library
*P Creates ObjectInfo reply
*I <servlib.h>
*F void MarshalInfo(MCB *mcb, ObjNode *obj);
*A mcb - request MCB
*A obj - object to marshal
*D Marshalling is a term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize, as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p This routine converts the MCB into a reply suitable for an ObjectInfo
request on the given object. Unless a server needs to do any special
processing on ObjectInfo requests it will not need to use this function
but merely set DoObjInfo as the action for ObjectInfo requests in the
DispatchInfo table.
*x MarshalData
*x MarshalInfo
*x MarshalString
*x MarshalObject
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalStream
*x InitMCB
*q MarshalInfo
*q Marshalling
*q MCB
*q Message control
*q Memory provision
*q Data vectors
#
*n MarshalObject\System library
*P Places the object's capability and pathname into the data
vector and places the offset of the first byte of this structure into the
control vector
*I <syslib.h> ; <message.h>
*F void MarshalObject( MCB *mcb, Object *obj );
*A mcb - MCB to be marshalled.
*A obj - Pointer to Object structure.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalObject()%b routine places the object's capability and
pathname into the data vector and places the offset of the first byte of
this structure into the control vector.
*x MarshalData
*x MarshalInfo
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalStream
*x InitMCB
*q Control vector
*q Data vector
*q Marshalling
*q Message creation
#
*n MarshalOffset\System library
*P Places a word containing the offset of the next free location
in the data vector into the control vector. The offset is aligned to a
word boundary.
*I <syslib.h> ; <message.h>
*F void MarshalOffset( MCB *mcb );
*A mcb - MCB to be marshalled.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalOffset()%b routine places a word containing the offset of
the next free location in the data vector into the control vector. The
offset is aligned to a word boundary.
*x MarshalInfo
*x MarshalData
*x MarshalString
*x MarshalWord
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Date
*q Control vector
*q Data vector
*q Marshalling
*q Message creation
#
*n MarshalStream\System library
*P Marshals the name, capability, mode and current position of the
given stream into the data vector and the offset of this into the control
vector
*I <syslib.h> ; <message.h>
*F void MarshalStream( MCB *mcb, Stream *stream );
*A mcb - MCB to be marshalled.
*A stream - Pointer to Stream structure.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalStream()%b routine marshals the name, capability, mode and
current position of the given stream into the data vector and the offset
of this into the control vector.
*x MarshalInfo
*x MarshalData
*x MarshalString
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x InitMCB
*q Control vector
*q Data vector
*q Capability
*q Marshalling
*q Message creation
#
*n MarshalString\System library
*P Copies the string into the data vector and places a word
containing the offset of its first byte in the control vector
*I <syslib.h> ; <message.h>
*F void MarshalString( MCB *mcb, string str );
*A mcb - MCB to be marshalled.
*A str - NULL terminated string.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p %bMarshalString()%b copies the string into the data vector and places a
word containing the offset of its first byte in the control vector.
*x MarshalData
*x MarshalInfo
*x MarshalWord
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Control vector
*q Data vector
*q Marshalling
*q Message creation
#
*n MarshalWord\System library
*P Places a word containing the given value in the control vector
*I <syslib.h> ; <message.h>
*F void MarshalWord( MCB *mcb, word value );
*A mcb - MCB to be marshalled.
*A value - 32-bit word value.
*R Nothing.
*D Marshalling is the term used to describe the creation of a
message from its components. Each of the Helios marshalling procedures
(MarshalXXXX) places the appropriate values in the next available
locations in the message control and data vectors, and increments
MsgHdr.ContSize and MsgHdr.DataSize as required. Notice that the
marshalling routines do not allocate any space in the control or data
vectors, but expect sufficient memory to have been already provided.
*p The %bMarshalWord()%b routine places a word containing the given value
in the control vector.
*x MarshalInfo
*x MarshalData
*x MarshalString
*x MarshalOffset
*x MarshalCap
*x MarshalDate
*x MarshalCommon
*x MarshalObject
*x MarshalStream
*x InitMCB
*q Control vector
*q Data vector
*q Marshalling routines
*q Capability
*q Marshalling
*q Message creation
#
*n mem\Helios command
*P Gives information on memory allocation
*F mem
*D The %bmem%b command displays details of the current memory
map. This includes information about each memory block as well as the
amount of memory available and the largest unallocated block.
*q Memory allocation
*q Memory map
*q mem
*x Free
#
*n memchr\C library function
*P Finds the first occurrence of a character in the first n
characters of an area of memory.
*I <string.h>
*F void *memchr(const void *s, int c, size_t n);
*A s - A pointer to the area of memory to be searched.
*A c - The character to be searched for.
*A n - The size of the area of memory to be searched.
*R if the character is found, %bmemchr()%b returns a pointer to
the matched character. It returns a null pointer if the character %sc%s is
not in the first %sn%s characters of the area of memory.
*D %bmemchr()%b finds the first occurrence of %sc%s in the
first %sn%s characters of the area of memory pointed to by %ss%s. %sc%s is
converted to an unsigned char before the search begins.
*c=#include <string.h>
*c=int main (void)
*c={
*c=char buffer[100];
*c=char *pointer_to_p;
*c=
*c=/*
*c=  Find the first occurrence of "p" in the buffer
*c=*/
*c=
*c=pointer_to_p = memchr(buffer, 'p', 100);
*c=}
*x strchr
*q memchr
*q Find first occurrence of char in first n chars of area of memory
*q Memory, find first occurrence of char in first n chars of area of
*q Character - find first occurrence of in first n chars of area of memory
#
*n memcmp\C library function
*P Compares the first n characters of two areas of memory
*I <string.h>
*F int memcmp(const void *s1, const void *s2, size_t n);
*A s1 - A pointer to one of the areas of memory to be compared.
*A s2 - A pointer to the other area of memory to be compared.
*A n - The number of characters to be compared.
*R a negative integer if the %ss1%s area of memory is numerically
less than the %ss2%s area of memory; a zero value if the two areas of
memory are numerically the same; a positive integer if the %ss1%s area of
memory is numerically greater than the %ss2%s area of memory.
*D %bmemcmp()%b compares the first %sn%s characters of the
areas of memory pointed to by %ss1%s and %ss2%s.
*p The comparison is of the numerical values of the ASCII characters.
*c=#include <string.h>
*c=int main(void)
*c={
*c=  char firstarray[100];
*c=  char secondarray[100];
*c=  int result;
*c=
*c=  result = memcmp(firstarray, secondarray, 100);
*c=}
*x strcmp
*q memcmp
*q Compare first n characters of two areas of memory - see memcmp
*q First n characters of two areas of memory, compare - see memcmp
*q Memory, compare first n characters of two areas of - see memcmp
#
*n memcpy\C library function
*P Copies characters from one area of memory to another (no memory
overlap allowed).
*I <string.h>
*F void *memcpy(void *s1, const void *s2, size_t n);
*A s1 - A pointer to the destination of the copy.
*A s2 - A pointer to the source of the copy.
*A n - The number of characters to be copied.
*R the unchanged value of %ss1%s.
*D %bmemcpy()%b copies %sn%s characters from the area of
memory pointed to by %ss2%s (the source) to the area of memory pointed to
by %ss1%s (the destination). The behaviour of %bmemcpy()%b is undefined if
the areas of memory overlap.
*c=#include <string.h>
*c=int main(void) {
*c=  char source[200];
*c=  destination[200];
*c=
*c=memcpy(destination, source, 200);}
*x memmove
*q memcpy
*q Copy characters from one area of memory to another
*q Characters - copy from one area of memory to another
*q Memory - copy characters from one area to another
#
*n memmove\C library function
*P Copies characters from one area of memory to another (the areas
can overlap).
*I <string.h>
*F void *memmove(void *s1, const void *s2, size_t n);
*A s1 - A pointer to the destination of the copy.
*A s2 - A pointer to the source of the copy.
*A n - The number of characters to be copied.
*R the unchanged value of %ss1%s.
*D %bmemmove()%b copies %sn%s characters from the area of
memory pointed to by %ss2%s (the source) to the area of memory pointed to
by %ss1%s (the destination). The copying will be carried out correctly
even if the areas of memory overlap.
*q memmove
*q Copy characters from one area of memory to another
*q Characters - copy from one area of memory to another
*q Memory - copy characters from one area to another
*q Memory overlap - see memcpy and memmove
#
*n memset\C library function
*P Fills a given area of memory with the same character.
*I <string.h>
*F void *memset(void *s, int c, size_t n);
*A s - A pointer to the area of memory to be filled.
*A c - The character to be used for filling.
*A n - The number of characters in the area of memory to be
filled.
*R the unchanged value of %ss%s.
*D %bmemset()%b fills the first %sn%s characters of the area
of memory pointed to by %ss%s with the value of the character %sc%s. %sc%s
is converted to an unsigned char before the filling takes place.
*c=#include <string.h>
*c=int main (void)
*c={
*c=/*
*c=  Zero the first hundred bytes of a buffer
*c=*/
*c=
*c=char buffer[200];
*c=
*c=memset(buffer,'\0', 100);
*c=}
*q memset
*q Fill area of memory with the same character
*q Area of memory - fill with the same character
*q Memory - fill area of with the same character
*q Character, fill area of memory with
#
*n MemSize\System library
*P Returns the size of a memory block
*I <syslib.h>
*F word MemSize(void *mem);
*A mem - address of memory block
*R size of block
*D This function returns the size of a block of memory. The
argument %bmem%b must have been obtained as a result of a call to
Malloc().
*q MemSize
*x Malloc
#
*n Message-passing\General interest
*P Provides a method of low-level data communication between
clients and servers
*D Most users and general programmers do not need to to worry
about message passing as it is handled by Helios internally.
*p The message passing routines %bGetMsg()%b and %bPutMsg()%b transfer the
message header, control vector and data vector. %bPutMsg()%b does %snot%s
guarantee delivery of the message and so any software explicitly using
%bPutMsg()%b and %bGetMsg()%b must include error detection and recovery
code. For this reason you should only use %bPutMsg()%b and %bGetMsg()%b if
you really need to do so. In most cases you should use pipes with the
higher level Posix %bread()%b and %bwrite()%b or the Helios %bRead()%b and
%bWrite()%b functions, which already include the necessary error recover
code.
*x GetMsg
*x PutMsg
*x Read
*x read
*x Write
*x write\000693
*q Message passing
*q Reading (messages)
*q Writing (messages)
*q Error recovery and detection
#
*n Metacharacters\General interest
*P Characters that have a special significance to the shell
*D Helios metacharacters are as follows, listed left to right
in order of decreasing precedence:
*c=| ; || && & ( ) < > << >>
*l |
*t Pipes the output from one process to the input of another one.
*l ;
*t Separates single commands or sequences of pipelines, causing the shell
to execute each command or sequence sequentially; each command or sequence
being executed on the completion of its predecessor.
*l ||
*t Separates two single commands or two pipelines, where the second is only
to be executed on the failure of the first.
*l &&
*t Separates two single commands or two pipelines, where the second is only
to be executed if the first one succeeds.
*l &
*t Runs a task as a background task.
*l ( )
*t Groups a sequence of commands or pipelines to be run in a child shell.
*l >
*t Redirects output from the standard output (stdout).
*l <
*t Redirects input from the standard input (stdin).
*l >>
*t Redirects output from the standard output (stdout), appending files
rather than overwriting them.
*l <<
*t Causes a command to read input from the shell's input until it
encounters a line that just contains a word that matches the word
following the << metacharacter in the command line.
*x Background-tasks
#
*n mkdir\Helios command
*P Creates a subdirectory
*F mkdir <dirname> [<dirname> ...]
*D %bmkdir%b creates %sdirname%s as a new subdirectory. Notice
that you may list more than one %sdirname%s to create several new
subdirectories. %bmkdir%b assumes that %sdirname%s is to be a subdirectory
of your current working directory unless you include `.', or `..' as part
of the name (where `.' indicates the current directory and `..' indicates
its parent directory), or you give the full pathname down from the root by
starting the name with a `/'.
*p You can remove an empty directory with %brm%b in the same way as you
might remove a file. However, a directory that contains some files or
subdirectories, even empty ones, cannot be removed unless you first remove
all its files and subdirectories.
*q mkdir
*q Creating directories
*k Making a new directory
*q Directory creation
#
*n mkdir\Posix library function
*P Makes a new directory
*I <sys/stat.h>
*F int mkdir (char *path, mode_t mode);
*A path - Pointer to the pathname of the new directory
*A mode - Access mode associated with the new directory
*R A value of zero, if the function completes successfully. If it
fails, it returns -1 and sets the variable errno to an error code that
indicates the error that occurred; no directory is created.
*E
*l [EACCES]
*t Search permission is denied on a component of the path prefix of the new
directory, or write permission is denied on the parent directory of the
directory to be created.
*l [EEXIST]
*t The file name already exists.
*l [EMLINK]
*t The link count of the parent directory would exceed the value of
LINK_MAX if the new directory was created.
*l [ENOENT]
*t A component of the path prefix does not exist or the %spath%s argument
points to an empty string.
*l [ENOSPC]
*t The file system does not contain enough space to hold the contents of
the new directory or to extend the parent directory of the new directory.
*l [ENOTDIR]
*t A component of the path prefix is not a directory.
*l [EROFS]
*t The path prefix resides on a read-only file system.
*l [ENAMETOOLONG]
*t The length of %spath%s is greater than the value of PATH_MAX.
*D %bmkdir()%b creates a new directory with name %spath%s and
access mode %smode%s. The file permission bits of %smode%s are modified by
the file creation mask of the task (see %bumask()%b). When bits are in
%smode%s other than the file permission bits are set the result is
undefined and they are ignored.
*p The owner ID of the directory is set to the effective user ID of the
task. The group ID of the directory is set to the group ID of its parent.
*p The new directory is created as an empty directory, although it may
contain entries for `.' and `..'.
*p This routine affects the time-related fields in %sstat struct%s, as
follows:
*l %sst_atime%s
*t Updated
*l %sst_ctime%s
*t Updated
*l %sst_mtime%s
*t Updated
*p These times are set to the time when %bmkdir()%b was successfully
executed. It has no affect on read-only file systems.
*x chmod\000074
*x stat
*x umask
*q Making a directory - see mkdir
*q Directory, making a - see mkdir
*q New directory, making a - see mkdir
*q mkdir
#
*n mkfifo\Posix library function
*P Makes a FIFO special file
*I <sys/types.h> ; <sys/stat.h>
*F int mkfifo (char *path, mode_t mode);
*A path - Pointer to the pathname of the new FIFO file
*A mode - Access mode associated with the new FIFO file
*R A value of zero, if the function completes successfully;
otherwise, it returns -1, sets the variable errno to an error code that
indicates the error that occurred, and no FIFO is created.
*E
*l [EACCES]
*t Search permission is denied on a component of the path prefix.
*l [EEXIST]
*t The file name already exists.
*l [EIO]
*t An I/O error occurred while writing to the file system.
*l [ENOENT]
*t A component of the path prefix does not exist or the %spath%s argument
points to an empty string.
*l [ENOSPC]
*t The directory that would hold the new file cannot be extended, or the
file system has exhausted its file allocation resources.
*l [ENOTDIR]
*t A component of the path prefix is not a directory.
*l [EROFS]
*t The path prefix resides on a read-only file system.
*l [ENAMETOOLONG]
*t The length of %spath%s is greater than the value of PATH_MAX.
*D %bmkfifo()%b creates a new FIFO file. %spath%s must refer
to an entry in a Helios FIFO server. The FIFO's access matrix is formed
from the %smode%s. The file permission bits of %smode%s are modified by
the file creation mask of the task (see %bumask()%b).
*p This routine affects the time-related fields in %sstat struct%s, as
follows:
*l %sst_atime%s
*t Updated
*l %sst_ctime%s
*t Updated
*l %sst_mtime%s
*t Updated
*p These times are set to the time when %bmkfifo()%b was successfully
executed. It has no affect on read-only file systems.
*x chmod\000074
*x exec
*x pipe
*x stat
*x umask
*q mkfifo
*q Making a FIFO special file - see mkfifo
*q FIFO special file, making a - see mkfifo
#
*n mktime\C library function
*P Converts a tm structure into a %stime_t%s value.
*I <time.h>
*F time_t mktime(struct tm *timeptr);
*A timeptr - A structure containing a time calendar.
*R the value of %stimeptr%s as a number of seconds.
*E If the calendar in %stimeptr%s cannot be represented as a
%stime_t%s type, %bmktime()%b returns -1, cast to %stime_t%s.
*D %bmktime()%b converts the values given in the structure
pointed to by %stimeptr%s into a time of type %stime_t%s. This universal
time is then broken down to the format decided by the %stm%s structure,
and calculates the day of the week, the day of the month, and the day of
the year, depending on the other values provided. The new values are then
reloaded into the structure. %bmktime()%b returns the calculated
%stime_t%s value.
*c=#include <time.h>
*c=
*c=/* Initialise broken_down_time, omitting weekday etc */
*c=struct tm broken_down_time = {0, 0, 11, 2, 6, 93, 0, 0, 0};
*c=
*c=int main( void )
*c={
*c=   time_t cal_time;
*c=   cal_time = mktime(&broken_down_time);
*c=   printf("Weekday is %d\n", broken_down_time.tm_wday);
*c=}
*x time\000642
*q mktime
*q Convert tm structure into a time_t value
*q Time calendar
*q tm structure calendar
#
*n modf\C library function
*P Splits the argument into fractional and integral parts.
*I <math.h>
*F double modf(double value, double *intptr);
*A value - The number to be split.
*A intptr - A pointer to the recipient of the integral part.
*R the fractional part of %svalue%s (the integral part is stored
in %s*intptr%s).
*D %bmodf()%b splits %svalue%s into a fractional and integral
part. Each part has the same sign as %svalue%s. The integral part is
stored in %sintptr%s and the fractional part is returned by %bmodf()%b.
*q modf
*q Split argument into fractional and integral parts
*q Argument - split into fractional and integral parts
*q Fractional and integral parts, split argument into
*q Integral and fractional parts, split argument into
#
*n more\Helios command
*P Provides facilities for viewing textual output
*F more [-cdfls] [-n] [+<linenumber>] [+/<pattern>] [<name>...]
*D %bmore%b allows you to examine text one screenful at a
time. This textual output can be from a file or a pipe. At the end of each
screenful (but not the last), %bmore%b stops the display and waits for you
to tell it to continue or to quit the file. If the file list is empty then
%bmore%b reads from the standard input (stdin); this is useful in pipes.
*p %bmore%b accepts a number of options from the command line, which are
listed below:
*l -%s<n>%s
*t Uses the integer %sn%s number of lines as the number of lines it will
display in a `screenful' (the default number of lines is 2 lines less than
the total number of lines capable of being displayed on the user's
terminal).
*l -c
*t Avoids scrolling the screen when displaying a new screenful. It does
this by starting from the top of the screen and clearing each line for
displaying a new line of text. This option only works if your terminal can
clear to end of line.
*l -d
*t Prompts the user at the end of each screenful with the message: "Press
space to continue, 'q' to quit".
*l -f
*t Counts logical lines rather than screen lines; that is, it counts each
over-long, wrapped-around line as one line, rather than however many lines
it may actually take up on the screen.
*l -l
*t Stops treating the control character ^L (formfeed) specially. Unless
this option is specified, %bmore%b will pause at the end of a line in
which it finds a ^L, in much the same way as it would at the end of each
screenful.
*l -s
*t Treats multiple blank lines as a single blank line.
*l +%s<linenumber>%s
*t Starts displaying the specified file at a point %slinenumber%s lines
from the beginning of the file.
*l +/%s<pattern>%s
*t Starts displaying the specified file from two lines before the first
occurrence of %spattern%s, where %spattern%s is any regular expression.
*p The following table lists the keys you may press in response to
%bmore%b's prompt (the default prompt is `--More--'), and what happens
when you use them. %bmore%b acts on these instructions at once (that is,
you do not have to give a carriage return before anything happens). The
character %si%s used below can be any integer; the default is 1.
*l %sRETURN%s
*t Displays the next line beyond the end of the current screenful.
*l %sSPACE%s
*t Displays another complete screenful.
*l %sQ%s
*t Quits %bmore%b and stops displaying the file at the current screenful.
Notice that you can type Q in upper or lower case: SHIFT has no special
effect.
*l %siSPACE%s
*t Displays %si%s number of lines more
*l [%si%s]^D
*t Sets scroll size to %si%s (^D, or CTRL-D, without %si%s does the default
scroll). ^D without %si%s scrolls 11 lines.
*l [%si%s]z
*t Displays another screenful. If %si%s is specified, then that becomes the
new window size.
*l %si%ss
*t Skips %si%s number of lines and then displays a screenful of text.
*l %si%sf
*t Skips %si%s number of screenfuls and then displays a screenful of text.
*t Displays the line number of the current line (the last line displayed).
*l v
*t Enters the file into your default text editor (the default is
MicroEmacs, but you can set up another editor, such as the public domain
vi, known as %bstevie%b, using the environment variable EDITOR); quitting
from the editor returns you to %bmore%b.
*l h
*t Describes all the %bmore%b commands.
*l %si%s/%sexpr%s
*t Displays a screenful, starting from 2 lines before the %si%sth next
occurrence of the regular expression %sexpr%s. This command will not work
if %bmore%b is taking its input from a pipe. You can use ERASE (RUBOUT) to
edit the search expression; erasing beyond the first character in the
command will cancel its action.
*l %si%sn
*t Displays a screenful, starting from 2 lines before the %si%sth next
occurrence of the last regular expression you used. This command will not
work if %bmore%b is taking its input from a pipe.
*l '
*t Returns to the line where the last search started; if there has been no
previous search, %bmore%b returns to the first line of the file.
*l !%scommand%s
*t Starts a new shell and runs %scommand%s. You can use %% in %scommand%s
to represent the current filename and ! to represent the last shell
command you gave. You can use a backslash (\) to escape a real %% and ! in
%scommand%s (that is, you can use\%% in place of %%, and\! for !).
*l [%si%s]:n
*t Goes to the %si%sth next file in the list of file names specified on the
command line (%s<name>%s...). If you have not got an %si%sth next file,
%bmore%b moves on to the last file listed.
*l [%si%s]:p
*t Goes to the %si%sth previous file in the list of file names specified on
the command line (%s<name>%s...). If you have not got an %si%sth next
file, %bmore%b moves on to the first file listed. If %bmore%b is busy
displaying a file when you give this command, it may simply go back to the
first line of the current file. If %bmore%b is taking its input from a
pipe, it will ring the terminal bell and ignore this command.
*l :f
*t Displays the current filename and linenumber (like :f in vi or stevie).
*l :q
*t Exits %bmore%b. Unlike in vi, the character q can be in upper or lower
case. This command is equivalent to the Q command, which was described
earlier.
*l .
*t Repeats the last command given to %bmore%b.
*p When %bmore%b takes its input from a file rather than a pipe, then along
with the --More-- prompt, it displays, as a percentage, how much of the
file has been read so far. Note that this percentage is measured according
to the number of characters read and not the number of lines read.
*p %bmore%b usually outputs to the terminal screen (the standard output).
If output goes to an output that is not the screen, %bmore%b acts in a
similar way to %bcat%b. However, unlike %bcat%b, if %bmore%b is given more
than one %sname%s as input, it will print a header before printing each
successive file represented in the input list.
*q Files, displaying
*q Files, editing
*q Textual output from files, displaying
*q Textual output from files, editing
*q Textual output from pipes, displaying
*q Pipe output, displaying
*q Examining text in screenfuls
*q Perusing files
*q Text editors
*q Editing text
*q vi
*q stevie
*q emacs
*q MicroEmacs - see emacs
*q Continuous text, displaying
*q more
*x cshrc
*x cat
*x emacs
*x Editor
#
*n MultiWait\System library
*P Waits for a message from one of several ports
*I <message.h>
*F word MultiWait(MCB *mcb, word nports, Port *ports);
*A mcb - message control block
*A nports - size of ports array
*A ports - array of message ports
*R index of selected port or Helios error code
*D This function allows a single process to wait for the first
message to arrive at any of several message ports. In the MCB only the
Timeout, Control and Data fields need to be initialised. If the Timeout is
zero the ports are merely polled for pending messages without suspending
the caller. If the Timeout is -1 the caller will wait until a message
arrives at any of the ports. If the Timeout is neither of these values,
MultiWait will return if at the end of this time (in microseconds), no
message has arrived. The Control and Data vector pointers should point to
areas of memory large enough to accept the largest message expected from
any port. The ports array should contain either a valid port descriptor,
or NullPort, in each position from ports[0] to ports[nports-1]. If any
port proves to be invalid MultiWait will return an error indicating which
port was bad.
*p When a message arrives at any of the ports, it is received into the MCB
as with GetMsg and MultiWait returns the index in the ports array of the
port which was selected. If any port already has a waiting message when it
is called, MultiWait will return immediately, otherwise it will wait
according to the Timeout.
*q MultiWait
#
*n mv\Helios command
*P Moves files
*F mv [-mi] <source> <destination>
*F mv [-mi] <source> [<source>...] <destination directory>
*D %bmv%b stands for `move'. %bmv%b moves the %ssource%s
file(s) from their original location to their new %sdestination%s. If this
fails, %bmv%b attempts to copy the file to the destination and then delete
the original version. This may occur, for instance, if the source and
destination are on physically separate file systems. The new file has all
the attributes of the original; the action of %bmv%b is simply to rename a
file. %bmv%b's syntax is similar to that of %bcp%b.
*p The first format of this command simply moves the %ssource%s file to the
destination specified. For example,
*c=mv orig new
*p will rename the file `orig' as `new'.
*p The second format enables you to copy multiple files and/or directories
to a %sdestination directory%s, using their original names. For example,
*c=mv Andy Maeve Frome/house
*p moves the files `Andy' and `Maeve' into the directory `Frome/house'.
*p Note that if a directory is used as the %ssource%s, it and all its
subdirectories are moved to the new %sdestination%s. If the %ssource%s
happens to be a symbolic link, this link is deleted, and a new link to its
parent file is created at the new %sdestination%s.
*p %bmv%b supports two options: -i and -m. The -i option allows you to
interactively choose whether or not to overwrite any existing files. The
-m option stops %bmv%b from copying and then deleting the %ssource%s files
if the move operation fails.
*x cp
*q mv
*q Directory
*q Hierarchy
*q Path
*q Interactive renaming
*q Overwriting files
*q Renaming files
*q Deleting files
*q Copying files destructively
#
*n Name-table\General interest
*P Provides a standard naming scheme on each processor in the
network
*D Helios uses a hierarchical naming scheme for accessing
objects in the system. The root of this naming system is the name table on
each processor. The name table is arranged hierarchically with the helios
root at the top, the names of the servers at the bottom, and with the
machine name and processor cluster names in between. When a processor is
booted it knows about local services, its own machine name and that of the
processor that booted it, along with any cluster names leading directly to
the root.
*q Naming scheme
*q Name table
*q Processor
*q Network
*x Servers
#
*n NegAcknowledge\System library
*P Indicates that one or more events has been lost
*I <syslib.h> ; <ioevents.h>
*F void NegAcknowledge( Stream *stream, WORD counter);
*A stream - Stream to the device
*A counter - Word indicating the next event expected
*D %bNegAcknowledge()%b should be used by an event handler
when the handler believes that a message containing events may have been
lost. The loss may be due to a number of reasons such as congestion in the
network; in other cases the device knows that an event has been lost, but
can do nothing about it - for example, an event may have to be discarded
because the device ran out of buffer space. To detect any loss, all events
contain a counter field. If a device knows that a message has been lost,
it will send a message with function code EventRc_IgnoreLost. There is no
way of detecting whether or not a negative acknowledgement succeeded. The
assumption is that if the negative acknowledgement failed for one reason
or another then the handler will simply use another %bNegAcknowledge()%b
later on.
*x Acknowledge
*x EnableEvents
*q NegAcknowledge
*q Event handling - see also NegAcknowledge
#
*n network\Helios command
*P Examines the current state of the network
*F network [list]|[avail]|[show]|[showall]|[owners]|[info] |[monitor]|[help]
*D The %bnetwork%b command interacts with the Helios network
server to find out various bits of information about the current state of
the network.
*p The command
*c=network list
*p gives a short list of all the processors in the current network.
*c=network avail
*p gives a brief summary of the processors currently available in the network.
*c=network show
*p gives more information about the processors, including processor type,
state, memory size, and the connections between the processors.
*p The command
*c=network showall
*p gives similar information to network show, but also displays the
hardware facilities present in the network. For example, if the network
resource map indicates reset and configuration drivers to control the
network then these will be listed by the showall option.
*p The command
*c=network owners
*p is used to list which user currently owns how many processors. For all
users currently logged in, the command will display both the absolute
number of processors and the percentage of the network. In addition the
command will show how many processors are reserved for use by the system
and how many processors are in the nework free pool.
*p  The %bnetwork info%b and %bnetwork monitor%b commands can be used
    to display performance information about the various processors in the
    network. For each processor the command displays the current
    CPU load and memory usage, both as a percentage and in the form of
    a horizontal bar, as well as the total amount of memory.
    The %b|%b character at the end of each bar
    indicates the maximum load measured during the run of the program.
*p  The %binfo%b option gives a snapshot of the current load in the
    network of processors. The %bmonitor%b option runs continuously
    until the user explicitly exits the program, and displays a menu at
    the bottom of the screen. The menu options are as follows:
*l  arrow keys
*t  The up and down arrow keys can be used to select
    a particular processor. The currently selected processor will be
    displayed in inverse video.
*l  First
*t  For large networks where there are too many processors to
    display on one screen, this option can be used to move back to the first
    processor.
*l  Last
*t  This moves directly to the last processor in the network.
*l  Next
*t  This moves to the next page of processors.
*l  Prev
*t  This moves to the previous page of processors.
*l  Tag
*t  This can be used to `tag' the current processor. With large
    networks it may be desirable to select a small number of processors and display
    information about only those processors. This is possible by the tagging
    mechanism. Tagged processors are marked with an asterisk.
*l  Untag
*t  This can be used to remove the tag on the current processor.
*l  Display tagged
*t  Normally this causes the program to show only those
    processors which have been tagged. It can also be used to switch back
    to normal mode.
*l  Examine
*t  This option can be used to display information about the
    current processor. It gives details of processor type, memory, connectivity,    any programs that are currently running, and any code that is currently
    loaded.
*l  Map
*t  This option can be used to run the %bmap%b
    program on the current processor, if additional performance information
    is required. This option may fail if the user does not have sufficient
    access to the specified processor.
*l  Run map
*t  This option can be used to create a new window and
    run a %bmap%b program on the current processor in that window.
    The %bmap%b program and the %bmonitor%b will continue running
    independently. This option may fail if the user does not have
    sufficient access to the specified processor.
*l  !
*t  This can be used to run a sub-shell. When the user exits from
    that shell the monitor resumes.
*l  + and -
*t  These options can be used to increase or decrease the
    sampling rate. By default the program will take a sample every two seconds.
*l  ?
*t  This option gives on-line help about the various options.
*l  Quit
*t  This is used to exit the program.
*p The command
*c=network help
*p gives detailed information on the network command.
#
*n NewCap\System library
*P Creates a new capability
*I <servlib.h>
*F void NewCap(Capability *cap, ObjNode *obj, AccMask mask);
*A cap - capability
*A obj - pointer to object
*A mask - access mask
*D %bNewCap()%b creates a new capability for the given object
that contains the given access mask.
*q NewCap
*q Capability, create a new
*q Access mask
#
*n NewKey\System library
*P Returns a new encryption key
*I <servlib.h>
*F Key NewKey(void);
*D %bNewKey()%b returns a new encryption key.
*q NewKey
*k Capability
*k Protection
*k Access
#
*n NewObject\System library
*P Creates and validates an object structure
*I <syslib.h>
*F Object *NewObject( string name, Capability *cap );
*A name - Full pathname of object.
*A cap - Capability for object.
*R Pointer to new object structure or NULL.
*D An object structure is created containing the pathname and
capability provided. The object will initially be given a pseudo-type; it
will be explicitly located when it is first used in a system library
routine. The name and capability will typically have been passed to this
task in a message (during environment transfer, for example).
*x CopyObject
*x NewStream
*q System library
*q Create object structure - see NewObject
*q Object structure, create and validate - see NewObject
*q Validate object structure - see NewObject
#
*n NewPort\System library
*P Locates, allocates and initializes a port.
*I <message.h> ; <syslib.h>
*F Port NewPort ( void )
*R Port descriptor of allocated port or NullPort
*D This function locates an unused slot in the port table,
initializes it as a local port, and then returns a suitable port
descriptor for it. If the kernel cannot find a free slot in the table, it
garbage collects and reuses the least recently used slot. Slots are
allocated in a cyclic manner to allow the maximum time to elapse between a
port being freed and its slot being reused. Programs should explicitly
release any ports they acquire.
*x FreePort
*q Ports - release
*q Local port
*q Releasing ports
*q Port handling functions
*q Allocate port
*q Port, allocate
*q Initialize port
*q Port, initialize
*q Locate port
*q Port, locate
#
*n NewProcess\System library
*P Initialises a process for subsequent execution
*I <process.h>
*F void *NewProcess(word stacksize, VoidFnPtr fn, word argsize);
*A stacksize - size of stack
*A fn - function for new process to run
*A argsize - size of argument
*D This function initialises a process ready for subsequent
execution by the %bRunProcess()%b or %bExecProcess%b functions. The
process is initialised to the given stacksize and expected size of
arguments. The caller should then place argsize arguments into the
prepared stack frame pointed to by the returned pointer. If at this point
the caller decides not to activate the prepared process, then it can be
cleaned up with a call to %bZapProcess()%b. Note that the %bFork()%b
function is a simpler way to initialise and activate a process.
*q NewProcess
*x Fork\000232
*x RunProcess
*x ExecProcess
*x ZapProcess
#
*n NewStream\System library
*P Creates a new stream structure from the supplied parameters
*I <syslib.h>
*F Stream *NewStream( string name, Capability *cap, word mode );
*A name - Full pathname of object to open
*A cap - Capability for the object
*A mode - Mode in which object is to be opened
*R Pointer to new stream structure or NULL
*D This function creates a new stream structure from the
parameters. The stream is opened and is ready for use. Like
%bNewObject()%b, the parameters will typically have been passed in a
message.
*x NewObject
*q Create new stream structure - see NewStream
*q Stream structure, create - see NewStream
#
*n newuser\Helios command
*q newuser, network command
*P Starts a new user session
*F newuser <user> | -
*D The newuser command can be used to start a new session for
the specified user within the current window, by interacting with the
nearest Session Manager. Depending on the configuration this may or may
not involve the Session Manager requesting a password. Creating a session
involves starting up a new Task Force Manager for that user, and running a
command for that user. This command is usually the login shell.
*q newuser command: user argument The %suser%s argument can be the name of
a user known to the system. This argument is optional.
*c=newuser martyn
*c=newuser
#
*n Null device\General interest
*P A server that acts as a sink for any data written to it.
*F /null
*D The Null device is a server that acts as a sink for any
data written to it. It can be opened like a file.
*q Servers
*x Server
#
*n NullFn\System library
*P Implements a handler for the IOC function NullFn
*I <servlib.h>
*F void NullFn(ServInfo *servinfo);
*A servinfo - pointer to server information in ServInfo structure
*D %bNullFn()%b implements a handler for the IOC function
NullFn. If a server has no need of any special handling of a function, a
pointer to the function may be installed in the DispatchInfo function
table. NullFn generates a success message where particular operations need
to be short-circuited.
*q DirServer
*q IOC functions
*q NullFn
*x Dispatch
#
*n ObjectInfo\System library
*P Obtains any information stored about the given object
*I <syslib.h> ; <gsp.h>
*F WORD ObjectInfo ( Object *object, STRING name, BYTE *info );
*A *object - Pointer to Context object
*A name - Name of target object
*A *info - Pointer to information
*R Error code
*D This function obtains any extra information on an object
stored by the server. It then places the information, which can include
such things as its size, date, protection status, and so forth, into the
buffer pointed at by %sinfo%s.
*p %bNote:%b %sinfo%s is entirely server specific.
*p As %bObjectInfo()%b may return information about types ObjInfo or
Link_Info, and Link_Info includes a variable sized name, you should make
sure the buffer that is to receive the information is at least IOCDataMax
bytes in size. One solution is to use the following union:
*c=union {
*c=       DirEntry   DirEntry;
*c=       ObjInfo    OInfo;
*c=       Link_Info  LInfo;
*c=       Byte       Buff[IOCDataMax];
*c=} Info;
*q ObjectInfo
*q Server
*q Obtain information about object
*q Information about object, obtain
*q Object information, obtain
#
*n objed\Helios command
*P Sets the stack size and other parameters for a program
*F objed [-i] [-s <ssize>] [-h <hsize>] [-m] [-n <name>] <file>
*D This command allows certain parameters held with an object
module to be altered. The compiled program specified by %sfile%s may be
inspected by using the -i flag, which simply causes %bobjed%b to print the
current settings of the stack size, the heap size, and the program name.
*p The -s flag is followed by the number of bytes to be allocated as stack
space when the program runs. The default is 2000 bytes, which is suitable
only for programs which do not declare large structures on the stack.
Stack overflow is a common cause for errors, and increasing the stack size
often clears up problems especially if the compiler does not generate
stack overflow checking code.
*p The -h flag is followed by the number of bytes of heap to be allocated
initially to the program. This value is not so crucial, as any memory
request will always be satisfied if there is sufficient free memory
available. The heap size is used when a memory allocation request fails;
in this case the maximum of heap size and the request are obtained.
Setting the heap size can limit memory fragmentation.
*p The -m flag enables you to display the module entries in a program.
*p The -n flag sets the name of the program. The default name is that of
the main library the program is linked with (for example, Cstart for a C
program because that is linked with cstart.o). You can use the -n option
to alter the name to something suitable.
*p Notice that %basm%b takes identical options to %bobjed%b.
*q Stack size
*q Heap size
*q Stack overflow
*q Memory fragmentation
*q objed
*x asm
#
*n objname\System library
*P Returns pointer to last part of given pathname
*I <servlib.h>
*F string objname(string);
*A string - character string
*D %bobjname()%b returns a pointer to the last component of
the pathname indicated by %sstring%s.
*q objname
#
*n od\Helios command
*P Displays a binary file
*F od [-option] <file>
*D The %bod%b command dumps binary files in a number of
formats. The format(s) used depend(s) on the option(s) supplied. The
possible options are as follows:
*l Option
*t Description
*l %b-a%b
*t Displays the ASCII name for each byte.
*l %b-b%b
*t Displays each byte as an unsigned octal number.
*l %b-c%b
*t Displays the ASCII character for each byte.
*l %b-d%b
*t Displays each short word (16 bits) as an unsigned decimal number.
*l %b-D%b
*t Displays each long word (32 bits) as an unsigned decimal number.
*l %b-e%b or %b-F%b
*t Displays each double word (64 bits) as a double precision floating point
number.
*l %b-f%b
*t Displays each long word (32 bits) as a single precision floating point
number.
*l %b-h%b or %b-x%b
*t Displays each short word (16 bits) as an unsigned hexadecimal number.
*l %b-H%b or %b-X%b
*t Displays each long word (32 bits) as an unsigned hexadecimal number.
*l %b-i%b
*t Displays each short word (16 bits) as a signed decimal number.
*l %b-I%b, %b-l%b or %b-L%b
*t Displays each long word (32 bits) as a signed decimal number.
*l %b-o%b or %b-B%b
*t Displays each short word (16 bits) as an unsigned octal number.
*l %b-O%b
*t Displays each long word (32 bits) as an unsigned octal number.
*l %b-w%b%s<n>%s
*t Specifies the number of bytes displayed on each line of the output. The
default is 32.
*p Options can be combined together. For example, the command shown below
would provide the output as indicated:
*c=od -cX hello.c
*c=0000000    #   i   n   c   l   u   d   e       <   s   t   d   i   o   .
*c=                636e6923        6564756c        74733c20        2c6f6964
*c=0000020    h   >  \r  \n  \r  \n   m   a   i   n   (   )  \r  \n   {
*c=                0a0d3e68        616d0a0d        29286e69        207b0a0d
*c=0000040    p   r   i   n   t   f   (   "   H   e   l   l   o       W   o
*c=                6e697270        22286674        6c6c6548        6f57206f
*c=0000060    r   l   d   \   n   "   )   ;  \r  \n   }  \r  \n
*c=                5c646c72        293b226e        7d0d0a0d        00006f0a
*c=0000075
*q od
*q Hex files
*q Octal files
*q Binary files
*x dump
#
*n offsetof\C library function
*P Represents the offset in bytes from the beginning of the given
structure
*I <stddef.h>
*F offset(type,member);
*D The macro %boffsetof()%b, defined in <stddef.h>, expands to
an integral constant expression that has type %ssize_t%s. The value of
this expression is the offset, in bytes, from the beginning of the
structure %stype%s of the member %smember%s.
*q offsetof
*q C library macro
#
*n Open\System library
*P Opens a stream to the named object
*I <syslib.h>
*F Stream *Open ( Object *object, STRING name, WORD mode );
*A object - Pointer to context object structure
*A name - Name of target object
*A mode - Mode to be used
*R Pointer to Stream structure or NULL if error
*D This function opens a stream to the named object relative
to %sobject%s. Depending on the value of the mode field, it opens the file
for reading, writing, or both; it may even create it, if necessary. You
may also use Open to locate modules and resident programs; in which case
the Stream structure is still allocated, but the server field will contain
the stored object value, and the Reply and Pos fields will not be defined.
*c=typedef struct Stream {
*c=        Node       Node;     /* link in housekeeping list      */
*c=        word       Type;     /* object type                    */
*c=        word       Flags;    /* control flag bits              */
*c=        word       Result2;  /* second result or error         */
*c=        word       FnMod;    /* function code modifier         */
*c=        word       Timeout;  /* seed for timeouts              */
*c=        Port       Reply;    /* port for object replies        */
*c=        Capability Access;   /* access capability              */
*c=        word       Pos;      /* current object position        */
*c=        Port       Server;   /* server message port            */
*c=        Semaphore  Mutex;    /* protection against multiaccess */
*c=        char       Name[Variable];    /* object pathname       */
*c=} Stream;
*p Valid modes for Open are as follows: O_Mask, O_ReadOnly, O_WriteOnly,
O_Block, O_Execute, O_ReadWrite, O_Create, O_Truncate, and O_Exclusive.
*x open
*x Close
*q Stream structure
*q Open stream to object
*q Stream, open to object
#
*n open\Posix library function
*P Opens a file for reading, writing, or both
*I <sys/types.h> ; <sys/stat.h> ; <fcntl.h> ; <posix.h>
*F int open (char *path, int oflag,...);
*A path - Pointer to pathname of file
*A oflag - Indicates file status or mode
*R On successful completion, %bopen()%b opens the file and returns
a non-negative integer that represents the lowest numbered unused file
descriptor. If %bopen()%b fails, it returns -1 and sets the variable errno
to indicate the error that occurred. In the case of a return value of -1,
no files can be created or modified.
*E
*l [EACCES]
*t (1) search permission is denied for a component of the pathname, (2) the
file exists but permission is denied for %soflag%s, or (3) the file does
not exist and the directory it is to be created in denies write access.
*l [EEXIST]
*t O_CREAT and O_EXCL are set, and the named file exists.
*l [EINTR]
*t %bopen()%b was terminated by a signal.
*l [EISDIR]
*t The file is a directory and %soflag%s specifies a write or read/write
access.
*l [EMFILE]
*t Too many file descriptors are currently in use by this task.
*l [ENFILE]
*t Too many files are currently open.
*l [ENOENT]
*t (1) O_CREAT is not set and the named file does not exist; (2) O_CREAT is
set and either the path prefix does not exist or the %spath%s argument
points to an empty string.
*l [ENOSPC]
*t The directory or file system which would contain the new file cannot be
extended.
*l [ENOTDIR]
*t A component of the pathname is not a directory.
*l [ENXIO]
*t O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no
task has the file open for reading.
*l [EROFS]
*t The named file is in a read-only file system and either O_WRONLY,
O_RDWR, or O_CREAT (if the file does not exist) is set with the %soflag%s
argument.
*l [ENAMETOOLONG]
*t The %spath%s string length is greater than the value of PATH_MAX.
*D This function opens the file corresponding to %spath%s for
reading and/or writing according to the value of %soflag%s and sets the
file pointer used to mark the current position within the file to the
beginning of the file. It then returns the file descriptor of the file it
has opened. %bopen()%b therefore establishes a connection between a
particular file and a file descriptor; other I/O functions may then use
the file descriptor returned by %bopen()%b to refer to the same file.
*p %bopen()%b returns the lowest possible file descriptor not currently
open for the current task as a file descriptor for the given file. The
file descriptor may not share a file with any other task in the system.
The file status flags and file access modes are set according to the value
of the argument %soflag%s. %soflag%s has a value that is the bitwise
inclusive OR of values from the table on the next page.
*p The following table lists the possible values of %soflag%s:
*f O_RDONLY\0x0001\Open for read only (file access mode)
*f O_WRONLY\0x0002\Open for write only (file access mode)
*f O_RDWR \0x0003\Open for read and write (file access mode)
*f O_CREAT\0x0100\Create file if file does not exist
*f O_EXCL\0x0200\Return error if file exists
*f O_TRUNC\0x0400\Truncate file size to 0
*f O_NONBLOCK\0x0800\No blocking
*f O_APPEND \0x1000 \Append each write (move pointer to EOF)
*p %bopen()%b affects the time-related fields in the %sstat struct%s, as
follows:
*l %sst_atime%s
*t Updated for files that did not previously exit, when O_CREAT was set.
*l %sst_ctime%s
*t Updated for files that did not previously exist, when O_CREAT was set,
or for existing files when O_TRUNC was set.
*l %sst_mtime%s
*t Updated for files that did not previously exist, when O_CREAT was set.
*p The times, where applicable, are set to the time when %bopen()%b was
successfully executed on the file. %bopen()%b does not affect files on
read-only file systems in this way.
*x Open
*x write\000693
*x creat
*x exec
*x fcntl
*x signal\000564
*x stat
*x umask
*x read
*x lseek
*x dup
*x close
*q open
*q Open file for reading/writing
*q Reading, open file for
*q Writing, open file for
#
*n opendb\Posix library function
*P Opens a text database file
*I <netdb.h>
*F int opendb(char *name, int mode)
*A name - name of database file
*A mode - mode of use
*R Zero if successful, else 100
*D This function opens a text database file in preparation for
scanning by scandb(). Only one database file may be open at any one time,
and when this function is called, the database may already have been
opened by a previous call. The behaviour of the function depends on the
mode argument which may be either 0, 1 or 2. In all cases, if the file is
not opened, it is opened for reading. If the mode is zero then the
database file is rewound. If the mode is one, the stayopen flag is set,
and the file rewound if already open. If the mode is two, the file is not
rewound if it was already open.
*q opendb
*x scandb
*x closedb
#
*n OpenDevice\System library
*P Loads and dynamically links an executing program to a device
driver
*I <syslib.h>
*F DCB *OpenDevice(string name,void *info);
*A name - filename of device driver held in /helios/lib
*A info - pointer to device specific configuration information
*D This function is used to load and to dynamically link an
executing program to a device driver. The device's DevOpen() routine is
called with the %sinfo%s pointer passed to OpenDevice() and the DCB that
this function returns is passed back to the caller of OpenDevice.
*q OpenDevice
#
*n opendir\Posix library function
*P Opens a directory stream
*I <sys/types.h> ; <dirent.h>
*F DIR *opendir (char *pathname);
*A pathname - Pointer to directory pathname
*R A pointer to an object of type DIR; otherwise, if the function
fails, it returns NULL and sets errno to indicate the error.
*E
*l [EACCES]
*t Search permission denied for any component of %spathname%s.
*l [EMFILE]
*t Too many file descriptors are currently open for the task.
*l [ENOTDIR]
*t A component of %spathname%s is not a directory.
*D The type DIR is defined in the header <dirent.h>. DIR
represents a directory stream (that is, an ordered sequence of directory
entries).
*p %bopendir()%b opens a directory stream corresponding to the directory
specified by
*q opendir %spathname%s. The directory stream is positioned at the first
entry and initially contains exactly one entry corresponding to each file
in the directory.
*p If a file is removed or added to the directory after the most recent
call to %bopendir()%b, an entry to that file is unspecified.
*x closedir
*x readdir
*x rewinddir
*q Directory operations - see also opendir
*q Directory stream, open - see opendir
*q Open directory stream - see opendir
#
*n Operators\General interest
*P Characters or symbols that have a special meaning in
expressions
*D Both the C programming language and the Helios Shell
recognize expressions constructed using arithmetic and logical operators.
The shell accepts the following operators, where precedence increases from
left to right and operators of equal precedence are grouped together
between square brackets:
*c=|| && | ^ & [== != =~ !~] [<= >= < >] [<< >>] [+ -] [* / %] ! ~ [( )]
*p In cases where operators of the same precedence occur several times, the
shell evaluates them from left to right. Here is a description of the
operators:
*l ||
*t Logical OR
*l |
*t Bitwise OR
*l ^
*t Bitwise eXclusive OR (XOR)
*l &&
*t Logical AND
*l &
*t Bitwise AND
*l =
*t Equivalent
*l !=
*t Not equivalent
*l ~
*t Tests for match with specified pattern
*l !=
*t Tests for no match with specified pattern
*l !
*t Logical NOT
*l ~
*t Bitwise NOT
*l <=
*t Less than or equal to
*l >=
*t Greater than or equal to
*l <
*t Less than
*l >
*t Greater than
*l >>
*t Shift right
*l <<
*t Shift left
*l +
*t Addition
*l -
*t Subtraction
*l /
*t Division
*l *
*t Multiplication
*l %%
*t Modulus
#
*n oserr\Posix library function
*P Holds Helios error code
*I <errno.h>
*F int oserr;
*D %boserr%b is a variable that holds the last Helios error
code generated by a posix function. It is set whenever errno is set.
*x errno
*q oserr
#
*n Parallel programming\General interest
*P Breaking down program and running some parts at the same time
*D Helios accepts more than one approach to parallelism. The
primary approach is that taken by %bCDL%b, where several programs
(%btasks%b) interact via %bpipes%b. A program can read or write to a pipe
without worrying about where the other end of the pipe is in the network;
it could be on the same processor or on another one altogether. All the
language compilers that run on Helios support pipes. The main advantage of
using pipes is that they do not involve any change to the language syntax,
usually just the addition of one library routine.
*p You can also take a low-level approach to parallelism: you can set aside
one or more dumb nodes on your network on which you can run an occam
parallel program. Unfortunately, an occam program cannot share a processor
with Helios, and so Helios resources must be accessed indirectly through a
server program and not accessed directly from occam.
*p Notice that there is no need for the programmer to write parallel
programs that do explicit message passing. Such programs are difficult to
write, often contain subtle synchronisation bugs and are non-portable. The
CDL approach to parallel programming provides exactly the same facilities
for parallelism as message passing, only without the problems mentioned
above.
*q Message passing
*q Programming in parallel
*q Parallel programming
*x CDL
#
*n pathcat\System library
*P Concatenates the given strings to make a pathname
*I <servlib.h>
*F void pathcat(string, string);
*A string - character string
*D %bpathcat()%b joins two given strings, one after another,
separating them with a forward slash (/), to form a pathname.
*q pathcat
#
*n pathconf\Posix library function
*P Gets configurable pathname variables
*I <unistd.h> ; <posix.h>
*F int pathconf(char *path, int name);
*A path - pointer to pathname of file or directory
*A name - variable in question
*R %bpathconf()%b returns the variable value for the specified
file or directory. If %sname%s is invalid, %bpathconf()%b returns -1. If
%sname%s has no limit for %spath%s, it returns -1 but does not set/reset
the value of errno. Other errors return -1 and set errno.
*E Sets errno and returns -1 for the following errors:
*l [EINVAL]
*t Invalid argument. The value of %sname%s is not valid.
*l [EACCES]
*t Permission denied.
*l [ENAMETOOLONG]
*t Filename too long. Pathname exceeds limit set for [NAME_MAX]
*l [ENOENT]
*t No such file or directory.
*l [ENOTDIR]
*t Not a directory. Pathname prefix is not a directory.
*D %bpathconf()%b finds out the value of a configurable limit
or option, %sname%s, that is associated with the file or directory
pathname indicated by %spath%s. The following table lists the configurable
variable names that can be queried in respect to the pathname specified:
*c= Variable           Value of name        int
*c= [LINK_MAX]        _PC_LINK_MAX           1
*c= [MAX_CANON]       _PC_MAX_CANON          2
*c= [MAX_INPUT]       _PC_MAX_INPUT          3
*c= [NAME_MAX]        _PC_NAME_MAX           4
*c= [PATH_MAX]        _PC_PATH_MAX           5
*c= [PIPE_BUF]        _PC_PIPE_BUF           6
*c= [POSIX_CHOWN_RESTRICTED]
*c=                   _PC_CHOWN_RESTRICTED   7
*c= [POSIX_NO_TRUNC]  _PC_NO_TRUNC           8
*c= [POSIX_VDISABLE] _PC_VDISABLE           9
*x fpathconf
*q pathconf
#
*n Pathname\General interest
*P Describes a file's location, indicating the path along which to
search
*D Pathnames can be %sabsolute%s or %srelative%s, both
indicate the route, or %spath%s, to be followed in order to find a
particular file. An absolute pathname describes the path from the root,
through any intervening directory levels, to the file in question. A
relative pathname describes the path from the current working directory
down to the file. The most obvious difference between the two kinds of
pathname is that an absolute pathname always starts with a forward slash
("/"), a relative pathname never does. Each intervening directory name is
followed by a forward slash. The last name given is the file being
described. For example, %s/users/bill/letters/fred%s is an absolute
pathname, describing the path from the root to the file %sfred%s. If the
current directory is %s/users/bill%s then the relative pathname for the
same file is %sletters/fred%s.
*q Pathnames, absolute
*q Pathnames, relative
*q Relative pathnames
*q Absolute pathnames
*q Filenames
*x Environment
#
*n pause\Posix library function
*P Suspends the calling task while awaiting a given signal
*I <signal.h>
*F int pause ( void );
*R No successful return: %bpause()%b can suspend a task
indefinitely or terminate it immediately. Returns -1 to indicate failure
and sets errno to indicate the error.
*E
*l [EINTR]
*t Signal caught by calling task and control returned from signal-catching
function.
*D %bpause()%b suspends the action of the calling task. It
will remain suspended until a signal arrives that executes a
signal-catching function or terminates the task.
*p If the action of the signal is to terminate the task, %bpause()%b will
not return.
*p If the action of the signal is to execute a signal-catching function,
%bpause()%b will return after the signal-catching function returns.
*x alarm
*x kill\000344
*x signal\000564
*x sleep\000573
*x wait
*q Suspend task - see pause
*q Task, suspend - see pause
#
*n PC-windows\General interest
*P Windowing of text output on PC-based systems.
*D The Helios idea of separate text windows for the output
from different shells, commands, and so forth fits in well even with
PC-based machines without graphics. The PC I/O server provides multiple
windows which are all 80 by 25 character only screens. These are swapped
to the front in turn using the hotkey combination of ALT/F1.
*q Windowing systems
*q PC windows
*x Window
#
*n perror\C library function
*P Writes an error message to the standard error output.
*I <stdio.h>
*F void perror(cons char *s);
*A s - A pointer to an error message string.
*D %bperror()%b writes the string %ss%s to the standard error
output, followed by a colon, space, and the error message represented by
the value in errno. The message is concluded by a newline.
*x strerror
*q perror
*q Write error message to standard error output
*q Error message - write to standard error output
*q Standard error output, write error message to
#
*n PhysToLogPri\System library
*P Converts physical priorities to logical priority levels
*I <process.h>
*F word PhysToLogPri(word physpri);
*A physpri - physical priority level
*R the logical priority.
*D This function converts physical priorities to logical
priority levels. It is the converse of %bLogToPhysPri()%b.
*q PhysToLogPri
*x LogToPhysPri
*x SetPriority
#
*n Pipe\General interest
*P A means of direct communication between tasks, whereby the
output from one task can be sent to become the input of another one.
*D Helios pipes are similar to Unix pipes. However, if
possible, Helios will try to run communicating tasks in parallel on
different processors. This means that the simple pipe %sls | more%s can
run with ls on processor 1 and more on processor 2; the stream between the
two connecting the stdin of more with the stdout of ls.
*p Pipes are an efficient way of passing data from one task to another,
where data is transmitted directly from one task to the other by a
message. Each task simply writes to or reads from the pipe, and each one
is suspended until the data is ready to be transferred.
*p Under Helios, a parallel program consists of tasks connected by pipes.
Any number of these software pipes may be used between the component
tasks, and any number of tasks may be specified. At load time Helios
assigns tasks to processors automatically, using any guidelines on
performing the placement that are provided by the user.
*p Although the pipe mechanism may at first sight seem inefficient, it is
not. Notice that two tasks communicating by way of a pipe send messages
directly to each other. These messages are normally sent by each side
issuing Read and Write system calls which map directly onto the low-level
message passing primitives. These calls also validate the handle passed
and also handle the retry protocol if a message fails to be delivered for
some reason. However, for ultimate efficiency, the user can pass messages
directly using the message ports provided within the pipe.
*q Communication between tasks
*q Task communication
*x Stream
*x Message-passing
*x CDL
*x Pipe
#
*n pipe\Posix library function
*P Creates an intertask channel (pipe)
*I <posix.h> ; <unistd.h>
*F int pipe(int fildes[2]);
*A fildes[2] - File descriptors
*R Zero, if a pipe is created successfully; otherwise, it returns
-1 and sets errno to indicate the error.
*E
*l [EMFILE]
*t The task is already using more than OPEN_MAX minus two file descriptors.
*l [ENFILE]
*t The number of open files in the system would exceed the current system
limit.
*D This function creates an inter-task channel, known as a
pipe, and returns two file descriptors, %sfildes[0]%s and %sfildes[1]%s.
The integer values of these file descriptors are the two lowest available
when %bpipe()%b executes. The O_NONBLOCK flags is clear for both file
descriptors (see %bfcntl()%b).
*p Once a pipe has been set up two communicating tasks can exchange data by
way of read and write calls. That is to say, data can be written to
%sfildes[1]%s and read from %sfildes[0]%s:
*l fildes[0]
*t for reading
*l fildes[1]
*t for writing
*p Reading %sfildes[0]%s accesses data written to %sfildes[1]%s on a
first-in-first-out basis. Attempts to write to %sfildes[0]%s and to read
from %sfildes[1]%s are doomed to failure.
*p %bpipe()%b affects the time-related fields of the %sstat%s structure, as
follows:
*l st_atime
*t Updated
*l st_ctime
*t Updated
*l st_mtime
*t Updated
*p The times are set to when %bpipe()%b was successfully executed on the
file. Files on read-only file systems are not affected by this function.
*x fcntl
*x open
*x read
*x write\000693
*q Creating a pipe
*q Creating an intertask channel - see pipe
*q Pipe, creating a
#
*n Pipe-server\General interest
*P Supports bi-directional inter-process communication.
*F /pipe
*D The pipe server is a standard Helios server that
understands and interprets the message protocol (GSP). Like the fifo
server, the pipe server provides a way of communicating between tasks.
Data passes between two communicating tasks via messages. Each task reads
and writes to and from the pipe and each is suspended until the data is
ready for transmission.
*p In many ways you can treat /pipe like a directory; for example, you can
list its contents with %bls%b to find out what pipes are open.
*q Servers
*q Message protocol
*q GSP
*q General Server Protocol
*x Server
*x Fifo-server
*x Message-passing
#
*n plink\Helios command
*q plink, network command
*q lstatus, network command
*P Sets a link into pending mode
*F plink <processor> <link>
*D As set out in the description of %bclink%b, a Helios link
can be in one of four states:
*l Not connected.
*t As far as Helios is concerned there is nothing at the other end of this
link and hence it is ignored.
*l Dumb.
*t There is some hardware at the other end of this link, but not a
processor running Helios. The hardware may be an M212 disc controller, a
T212 or T222 with special hardware such as an ethernet connection, or a
32-bit processor running occam, standalone C, or some other software that
does not require Helios.
*l Intelligent.
*t This means that there is a processor at the other end running Helios.
The link is used for distributed searches and hence for communication
within the network. When a link is set to intelligent mode the kernel will
perform a handshake across the link, to ensure that Helios is running at
the other side.
*l Pending.
*t This is a special case of intelligent mode. At some point in the future
there may be a processor running Helios at the other end of this link, and
when that happens the remote processor will send a handshake. Until this
handshake arrives the link will not be used for distributed searches or
for communication.
*p The %bclink%b command can be used to change a link state, by running it
on the appropriate processor; this is useful in the absence of a Network
Server. However, in a multi user environment it may not work. If the
processor concerned is not currently in the user's domain, it may not be
possible to run a program there. Instead there are other commands which
interact with the Network Server to achieve the same thing.
*p The %bplink%b command takes two arguments: a processor name and a link
number. It is used to set the link into pending mode:
*c=plink /02 3
*p Other similar commands - %bdlink%b, %belink%b, and %blstatus%b - can be
used to change the mode of a link and examine its current state.
*x clink
*x dlink
*x elink
*x lstatus
#
*n popd\Helios command
*P `Pops' the directory stack
*F popd [+<n>]
*D This command `pops' (or, if you prefer, `pulls') the
directory stack and returns you a new top directory. When you qualify
%bpopd%b with the argument %s+n%s, it pops the %sn%sth entry in the stack.
Helios directory stack elements are numbered 0, 1, 2, 3,..., starting from
the top. This means that when you use %bpopd%b without %s+n%s you `pop'
whatever was at 0, 1 becomes the new 0, 2 becomes the new 1, 3 becomes the
new 2, and so on.
*p By using %bpopd%b's complement, %bpushd%b, you can push a directory on
to the directory stack with the effect that the shell then makes that
directory your current working directory. You can then return to your old
working directory by using %bpopd%b to pull the current directory off the
stack making the next directory become the current one. For example, if
your current working directory is /helios/work,
*c=pushd /helios/examples
*p changes your working directory to /helios/examples. The %bdirs%b command
will show you what the stack now contains:
*c=%dirs /helios/examples  /helios/work
*p then, when you are ready to return to your previous working directory,
*c=popd
*p will restore /helios/work.
*q Shell commands
*q Directory stack
*q popd
*x pushd
*x dirs
#
*n _posixflags\Posix library function
*P Alters posix configuration flags
*I <unistd.h>
*F int _posixflags ( int how, int set );
*A how - how to change configuration flags
*A set - set of bits to change
*D %b_posixflags()%b is a Helios extension. The values for
%bhow%b are as follows:
*l PE_BLOCK
*t assert bits set in set
*l PE_UNBLOCK
*t clear bits set in set
*l PE_SETBLOCK
*t set flags to value of set
*p The Posix configuration flag is:
*l PE_RemExecute
*t execute programs via the Task Force Manager (TFM).
*q Helios posix extensions
*q _posixflags
*q TFM
*q Task Force Manager
#
*n PostInsert\System library
*P Inserts the node immediately after another in a list
*I <queue.h>
*F void PostInsert ( Node *pred, Node *node );
*A pred - Pointer to Node structure
*A node - Pointer to Node structure
*R Nothing
*D This function inserts %snode%s immediately after %spred%s
in its list. %sPred%s may be a list structure, in which case %snode%s is
added to the head of the list. (See %bAddHead()%b for an example of a Node
structure.)
*x PreInsert
*x AddHead
*q PostInsert
*q Insert node immediately after
*q Node, insert immediately after
#
*n pow\C library function
*P Calculates x to the power y.
*I <math.h>
*F double pow(double x, double y);
*A x - A number.
*A y - The exponent.
*R the value of %sx%s to the power %sy%s.
*E A domain error will occur in the following situations:
*c=  1.  x == 0  AND  y <= 0
*c=  2.  x < 0   AND  y is not an integer
*p In these cases errno is set to EDOM.
*p A range error will occur if the result of %bpow()%b is too large to fit
in a double. In this case %bpow()%b returns the value HUGE_VAL (with the
same sign as the correct value of the function) and errno is set to
ERANGE.
*D %bpow()%b calculates the value of %sx%s raised to the power
%sy%s.
*q pow
*q Calculate x to the power y
*q Power calculations - see also pow
#
*n pr\Helios command
*P Formats a file ready for printing
*F pr [<filelist>]
*D The %bpr%b command formats the files given as arguments
ready for printing. If the %sfilelist%s is omitted then the standard input
is used. %bpr%b is commonly used in conjunction with output redirection to
direct the output to a printer.
*x cat
*q Printing files
*q pr
#
*n PreInsert\System library
*P Inserts the node immediately before another in a list
*I <queue.h>
*F void PreInsert ( Node *next, Node *node );
*A next - Pointer to Node structure
*A node - Pointer to Node structure
*R Nothing
*D %bPreInsert()%b inserts %snode%s immediately before
%snext%s in its list. %sNext%s may point to the earth field in a list
structure, in which case %snode%s becomes the new tail item.
*x PostInsert
*q List structure
*q Node structure
*q PreInsert
*q Insert node immediately before
*q Node, insert immediately before
#
*n printenv\Helios command
*P Displays environment variable values
*F printenv
*D The %bprintenv%b command is used to display the names and
values of all environment variables that are currently set.
*q Environment variables
*q Shell commands
*q printenv
*x setenv
*x unsetenv
#
*n printf\C library function
*P Writes a formatted string to standard output.
*I <stdio.h>
*F int printf(const char *format, ...);
*A *format - A format string.
*A ... - Subsequent arguments to the format string.
*R the number of characters written, or a negative value if an
output error occurred.
*E %bprintf()%b returns a negative value if an output error
occurred.
*D %bprintf()%b writes the string pointed to by %sformat%s to
standard output. When %bprintf()%b encounters a percent sign %% in the
string, it expands the equivalent argument into the format defined by the
format tokens after the %%.
*p The format tokens are those described in %bfprintf()%b.
*p Each token acts on the equivalent argument, that is, the third token
relates to the third argument after the format string. There must be a
single argument for each token. If the token or its equivalent argument is
invalid, the behaviour is undefined.
*c=#include <stdio.h>
*c=
*c=int main()
*c={
*c=   char ch = 'S';
*c=   int number = 120, hex = 0x10, oct = 010, dec = 10;
*c=   int count;
*c=   double fp = 3.1415;
*c=
*c=   printf("%d    %+d    %06d    %X    %x     %o\n\n",
*c=        number, number, number, number, number, number);
*c=
*c=   printf("ZZZZ%nYYYY\n", &count);
*c=   printf("Number of Zs is: %d\n\n", count);
*c=   printf("%10c%5c\n",ch,ch);
*c=   printf("%f    %.2f    %E\n",fp,fp,fp);
*c=   printf("%i    %i    %i\n\n",hex,oct,dec);
*c=}
*c=
*c=/* Produces the following output:
*c= *
*c= *     120    +120    000120    78    78    170
*c= *
*c= *     ZZZZYYYY
*c= *     Number of Zs is: 4
*c= *
*c= *             S    S
*c= *     3.141500    3.14    3.141500E+000
*c= *     16    8    10
*c= *
*c= */
*x fprintf
*q printf
*q Write formatted string to standard output
*q Formatted string - write to standard output
*q I/O
#
*n Process\General interest
*P
*D A Unix process is roughly equivalent to a Helios %stask%s
(see Task). A Helios process is also commonly referred to as a %sthread%s
(see also Thread). A number of Helios processes may run within a Helios
task. When running within a single task, processes may share memory,
synchronising by way of semaphores. Processes in different tasks may not
share memory as Helios tasks are usually run on different processors.
*p A task is simply a collection of Helios processes (threads). A process
is suspended from execution whenever it is waiting to send or receive a
message and the other end is not yet ready, and when it is waiting for an
event or the timer. A process may be interrupted after its standard
timeslice of processor time has been used up. For transputers
all of the scheduling is done by the processor, while for C40s
all of the scheduling is done through software.
*x Task
*x Thread
#
*n Processor\General interest
*P A hardware processing unit
*D The Helios distributed operating system can run on a number
of different kinds of processor. Originally designed for the transputer,
Helios currently runs on all the T4XX and T8XX generations of transputer
(the T212 is too small, unfortunately) and the Texas Instruments' CMS320C40
processor.  It will also run on the Inmos T9000 when
it is released. Later versions of Helios have been (or will be) extended
to run on other processors, including the Acorn ARM and the Intel i860.
*p Helios can run on mixed networks of T4s and T8s.
*q Transputer
*q i860
*q T9000
*q C40
*q T8
*q T4
*q T2
*q ARM
*q Acorn
*q Intel
*q Inmos<
*q Texas Instruments
#
*n Processor-manager\General interest
*P A standard server that can be found on all processors
*F /tasks
*D The processor manager is a standard server which can be
found on all processors. It handles the tasks running on its processor.
*q Servers
*q Processor manager
*q Tasks
*x Server
#
*n Protect\System library
*P Sets the access matrix of the named object
*I <syslib.h> ; <protect.h>
*F WORD Protect ( Object *object, STRING name, Matrix matrix );
*A object - Pointer to context object structure.
*A name - Name of target object.
*A matrix - New access matrix.
*R Error code
*D %bProtect()%b sets the access matrix of the object named
%sname%s. Each object is associated with a 4-by-8-bit matrix, called an
access matrix. This matrix determines the rights of access to the object
(for example, Read, Write, Delete, Alter, or Execute) for various
categories of client (from `owner' to `everyone'). The matrix may only be
set if the client has Alter access, and the matrix cannot be set to a
value which would prevent the matrix being changed again, or the object
being deleted.
*q Access-matrix
*q Set the access matrix of object
*q Object access matrix, set
*q Access-matrix of object, set
*q Object structure
#
*n Protection\General interest
*P Insulating programs from each other, and the operating system
from programs.
*D Helios was initially designed for the transputer. The
transputer was initially designed without any hardware protection, such as
memory management or privileged processor states. The transputer also does
not have suitable bus error and instruction restart facilities which would
allow an external memory manager to be added. Such an external memory
protection would be useless anyway, because transputer ON-chip RAM is
universally accessible.
*p Given such a lack of facilities for protection, it was impossible to
implement any protection mechanism between programs running on the same
processor, which is why Helios  tries to run each task on a
separate processor. It is possible, however, to establish protection
boundaries between processors. This means that when more than one user is
using Helios, a single processor may not be used by more than one user at
a time, although a single user may multi-task on the same processor if
necessary. The idea behind the Helios method of protection is to protect
users from one another, and servers from users.
*p Protection mechanisms fall into two major classes: access list and
capability. In the access list mechanism the identity of the client is
compared against a list of valid users. This is like providing a doorman
with a guest list: the doorman simply checks arrivals against the names on
his list; the only people he allows in are those whose names match the
names on his list. In the capability mechanism, the client presents with
his request some proof that it has the necessary rights. This is more like
the doorman asking to see an invitation or ticket so that he can check if
the person is a valid guest with a right of entry to the party.
*p On protected architectures, these two mechanisms rely on the hardware to
protect the user's identifier, or the capability lists, from attempts at
forgery. In an unprotected architecture these must be safeguarded by
making it unlikely that a forger could construct a valid userid or
capability. This can be done either by choosing userids or capabilities
from a very large address space, or by encrypting with an unknown key.
*p The access list mechanism is unsuitable for distributed systems because
it relies on some central authority to create globally unique user
identifiers, and all uses of an identifier must be checked with it for
validity. Helios, as a distributed system, cannot rely on such a central
service. The capability mechanism, however, does not require a central
service and suits the distributed nature of Helios. Capabilities can be
generated and validated by individual servers. They allow a protection
mechanism to be constructed that bases its evaluation of a client's access
rights not on some absolute relationship between the client and the
object, but on the route the client used to access it.
*p Where appropriate, Helios server requests are accompanied by a 64-bit
capability. Certain operations cause new capabilities to be returned to
the client. It is intended that these capabilities only encode the rights
of the client; they must always be presented in conjunction with some form
of object identifier (such as a filename). Therefore they differ from the
classic form of capability which encodes the object identity and access
rights into a single item.
*p Once a capability has been passed out, the client may store it in any
way it sees fit. It may be stored in a file, compiled in a program, or
even printed out so that the user may write it down and type it back in
later.
*p Helios now runs on other processors, such as the TMS320C40, from which
it offers some limited form of memory protection.  Helios will also run on the
future T9000 which will have some limited form of hardware protection.
At present, however, the protection mechanism is still as described above.
*q Protection mechanism
*x Capability
*x Access-matrix
#
*n ps\Helios command
*P Finds out which programs are running in the network
*F ps [all] | [<user>] | [<processor>]
*D The %bps%b command can be used to find out which commands
are running in the network. There are various different ways of invoking
the command, to achieve different results.
*p %bps%b by itself, without any arguments, lists the tasks running on all
processors inside the user's domain. If the current session does not
involve a Taskforce Manager and hence is not running in a domain, ps by
itself will list the tasks running on the current processor.
*p To look at every program running on every processor in the network, the
%sall%s option can be used.
*p To look at every program running in the domain of a specific user, that
user name (for example, %bps%b tom) can be specified as the argument.
*p To look at every program running in a specific processor, you should
specify the processor name, preceded by a slash character (for example,
%bps%b /00). This character distinguishes user names and processor names.
*q ps
*q Running commands, list
*q User names
*q Processor names
*q Running tasks, list
*q Running programs, list
#
*n PseudoStream\System library
*P Makes a pseudo stream to the given object
*I <syslib.h>
*F Stream *PseudoStream (Object *object, word mode);
*A object - pointer to an object
*A mode - stream mode
*D This function manufactures a stream of type Type_Pseudo to
the given object. The stream, unlike most streams, will not be opened. It
may be used whenever a normal stream can be used, and it will be opened
automatically if necessary.
*q PseudoStream
#
*n pushd\Helios command
*P `Pushes' the directory stack
*F pushd [<name> | +<n>]
*D %bpushd%b on its own swaps the top two elements of the
directory stack.
*p Given a %sname%s argument, %bpushd%b changes to a directory with a name
that matches %sname%s (that is, it acts like %bcd%b) and `pushes' your old
current working directory on to the stack. If you use the optional +%sn%s
argument, where %sn%s indicates the %sn%sth element in the stack from the
top (that is, from 0), then %bpushd%b swaps that element with the top one
and sets you in it (`%bcd%b's to it).
*p You usually use %bpushd%b, in conjunction with %bpopd%b, to temporarily
hop out of one directory into another one and then back again:
*c=pushd otherdir
*c= ...
*c=popd
*p For further details, see the summary for %bpopd%b.
*x popd
*x dirs
*q Directory stack
*q pushd
*k Swap between directories
#
*n putc\C library function
*P Writes a character to a file stream.
*I <stdio.h>
*F int putc(int c, FILE *stream);
*A c - The character to be written.
*A *stream - A pointer to a file stream.
*R the character written if successful. If a write error occurs,
%bputc()%b returns EOF.
*E %bputc()%b returns EOF if a write error occurs.
*D %bputc()%b is a macro which converts %sc%s to an unsigned
char, writes it to the output stream pointed to by %sstream%s, and moves
the read/write position for the file stream as appropriate.
*x fputc
*q putc
*q Write character to file stream
*q Character, write to file stream
*q File stream, write character to
#
*n putchar\C library function
*P Writes a character to standard output.
*I <stdio.h>
*F int putchar(int c);
*A c - The character to be written.
*R the character written if successful. If a write error occurs,
%bputchar()%b returns EOF.
*E %bputchar()%b returns EOF if a write error occurs.
*D %bputchar()%b converts %sc%s to an unsigned char, writes it
to the standard output, and moves the read/write position for the file
stream as appropriate.
*x fputc
*x putc
*x getchar
*q putchar
*q Write character to standard output
*q Character, write to standard output
*q Standard output, write character to
#
*n PutMsg\System library
*P Sends the message described in the message control block
*I <message.h>
*F WORD PutMsg ( MCB *mcb );
*A mcb - Pointer to message control block
*R Error code
*D This function sends the message in the message control
block (%smcb%s).
*p %bPutMsg()%b is used with %bGetMsg()%b to effect message passing between
tasks. Like %bGetMsg()%b, %bPutMsg()%b is subject to a timeout, and a
timeout of -1 causes the call to be suspended until the message is sent.
*x Abort
*x GetMsg
*x NewPort
*q Send message in mcb
*q MCB
*q Message in mcb, send
#
*n PutReady\System library
*P Tests whether a port is ready for transmission
*I <message.h>
*F WORD PutReady( Port port );
*A port - Port to test
*R Error code
*D This function tests whether a port is ready for
transmission. It returns zero if a call to %bPutMsg()%b on this port would
complete immediately. If a non-zero result is returned the process would
be blocked in %bPutMsg()%b. A non-zero return code is also returned if the
port is invalid.
*q PutMsg
*x GetReady
*q Port ready for transmission - see PutReady
#
*n puts\C library function
*P Writes a line to standard output.
*I <stdio.h>
*F int puts(const char *s);
*A s - A pointer to the string to be written.
*R zero if successful, and non-zero if unsuccessful.
*E %bputs()%b returns non-zero if unsuccessful.
*D %bputs()%b writes the string pointed to by %ss%s to the
standard output file stream, followed by a newline character. The write
does not include the string terminating character.
*x fputs
*x putchar
*x getchar
*x gets
*q puts
*q Write line to standard output
*q Line, write to standard output
*q Standard output, write line to
#
*n pwd\Helios command
*P Lists the full pathname of the current working directory
*F pwd
*D %bpwd%b prints the pathname of your current working
directory, with the root to the left, the current directory to the right,
and all intermediate directory names listed from left to right according
to their position in the hierarchy, separated by slashes (/). For example,
if your current working directory is `progs' and you invoke %bpwd%b, the
result might look something like this:
*c=/c/fred/progs
*p showing that `progs' is in the directory `fred', which in turn is in
`c'.
*q Shell commands
*k Filing system hierarchy
*q Pathname of current directory
*q Print pathname of current directory
*q Current directory pathname
*x cd
#
*n qsort\C library function
*P Sorts an array of objects.
*I <stdlib.h>
*F void qsort(void *base, size_t nmemb, size_t size, int
(*compar)(const void *, const void *));
*A base - Pointer to the start of the array.
*A nmemb - Number of objects in the array.
*A size - Size of the array objects.
*A (*compar)(const void *, const void *) - Pointer to comparison
function.
*D %bqsort()%b sorts objects in the array pointed to by
%sbase%s, according to comparisons performed by the function pointed to by
%scompar%s. The array contains %snmemb%s objects of %ssize%s bytes.
*p The comparison function must return an integer less than, equal to, or
greater than zero, depending on whether the first argument to the function
is considered to be less than, equal to, or greater than the second
argument.
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=#include <string.h>
*c=
*c=int sort_compare( char**, char** );
*c=
*c=
*c=int main(argc, argv)
*c=int argc;
*c=char **argv;
*c={
*c=   int i;
*c=
*c=
*c=   /*
*c=    * Sort the command line arguments, according to the
*c=    * string comparison in sort_compare.
*c=    */
*c=   qsort( argv, argc, sizeof(char *), sort_compare);
*c=   for (i = 1; i < argc; ++i)
*c=      printf("%s\n", argv[i]);
*c=
*c=}
*c=
*c=int sort_compare(arg1, arg2)
*c=char **arg1, **arg2;
*c={
*c=   return(strcmp(*arg1, *arg2));
*c=}
*c=
*c=/*
*c= * Will produce the following output when called with the
*c= * three arguments: ace, hello, and bye
*c= *
*c= *      ace
*c= *      bye
*c= *      hello
*c= */
*x bsearch
*q qsort
*q Sort array of objects - see qsort
*q Array of objects, sort - see qsort
#
*n raise\C library function
*P Forces a pseudo-exception via the signal handler.
*I <signal.h>
*F int raise(int sig);
*A sig - A signal number, as defined in %s<signal.h>%s.
*R zero if successful, non-zero if unsuccessful.
*E If %braise()%b is called with an unrecognised signal number, it
returns a non-zero value.
*D %braise()%b is used to generate a pseudo-invocation of the
signal handler. The actual function called in response to a %braise()%b
call depends on the signal initialisation for the signal number given as a
parameter.
*x signal\000563
*q signal
*q raise
*q Forcing a pseudo-exception via the signal handler
*q Pseudo-exception
*q signal handler
#
*n raise\Posix library function
*P Forces a pseudo-exception via the signal handler
*I <signal.h>
*F int raise(int sig);
*A sig - A signal number, as defined in %s<signal.h>%s
*R Zero if successful; non-zero if unsuccessful.
*E If %braise()%b is called with an unrecognised signal number, it
returns a non-zero value.
*D %braise()%b generates a pseudo-invocation of the signal
handler. The actual function called in response to a %braise()%b call
depends on the signal initialisation for the signal number given as a
parameter.
*x Signal
*x signal\000564
*q Forcing a pseudo-exception via the signal handler
*q Pseudo-exception
*q signal handler
#
*n RAM disc server\General interest
*P Supports the RAM disc
*F /ram
*D The ram server is a standard Helios server that understands
and interprets the message protocol (GSP). It controls access to the RAM
disc.
*p The RAM disc implements a fully functional filing system in the
processor's main memory. The server is loaded on demand and allocates
memory to contain any files written to it dynamically. The RAM disc is not
proof against processor crashes.
*p In many ways you can treat /ram like a directory; for example, you can
list its contents with %bls%b and you can delete it, or its contents, with
%brm%b.
*q Servers
*x Server
#
*n rand\C library function
*P Generates a pseudo-random number.
*I <stdlib.h>
*F int rand(void);
*R a positive pseudo-random integer.
*D %brand()%b generates a pseudo-random integer in the range 0
to RAND_MAX.
*x srand
*q rand
*q Pseudo-random numbers - see rand
#
*n Raw\General interest
*P Term meaning unprocessed input
*D Raw means unprocessed. A program can, under certain
circumstances, receive %sraw%s %sinput%s. This means that it receives
every character as it is typed. It is up to the program to interpret any
special character, such as backspace. The opposite of raw input is
%scooked%s %sinput%s.
*q Backspace
*q Del
*x Cooked
#
*n Read\System library
*P Reads a buffer full of data from the stream
*I <syslib.h>
*F WORD Read ( Stream *stream, BYTE *buffer, WORD size, WORD
timeout );
*A stream - Pointer to Stream structure.
*A buffer - Pointer to buffer.
*A size - Size of data required in bytes.
*A timeout - Timeout in microseconds before which the read must
complete.
*R Number of bytes actually read or error.
*D This function reads data from %sstream%s into %sbuffer%s.
It returns the the number of bytes received, -1 for an end of file or negative result if %bstream%b is invalid.
Notice that a zero size does not mean end of file, it merely means that no
characters arrived before the timeout. You may use a short timeout to poll
a stream for input. Alternatively, you could use -1 for timeout, to give
an infinite timeout.
*q Timeouts
*q Read buffer full of data from the stream
*q Data buffer, read
*q Stream structure
*x read
*x Write
#
*n read\Posix library function
*P Reads data from file to buffer
*I <posix.h> ; <unistd.h>
*F int read(int fd, char *buf, unsigned nbyte);
*A fd - File descriptor of file open for reading.
*A buf - Pointer to buffer.
*A nbyte - Number of bytes to be read.
*R The number of bytes actually read. On failure, it returns a
value of -1 and sets errno to indicate the error that occurred.
*E
*l [EAGAIN]
*t The O_NONBLOCK flag is set for the file descriptor indicated by %sfd%s
and this would delay the read operation.
*l [EBADF]
*t %sfd%s indicates a file descriptor that is not valid and not open for
reading.
*l [EINTR]
*t The read operation was terminated prematurely by a signal and no data
was transferred.
*D This function tries to read %snbyte%ss of data from the
file indicated by the open file descriptor %sfd%s into the buffer pointed
at by %sbuf%s.
*p For most files, %bread()%b starts at the file position specified by the
file pointer associated with %sfd%s. Each read operation increments this
file pointer by the actual number of bytes read. When %bread()%b attempts
to read a file that does not support seeking, it must start to read from
the current position. For all files, reading can continue until the
end-of-file is reached, whereupon a value of 0 is returned.
*p The number of bytes actually read may not exceed the value of %snbyte%s,
which may not itself exceed INT_MAX, although the number can of course be
less than %snbyte%s (if there are less than %snbyte%ss bytes left in the
file, for example). The number of bytes returned may also be less than
%snbyte%s if the operation is terminated prematurely on the receipt of a
signal, or if the file being read is a pipe or FIFO that does not have
that amount of bytes ready for reading. In the last case, %bread()%b
simply returns the number of bytes transferred without setting an error.
*p If the %bread()%b attempts to read an empty pipe or FIFO, its action
depends on whether a task has that pipe or FIFO open for writing. If no
task has it open for writing, %bread()%b simply returns a 0 to indicate an
end-of-file condition. If a task has the pipe or FIFO open for writing and
O_NONBLOCK is set, %bread()%b returns a value of -1 and sets errno to
[EAGAIN]; if O_NONBLOCK is clear, %bread()%b blocks until some data is
written or the pipe is closed by all tasks that had it open for writing.
*p If %bread()%b attempts to read a file that supports non-blocking read
operations and has no data ready for reading, its action depends on the
current setting of the O_NONBLOCK flag: if O_NONBLOCK is set, %bread()%b
returns -1 and sets the errno variable to [EAGAIN]; if O_NONBLOCK is
clear, it blocks until some data becomes available. The use of this flag
has no effect if there is some data available for reading.
*p %bread()%b affects the time-related fields of the structure %sstat%s, as
follows:
*l st_atime
*t Updated
*l st_ctime
*t Not affected
*l st_mtime
*t Not affected
*p These times, where applicable, are set to a time greater than or equal
to the time that the function read successfully transferred data and less
than or equal to the time of the last %bclose()%b of the file. Files on
read-only systems are not affected.
*x Read
*x write\000693
*x pipe
*x open
*x dup
*q Read data from file to buffer
*q Data - read from file to buffer
#
*n readdir\Posix library function
*P Returns a pointer to a directory stream
*I <sys/types.h> ; <dirent.h>
*F struct dirent *readdir(DIR *dir);
*A dir - Directory pointer to a directory stream.
*R A pointer to an object of type %sstruct dirent%s. If
unsuccessful, it returns NULL and sets errno. On reaching
end-of-directory, it returns NULL and leaves errno unset.
*E
*l [EBADF]
*t %sdir%s does not refer to an open directory stream.
*D Type DIR is defined in the header file %s<dirent.h>%s. It
represents an ordered sequence of directory entries, known as a directory
stream.
*p %breaddir()%b returns a pointer to a structure that represents the
directory entry at the current position in the directory stream pointed at
by %sdir%s and sets the next entry in the stream to the new current
position. It returns a NULL pointer on reaching the end of the stream.
*p The data %breaddir()%b points at may be overwritten by another call to
%breaddir()%b on the same directory stream, but not on another stream.
*p %breaddir()%b will not return directory entries containing empty names.
Directory entries `.' and `..' are returned as normal entries.
*x opendir
*x rewinddir
*x closedir
*q Directory operations
#
*n realloc\C library function
*P Changes the size of an object in memory.
*I <stdlib.h>
*F void *realloc(void *ptr, size_t size);
*A ptr - A pointer to the area of memory.
*A size - The new size of the area of memory.
*R a pointer to the allocated space. If it was not possible to
allocate %ssize%s bytes, %brealloc()%b returns a null pointer.
*E If it is not possible to allocate %ssize%s bytes, %brealloc()%b
returns a null pointer. %sptr%s must point to an area of memory which was
previously allocated by %bcalloc()%b, %bmalloc()%b, or %brealloc()%b and
which has not been deallocated by a call to %bfree()%b or %brealloc()%b.
If this is not the case the behaviour of %brealloc()%b is undefined.
*D %brealloc()%b allocates an area of memory of %ssize%s size,
and copies the previously allocated area of memory pointed to by %sptr%s
into the newly allocated area. If the previous area is larger than the new
area, the overflow may be lost.
*p If %sptr%s is null, %brealloc()%b behaves like a call to %bmalloc()%b.
*p If %ssize%s is zero the object pointed to by %sptr%s is freed.
*c=#include <stdio.h>
*c=#include <stdlib.h>
*c=
*c=int main(void)
*c={
*c=   int i;
*c=   int *array;
*c=   char *vector;
*c=
*c=   array = (int *)malloc( 500*sizeof(int) );
*c=   for (i = 0; i<500; ++i)
*c=       array[i] = i;
*c=   vector = (char *)calloc(200, sizeof(char));
*c=   array = (int *)realloc((void *)array, 1000);
*c=}
*c=
*c=/*
*c= * The net effect is that the original array of size 500 has
*c= * been freed by the call to realloc (due to the intervening
*c= * calloc call), and the contents have been copied to the
*c= * new location returned by realloc
*c= */
*x calloc
*x malloc
*x free
*q realloc
*q Change size of object in memory - see realloc
*q Memory object size, change - see realloc
*q Size of object in memory, change - see realloc
#
*n Rebooting Helios\General interest
*P Restarts the system
*D If you have a problem and need to restart Helios, try
pressing and holding down the CONTROL key (CTRL), the SHIFT key, and the
F10 function button (CTRL-SHIFT-F10).
*q Rebooting Helios
#
*n rebootio\Helios command
*P Reboots an I/O Server
*F rebootio [I/O Server]
*D The %brebootio%b command sends a special message to an I/O
Server which causes it to reboot Helios. This can be used to implement a
Unix-style fast boot facility, typically inside a shell script.
*q rebootio
#
*n Reconfigure\System library
*P Causes the Kernel to reconfigure its links
*I <link.h>
*F WORD Reconfigure( LinkConf *config );
*A config - Pointer to new configuration structure
*R Error code
*D This function causes the Kernel to reconfigure its links
according to the LinkConf vector in the configuration. Links may be
changed from Intelligent to Dumb mode or vice versa. This is primarily for
use by system routines where the hardware allows electronic
reconfiguration of the processor topology.
*x Configure
*q Link modes
*q Intelligent mode
*q Dumb mode
*q Hardware processor reconfiguration
*q Reconfigure kernel links
*q Kernel links, reconfigure
*q Links, reconfigure
#
*n recv\Posix library function
*P Receives a message from a socket
*I <sys/socket.h>;<sys/types.h>
*F int recv(int fd, char *buf, int len, int flags);
*A fd - file descriptor
*A buf - pointer to character buffer
*A len - length of buffer
*A flags - what to receive
*D This function is basically identical to the BSD Unix
version of %brecv%b: it receives messages from a connected socket.
*q recv
*x connect
*x recvfrom
*x recvmsg
*q BSD compatibility, Berkeley
#
*n recvfrom\Posix library function
*P Receives a message from a socket
*I <sys/socket.h>;<sys/types.h>
*F int recvfrom(int fd, char *buf, int len, int flags, struct
sockaddr *from, int *fromlen);
*A fd - file descriptor
*A buf - pointer to character buffer
*A len - length of buffer
*A flags - indicates what is to be done
*A from - pointer source address
*A fromlen - size of source address
*D This function is basically identical to the BSD Unix
version of %brecvfrom%b; it receives data from a socket, regardless of
whether or not it is connected.
*q recvfrom
*x connect
*x recv
*x recvmsg
*q BSD compatibility, Berkeley
#
*n recvmsg\Posix library function
*P Handles message reception from a socket
*I <sys/socket.h>;<sys/types.h>
*F int recvmsg(int fd, struct msghdr *msg, int flags);
*A fd - file descriptor
*A msg - pointer to message header
*A flags - message flag
*D This function is basically identical to the BSD Unix
version of %brecvmsg%b; it receives messages from a socket, even if the
socket is not %sconnected%s.
*p The structure %sstruct msghdr%s used by %brecvmsg%b and %bsendmsg%b is
as follows:
*c=struct msghdr {
*c=       caddr_t msg_name;          /* optional address */
*c=       int     msg_namelen;       /* size of address */
*c=       struct iovec *msg_iov;     /* scatter/gather array */
*c=       int     msg_iovlen;        /* # elements in msg_iov */
*c=       caddr_t msg_accrights;     /* access rights sent/received */
*c=       int     msg_accrightslen;
*c=};
*p The %sflags%s are defined as:
*f MSG_OOB\0x1\process out-of-band data
*f MSG_PEEK\0x2\peek at incoming data
*f MSG_DONTROUTE\0x4\send without using routing tables
*f MSG_MAXIOVLEN\16\limit scatter/gather array to a maximum of 16
entries
*q recvmsg
*x sendmsg
*x connect
*x recv
*x recvfrom
*q BSD compatibility, Berkeley
#
*n Refine\System library
*P Refines or restricts a capability
*I <syslib.h>
*F WORD Refine( Object *object, AccMask mask );
*A object - Pointer to object to refine
*A mask - Mask of bits to refine
*R Error code
*D This function refines or restricts the access rights
contained in the capability in the object structure. It does this by
generating a new capability with a new set of access rights composed of
the bitwise AND of the old capability's access mask and the mask given in
the arguments. The new capability overwrites the old one, so if the old
access needs to be preserved, the Object structure should be copied.
*x CopyObject
*q Capabilities
*q Access mask
*q Object structure
*q Refine capability
*q Restrict capability
*q Capability, restrict
*q Capability, refine
#
*n refine\Helios command
*P Refines and generates capabilities
*F refine [+|-|=] [rwefghvxyzda] <object list>
*D This command gives you the name and the capability, in
coded form, for each individual %sobject%s in a list. The capability is
encoded in the form of 16 characters. These characters are concatenated
with the name of the file, and prefixed with an @ character. The Helios
system library will recognise this format for filenames, so it will allow
you to use such a string in situations when it would usually expect to be
given the name of a file. In particular, these strings can be placed in a
shell variable or in an environment variable, and they can be compiled
into programs. The %brefine%b command also allows you to change the access
mask which is stored in the capability, using similar options to those you
would use with the %bchmod%b command.
*q refine
*q Capability, refine
*q Capability, generate
*x chmod\000074
*x Access-matrix
*x Capability
#
*n rehash\Helios command
*P Recomputes internal hash tables
*F rehash
*D This command forces the shell to recompute the internal
hash table of the contents of the directories on your current path. You
must give %brehash%b if you add any new commands to one of your
directories while you are logged in. Systems programmers must also use it
if they make any changes to the contents of one of the system directories.
*p It is essential to note that any new changes will not work until you
recompute the hash table. (It happens automatically each time you log in
or start a new shell). Trying to use a new command is a bit like
telephoning a switchboard operator and asking to be put through to
someone. If the operator's internal directory is up to date then there is
no problem; otherwise you may have some difficulty, because the operator
may not know the extension number for the person you wish to contact. Once
the internal directory has been rewritten to include the new name and
extension number, of course, you can get through without any difficulty.
*q Shell commands
*q rehash
#
*n RemEvent\System library
*P Removes the event handler from the event chain
*I <event.h>
*F void RemEvent ( Event *handler );
*A handler - Pointer to Event structure
*D This function removes the referenced Event handler from the
Event list. It should have been placed there by a previous call to
%bSetEvent()%b.
*x SetEvent
*q Event structure
*q Remove event handler from the event chain
*q Event handler, remove from the event chain
*q Event list - see also RemEvent
#
*n RemHead\System library
*P Removes the head node from the list and returns it
*I <queue.h>
*F Node *RemHead ( List *list );
*A list - Pointer to List structure.
*R Pointer to Node structure.
*D This function removes the head node from %slist%s and
returns it. If %slist%s is empty, %bRemHead()%b returns NULL. (See
%bAddHead()%b for description of the List and Node structures.)
*x RemTail
*q Node structure
*q List structure
*q AddHead
*q List structure - see also AddHead
*q Node structure - see also AddHead
*q Remove head node from list
*q Head node, remove from list
*q Node, remove from list
#
*n remote\Helios command
*P Runs a program on another processor
*F remote [-d] <processor> <command> [<args>]
*D %bremote%b runs %scommand%s in another processor,
%sprocessor%s, passing it arguments in the usual way. The action is
identical to running a command from a shell running in a remote processor,
but without requiring the shell to be running in that processor. For
example,
*c=remote /10 ls /loader
*p runs the %bls%b command within processor 10, listing the currently
loaded modules in processor 10.
*p The %s-d%s option allows you to run the program as a background task.
*x wsh
*x Background-tasks
*q Running a program on a remote processor
*q Remote processor, using a
*q remote
#
*n Remove\System library
*P Removes the given node from whatever list it is in.
*I <queue.h>
*F Node *Remove ( Node *node );
*A node - Pointer to Node structure.
*R The removed node
*D This function removes %snode%s from whatever list it is in.
The %snode%s MUST be in a list, otherwise corruption may occur. The
pointers in a node are set up by %bRemove()%b in such a way that
subsequent calls to %bRemove()%b will not corrupt memory.
*x remove
*x RemHead
*x RemTail
*q Remove node from list
*q Memory corruption
*q Node, remove from list
*q Node structure
#
*n remove\C library function
*P Removes access to a file.
*I <stdio.h>
*F int remove(const char *filename);
*A %sfilename%s - A pointer to the filename string.
*R zero if %bremove()%b was successful and non-zero if it was not.
*E If the remove was unsuccessful errno is set to a value, and
%bremove()%b returns a non-zero value.
*D %bremove()%b removes access to the file identified by the
string pointed to by %sfilename%s.
*x Remove
*q remove
*q Remove access to file - see remove
*q Access to file, remove - see remove
*q File access, remove - see remove
#
*n RemoveAttribute\System library
*P Removes one of a set of device attributes
*I <attrib.h>
*F void RemoveAttribute( Attributes *attr, Attribute item);
*A attr - Pointer to an Attributes structure
*A item - Attribute to be removed from the set
*D This function removes an attribute from a set of attributes
obtained by a call to %bGetAttributes()%b. Note that the change has no
effect on the behaviour of the device or Stream until a call to
%bSetAttributes()%b has been made.
*p You cannot remove two or more attributes at one time. Each attribute
must be removed with a separate call to %bRemoveAttribute()%b.
*x SetAttributes
*x GetAttributes
*x AddAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Device attribute handling
*q Attribute handling
#
*n RemTail\System library
*P Removes the tail node from the list and returns it
*I <queue.h>
*F Node *RemTail ( List *list );
*A list - Pointer to List structure
*R Pointer to Node structure or NULL
*D This function removes the tail node from %slist%s and
returns it. If %slist%s is empty, %bRemTail()%b returns NULL.
*x RemHead
*x Remove
*q List structure
*q Node structure
*q Remove tail node from list
*q Tail node, remove from list
*q Node, remove from list
*q List handling - see RemTail
*q List handling - see AddTail
*q List handling - see RemHead
*q List handling - see AddHead
#
*n Rename\System library
*P Renames `from' as `to' relative to `object'
*I <syslib.h>
*F WORD Rename ( Object *object, STRING from, STRING to );
*A object - Pointer to context object structure
*A from - Name of object to be renamed
*A to - New name of object
*R Error code
*D This function renames the object called `from' as `to'
relative to `object'. Both paths must be on the same server. In general,
this only works for filing systems, where the two names must refer to the
same volume.
*q Rename `from' as `to' relative to `object'
*q Object structure
#
*n rename\C library function
*P Renames a file.
*I <stdio.h>
*F int rename(const char *old, const char *new);
*A old - A pointer to the old filename.
*A new - A pointer to the new filename.
*R zero if %brename()%b was successful and non-zero if it was not.
*E If the rename was unsuccessful, %brename()%b returns a non-zero
value.
*D %brename()%b changes the name of the file from the %sold%s
string to the %snew%s string. If a file is renamed to an existing name the
existing file is overwritten.
*x Rename
*x remove
*q rename
*q Renaming a file - see rename
*q File, renaming a - see rename
#
*n rename\Posix library function
*P Renames a file
*I <posix.h> ; <unistd.h>
*F int rename(const char *old, const char *new);
*A old - Pointer to existing pathname of file
*A new - Pointer to new pathname of file
*R Zero on successful completion; otherwise, it returns -1 and
sets the variable errno to one of the following error codes to indicate
the error.
*E
*l [EACCES]
*t A component of either pathname prefix denies search permission; or one
of the directories containing %sold%s or %snew%s denies write permission;
or, write permission is denied by a directory pointed to by the %sold%s or
%snew%s arguments.
*l [ENOTEMPTY]
*t The link named by %snew%s contains entries other than `.' and `..'.
*l [EEXIST]
*t The link named by %snew%s contains entries other than `.' and `..'.
*l [EINVAL]
*t The %snew%s directory is a descendant of the %sold%s directory.
*l [EISDIR]
*t The %snew%s argument points at a directory and the %sold%s argument
points at a file which is not a directory.
*l [ENOENT]
*t A component of either pathname prefix does not exist or either %sold%s
or %snew%s points to an empty string.
*l [ENOSPC]
*t The directory that would contain %snew%s cannot be extended.
*l [ENOTDIR]
*t A component of either pathname prefix is not a directory; or the %sold%s
argument names a directory and the %snew%s argument names a non-directory
file.
*l [EPERM]
*t The argument %sold%s names a directory and the system restricts the
renaming of directories to tasks with appropriate privileges, and the
calling task does not have these appropriate privileges.
*l [EROFS]
*t The requested operation requires writing in a directory on a read-only
file system.
*l [EBUSY]
*t The link named by %sold%s or %snew%s is currently in use elsewhere by
the system or another task.
*l [EXDEV]
*t The link named by %sold%s and %snew%s are on different file systems.
*l [ENAMETOOLONG]
*t %snew%s or %sold%s corresponds to a string that is greater in length
than the value associated with PATH_MAX.
*D This function changes the name of a file from %sold%s to
%snew%s; that is, %sold%s points to the file's current pathname and
%snew%s points to the pathname by which it will be known after the
successful execution of %brename()%b.
*p If the %sold%s argument points to the pathname of a file that is not a
directory, the %snew%s argument may not point to the pathname of a
directory; if the %sold%s argument points to the pathname of a file that
is a directory, the %snew%s argument may not point to the pathname of a
file that is not a directory (that is, a directory may only be renamed
with another directory name, and a file with a filename). In either case,
if %snew%s exists, it will be deleted when %sold%s is renamed to %snew%s.
A link to %snew%s must exist for this to take place. Where %snew%s and
%sold%s refer to directories and %snew%s is the name of an existing
directory, that directory must not have any entries other than `.' and
`..'. Also, %snew%s must not be a descendant of %sold%s. Write access
permission must also be available for the directories containing %sold%s
and %snew%s, or for the directories %sold%s and %snew%s.
*x link
*x unlink
*x link
*x rmdir\000506
*q Rename file - see rename
*q File, rename - see rename
#
*n ReOpen\System library
*P Re-opens a stream which has been timed out or closed by the
server
*I <syslib.h>
*F word ReOpen( Stream *stream );
*A stream - Stream to reopen
*R Helios error code
*D A new %bOpen%b request is sent to the stream's server and
the structure updated with the results. This is used primarily within
SysLib to recover from certain classes of error. It may be of some use if
you wish your programs to do their own message handling.
*x Open
*x NewStream
*q SysLib
*q Message handling
*q Error recovery
#
*n repeat\Helios command
*P Repeats a specified command a given number of times
*F repeat <n> <command>
*D %brepeat%b is a very short loop consisting of just one
line. %brepeat%b repeats %scommand%s, where %scommand%s is a single
%scommand%s with arguments, %sn%s times, where %sn%s is an integer (0, 1,
2,...). Even if %sn%s is zero, input and output redirections occur exactly
once.
*p %scommand%s must not be a pipeline, a command list, or a bracketed
command list; it may only be a simple command (which means, of course,
that it could be another %brepeat%b). For example:
*c=% repeat 5 echo the quick brown fox jumped over the lazy dogs
*c=the quick brown fox jumped over the lazy dogs
*c=the quick brown fox jumped over the lazy dogs
*c=the quick brown fox jumped over the lazy dogs
*c=the quick brown fox jumped over the lazy dogs
*c=the quick brown fox jumped over the lazy dogs
*c=%
*q Shell commands
*q Loop
*q repeat
*x if
#
*n Resource map\General interest
*P Provides a textual description of the interconnections between
the processors in your network for the network server.
*D The resource map describes how your network is configured
and keeps a list of attributes for each individual processor on the
network. The network server uses this map for booting and controlling the
network.
*p Resource maps require a specification of a master node and the name of
the device driver used to reset nodes. The driver used will depend on the
hardware involved.
*p The textual description in the map must be converted into binary before
it can be used by the network server; this conversion is done by the
resource map compiler, %brmgen%b.
*p There is a default resource map provided with Helios,
%setc/default.map%s, which is the binary version of the text resource map
%setc/default.rm%s. This map defines the smallest possible configuration,
a network consisting of a single processor connected to the I/O server on
the host processor.
*p If your network differs from the default, you must create a new map
which correctly reflects the true layout. Once you have your new map,
compile it with %brmgen%b and place it in %setc/default.map%s, so that it
is automatically used as normal, or alter the %sinitrc%s file so that it
refers to the filename of the file containing your newly compiled map.
Reboot Helios and check the network nodes that have been booted. Error
messages will be given if the physical layout does not match that
described by your map.
*x rmgen
*x network
*q Network configuration
*q Map
*q Processor interconnections
*q Resource map
#
*n Result2\System library
*P Extracts the error code or second result from an object
structure
*I <syslib.h>
*F WORD Result2 ( Object *object );
*A object - Pointer to object structure
*R Stored error code
*D This function returns the last error on %sobject%s.
Whenever an operation on an object or a stream fails the error code is
stored in the structure. Some operations also return two results, in which
case you can retrieve the second result with %bResult2()%b.
*q Object structure
*q Extract error code or second result from object structure
*q Second result from object structure, extract
*q Error code, extract
#
*n Revoke\System library
*P Revokes all the capabilities for a given object
*I <syslib.h>
*F word Revoke(Object *object);
*A object - object to be revoked
*R Helios error code
*D The Helios protection mechanism is based on capabilities
which are encrypted using a key which is stored with the object to which
they refer. Only if a capability decrypts successfully with this key will
any access be allowed. The %bRevoke()%b function causes the server
containing the given object to choose a new key to be stored with the
object. This makes all existing capabilities for the object invalid. The
object passed to %bRevoke()%b will be re-initialized with a capability
encrypted with the new key and will be the only valid capability for the
object. %bRevoke()%b is only allowed if the client has Alter access rights
to the object.
*q Revoke
*x Protect
#
*n rewind\C library function
*P Sets the file stream's read/write position pointer to the start
of the file.
*I <stdio.h>
*F void rewind(FILE *stream);
*A stream - A pointer to a file stream.
*D %brewind()%b sets the read/write position pointer of the
file stream %sstream%s to the start of the file. The error indicators for
the stream are cleared.
*c=#include <stdio.h>
*c=
*c=int main( void )
*c={
*c=   FILE *stream;
*c=
*c=   stream = fopen("data.dat","w+");
*c=
*c=   if (stream == NULL)
*c=      printf("Couldn't open data.dat for write.\n");
*c=   else
*c=   {
*c=      fprintf(stream, "01234");
*c=      rewind(stream);
*c=      printf("First character in data.dat is: '%c'\n", getc(stream));
*c=   }
*c=}
*c=
*c=/*
*c= * Output:
*c= *         First character in data.dat is ' 0'
*c= */
*x clearerr
*q rewind
*q Set file stream's read/write position pointer to start of file
*q Start of file, set file stream's read/write position pointer to
*q File stream's read/write position pointer to start of file
*q Read/write position pointer to start of file - see rewind
#
*n rewinddir\Posix library function
*P Resets the position of the given directory stream to the start
*I <sys/types.h> ; <dirent.h>
*F void rewinddir(DIR *dir);
*A dir - Directory pointer to a directory stream
*R Nothing
*D Type DIR is defined in the header file <dirent.h>. It
represents an ordered sequence of directory entries, known as a directory
stream.
*p %brewinddir()%b resets the current position in the directory stream
associated with %sdir%s to the beginning of the directory. It also causes
the directory stream to refer to the current state of the corresponding
directory, as a call to %bopendir()%b would have done. %brewinddir()%b
does not have a return value; if %sdir%s does not refer to a valid
directory stream, then %brewinddir()%b has no effect. If a file is removed
or added to the directory after the most recent call to %brewinddir()%b,
an entry to that file is unspecified.
*x opendir
*x readdir
*x closedir
*q Directory operations
#
*n rm\Helios command
*P Deletes files and directories
*F rm [-fir] <filelist>
*D This command removes the files specified. For example,
*c=rm *.h /fred/docs/oldfile
*p deletes all the files in the current directory which end in `.h' and
also deletes the file `oldfile' in the directory `/fred/docs'.
*p The -f flag forces the command to continue after an error. When this
flag is given, no error messages are given about being unable to delete
files, and the return code is always zero. If the flag is not given,
suitable error messages are displayed.
*p The -i flag causes %brm%b to enter interactive mode. In this mode,
%brm%b displays in turn the names of the files to be deleted. After each
name %brm%b pauses and waits for the user to type the letter y if the file
is to be deleted or the letter n if the file is to be retained. It
continues in this fashion until all the files in the list have been either
deleted or retained. Interactive mode is particularly useful when a
pattern, such as *.h, provides the filelist, because a pattern can
accidentally match files that should not be removed. In interactive mode,
however, there is a chance for such files to be noticed and retained.
*p The third flag, -r, causes %brm%b to delete recursively. This should be
used with care, as it causes %brm%b to take special action when a
directory is given rather than a filename. Usually a directory that
contains some files may not be deleted; using the -r flag causes %brm%b to
look inside the directory and delete any files it finds within it. If
there are subdirectories within the specified directory then those too are
entered and totally deleted. Therefore the effect of
*c=rm -r /users/fred
*p will delete all the files and subdirectories held within the directory
/users/fred. This is like cutting off the entire section of the directory
tree at /users/fred.
*q rm
*q Deleting files
*q Deleting directories
#
*n rmdir\Helios command
*P Removes empty directories
*F rmdir [-p] [<dir>...]
*D This command removes one or more directories, specified as
%sdir%s. If %sdir%s is an empty directory, %brmdir%b will delete it.
*p The option %b-p%b allows for multiple deletion. For example, if you type
*c=rmdir -p /helios/tmp/games/zoids
*p the directory called zoids will be deleted (assuming that it is empty).
If by deleting zoids you leave the games directory empty except for the
system files dot (.) and dot-dot(..), then %brmdir%b will also delete that
directory. This process of pruning the directory structure will continue
until %brmdir%b reaches a non-empty directory.
*x dot
*x dot-dot
*x rm
*q Deleting directories
#
*n rmdir\Posix library function
*P Removes a directory
*I <posix.h> ; <unistd.h>
*F int rmdir(char *path);
*A path - Pointer to pathname of existing directory
*R Zero on successful completion; otherwise, it returns -1 and
sets the variable errno to indicate the error.
*E
*l [EACCES]
*t Search permission is denied on a component of the path or write
permission is denied on the parent directory of the directory to be
removed.
*l [EEXIST]
*t The directory named by %spath%s contains directory entries other than
`.' and `..'.
*l [ENOTEMPTY]
*t The directory named by %spath%s contains directory entries other than
`.' and `..'.
*l [ENOENT]
*t A component of the pathname prefix does not exist; the directory named
by %spath%s does not exist; or %spath%s points to an empty string.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [EROFS]
*t The directory to be removed lives on a read-only file system.
*l [EBUSY]
*t The directory to be removed is currently being used elsewhere by the
system or by another task.
*l [ENAMETOOLONG]
*t %spath%s corresponds to a string that is greater in length than the
value associated with PATH_MAX.
*D This function removes the directory indicated by %spath%s.
%spath%s must exist and should be empty or contain only `.' or `..'
entries.
*x unlink
*x mkdir\000403
*q Removing a directory - see rmdir
*q Deleting a directory - see rmdir
*q Delete directory - see rmdir
*q Directory, remove - see rmdir
#
*n rmgen\Helios command
*q rmgen, network command
*P Compiles a network resource map
*F rmgen <basename> | [-o <outfile>] [<source file>]
*D One of the most important configuration files in Helios is
the Network Resource Map. This file contains a complete description of the
processor network such as the number of processors, the interconnection
between the processors, the hardware reset scheme or schemes and the
hardware link configuration scheme or schemes. A network will not boot up
completely without a valid resource map. Helios has two formats for the
resource map: the user can produce a text file by hand; the networking
software uses a binary format. The purpose of the %brmgen%b command is to
translate the textual form to the binary one. Using the Resource
Management library it is possible to write programs, for example,
graphical editors, which produce a binary file directly. There are two
reasons for having separate text and binary formats.
*p Using a binary form speeds up the bootstrap process. It is no longer
necessary to read in and parse what may be quite a large textual file.
Instead a binary file with a known format is read, which is much faster.
*l If there is some mistake in the textual resource map then %brmgen%b may
find it, before the user has to reboot the network with an invalid map. The
%brmgen%b program does a number of consistency checks in addition to the
syntax analysis, to give a better chance of producing a correct resource
map.
*p By convention, the textual resource maps are given the suffix %s.rm%s,
and the binary files are given the suffix %s.map%s. The %brmgen%b program
may be invoked in two ways. The first of these two ways specifies the
basename only, and %brmgen%b appends %s.rm%s for the source and %s.map%s
for the output file. The second way enables you to specify the source and
the output files explicitly. An output file can be specified with the
%s-o%s option. Possible ways of running %brmgen%b are as follows:
*c=rmgen /helios/etc/default
*c=rmgen -o /helios/etc/default.map /helios/etc/default.rm
#
*n RS232 device\General interest
*P Handles the host's RS232 port traffic
*F /rs232
*D /rs232 is provided by the I/O server. It handles I/O via the
RS232 port, if one is available on the host machine.
*q Devices
#
*n run\Helios command
*P Runs a command in its own window
*F run [-d] <command> [<arg>...]
*D This command creates a window, executes the specified
command with its associated arguments, and then closes the window when the
command terminates. The command is located using the environment variable
`path'.
*p The %s-d%s option returns control to the shell prompt before the
termination of %scommand%s.
*p The default %scommand%s is %bshell%b with no arguments.
*q run
*q path environment variable
*q Windows
*q Creating windows
*q Terminating windows
*x shell
#
*n RunProcess\System library
*P Launches a process prepared by %bNewProcess()%b
*I <process.h>
*F void RunProcess(void *args);
*A args - Pointer returned by %bNewProcess()%b
*D The %bRunProcess()%b function is identical to the
%bExecProcess()%b function, except that it runs processes at standard
priority. It has been retained for compatibility with previous releases of
Helios.
*q RunProcess
*x ExecProcess
*x NewProcess
*x Fork\000232
#
*n scandb\Posix library function
*P Scans a text database for an entry
*I <netdb.h>
*F int scandb(char *pattern, ... );
*A pattern - Pattern to scan for
*R 0 on success, 100 on failure
*D This function scans a textual database for an entry which
matches the given pattern. The database file consists of records which are
single lines of text; blank lines and lines beginning with '#' are
ignored. The pattern is a text string which describes the format of each
line in the file, and which fields are to be matched and which are to be
extracted. Each field is described by a two or three character format code
consisting of a match mode character, an optional 'l' character, followed
by a field type letter. Corresponding to each field in the pattern is an
argument. The match modes are as follows:
*l !
*t match this field exactly with the argument.
*l ?
*t match the field if it has a wildcard value.
*l %%
*t assign the value of the field to the argument.
*l $
*t ignore this field.
#
*n scanf\C library function
*P Reads formatted data from standard input.
*I <stdio.h>
*F int scanf(const char *format, ...);
*A format - A format string.
*A ... - Subsequent arguments to the format string.
*R the number of inputs which have been successfully converted. If
an end-of-file character occurred before any conversions took place,
%bscanf()%b returns EOF.
*E If an end of file character occurred before any conversions took
place, %bscanf()%b returns EOF. Other failures cause termination of the
procedure.
*D %bscanf()%b matches the data read from the standard input
to the specifications set out by the format string, %sformat%s. The format
string can include white space, ordinary characters, or conversion tokens.
*p 1. White space causes the next series of white space characters read to
be ignored.
*p 2. Ordinary characters in the format string cause the characters read to
be compared to the corresponding character in the format string. If the
characters do not match, conversion is terminated.
*p 3. A conversion token in the format string causes the data sequence read
in to be checked to see if it is in the specified format. If it is, it is
converted and placed in the appropriate argument following the format
string. If the data is not in the correct format, conversion is
terminated.
*p The conversion tokens are those described in %bfscanf()%b.
*p Each token acts on the equivalent argument, that is, the third token
relates to the third argument after the format string. There must be a
single conversion sequence received for each token. If the token is
invalid, the behaviour is undefined.
*p Any mismatch between the token format and the data received causes an
early termination of %bscanf()%b.
*c=#include <stdio.h>
*c=
*c=int main(void)
*c={
*c=   int hex, running;
*c=
*c=   printf("Enter hexadecimal number, or 00 to quit:\n");
*c=   do
*c=   {
*c=      printf("Number = ");
*c=      fflush( stdout );
*c=      running = scanf("%x", &hex);
*c=      printf("Decimal value = %i\n", hex);
*c=   }
*c=   while (hex && running);
*c=}
*x fscanf
*q scanf
*q Read formatted data from standard input - see scanf
*q Formatted data, read from standard input - see scanf
*q Data - read from standard input - see scanf
*q Standard input, read formatted data from - see scanf
#
*n SearchList\System library
*P Searches a list for a given Node
*I <queue.h>
*F Node *SearchList(List *list, WORD fn, WORD arg);
*A list - List to search
*A fn - Test function
*A arg - Argument passed to %sfn%s
*R Pointer to found node or to NULL
*D This function scans the list applying the function to each
node in turn. The function takes two arguments, a pointer to the current
node and the %sword arg%s passed to %bSearchList()%b. If the function
returns a non-zero result the search is terminated and the node returned
as a result of %bSearchList()%b. If the end of the list is reached,
%bSearchList()%b returns NULL.
*x WalkList
*q Node, search list for - see SearchList
*q List handling - see SearchList
*q List handling - see WalkList
#
*n sed\Helios command
*P Stream editor
*F sed [-n] [-g] [-f <script>] [-d <sfile>] [<file>]...
*D The stream editor %bsed%b copies the named file(s) in order
(the default is stdin) to stdout, editing them according to the script(s)
of editing commands.
*p Full documentation for this command can be found on the Unsupported
Software disc that accompanies this release.
#
*n Seek\System library
*P Seeks the current file position in the file
*I <syslib.h>
*F WORD Seek ( Stream *stream, WORD mode, WORD pos );
*A stream - Pointer to Stream
*A mode - Seek mode
*A pos - Position in file
*R New file position
*D This function seeks the current file position in the file.
The %smode%s ensures that the seek is relative to the start of the file,
relative to the current position, relative to the end of the file, or
relative to the last operation. Valid %smode%ss are S_Beginning (seek
relative to start-of-file), S_Relative (seek relative to current
position), and S_End (seek relative to end-of-file).
*q Seek current file position in file
*q Current file position in file, seek
*q File position, seek
*x fseek
*x lseek
#
*n select\Posix library function
*P Provides synchronous I/O multiplexing
*I <sys/time.h> <sys/socket.h>; <sys/types.h>
*F nfound select(int nfds, int *readfds, int *writefds, int *exceptfds, struct timeval *timeout);
*A nfds - Number of file descriptor (fds) to check
*A readfds - Pointer to bit mask of I/O fds ready for reading
*A writefds - Pointer to bit mask of I/O fds ready for writing
*A exceptfds - Pointer to bit mask of I/O fds with pending
exceptions
*A timeout - Pointer to timeval structure
*E
*l [EBADF]
*t Bit mask specified invalid descriptor
*l [EINTR]
*t Signal delivered before even occurred or time limit exceeded
*l [EFAULT]
*t Pointer to outside address space
*l [EINVAL]
*t Timeout value invalid
*R Number of descriptors in requested state. If an error occurs,
it returns -1. It returns zero if time limit is exceeded.
*D This function is basically identical to the BSD Unix version
of %bselect()%b; it handles reading, writing, and exception handling.
*p %bselect%b looks at the bit masks indicated by the arguments
%sreadfds%s, %swritefds%s and %sexceptfds%s to see if any are ready for
reading or writing, or if any have any pending exception conditions. In
the masks a file descriptor %sf%s is represented by the bit 1<<%sf%s. The
masks may be zero if there are no values of any interest.
*p %snfds%s specifies the number of file descriptors to be checked.
%bselect%b checks the bits from zero through to %snfds%s minus one. It
then returns the number of file descriptors found to be in the state(s)
requested, and it alters the bit masks to indicate which file descriptors
are ready.
*p The %stimeout%s argument is a pointer to the structure %stimeval%s. The
format of %stimeval%s is as follows:
*c=struct timeval{
*c=               unsigned long tv_sec;
*c=               long          tv_usec;
*c=};
*p A non-zero pointer specifies a maximum interval to wait for the
selection to complete. A zero pointer blocks the selection indefinitely.
Polling can be achieved by using a non-zero timeout pointer to a zero
timeval.
*q select
*x accept
*x connect
*x recv
*x send
#
*n SelectStream\System library
*P Checks streams for readiness
*I <syslib.h>
*F word SelectStream (word nstreams, Stream **streams, word *flags,
word timeout);
*A nstreams - number of streams in array
*A streams - array of pointers to Stream structures
*A flags - array of control flags
*A timeout - time to wait
*D This function checks each given stream for a set of
conditions to become true. The argument %bnstreams%b indicates the size of
the %sstreams%s and %sflags%s arrays. For each entry in the %sstreams%s
array, the equivalent entry in the %sflags%s array should have one or more
of the following bits set:
*l O_ReadOnly
*t Check that the stream is ready for reading
*l O_WriteOnly
*t Check that the stream is ready for writing
*l O_Exception
*t Check the stream for an exceptional condition
*p If the streams array entry is NULL or invalid, none of the above bits is
set in the flags array, or the stream does not have the Selectable bit set
in its Flags field, it is ignored. If the timeout is zero, the streams
will just be polled; otherwise, SelectStreams will wait for the given time
in microseconds, or forever if the timeout is -1. The result will be the
number of streams that are ready, these will be marked by setting the
O_Selected bit in the flags vector. With the exception of the lower 4
bits, SelectStream does not change the values in the flags vector, the
remaining bits may be used by higher level software (for example, the
Posix library uses the top 16 bits to store the file descriptor which
corresponds to the stream).
*q SelectStream
*x select
#
*n send\Posix library function
*P Sends a message from a socket
*I <sys/socket.h>;<sys/types.h>
*F int send(int fd, char *buf, int len, int flags);
*A fd - file descriptor
*A buf - pointer to character buffer
*A len - length of buffer
*A flags - modifiers
*R Number of characters sent; -1 if an error occurred.
*E
*l [EBADF]
*t Invalid descriptor
*l [ENOTSOCK]
*t Not a socket
*l [EFAULT]
*t Invalid address space specified
*l [EMSGSIZE]
*t Socket requires message to be sent atomically, and the size of the
message to be sent made this impossible
*l [EWOULDBLOCK]
*t Socket is marked non-blocking and the requested operation would block
*D This function is basically identical to the BSD Unix
version of %bsend%b; it transmits a message to another connected socket.
*q send
*x connect
*x socket
*x recv
*q BSD compatibility, Berkeley
#
*n SendEnv\System library
*P Transfers an environment to another Task
*I <syslib.h> ; <environ.h>
*F WORD SendEnv( Port dest, Environ *env );
*A dest - Port to which environment is to be sent
*A env - Pointer to environment to send
*R Error code
*D This function is a partner of %bGetEnv()%b, these two
together implement an environment exchange protocol for sending an
execution environment to another Task. The execution environment consists
of four vectors: an argument vector and an environment vector in standard
formats, a vector of pointers to Object structures and a vector of
pointers to Stream structures, all NULL terminated. %bSendEnv()%b marshals
these vectors into a message which is delivered to the destination port.
%bGetEnv()%b re-constructs the vectors using %bNewObject()%b and
%bNewStream()%b. %bSendEnv()%b copies the data passed to it, so that the
environment can be reused straight away.
*q NewObject
*q NewStream
*q Transfer environment to another task - see SendEnv
*q Environment, transfer to another task - see SendEnv
*x GetEnv
#
*n SendException\System library
*P Sends an exception message to the given port
*I <message.h>
*F void SendException ( Port port, word code );
*A port - Descriptor for the destination port
*A code - Exception code
*R Nothing
*D This function sends an exception message to %sport%s, with
the %sfnrc%s field set to the value of %scode%s. If a process is waiting
for %bGetMsg()%b on the port, it returns with the given code. Exception
messages are just like normal messages, except that they consist only of a
message header and the kernel makes slightly more effort to deliver them.
*q GetMsg
*q Send exception message to port
*q Exception message - send to port
#
*n SendIOC\System library
*P Sends a message to the Task's I/O Controller
*I <syslib.h>
*F void SendIOC( MCB *mcb );
*A mcb - MCB for message to be sent
*D The message described by the MCB is sent to the task's IOC.
This routine performs the necessary negotiation to prevent more than one
process in a Task sending a message to the IOC at the same time.
*q I/O Controller, send message to - see SendIOC
*q Task IOC, send message to - see SendIOC
#
*n sendmsg\Posix library function
*P Sends a message from a socket
*I <sys/socket.h>;<sys/types.h>
*F int sendmsg(int fd, struct msghdr *msg, int flags);
*A fd - file descriptor
*A msg - pointer to message
*A flags - operation modifiers
*R Number of characters sent; -1 if an error occurred.
*E
*l [EBADF]
*t Invalid descriptor
*l [ENOTSOCK]
*t Not a socket
*l [EFAULT]
*t Invalid address space specified
*l [EMSGSIZE]
*t Socket requires message to be sent atomically, and the size of the
message to be sent made this impossible
*l [EWOULDBLOCK]
*t Socket is marked non-blocking and the requested operation would block
*D This function is basically identical to the BSD Unix
version of %bsendmsg%b; it transmits a message to another socket, which
need not be %sconnected%s.
*q sendmsg
*x recvmsg
*x send
*x sendto\000525
*x socket
*x recv
*x connect
*q BSD compatibility, Berkeley
#
*n SendSignal\System library
*P Sends a signal to a task
*I <syslib.h>
*F WORD SendSignal( Stream *stream, word signal );
*A stream - Stream to task to signal
*A signal - Signal code
*R Error code
*D This function sends an asynchronous signal to the given
task. The stream argument is obtained by %bOpen%bing either the Object
returned from Execute or its entry in /tasks.
*x SetException
*x Execute
*x Open
*q Signal, send to task - see SendSignal
*q Task signalling - see SendSignal
#
*n sendto\Helios command
*P Sends a simple noninteractive mail message to the given
recipient(s)
*F sendto [ -s <subject> ] <address>...
*D %bsendto%b sends a simple noninteractive mail message by
reading standard input (stdin) and directing it to the given recipient(s),
indicated by the %saddress%s arguments. %saddress%s is the login name of
the user to whom you wish to direct your message. All messages are
datestamped with the time sent.
*p If you wish, you can attach a subject title to your message, using the
%b-s%b option and a string, %ssubject%s. For example, supposing the user
"tony" wishes to send a mail message to the users "fred", "bill" and
"mary" about an itinerary he has planned for them all. His command line
might look like this:
*c=sendto -s "travel arrangements" fred bill mary
*p Whatever he then types will be immediately directed to the standard
output (stdout) of users with the login names fred, bill and mary,
prefaced with a line like this:
*c=Message from tony at 12:40 about travel arrangements
*p Output will stop going to the recipients when "tony" presses the control
combination CTRL-D (eof). A %bsendto%b message interrupts other output
being sent to its recipient's screen. (If you are in %bemacs%b, for
example, you'll have to press CTRL-L to refresh the screen after receiving
a message from %bsendto%b.)
*q sendto
*q emacs
*q eof
*q Sending messages
*q Mail
*q CTRL-D
*q End-of-file marker
*x write\000692
*x wall
#
*n sendto\Posix library function
*P Sends a message to a socket
*I <sys/socket.h>;<sys/types.h>
*F int sendto(int fd, char *buf, int len, int flags, struct
sockaddr *to, int tolen);
*A fd - File descriptor
*A buf - Pointer to a character buffer
*A len - Length of buffer
*A flags - Operation modifiers
*A to - Pointer to target
*A tolen - Size of target
*R Number of characters sent; -1 if an error occurred.
*E
*l [EBADF]
*t Invalid descriptor
*l [ENOTSOCK]
*t Not a socket
*l [EFAULT]
*t Invalid address space specified
*l [EMSGSIZE]
*t Socket requires message to be sent atomically, and the size of the
message to be sent made this impossible
*l [EWOULDBLOCK]
*t Socket is marked non-blocking and the requested operation would block
*D This function is basically identical to the BSD Unix
version of %bsendto%b; it transmits a message to another socket, which
need not be %sconnected%s.
*q sendto
*x send
*x sendmsg
*x socket
*x recv
*x connect
*q BSD compatibility, Berkeley
#
*n ServerInfo\System library
*P Obtains any information from the server
*I <syslib.h>
*F WORD ServerInfo ( Object *object, WORD *info );
*A object - Pointer to context object structure
*A info - Pointer to information
*R Error code
*D This function obtains any information on the specified
server. Like %bObjectInfo()%b, %bServerInfo()%b is entirely server
specific. For a file server, the information comprises disc usage
statistics; for a window server, it comprises such things as window size
and position. The object itself is not accessed as it merely serves to
identify the server.
*x ObjectInfo
*q Object structure
*q Obtain information from server
*q Information from server, obtain
*q Server information, obtain
#
*n Servers\General interest
*P Provide a service for a client
*D Helios works according to a general client-server model,
whereby a client (for example, an application program) requiring some
service contacts the server program that performs that service.
*p A server can exist on any processor, or on all processors; its location
is invisible to the client. Some servers, however, need to be on a
particular processor because of the peripherals associated with that
processor. Helios locates previously unknown server by flood search of the
network, starting with neighbouring processors and then spreading through
the network until the server is located.
*p Each server consists of a task containing several processes. A single
port handles General Server Protocol (GSP) requests from all clients to
the server. To prevent congestion, a single dispatcher process is
dedicated to receiving requests from this channel and it creates a new
process dynamically to handle each request as it arrives.
*q GSP
*q Task
*q Process
*x Server
*x Dispatch
*x Name-table
*x General
#
*n ServMalloc\System library
*P Server library version of Malloc
*I <servlib.h>
*F void *ServMalloc(word size);
*A size - size of memory to allocate
*D All servers should use this server library malloc routine.
If a %bServMalloc()%b fails, the SafetyNet block is freed, but a memory
failure is reported anyway. The freeing of the SafetyNet should allow the
server enough heap space to respond to any subsequent clean up requests
sent to it. The size of a server's SafetyNet can be altered by changing
the value held in the external variable SafetySize. This has to be done
before the server makes its call to the %bDispatch()%b function.
SafetySize is a ServLib external word sized variable that defaults to
5120.
*q ServMalloc
*x Dispatch
#
*n set\Helios command
*P Prints or sets shell variables
*F set <name> | set <name>=<word> | set <name>[<index>]=<word> |
set <name>=( <wordlist> )
*D This command lists or sets internal shell variables. If you
give %bset%b without an argument, it lists the current values of the shell
variables; for example:
*c=argv    ()
*c=autologout      10
*c=cwd     /helios
*c=history 20
*c=home    /helios
*c=path    (/helios/bin .)
*c=prompt  %
*c=savehist        20
*c=shell   /helios/bin/shell
*c=term    ansi
*c=user    anon
*p Notice that where a variable has a value consisting of either no words
or more than one word (argv, path, for example), %bset%b displays it as a
list within parentheses.
*p %bset%b can optionally be followed by four different forms of arguments.
The first of these is a single simple argument, %sname%s. This sets the
variable %sname%s to the null string, cancelling any previous value of
%sname%s.
*p The second optional form of this command sets the variable %sname%s to
the value %sword%s, where %sword%s is a value of one word. For example,
*c=set prompt=$
*p sets the single value `$' to the variable `prompt'. If you wish to
include more than one word as part of the prompt, or you simply wish to
make sure that it is followed by a blank space, you must give the %sname%s
in quotation marks:
*c=set prompt='$ '
*p The third possible format of %bset%b sets the %sindex%sth word
(component) of %sname%s to %sword%s; this word must already exist. For
example,
*c=set path[3]=.
*p means `set the third word in the wordlist associated with the variable
"path" to "."' (that is, set it to the current working directory).
*p The final possible format for %bset%b sets the variable %sname%s to the
list of words in %swordlist%s. For example,
*c=set path=(/c/project/bin /c/common/pathway /bin)
*p sets the variable `path' to the list of values in parentheses.
*p The shell carries out variable expansion on all arguments before %bset%b
sets them to new values.
*p If you set the variable `path', you must remember to issue a %brehash%b
command afterwards for the new path to take effect.
*q Shell commands
*x @
*x printenv
*x rehash
*x setenv
*q set
*q Setting variables
#
*n SetAttributes\System library
*P Installs a new set of attributes for a device
*I <attrib.h>
*F WORD SetAttributes( Stream *stream, Attributes *attr);
*A stream - Stream to the device specified
*A attr - Pointer to an Attributes structure
*R Error code
*D This function changes the attributes associated with a
device or stream. It uses the Attributes structure defined in <attrib.h>.
*x GetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*x SetOutputSpeed
*q Attributes structure
*q Device attribute handling
#
*n setbuf\C library function
*P Controls file buffering.
*I <stdio.h>
*F void setbuf(FILE *stream, char *buf);
*A stream - A pointer to a file stream.
*A buf - A pointer to an array of size BUFSIZ.
*D %bsetbuf()%b may be called after the file associated with
%sstream%s has been opened, but before it has been read from or written
to. %bsetbuf()%b causes %sstream%s to be fully buffered in the array
%sbuf%s. If %sbuf%s is a null pointer, the stream will not be buffered.
*x setvbuf
*q setbuf
*q Control file buffering - see setbuf
*q File buffering - see setbuf
*q Buffering of files - see setbuf
#
*n SetDate\System library
*P Sets the datestamp on the named object to the given value
*I <syslib.h>
*F WORD SetDate ( Object *object, STRING name, DateSet *date );
*A object - Pointer to context object structure
*A name - Name of target object
*A date - Pointer to date set
*R Error code
*D This function sets the date on the named object. The date
set is a structure as follows:
*c=typedef unsigned int Date; /* in seconds since 00:00:00 1/1/70 GMT  */
*c=/* common set of dates used by most objects */
*c=typedef struct DateSet {
*c=        Date            Creation;     /* time object was created    */
*c=        Date            Access;       /* time object last accessed  */
*c=        Date            Modified;     /* time object last modified  */
*c=} DateSet;
*p A zero date is not altered. If a server does not support all three dates
this function may not have any effect.
*x GetDate
*q Set datestamp on object to given value
*q Datestamp - set on object to given value
#
*n setenv\Helios command
*P Sets a value for an environment variable
*F setenv <name> <wordlist>
*D The %bsetenv%b command assigns values to environment
variables. It must be given at least two arguments. The first argument
must be the name of the environment variable to be created (%sname%s). The
second and subsequent arguments (%swordlist%s) refer to the value or
values to be assigned to %sname%s. If the variable %sname%s does not
already exist, it is created; if it does exist, its value is overwritten
with the value or values represented by %swordlist%s. For example,
*c=setenv HOME /helios/example
*p sets the value of environment variable HOME to be /helios/example. From
now on using %bcd%b or %bchdir%b without arguments will change the
directory to your new home directory, /helios/example.
*p If you set the variable PATH, you must remember to issue a %brehash%b
command afterwards for the new path to take effect.
*p If you do not wish to use the default editor, MicroEmacs, you can set
the EDITOR environment variable so that you always use another supplied
editor instead whenever you use a command that can invoke a text editor,
such as %bmore%b.
*q Shell commands
*q setenv
*q Setting environment variables
*x @
*x printenv
*x rehash
*x set
*x more
*x emacs
#
*n SetEvent\System library
*P Installs the given event handler in the event chain
*I <event.h>
*F Code SetEvent(Event *event);
*A event - Pointer to event structure
*D This function adds the Event
structure to the Event list. The event procedure is called whenever an
interrupt is asserted on a processor.
*q Event handling
*q Registering event handlers
*q SetEvent
*x RemEvent
#
*n SetException\System library
*P Sets a new exception handler for the task
*I <syslib.h>
*F WORD SetException( WordFnPtr fn, void *data, word datasize );
*A fn - Pointer to exception function
*A data - Pointer to exception data area
*A datasize - Size of data area
*R Error code
*D This function replaces the task's exception handler.
Subsequently %sfn%s will be called whenever an exception is sent to the
task using %bSendSignal()%b. The function will be called with the signal
code and a pointer to a copy of the data area as arguments.
*p %bCAUTION:%b This function has been made obsolete by %bSetSignalPort()%b
and should not be used.
*x SendSignal
*x SetSignalPort
*q Exception handler - see also SetException
#
*n SetFileSize\System library
*P Sets the size of the file
*I <syslib.h>
*F WORD SetFileSize ( Stream *stream, WORD size );
*A stream - Pointer to Stream
*A size - Size of file
*R Error code
*D This function sets the size of the file to %ssize%s. The
value of %ssize%s may be less than or equal to the original size of the
file.
*p If you set a file's length with %bSetFileSize()%b, you can only extend
it by writing at the end of the file.
*p CAUTION: %bSetFileSize()%b is not supported by all servers.
*x GetFileSize
*q Set size of file
*q File size, set
*q Size of file, set
#
*n setgid\Posix library function
*P Sets the group id
*I <unistd.h>
*F int setgid( gid_t gid );
*D See setuid() for a description of the Helios emulation of
user and group ids.
*x setuid
*x getgid
*x getegid
#
*n SetInfo\System library
*P Sets any special state information associated with a stream
*I <syslib.h>
*F WORD SetInfo( Stream *stream, void *info, word size );
*A stream - Pointer to Stream structure
*A info - Info structure to send
*A size - Size of structure
*R Error code
*D This function sets any special state information associated
with the stream. %bSetInfo()%b is the inverse of %bGetInfo()%b.
*x GetInfo
*q Special state information, set
#
*n SetInputSpeed\System library
*P Changes the current input speed associated with a device
*I <attrib.h>
*F void SetInputSpeed( Attributes *attr, WORD speed);
*A attr - Pointer to an Attributes structure
*A speed - The new input speed
*D This function changes the current input speed in a set of
Attributes obtained by a call to %bGetAttributes()%b. Note that the change
has no effect on the behaviour of the device until a call to
%bSetAttributes()%b has been made.
*x GetAttributes
*x SetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetOutputSpeed
*q Changing baud rate
*q Device attribute handling
#
*n setjmp\C library function
*P Sets up a non-local jump.
*I <setjmp.h>
*F int setjmp(jmp_buf env);
*A env - An array into which a copy of the calling environment is
put.
*R when first called, %bsetjmp()%b returns zero. After the
completion of %blongjmp()%b, it returns a value defined by the call to
%blongjmp()%b, which is always non-zero.
*D %bsetjmp()%b is used to set up a non-local goto by saving
the calling environment (stack frame) in %senv%s. This environment is used
by the %blongjmp()%b function. The %bsetjmp()%b function should only
appear in the comparison part of an IF statement or the controlling
expression of a switch. If the %bsetjmp()%b appears anywhere else the
behaviour of %bsetjmp()%b is undefined.
*x longjmp
*q setjmp
*q Set up non-local jump - see setjmp
*q Non-local jump, set up - see setjmp
*q Jump (non-local) - see also setjmp
#
*n setlocale\C library function
*P Sets or interrogates part of the program's locale.
*I <locale.h>
*F char *setlocale(int category, const char *locale);
*A category - Specification locale part to be set or interrogated
*A locale - Pointer to string that selects the locale's
environment
*R C unless the parameters are invalid.
*D %bsetlocale()%b sets or interrogates part of the program's
locale according to the values of %scategory%s (the part to be set) and
%slocale%s (a pointer to the environment it is to be set to).
*p The possible values of category are as follows:
*l 1. LC-ALL
*t All categories
*l 2. LC_COLLATE
*t Affects %bstrcoll()%b and %bstrxfrm()%b
*l 3. LC_CTYPE
*t Affects character handling
*l 4. LC_NUMERIC
*t Affects the format of the decimal point ('.', ',', etc)
*l 5. LC_TIME
*t Affects the %bstrftime()%b function
*p If %slocale%s is a null string, %bsetlocale()%b returns the current
locale for the given category. Currently the only acceptable locale is
"C". %bsetlocale()%b therefore has no real effect.
*q setlocale
*q Set part of the program's locale - see setlocale
*q Interrogate part of the program's locale - see setlocale
*q Program's locale, interrogate part of - see setlocale
*q Program's locale, set part of - see setlocale
#
*n SetOutputSpeed\System library
*P Changes the current output speed associated with a device
*I <attrib.h>
*F void SetOutputSpeed( Attributes *attr, WORD speed);
*A attr - Pointer to an Attributes structure
*A speed - The new output speed
*D This function changes the current output speed in a set of
Attributes obtained by a call to %bGetAttributes()%b. Note that the change
has no effect on the behaviour of the device until a call to
%bSetAttributes()%b has been made.
*x GetAttributes
*x SetAttributes
*x AddAttribute
*x RemoveAttribute
*x IsAnAttribute
*x GetInputSpeed
*x GetOutputSpeed
*x SetInputSpeed
*q Changing baud rate
*q Baud rate
*q Device attribute handling
#
*n setpgid\Posix library function
*P Sets a process group
*I <unistd.h>
*F int setpgid(pid_t pid, pid_t pgid);
*A pid - id of process to be set
*A pgid - process group to be set
*D This function sets the process group id of process %spid%s
to %spgid%s. If %spid%s is zero the current process is used; if %spgid%s
is zero the process group of the current process is used. The process
group is only used to determine to which children of a task certain
signals will be propagated. The values of %spid%s and %spgid%s are local
to a task and have no meaning outside it. This routine may only be called
by a parent on itself or on one of its children (using a %spid%s returned
by %bvfork()%b), or between %bvfork()%b and %bexec()%b by a child.
*q setpgid
*x getpgrp
*x vfork
*x exec
#
*n SetPriority\System library
*P Sets the logical priority level of the process
*I <process.h>
*F void SetPriority(word logpri);
*A logpri - logical priority level
*D This function sets a process priority in a portable
fashion. It maps the logical priority requested onto the true physical
priorities available for a given implementation of Helios.
*p The following standard logical levels are defined in %s<process.h>%s:
*l HighestPri
*t -32768
*l DevicePri
*t -24576
*l HighServerPri
*t -16384
*l ServerPri
*t -8192
*l StandardPri
*t 0
*l BackgroundPri
*t 8192
*l LowBackgroundPri
*t 16384
*l IdlePri
*t 32768
*p On an 8-physical-process-level implementation of Helios, each of these
logical levels translate to a physical priority level (with the exception
of HighestPri and DevicePri, which share the same priority level, level
1).
*p On a 4-physical-level system, these translate as follows:
*l Level 1
*t ServerPri and higher
*l Level 2
*t StandardPri and BackgroundPri
*l Level 3
*t LowBackgroundPri and IdlePri
*p On standard transputer-based systems (T4XX or T8XX), all logical
priorities will result in a physical priority of 1. This is because the
transputer hardware only supports a simple 2-level priority scheme.
Physical priority 0 is reserved for kernel processes.
*p On C40 based systems, 8 physical levels of priority are allowed
as the scheduler has been written in software.  Physical priority
0 is also reserved for kernel processes, although this may be obtained
through the %bSystem()%b (C40 specific) call.
*p HighestPri is always guaranteed to set the highest user priority
possible and IdlePri is always guaranteed to set the lowest possible
process level.
*p If %bSetPriority()%b is not used by a program, then its priority will
default to StandardPri. The Processor Manager, Loader and all IOCs are run
at HighServerPri. Other servers, such as the file system, will be run at
ServerPri.
*p To ensure that a server handles requests at a given priority, you must
set the priority before you call the server library function
%bDispatch()%b. All requests will then be processed at this priority.
*p You should be aware that %bGetPriority()%b may return a
different priority to the one you set with %bSetPriority()%b; this is
because of the conversion to a physical priority level and back.
*p Physical priority level zero is a special priority level that is normally
only available to kernel processes. Processes at this level are never
timesliced and always run until they block or are completed.
*q SetPriority
*q GetPriority
*q Portability
*x GetPriority
#
*n setsid\Posix library function
*P Sets process group id
*I <unistd.h>
*F int setsid(void);
*A
*D This function sets the process group of the current process
equal to its process id.
*q setsid
*x getpgrp
*x setpgid
#
*n SetSignalPort\System library
*P Sets a port for signal messages
*I <syslib.h>
*F Port SetSignalPort(Port port);
*A port - port to set
*R original port
*D This function informs the Tasks IO Controller of the port
to which signal messages will be sent. Each time a signal is generated for
the Task, a message containing the identity of the signal will be sent to
this port. The Posix library establishes a process to wait permanently for
messages on a port which it installs by this mechanism. Applications code
should not normally need use this function.
*q SetSignalPort
*x signal\000564
#
*n setsockopt\Posix library function
*P Sets socket options
*I <sys/socket.h>;<sys/types.h>
*F int setsockopt(int fd, int level, int optname, char *optval, int *optlen);
*A fd - File descriptor
*A level - Level number
*A optname - Name of option flag
*A optval - Pointer to option value
*A optlen - Pointer to option size
*D This function is basically identical to the BSD Unix
version of %bsendsockopt%b; it manipulates options associated with a
socket.
*p Here are the level numbers %bsetsockopt()%b can apply to a socket, the
system and an ioctl:
*f SOL_SOCKET\0xffff\options for socket level
*f SOL_SYSTEM\0xfff0\options for system level
*f SOL_IOCTL\0xfff1\options for ioctl level
*x getsockopt
*q setsockopt
*q BSD compatibility, Berkeley
#
*n setuid\Posix library function
*P Sets the user id
*I <unistd.h>
*F int setuid( uid_t uid );
*A uid - user id to set
*D Helios does not implement the Unix user and group id
mechanism since it is inappropriate in a distributed system. However to
ease compatibilty the Posix library stores a user id and a group id which
may be manipulated using the appropriate routines. It is important to
note, however, that the values stored have no effect at all on the
behaviour of a user's program.
*p For a more details see "Compatibility" in the "Helios Operating System"
manual.
*x getuid
*x geteuid
*x setgid
*x getgid
*x getegid
#
*n setvbuf\C library function
*P Defines the way that a file stream is buffered
*I <stdio.h>
*F int setvbuf(FILE *stream, char *buf, int mode, size_t size);
*A stream - A pointer to a file stream.
*A buf - A pointer to a file buffer.
*A mode - The way the file stream is to be buffered.
*A size - The size of the file buffer.
*R %bsetvbuf()%b returns zero if successful, and non-zero if the
operation fails.
*E If %smode%s or %ssize%s is invalid, or %sstream%s cannot be
buffered, %bsetvbuf()%b returns 1.
*D %bsetvbuf()%b may be called after the file associated with
%sstream%s has been opened, but before it has been read from or written
to. %bsetvbuf()%b causes %sstream%s to be buffered in the format specified
by %smode%s. Valid formats are:
*l 1. _IOFBF
*t Fully buffered I/O
*l 2. _IOLBF
*t Line buffered output
*l 3. _IONBF
*t Unbuffered I/O
*p The buffer used is of %ssize%s bytes. If %sbuf%s is not a null pointer,
it is used as the buffer, otherwise an internal array is used as the
buffer.
*x setbuf
*q setvbuf
*q Define file stream buffering - see setvbuf
*q File stream buffering - see setvbuf
#
*n shell\Helios command
*P Invokes the Helios shell
*F shell [<options>] [<args>]
*D This command invokes another copy of the shell interpreter.
Note that this is also done by the %bwsh%b command which also starts up
another window for the new shell. The %bshell%b command starts up a new
shell and prohibits access to the original shell until the new one is
terminated.
*p When a new shell is started it looks for a file called %scshrc%s or
%s.cshrc%s in the user's home directory. This file usually contains a set
of commands to set up suitable defaults to each user's taste. The shell
started by Helios, known as the login shell, will always execute any
commands held in %sloginrc%s, %s.loginrc%s, %slogin%s or %s.login%s before
looking for %scshrc%s.
*p Any arguments passed to the shell are made available in the shell
variable argv. These can be inspected by shell commands.
*p A full description of the shell, including all the available options,
can be found in the document %sHelios%s %sShell%s, which is part of the
%sHelios%s %sOperating%s %sSystem%s manual.
*x wsh
*x source
*x loginrc
*x cshrc
*q Login shell
*q Shell startup files
*q Creating a new shell
*q Starting a new shell
*q Shell, start
#
*n Shell scripts\General interest
*P File containing shell commands or programs to be executed in a
given order
*D A %sshell script%s is a file, usually written by the user,
containing a number of commands or programs to be carried out in a given
order (%scommand%s %sflow%s). A shell script can be executed with the
%bsource%b command (see %bsource%b) or directly by typing their name to
the command line.
*x source
#
*n shift\Helios command
*P Manipulates shell variables
*F shift [<variable>]
*D The shell command %bshift%b, when qualified with
%svariable%s, shifts all the members of that variable's value list one
position to the left, discarding the first one. %bshift%b without
%svariable%s acts on %sargv%s, shifting that one position to the left and
discarding argv[1].
*p The action of %bshift%b follows that described in the words of the song:
`There were ten in a bed and the little one said: "roll over!", and so
they all rolled over and one fell out. There were nine in a bed and the
little one said...'; the first one (for example, argv[1]) `falls out' and
the others all `roll over' one position left; for example:
*c=%set bed=(ten nine eight seven six five four three two one)
*c=%shift bed
*c=%echo $bed
*c=nine eight seven six five four three two one
*p It is an error if you try to use %bshift%b when %svariable%s or %sargv%s
are not set, or contain no words.
*q Shell commands
*q shift
*q Variable manipulation
#
*n shutdown\Posix library function
*P Shuts down all or part of a connection on the given socket
*I <sys/socket.h>;<sys/types.h>
*F int shutdown(int fd, int how);
*A fd - File descriptor
*A how - Level of shutdown
*R 0 if call succeeded; -1 if fails.
*E
*l [EBADF]
*t Not a valid descriptor
*l [ENOTSOCK]
*t Descriptor represents a file, not a socket
*l [ENOTCONN]
*t Socket not connected
*D This function is basically identical to the BSD Unix
version of %bshutdown%b; it shuts down all or part of a connection on the
given socket. %show%s indicates the level of shutdown (0 = no further
receives; 1 = no further sends; 2 = no further receives or sends).
*q shutdown
*q BSD compatibility, Berkeley
#
*n sigaction\Posix library function
*P Examines and changes signal action
*I <signal.h>
*F int sigaction (int sig, struct sigaction *act, struct sigaction *oact)
*A sig - Signal to set new action
*A act - Pointer to structure specifying action to be taken
*A oact - Pointer to structure specifying previous action taken
*R Zero on the successful completion of the function; -1 on the
failure of the function. In the event of failure, errno is set to indicate
the error.
*E
*l [EINVAL]
*t Value of %ssig%s is not a valid signal number.
*D %bsigaction()%b enables the calling task to examine and/or
specify the action to be taken on receipt of a specified signal. The
required signal is specified with the argument %ssig%s. Acceptable values
for this argument are defined in <signal.h>.
*p The structure %ssigaction%s is defined in the header file <signal.h>.
*f %bType%b\%bName%b\%bDescription%b
*f \\
*f %svoid(*)()%s\%ssa_handler%s\SIG_DFL, SIG_IGN, or pointer to a
function
*f %ssigset_t%s\%ssa_mask%s\Set of signals to be blocked during
execution of signal-catching function
*f int\sa_flags\Special flags to be used when delivering signal
*p If %sact%s is not NULL, it points to a structure specifying the action
to be taken when delivering the specified signal. If the argument %soact%s
is not NULL, the action previously associated with the signal is stored in
the location pointed to by the argument %soact%s. If %sact%s is NULL,
signal handing remains unchanged. The call can therefore be used to find
out what actions are currently set for handling a given signal.
*p The %ssa_flags%s field can be used to alter the delivery of the
specified signal. If %ssig%s is SIGCLD, the flag bit S_CLDSTOP, defined in
the header <signal.h>, can be set in %ssa_flags%s. SA_CLDSTOP causes the
generation of SIGCLD when the children of the task stop.
*p When a signal is caught by a signal-catching function installed by the
%bsigaction()%b function, a new signal mask is calculated and installed
for the duration of the signal-catching function. This mask is formed by
taking the union of the current signal mask and the set associated with
the action for the signal being delivered, and then including the signal
being delivered. If and when the user's signal handler returns normally,
the original signal mask is restored.
*p Once an action is installed for a specific signal, it remains installed
until another action is explicitly requested, or until one of the
%bexec()%b family of functions is called.
*p The set of signals specified by the %ssa_mask%s field pointed to by the
argument %sact%s is not allowed to block those signals that cannot be
ignored, as defined in <signal.h>.
*p If %bsigaction()%b fails, no new signal handler is installed.
*x kill\000344
*x sigprocmask
*x signal\000564
*q exec
*q Examine signal action
*q Change signal action
*q Signal action, examine and change - see sigaction
#
*n sigaddset\Posix library function
*P Adds a given signal set
*I <signal.h>
*F int sigaddset (sigset_t *set, int sig)
*A set - Pointer to signal set
*A sig - Signal number of signal to be added
*R Zero on the successful completion of the function; -1 on the
failure of the function. In the event of a failure, errno is set to
indicate the error.
*E
*l [EINVAL]
*t Value of %ssig%s is not a valid signal number.
*D %bsigaddset()%b adds the signal specified by the value of
%ssig%s from the signal set pointed to by %sset%s.
*x sigdelset
*q Add signal set
*q Manipulating signal sets
*q Signal set, add - see sigaddset
*q Signal sets, manipulate
#
*n sigblock\Posix library function
*P Blocks signals specified by the mask
*I <signal.h>
*F int sigblock( int mask );
*A mask - mask of signal(s) to be blocked
*R Previous set of masked signals
*D This function adds the signals indicated by the %smask%s
argument to the set of signals that are currently blocked from delivery.
Signal represented by integer %si%s is blocked if the %si%sth bit of the
signal mask is a 1.
*p The signals that cannot be blocked by this means are SIGKILL, SIGSTOP,
and SIGCONT.
*p This function has been provided here for compatibility with BSD.
*q sigblock
*q Blocking signals from delivery
*q Signals, blocking
*q Berkeley Software Distribution - see BSD
*q BSD compatibility
*x kill\000344
#
*n sigdelset\Posix library function
*P Deletes a given signal set from a signal set
*I <signal.h>
*F int sigdelset (sigset_t *set, int sig);
*A set - Pointer to signal set
*A sig - Signal number of signal to be deleted
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to give the error.
*E
*l [EINVAL]
*t Value of %ssig%s is not a valid signal number.
*D %bsigdelset()%b deletes the signal specified by the value
of %ssig%s from the signal set pointed to by %sset%s.
*x sigaddset
*x sigemptyset
*q Delete signal set
*q Manipulating signal sets
*q Signal set, delete - see sigdelset
*q Signal sets, manipulate
#
*n sigemptyset\Posix library function
*P Initializes a given signal set
*I <signal.h>
*F int sigemptyset (sigset_t *set);
*A set - Pointer to signal set
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to show the error.
*D %bsigemptyset()%b initialises the signal set pointed to by
%sset%s, excluding all the signals defined here. Applications should call
%bsigemptyset()%b at least once for each object of type %ssigset_t%s
before use of that object.
*x sigfillset
*q Initialize signal set
*q Manipulating signal sets
*q sigemptyset
*q siginitset
*q Signal set, initialize - see sigemptyset
*q Signal sets, manipulate
#
*n sigfillset\Posix library function
*P Initializes a given signal set
*I <signal.h>
*F int sigfillset (sigset_t *set)
*A set - Pointer to signal set
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to show the error.
*D %bsigfillset()%b initialises the signal set pointed to by
%sset%s, including all the signals.
*x sigemptyset
*x sigaddset
*x sigdelset
*q Initializes signal set
*q Manipulating signal sets
*q Signal set, initialize - see sigfillset
*q Signal sets, manipulate
#
*n siginitset\Posix library function
*P Previous name given to sigemptyset
*I <signal.h>
*F int siginitset (sigset_t *set);
*A set - Pointer to signal set
*D See %bsigemptyset()%b.
*x sigemptyset
*x sigfillset
*x sigaddset
*x sigdelset
*q siginitset
#
*n sigismember\Posix library function
*P Tests to see if the specified signal is a member of the
specified set
*I <signal.h>
*F int sigismember (sigset_t *set, int sig);
*A set - Pointer to signal set
*A sig - Signal number of signal to be added
*R A value of 1 on the successful completion of the function,
where the specified signal is a member of the set; a value of 0 on the
failure of the function. On failure, it sets errno to show the error.
*E
*l [EINVAL]
*t Value of %ssig%s is not a valid signal number.
*D %bsigismember()%b tests to see if the signal specified by
the value of %ssig%s is a member of the signal set pointed to by %sset%s.
*x sigdelset
*x sigaddset
*x sigfillset
*x sigemptyset
*q Test signal
*q Manipulating signal sets
*q Signal, test - see sigismember
*q Signal sets, manipulate
#
*n Signal\System library
*P Performs the semaphore signal operation on the semaphore
*I <sem.h>
*F void Signal ( Semaphore *semaphore );
*A semaphore - Pointer to Semaphore structure
*R Nothing
*D This function increments the semaphore's count by one and
restarts the first waiting process, if any.
*x Wait
*x InitSemaphore
*q Semaphore structure
*q Perform semaphore signal operation on semaphore
*q Semaphore signal operation - perform on semaphore
#
*n signal\C library function
*P Defines the way that errors and exceptions are handled.
*I <signal.h>
*F void (*signal(int sig, void (*func)(int)))(int);
*A sig - A signal number (a predefined value, describing an
error/exception type).
*A (*func)(int) - A function returning a pointer that is invoked
on the reception of the predefined value.
*R a pointer to the function used as a parameter to the previous
call of %bsignal()%b with the same signal number parameter.
*E If the predefined error/exception value is not recognised by
%bsignal()%b, %bsignal()%b returns SIG_ERR.
*D %bsignal()%b is used to assign functions to be called on
reception of particular, predetermined signal values.
*p There are two predefined functions implemented as macros in the header
file %s<signal.h>%s:
*l 1. SIG_DFL
*t Uses the default system error/exception handling for the pre-defined
value.
*l 2. SIG_IGN
*t Ignores the error/exception.
*p The functions will then be called in response to a "%braise()%b" or
other invocation of the signal handler, using a signal number as a
parameter.
*q signal If the second parameter is a function other than SIG_DFL or
SIG_IGN, SIG_DFL will be called, and then the function.
*p The system is initialised such that all errors or exceptions are handled
by default. The available signal numbers are as follows:
*l 1. SIGABRT
*t abort error
*l 2. SIGFPE
*t arithmetic exception
*l 3. SIGILL
*t illegal instruction
*l 4. SIGINT
*t attention request from user
*l 5. SIGSEGV
*t bad memory access
*l 6. SIGSTERM
*t termination request
*l 7. SIGSTAK
*t stack overflow
*p The user can define signal numbers 8 and 9 for his or her own use.
*q signal
*c= /* To arrange that an interrupt by the user should not go through the
*c=    default exception handling system, call
*c=
*c= signal(SIGILL, SIG_IGN);
*c=
*c= If the signal is then raised in a later part of the program
*c=
*c= raise(SIGILL);
*c=
*c= the signal will be ignored.  */
*c=
*c= /* If the user has chosen to define a signal for his own purposes, */
*c=
*c= extern void _mess_handler(int)
*c=
*c= #define  SIG_MESS      8
*c= #define  MESS_HANDLER  _mess_handler
*c=
*c= int
*c= main(void)
*c= {
*c= void (*ptr)(int);
*c=
*c= ptr = signal(SIG_MESS, MESS_HANDLER);
*c= raise(SIG_MESS);
*c=
*c= }
*c= /* When raise is called, the default error handler is called with
*c=    SIG_MESS as a parameter, and then MESS_HANDLER is called.  */
*x Signal
*x raise\000469
*q signal
*q Error handling - see signal
*q Handling errors - see signal
*q Handling exceptions - see signal
*q Exception handling - see signal
#
*n signal\Posix library function
*P Defines the way errors and exceptions are handled
*I <signal.h>
*F void (*signal(int sig, void (*func)(int)))(int);
*A sig - Signal number (a predefined value, describing an
error/exception type).
*A (*func)(int) - Pointer to a function, which is invoked on the
reception of the predefined value.
*R Returns a pointer to the function used as a parameter to the
previous call of %bsignal()%b with the same signal number parameter.
Otherwise, it returns a value of SIG_ERR and sets errno to indicate the
error.
*E
*l [EINVAL]
*t The value of %ssig%s is not a valid signal number.
*D %bsignal()%b allows the calling task to examine and change
the action to be taken on the reception of particular, predetermined
signal values. %ssig%s specifies the signal value; %sfunc%s specifies the
functions that produce the required action.
*p There are two predefined functions implemented as macros in the header
file %s<signal.h>%s:
*l SIG_DFL
*t Uses the default system error/exception handling for the pre-defined
value
*l SIG_IGN
*t Ignores the error/exception
*p These functions will then be called in response to a %braise()%b or
other invocation of the signal handler, using a signal number as a
parameter. If the second parameter is a function other than SIG_DFL or
SIG_IGN, SIG_DFL will be called, and then the function.
*p The system is initialised such that all errors or exceptions are handled
by default. The available signal numbers are as follows:
*f 1\SIGABRT\Abort error
*f 2\SIGFPE\Arithmetic exception
*f 3\SIGILL\Illegal instruction
*f 4\SIGINT\Attention request from user
*f 5\SIGSEGV\Bad memory access
*f 6\SIGTERM\Termination request
*f 7\SIGSTAK\Stack overflow
*f 8\SIGALRM\Alarm/timeout signal
*f 9\SIGHUP\Hangup
*f 10\SIGPIPE\Pipe signal
*f 11\SIGQUIT\Interactive termination signal
*f 12\SIGTRAP\Trace trap signal (for compatibility only)
*f 13\SIGUSR1\User defined signal
*f 14\SIGUSR2\User defined signal
*p Notice that the user can define signal numbers 13 and 14 for his or her
own use.
*p Notice that %bsignal()%b cancels a pending signal if %sfunc%s is
SIG_IGN. It may cancel any pending signal, except a pending SIGKILL or
SIGSTOP signal.
*q signal
*c=/* To arrange that an interrupt by the user should not
*c=   go through the default exception handling system, call
*c=
*c=signal(SIGILL, SIG_IGN);
*c=
*c=If the signal is then raised in a later part of the
*c=program
*c=
*c=raise(SIGILL);
*c=
*c=the signal will be ignored.  */
*c=
*c=/* If the user has chosen to define a signal for his
*c=   own purposes, */
*c=
*c=extern void *_mess_handler(int)
*c=
*c=#define  SIG_MESS      8
*c=#define  MESS_HANDLER  _mess_handler
*c=
*c=int main(void)
*c={
*c=void (*ptr)(int)
*c=
*c=ptr = signal(SIG_MESS, MESS_HANDLER);
*c=raise(SIG_MESS);
*c=}
*c=
*c=/* When raise is called, the default error handler is
*c=   called with SIG_MESS as a parameter, and then
*c=   MESS_HANDLER is called.  */
*x pause
*x kill\000344
*x _exit
*x raise\000470
*q Error handling - see signal
*q Handling errors - see signal
*q Handling exceptions - see signal
*q Exception handling - see signal
*q signal
#
*n SignalStop\System library
*P Signals a semaphore and halts a process
*I <sem.h>
*F void SignalStop(Semaphore *sem);
*A sem - semaphore to signal
*R Does NOT return
*D This function performs a Signal() operation on the given
semaphore and then suspends its process irrevocably. It is used in the
System library routine FreeStop().
*q SignalStop
*x FreeStop
*x FreeMemStop
*x Signal
#
*n sigpending\Posix library function
*q Examine pending signal - see sigpending
*q Signals, examine pending - see sigpending
*q Pending signals - see sigpending
*q Blocked signals - see sigpending
*P Examines pending signals
*I <signal.h>
*F int sigpending (sigset_t *set)
*A set - Pointer to signal set
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to show the error that
occurred.
*D %bsigpending()%b takes the set of signals that are blocked
from delivery and pending for the calling task and stores them in the
space pointed at by %sset%s.
*x sigprocmask
#
*n sigprocmask\Posix library function
*P Examines and changes signal masks
*I <signal.h>
*F int sigprocmask (int how, sigset_t *set, sigset_t *oset)
*A how - Indicates how the signal set is to be altered
*A set - Pointer to signal set to be used
*A oset - Pointer to the previous mask
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to indicate the error
that occurred.
*E
*l [EINVAL]
*t Value of %show%s is not a valid value (see below).
*D %bsigprocmask()%b examines and/or changes the signal mask
of the calling task. If the value of %sset%s is not NULL, it points to the
set of signals to be used to change the currently blocked set.
*p The value of %show%s indicates how the set of signals is to be changed.
%show%s can have one of the following defined values:
*f SIG_BLOCK\1\Union the current signal set and the set pointed at by
%sset%s to produce the new set.
*f SIG_UNBLOCK\2\Intersect the current signal set and the complement of
the signal set pointed at by %sset%s to produce the new set.
*f SIG_SETMASK\3\Take the signal set pointed at by %sset%s as the new
set.
*p If %soset%s is not NULL, it points to space holding the previous mask.
If the value of %sset%s is NULL, the signal mask remains unchanged. This
means that you can use this call to find out about currently blocked
signals.
*p If there are any pending unblocked signals after a call to
%bsigprocmask()%b, at least one of those signals will be delivered before
%bsigprocmask()%b returns.
*p Signals that cannot be ignored cannot be blocked.
*p If %bsigprocmask()%b fails, the signal mask of the task remains
unchanged.
*x sigaction
*x sigpending
*x sigsuspend
*q Examine signal masks
*q Change signal masks
*q Signal masks, examine and change - see sigprocmask
*q Blocked signals - see sigprocmask
#
*n sigsetjmp\Posix library function
*P Sets up a non-local jump
*I <setjmp.h>
*F int sigsetjmp(sigjmp_buf env, int savemask);
*A env - Environment
*A savemask - Mask
*D %bsigsetjmp()%b complies with the C %bsetjmp()%b function.
If the value of %ssavemask%s is not zero, %bsigsetjmp()%b saves the
current task's current signal mask as part of the calling environment.
*x sigaction
*x sigprocmask
*x sigsuspend
*q Non-local jump - see sigsetjmp
*q Jump, non-local - see sigsetjmp
#
*n sigsuspend\Posix library function
*P Suspends a task until the delivery of a given signal
*I <signal.h>
*F int sigsuspend (sigset_t *set)
*A set - Pointer to signal set
*R Zero on the successful completion of the function; -1 on the
failure of the function. On failure, it sets errno to indicate the error
that occurred.
*E
*l [EINVAL]
*t The calling task has caught a signal; control returns from the
signal-catching function.
*D %bsigsuspend()%b replaces the signal mask of the task with
the set of signals pointed to by %sset%s. It then proceeds to suspend the
task until a signal is delivered that causes the termination of the task
or executes a signal-catching function.
*p If the task is terminated, the %ssigsuspend%s function returns. If the
resulting action is the execution of a signal-catching function,
%ssigsuspend%s only returns after the signal-catching function returns.
The signal mask is then restored to the set that existed before
%ssigsuspend%s was called.
*p Signals that cannot be ignored cannot be blocked.
*x sigaction
*x sigpending
*x sigprocmask
*q Waiting for a signal
*q Replace signal mask
*q Suspend task - see sigsuspend
*q Signal, task - see sigsuspend
#
*n sin\C library function
*P Calculates the sine of the argument.
*I <math.h>
*F double sin(double x);
*A x - A number in radians.
*R the sine of %sx%s.
*D %bsin()%b calculates the sine of %sx%s (given in radians).
*q sin
*q Calculate sine
*q Sine - see sin
*x cos
*x sinh
#
*n sinh\C library function
*P Calculates the hyperbolic sine of the argument.
*I <math.h>
*F double sinh(double x);
*A x - A number.
*R the hyperbolic sine of %sx%s.
*E A range error will occur if %sx%s is so large that %bsinh()%b
would result in an overflow. In this case %bsinh()%b returns the value
HUGE_VAL (with the same sign as the correct value of the function) and
errno is set to ERANGE.
*D %bsinh()%b calculates the hyperbolic sine of %sx%s.
*q sinh
*q Calculate hyperbolic sine
*q Hyperbolic sine - see sinh
*q Sine (hyperbolic) - see sinh
*x sin
#
*n sleep\Helios command
*P Suspends execution until it has waited a given number of
seconds
*F sleep <time>
*D %bsleep%b suspends command execution for %stime%s number of
seconds. It returns a warning if given a negative %stime%s or if %stime%s
is greater than 2100 (35 minutes).
*q sleep
*q Suspending command execution
*q Command execution, suspending
*q Execution, suspending
#
*n sleep\Posix library function
*P Suspends the current task for a specified number of seconds
*F unsigned int sleep (unsigned int seconds)
*A seconds - Number of seconds the task is to be suspended
*R The unslept amount of time (%sseconds%s - time actually slept);
this will usually be zero. It may, however, be non-zero if the task had an
alarm that went off before the time specified by %sseconds%s elapsed, or
if it was awakened by another signal.
*D %bsleep()%b suspends the current task from execution for
the number of seconds specified with the argument %sseconds%s. The actual
time the task is asleep may be less than specified. The reasons for this
are as follows:
*p 1. The timer may be inaccurate; and
*p 2. Any caught signal can terminate this function after execution of the
signal's catching routine.
*p The sleep time may be longer than specified if there is other scheduling
activity in the system.
*p %bsleep()%b acts like a cross between %balarm()%b and %bpause()%b: it
sets a time period in the same way as %balarm()%b and suspends task
execution in much the same way as %bpause()%b. The previous state of an
existing alarm signal is saved and restored. The calling program may have
set an alarm signal before calling %bsleep()%b; if the alarm signal is due
to occur before the sleep time specified by %sseconds%s has elapsed, then
the task will only sleep until such time as the alarm would have occurred,
and the calling program's alarm catch routine will execute before the
%bsleep()%b routine returns, but if the sleep time is less than the time
before the alarm is due to occur, then %bsleep()%b will occur normally and
the alarm will go off at the time it is due.
*p %bNote:%b Only one process of a task may sleep at any one time. Any
attempt to make a second process sleep will result in undefined results.
*x alarm
*x pause
*x signal\000564
*q Suspend task - see sleep
*q Task, suspend - see sleep
*q pause
*q alarm
#
*n socket\Posix library function
*P Creates an endpoint for communication, a socket
*I <sys/socket.h>;<sys/types.h>
*F int socket(int domain, int type, int protocol);
*A domain - An address family, as defined in <sys/socket.h>
*A type - An integer representing a valid type, as defined in
%s<sys/socket.h>%s
*A protocol - The protocol to be used (0 is only one supported)
*R If an error occurred it returns -1; otherwise, returns a
descriptor value for socket
*E
*l [EAFNOSUPPORT]
*t Address family not supported
*l [ESOCKTNOSUPPORT]
*t Socket type not supported
*l [EPROTONOSUPPORT]
*t Protocol not supported
*l [EMFILE]
*t Per-process descriptor table is full
*l [ENOBUFS]
*t No buffer space available for socket to be created
*D This function is basically identical to the BSD Unix
version of %bsocket%b; it creates an endpoint for communication and
returns a valid descriptor for that endpoint.
*x socketpair
*q socket
*q BSD compatibility, Berkeley
#
*n socketpair\Posix library function
*P Creates a pair of connected sockets
*I <sys/socket.h>;<sys/types.h>
*F int socketpair(int domain, int type, int protocol, *sv);
*A domain - An address family, as defined in <sys/socket.h>
*A type - An integer representing a valid type, as defined in
%s<sys/socket.h>%s
*A protocol - The protocol to be used (0 only one supported)
*A sv - A pointer to socket descriptors
*R 0 if succeeds; otherwise, -1.
*E
*l [EMFILE]
*t Too many descriptors are in use
*l [EAFNOSUPPORT]
*t The specified address family is not supported
*l [EPROTONOSUPPORT]
*t The specified protocol is not supported
*l [EOPNOSUPPORT]
*t The specified protocol does not support creation of socket pairs
*l [EFAULT]
*t The address %ssv%s does not specify a valid address space
*D This function is basically identical to the BSD Unix
version of %bsocketpair%b; it creates an unnamed pair of connected sockets
in the specified domain, with the given type and using the given protocol.
*q socketpair
*x socket
*q BSD compatibility, Berkeley
#
*n sopen\Posix library function
*P Maps between Helios and Posix files
*I <syslib.h> ; <posix.h> ; <unistd.h>
*F int sopen(Stream *s);
*A s - Helios stream
*R A file descriptor or -1.
*D This function takes a Helios stream structure and installs
it into a Posix library file descriptor. It returns the file descriptor
allocated, or -1 if there is no more space. %bsopen()%b is one of a set of
Helios extensions that enable Posix objects to be mapped to Helios
objects.
*q Mapping files
*x fdstream
*q Helios posix extensions
#
*n source\Helios command
*P Executes a shell script
*F source [-h] <name>
*D The %bsource%b shell command executes shell scripts (text
files containing a sequence of commands) within the current shell. Shell
scripts are usually executed in a new shell. Commands are read from the
shell script %sname%s, instead of from the standard input, and executed in
the same shell. You may nest %bsource%b commands (that is, you may have a
%bsource%b argument that includes a %bsource%b command whose argument
%sname%s includes a %bsource%b command, and so on). An error in a
%bsource%b at any level terminates all nested %bsource%b commands.
*p The commands in %sname%s will not appear on the history list unless you
specify the option `-h'. If you give this option, the %bsource%b command
simply places the commands on the history list without executing them.
*q Shell commands
*q Shell scripts
*q source
*x Shell
#
*n split\Helios command
*P Splits text files into several smaller chunks
*F split [-n] <infile> [<chunkname>]
*D %bsplit%b splits %sinfile%s up into 1000 line chunks, and
writes these chunks to files named xaa, xab, xac ... xzz. To use stdin as
the input source, use `-' in place of %sinfile%s.
*p The number of lines per chunk can be varied via the -n option; for
example, -100 splits %sinfile%s up into 100-line chunks.
*p You may also change the output filenames via the %schunkname%s
parameter. This name is then used to prefix output filenames instead of
`x'. For example, a %schunkname%s of `mail' will cause the output of files
called `mailaa', `mailab', `mailac' ... `mailzz'.
*q split
*q Splitting files into chunks
#
*n splitname\System library
*P Splits filenames
*I <syslib.h>
*F int splitname (char *prefix, char delimit, char *str);
*A prefix - Pointer to an array of at least NameMax chars
*A delimit - Character used as pathname delimiter
*A str - Character string
*D %bsplitname%b copies characters out of %sstr%s into
%sprefix%s until it either finds a null or it encounters the %sdelimit%s
character. It returns the position in %sstr%s of the character after
%sdelimit%s. This function is usually used for splitting up filenames,
where %sdelimit%s is a forward slash (/). You should make sure that
%sprefix%s points to an array of at least %sNameMax%s characters.
*q splitname
#
*n sprintf\C library function
*P Writes a formatted string to a string.
*I <stdio.h>
*F int sprintf(char *s, const char *format, ...);
*A s - A string that the output is written to.
*A format - A format string.
*A ... - Subsequent arguments to the format string.
*R The number of characters written, excluding the string
terminating character.
*D %bsprintf()%b writes the string pointed to by %sformat%s to
%ss%s. When %bsprintf()%b encounters a percent sign (%%) in the format
string, it expands the equivalent argument into the format defined by the
tokens after the %%. The format tokens are those described in
%bfprintf()%b (see %bfprintf()%b).
*p Each token acts on the equivalent argument, that is, the third token
relates to the third argument after the format string. There must be a
single argument for each token. If the token or its equivalent argument is
invalid, the behaviour is undefined.
*c= int main(void)
*c= {
*c=     char string[100];
*c=     int i = 99;
*c=     double fp = 1.5e5;
*c=     char *s = "a sequence of characters";
*c=     char c = 'A';
*c=
*c=     sprintf(string, "This is %s %c %d, %f", s, c, i, fp);
*c=}
*c=
*c=/* Write the following output to the string:
*c=   This is a sequence of characters A 99 150000.000000    */
*q fprintf
*q sprintf
*q Write formatted string to string - see sprintf
*q Formatted string - see sprintf
*q String, formatted - see sprintf
*x printf
*x vprintf
*x vsprintf
*x fprintf
*x scanf
#
*n sqrt\C library function
*P Calculates the square root of the argument.
*I <math.h>
*F double sqrt(double x);
*A x - A number.
*R the non-negative square root of %sx%s.
*E A domain error will occur if %sx%s is negative. In this case
errno is set to EDOM.
*D %bsqrt()%b calculates the square root of %sx%s.
*q sqrt
*q Calculate square root
*q Square root - see sqrt
#
*n srand\C library function
*P Sets the seed for pseudo-random numbers generated by
%brand()%b.
*I <stdlib.h>
*F void srand(unsigned int seed);
*A seed - The new seed to be used by %brand()%b.
*D %bsrand()%b causes %brand()%b to be seeded with the value
seed. Subsequent calls to %brand()%b will start a new sequence of
pseudo-random numbers. If %bsrand()%b is called again with the same value
of %sseed%s the random number sequence will be repeated.
*p If %brand()%b is called before any calls to %bsrand()%b have been made
the effect will be the same as if %bsrand()%b had been called with a
%sseed%s value of 1.
*x rand
*q srand
*q Pseudo-random numbers - see rand, srand
*q Seeding pseudo-random numbers - see rand, srand
#
*n sscanf\C library function
*P Reads formatted data from a string.
*I <stdio.h>
*F int sscanf(const char *s, const char *format, ...);
*A s - The string the data is read from.
*A format - A format string.
*A ... - Subsequent arguments to the format string.
*R the number of inputs which have been successfully converted. If
a string terminating character occurred before any conversions took place,
%bsscanf()%b returns EOF.
*E If a string terminating character occurred before any conversions
took place, %bsscanf()%b returns EOF. Other failures cause termination of
the procedure.
*D %bsscanf()%b matches the data read from the string %ss%s to
the specifications set out by the format string. The format string can
include white space, ordinary characters, or conversion tokens.
*l %bWhite space%b
*q White space in format strings
*q Format strings
*q Blank space in format strings
*q Spaces in format strings
*t White space causes the next series of white space characters read to be
ignored.
*l %bOrdinary characters%b
*q Ordinary characters in format strings
*q Characters in format strings
*t Ordinary characters in the format string cause the characters read to be
compared to the corresponding character in the format string. If the
characters do not match, conversion is terminated.
*l %bConversion tokens%b
*q Conversion tokens in format strings
*q Tokens, conversion in format strings
*t A conversion token in the format string causes the data sequence read in
to be checked to see if it is in the specified format. If it is, it is
converted and placed in the appropriate argument following the format
string. If the data is not in the correct format, conversion is
terminated.
*p Conversion tokens are described in %bfscanf()%b.
*q Conversion tokens
*q Tokens, conversion
*p Each token acts on the equivalent argument. In other words, the third
token relates to the third argument after the format string. There must be
a single conversion sequence received for each token. If the token is
invalid, the behaviour is undefined.
*p Any mismatch between the token format and the data received causes an
early termination of %bsscanf()%b.
*c= int main(void)
*c= {
*c=    char *string = "String 9876 text";
*c=    char s[100];
*c=    int i;
*c=
*c=    sscanf(string,"%s %d text", s, &i);
*c=    printf("%s, %d", s, i);
*c= }
*x fscanf
*q sscanf
*q Read formatted data from string - see sscanf
*q Formatted data, read - see sscanf
*q String, read formatted data from - see sscanf
#
*n startns\Helios command
*q startns, nework command
*P Starts or restarts networking software
*F startns [-r] [-nons] [-nosm] [nsrc=<file>] [-d | -dabeilmpr]
[<map>]
*D The startns command is used to start the networking
software. In particular, it starts the Network Server, which is
responsible for administering the network, and the Session Manager, which
is responsible for administering multiple users. These two programs are
never started up directly. The %bstartns%b command is usually executed
from the %sinitrc%s file, so that the whole network is booted up as part
of the Helios bootstrap mechanism.
*q initrc
*p The %s-r%s option to startns is used to specify a full reset. This
option should be used in the %sinitrc%s file, to ensure that the whole
network is booted or rebooted and hence in a consistent state. When
executing %bstartns%b from the %slogout%s file the %s-r%s option should
not be used: the intention here is to keep the network running rather than
reboot it. The %s-nons%s and %s-nosm%s options are used to suppress
starting up the Network Server and Session Manager respectively. By
default, %bstartns%b will start up both programs.
*p The %snsrc=<file>%s argument can be used to specify the name of an
alternative network option file, the default being %s/helios/etc/nsrc%s.
This file contains additional options for the Network Server and Session
Manager, such as whether or not the network is a single user or multi-user
system.
*p The %bstartns%b program can be given an an argument which makes it start
up the Network Server with some or all of the debugging options already
enabled. If you specify %s-d%s by itself then all the debugging options
are enabled; otherwise, the letters following -d are the initial letters
of the debugging options you wish to be enabled: %ballocate%b, %bboot%b,
%bexecute%b, %binitialise%b, %blinks%b, %bmonitor%b, %bproblems%b, and
%brelease%b.
*q Debugging options
*q allocate
*q boot
*q execute
*q initialise
*q links
*q monitor
*q problems
*q release
*p The final argument indicates the resource map which defines the network.
This file describes the processors available, the interconnections (real
or desired), the hardware facilities available to perform processors
resets and network configuration, and several other options. The default
resource map is %s/helios/etc/default.map%s but an alternative can be
specified.
*q Resource map
*q Network configuration
#
*n stat\Posix library function
*P Reads and returns a file's status
*I <sys/stat.h>
*F int stat(char *path, struct stat *buf);
*A path - Pointer to file pathname
*A buf - Pointer to %sstat%s structure
*R 0 if successful; otherwise, returns -1 and sets errno.
*E
*l [EACCES]
*t Search permission is denied for a component of the pathname prefix.
*l [ENOENT]
*t The file specified by %spath%s does not exist or %spath%s points at an
empty string.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [EFAULT]
*t %sbuf%s or %spath%s points outside the allocated address space of the
task.
*l [ENAMETOOLONG]
*t The %spath%s argument is longer than PATH_MAX.
*D This function finds and returns information about the
status of %spath%s. Read, write, or execute permission to %spath%s is
unnecessary, but it must be reachable by the given path. %sstat%s obtains
the information about the file indicated by %spath%s and writes it to the
position specified by %sbuf%s.
*x creat
*x dup
*x fcntl
*x open
*x fstat
*x pipe
*q Read and return file status
*q File status - read and return
#
*n stevie\Helios command
*P Text editor
*F stevie [[-t <tag>] | +[[<n>]|[/<pat>]]] [<file>...]
*D %bstevie%b is a public domain text editor designed to mimic
the interface of the Unix text editor %bvi%b.
*p Full documentation for this command can be found on the Unsupported
Software disc that accompanies this release.
*x ctags
#
*n stopio\Helios command
*P Terminates an I/O Server
*F stopio [I/O Server]
*D The %bstopio%b command sends a special message to an I/O
Server which causes it to exit and return control to the host operating
system. This can be used when shutting down a network, typically by
incorporating it into the %s.login%s file for user shutdown.
*p The command takes a single optional argument, the name of the I/O Server
to terminate. If no argument is specified then the command will look for
an I/O Server /IO. Otherwise it will look for the specified I/O Server.
*c= stopio
*c= stopio /Net/BillPC
*q stopio
#
*n strcat\C library function
*P Appends one string onto another.
*I <string.h>
*F char *strcat(char *s1, const char *s2);
*A s1 - A pointer to the string to be extended.
*A s2 - A pointer to the string to be appended.
*R the unchanged value of %ss1%s.
*D %bstrcat()%b appends the string pointed to by %ss2%s
(including the null terminating character) onto the end of the string
pointed to by %ss1%s. The first character of %ss2%s overwrites the null
terminating character of %ss1%s.
*c=#include <string.h>
*c=
*c=int main (void)
*c={
*c=   char string[50];
*c=   strcpy(string, "First part ")
*c=   strcat(string, "extension to append");
*c=   Puts(string);
*c=}
*c= /* Outputs the string:
*c=    "First part extension to append" */
*x strncat
*q strcat
*q Append string - see strcat or strncat
*q String, append - see strcat or strncat
#
*n strchr\C library function
*P Finds the first occurrence of a character in a string.
*I <string.h> ; <stdio.h>
*F char *strchr(const char *s, int c);
*A s - A pointer to the string to be searched.
*A c - The character to be searched for.
*R if the character is found, %bstrchr()%b returns a pointer to
the matched character. It returns a null pointer if the character %sc%s is
not in the string.
*D %bstrchr()%b finds the first occurrence of %sc%s in the
string pointed to by %ss%s. The search includes the null terminating
character. %sc%s is converted to a char before the search begins.
*x memchr
*x strpbrk
*x strrchr
*q strchr
*q Find first occurrence of character in string - see strchr
*q Character - find first occurrence of in string
*q String, find first occurrence of character in - see strchr
#
*n strcmp\C library function
*P Compares two strings
*I <string.h>
*F int strcmp(const char *s1, const char *s2);
*A s1 - A pointer to one of the strings to be compared.
*A s2 - A pointer to the other string to be compared.
*R A negative integer if the %ss1%s string is numerically less
than the %ss2%s string, a zero value if the two strings are numerically
the same, or a positive integer if the %ss1%s string is numerically
greater than the %s2%s string.
*D %bstrcmp()%b compares the two strings pointed to by %ss1%s
and %ss2%s.
*p The comparison is of the numerical values of the ASCII characters.
*c= #include <string.h>
*c= int main (void)
*c={
*c=char string1[50], string2[50];     /* Compares two strings */
*c=int result;
*c=
*c=strcpy(string1, "Text");
*c=strcpy(string2, "Text");
*c=result = strcmp(string1, string2); /* strcmp returns 0 */
*c=}
*x memcmp
*x strcoll
*x strncmp
*q strcmp
*q Compare two strings - see strcmp
*q Strings, compare - see strcmp
#
*n strcoll\C library function
*P Compares two strings (transformed according to the program's
locale).
*I <string.h>
*F int strcoll(const char *s1, const char *s2);
*A s1 - A pointer to one of the strings to be compared.
*A s2 - A pointer to the other string to be compared.
*R a negative integer if the %ss1%s string is numerically less
than the %ss2%s string, a zero value if the two strings are numerically
the same, or a positive integer if the %ss1%s string is numerically
greater than the %ss2%s string.
*D %bstrcoll()%b compares the two strings pointed to by %ss1%s
and %ss2%s. Before comparison takes place the two strings are transformed
according to the program's locale. Since the only permissible locale is
"C", %bstrcoll()%b is equivalent to %bstrcmp()%b.
*p The comparison is of the numerical values of the ASCII characters.
*x ASCII
*x memcmp
*x strcmp
*x strncmp
*q strcoll
*q Compare strings - see strcoll
*q Strings, compare - see strcoll
#
*n strcpy\C library function
*P Copies a string into an array.
*I <string.h>
*F char *strcpy(char *s1, const char *s2);
*A s1 - A pointer to the array used as the copy destination.
*A s2 - A pointer to the string used as the copy source.
*R the unchanged value of %ss1%s.
*E The behaviour of %bstrcpy()%b is undefined if the source and
destination overlap.
*D %bstrcpy()%b copies the source string (pointed to by
%ss2%s) into the destination array (pointed to by %ss1%s). The copy
includes the null terminating character. The behaviour of %bstrcpy()%b is
undefined if the source and destination overlap.
*c= int main (void)
*c={
*c= /*
*c=   Copies a string into an array
*c= */
*c=
*c=    char copy[50];
*c=
*c=    strcpy(copy, "String to be copied");
*c=}
*x strncpy
*q strcpy
*q Copy string into array - see strcpy
*q String - copy into array
*q Array, copy string into - see strcpy
#
*n strcspn\C library function
*P Counts the number of characters at the start of a string which
do not match any of the characters in another string.
*I <string.h>
*F size_t strcspn(const char *s1, const char *s2);
*A s1 - A pointer to the string to be measured.
*A s2 - A pointer to the string containing the characters to be
checked.
*R the length of the unmatched segment.
*D %bstrcspn()%b counts the characters in the string pointed
to by %ss1%s which are not in the string pointed to by %ss2%s. As soon as
%bstrcspn()%b finds a character present in both strings it stops and
returns the number of characters counted.
*p The null terminating character is not considered to be part of the
%ss2%s string.
*c=int main (void)
*c= { /* Print string up to any numeric characters.  */
*c=
*c=    char *dec_string = "1234567890";
*c=    char *given_string = "Hello there 123hello";
*c=    size_t no_chars;
*c=
*c=    no_chars = strcspn(given_string, dec_string);
*c=    given_string[no_chars] = "\0";
*c=    puts(given_string);
*c=
*c=    /* Outputs the string "Hello there" */
*c=}
*x strspn
*x strtok
*q strcspn
*q Count chars at start of string1 not matching chars in string2
*q Number of chars at start of string1 not matching chars in string2
*q Characters at start of string1 not matching characters in string2
*q String comparison - see strcspn
*q Compare strings - see strcspn
#
*n Stream\General interest
*P Performs I/O (input / output) on files and devices
*D Helios provides a number of different types of input/output
mechanisms. At the highest level are the languages I/O calls such as the C
call %bfread%b. These calls are buffered, and the size and type of such
buffering can be altered using the call %bsetvbuf%b. The I/O is identified
by a C file handle normally obtained by a call to %bfopen%b or similar.
*p Language I/O calls are mapped onto the Posix I/O standard mechanism
using calls such as %bread%b. These calls are not buffered, and in
particular if a block of data is sent down a pipe from one process to
another then the entire block may be sent by one call to %bwrite%b and it
may be received by one or more calls to %bread%b. Posix calls use Posix
file descriptors which are normally obtained by a call to %bopen%b.
*p Posix calls map onto the lowest level of I/O called a stream. These
calls are also unbuffered, and normally require a timeout to be specified.
The calls are of the form %bRead%b or %bWrite%b and they operate on Helios
stream identifiers. The identifiers may be obtained by calls such as
%bOpen%b, or the routine %bfdstream%b, which returns a stream identifier
from a Posix descriptor.
#
*n strerror\C library function
*P Converts an error number into an error message string.
*I <string.h>
*F char *strerror(int errnum);
*A errnum - The error number to be converted.
*R a pointer to the error message string.
*D %bstrerror()%b a pointer to generates one of the following
error messages according to the value of %serrnum%s:
*l %bValue%b
*t %bMessage%b
*l 0
*t "No error (errno = 0)"
*l EDOM
*t "EDOM - function argument out of range"
*q EDOM
*q Function argument out of range
*q Argument out of range
*l ERANGE
*t "ERANGE - function result not representable"
*q ERANGE
*q Function result not representable
*q Result not representable
*l ESIGNUM
*t "ESIGNUM - illegal signal number to signal() or raise()"
*q signal
*q ESIGNUM
*q Illegal signal number
*q Signal number, illegal
*p If %serrnum%s is not one of the values above (that is, 0, EDOM, and so
on), the following error message is generated:
*p "Error code (errno) errnum has no associated message"
*x perror
*q strerror
*q Convert error number into error message string - see strerror
*q Error number - convert into error message string
*q Error message string, convert into error number into - see strerror
#
*n strftime\C library function
*P Does a formatted conversion of a tm structure to a string.
*I <time.h>
*F size_t strftime(char *s, size_t maxsize, const char *format,
const struct tm *timeptr);
*A s - A pointer to the string where the string is written.
*A maxsize - The maximum number of characters to be written into
the string.
*A format - A pointer to the format string.
*A timeptr - A pointer to a calendar time structure.
*R if the number of characters written is less than %smaxsize%s,
%bstrftime()%b returns the number of characters written. If the number of
characters to be written exceeds %smaxsize%s, %bstrftime()%b returns zero.
*E If the number of characters to be written exceeds %smaxsize%s,
%bstrftime()%b returns zero, and the contents of the string pointed to by
%ss%s are undefined.
*D %bstrftime()%b is used to convert the values in a time
structure according to the demands of a format string, and to write the
resulting string to a string. The format string consists of ordinary
characters and tokens. Normal characters are written directly to %ss%s,
and tokens are expanded. Tokens are single characters, preceded by a %%.
*l %bToken%b
*t %bDescription and Range%b
*l %%a
*t gives abbreviated day (for example, Sun).
*l %%A
*t gives full day (e.g., Sunday).
*l %%b
*t gives abbreviated month (for example, Apr).
*l %%B
*t gives full month (e.g., April).
*l %%c
*t gives date and time in form of a string of decimals. For example, 7.4.88
12:15
*l %%d
*t gives day of the month as string of decimals: 01 - 31
*l %%H
*t gives hours using twenty-four hour clock: 00 - 23
*l %%I
*t gives hours using twelve hour clock: 01 - 12
*l %%j
*t gives day of the year: 001 - 366
*l %%m
*t gives month as string of decimals: 01 - 12
*l %%M
*t gives minutes: 00 - 59
*l %%p
*t gives AM or PM.
*l %%S
*t gives seconds: 00 - 59
*l %%U
*t gives week number, counting Sunday as first day: 00 - 52
*l %%w
*t gives day of week, counting from Sunday: 0 - 6
*l %%W
*t gives week number, counting Monday as first day: 00 - 52
*l %%x
*t gives date in default format.
*l %%X
*t gives time in default format.
*l %%y
*t gives year of the century: 00 - 99
*l %%Y
*t gives year.
*l %%Z
*t gives time zone if one exists.
*l %%
*t gives '%%'.
*x mktime
*q strftime
*q Formatted conversion of tm structure - see strftime
*q Time structure, formatted conversion - see strftime
#
*n strings\Helios command
*P Finds printable strings in the given file or files
*F strings [-] [-a] [-o] [-<number>] <file>...
*D The %bstrings%b command enables you to look for ASCII
strings in a binary file, where a string may be any sequence of four or
more printable characters ending with a newline character or a null
character.
*p Here is a summary of the various options to %bstrings%b:
*l Flag
*t Action
*l -
*t Takes input from the standard input as well as %s<file>%s (default)
*l -a
*t Finds strings ending with null, newline, or a non-printable character.
*l -o
*t Gives each string preceded by its offset in the file (in hexadecimal)
*l -%s<number>%s
*t Uses %s<number>%s as the minimum number of characters in a string
(default is 4).
*x ASCII
*x ascii
*x od
#
*n strlen\C library function
*P Calculates the length of a string.
*I <string.h>
*F size_t strlen(const char *s);
*A s - A pointer to the string to be measured.
*R the length of the string (excluding the null terminating
character).
*D %bstrlen%b counts the number of characters in the string up
to, but not including, the null terminating character.
*c=int main(void)
*c= {  char *string = "String to be measured";
*c=    size_t result;
*c=
*c=    result = strlen(string);
*c=
*c=    /*
*c=      Gives a result of 21
*c=    */
*c= }
*q strlen
*q Calculate length of string - see strlen
*q String length, calculate - see strlen
*q Length of string, calculate - see strlen
#
*n strncat\C library function
*P Appends one string onto another (up to a maximum number of
characters).
*I <string.h>
*F char *strncat(char *s1, const char *s2, size_t n);
*A s1 - A pointer to the string to be extended.
*A s2 - A pointer to the string to be appended.
*A n - The maximum number of characters to be appended.
*R the unchanged value of %ss1%s.
*D %bstrncat()%b copies a maximum of %sn%s characters from the
string pointed to by %ss2%s (excluding the null terminating character)
onto the end of the string pointed to by %ss1%s. The first character of
%ss2%s overwrites the null terminating character of %ss1%s. A null
terminating character is appended to the end of the result.
*c= int main (void)
*c= { /*
*c=   Appends the first 24 characters of a string to another string.
*c=  */
*c=
*c=    char copy[50] = {"abcdefghijklmnopqrstuvwxyz"};
*c=    char source[50];
*c=    int result;
*c=
*c=    result = strncat(copy, source, 24);
*c= }
*x strcat
*q strncat
*q Append string - see also strncat
*q String, append - see also strncat
#
*n strncmp\C library function
*P Compares the first n characters of two strings.
*I <string.h>
*F int strncmp(const char *s1, const char *s2, size_t n);
*A s1 - A pointer to one of the strings to be compared.
*A s2 - A pointer to the other string to be compared.
*A n - The maximum number of characters to be compared.
*R a negative integer if the %ss1%s string is numerically less
than the %ss2%s string, a zero value if the two strings are numerically
the same, or a positive integer if the %ss1%s string is numerically
greater than the %ss2%s string.
*D %bstrncmp()%b compares up to the first %sn%s characters of
the strings pointed to by %ss1%s and %ss2%s.
*p The comparison is of the numerical values of the ASCII characters.
*c= int main (void)
*c= {  /* Compares two strings */
*c=    char string1[50], string2[50];
*c=    int result;
*c=
*c=    strcpy(string1, "Text");
*c=    strcpy(string2, "Textual difference");
*c=    result = strncmp(string1, string2, 4);
*c=
*c=    /*  strncmp returns 0  */
*c= }
*x memcmp
*x strcmp
*x strcoll
*x strncmp
*q strncmp
*q First n characters of two strings, compare - see strncmp
*q Compare strings - see strcmp, strncmp
#
*n strncpy\C library function
*P Copies a string into an array (up to a maximum number of
characters).
*I <string.h>
*F char *strncpy(char *s1, const char *s2, size_t n);
*A s1 - A pointer to the array used as the copy destination.
*A s2 - A pointer to the string used as the copy source.
*A n - The maximum number of characters to be copied.
*R the unchanged value of %ss1%s.
*E The behaviour of %bstrncpy()%b is undefined if the source and
destination overlap.
*D %bstrncpy()%b copies up to %sn%s characters from the source
string (pointed to by %ss2%s) into the destination array (pointed to by
%ss1%s). The behaviour of %bstrcpy()%b is undefined if the source and
destination overlap.
*p If the source string is less than %sn%s characters long, the extra
spaces in the destination array will be filled with null characters.
*c=int main(void)
*c= {  /* Copies the first 20 characters of a string */
*c=
*c=    char copy[50], source[50];
*c=    char *result;
*c=
*c=    result = strncpy(copy, source, 20);
*c= }
*x strcpy
*q strncpy
*q Copy string into array - see strcpy or strncpy
*q String - copy into array
*q Array, copy string into - see strcpy, strncpy
#
*n strpbrk\C library function
*P Finds the first character in one string that is present in
another string.
*I <string.h>
*F char *strpbrk(const char *s1, const char *s2);
*A s1 - A pointer to the string to be searched.
*A s2 - A pointer to the string containing the characters to be
searched for.
*R a pointer to the first character found in both strings. If none
of the characters in the %ss2%s string occur in the %ss1%s string,
%bstrpbrk()%b returns a null pointer.
*D %bstrpbrk()%b finds the first character in the string
pointed to by %ss1%s which is also contained within the string pointed to
by %ss2%s.
*c= int main (void)
*c= { /*
*c=    Return a pointer to the first occurrence of 'r', 'c' or 'g'
*c=  */
*c=
*c=    char string = "hello world";
*c=    char *result;
*c=
*c=    result = strpbrk(string, "rcg");
*c= }
*x strchr
*x strrchr
*q strpbrk
*q Find first char in string1 present in string2 - see strpbrk
*q Character - find first one in string1 present in string2
*q String comparison - see strpbrk
#
*n strrchr\C library function
*P Finds the last occurrence of a given character in a string.
*I <string.h>
*F char *strrchr(const char *s, int c);
*A s - A pointer to the string to be searched.
*A c - The character to be searched for.
*R a pointer to the last occurrence of the character.
*E Returns NULL if %sc%s does not occur in the string.
*D %bstrchr()%b finds the last occurrence of %sc%s in the
string pointed to by %ss%s. The search includes the null terminating
character. %sc%s is converted to a char before the search begins.
*c=int main(void)
*c= { /*
*c=   Finds the last time that '9' occurs in a string
*c=  */
*c=
*c=    char string = "0749";
*c=    char *result;
*c=
*c=    result = strrchr(string, '9');
*c= }
*x strpbrk
*x strchr
*q strrchr
*q Find last occurrence of character in string - see strrchr
*q Character - find last occurrence of in string
*q String, find last occurrence of character in - see strrchr
#
*n strspn\C library function
*P Counts the number of characters at the start of a string that
are also in another string.
*I <string.h>
*F size_t strspn(const char *s1, const char *s2);
*A s1 - A pointer to the string to be measured.
*A s2 - A pointer to the string containing the characters to be
looked for.
*R the length of the matched segment.
*D %bstrspn()%b counts the characters in the string pointed to
by %ss1%s which are also present in the string pointed to by %ss2%s. As
soon as %bstrspn()%b finds a character in the first string which is not
present in the second string, it stops and returns the number of
characters counted.
*c=int main(void)
*c= {
*c=   char *string = "carcinogenic";
*c=   size_t result;
*c=
*c=   result = strspn(string, "arc");
*c=
*c=   /*
*c=    Counts the number of characters at the beginning
*c=    of the string consisting of 'a', 'r' and 'c'
*c=
*c=    Returns 4
*c=   */
*c=}
*x strcspn
*x strtok
*q strspn
*q Count number of chars at start of string1 also in string2 - see strspn
*q Number of chars at start of string1 also in string2 - see strspn
*q Characters at start of string1 also in string2, count - see strspn
#
*n strstr\C library function
*P Finds the first occurrence of one string in another.
*I <string.h>
*F char *strstr(const char *s1, const char *s2);
*A s1 - A pointer to the string to be searched.
*A s2 - A pointer to the string to be searched for.
*R a pointer to the string, if found.
*E Returns NULL if the %ss2%s string does not occur within the
%ss1%s string.
*D %bstrstr()%b finds the first occurrence of the %ss2%s
string (excluding the null terminating character) in the %ss1%s string.
*c= int main(void)
*c=  {
*c=   char *string1 = "string to be searched";
*c=   char *string2 = "sea";
*c=
*c=   printf("%s\n", strstr(string1, string2));
*c=  }
*c=
*c= /*
*c= Displays:  searched
*c= */
*c=}
*x strspn
*x strpbrk
*q strstr
*q Find first occurrence of string1 in string2 - see strstr
*q First occurrence of string1 in string2 - see strstr
*q String - first occurrence of string1 in string2
#
*n strtod\C library function
*P Converts the initial part of a string to a double and saves a
pointer to the rest of the string.
*I <stdlib.h>
*F double strtod(const char *nptr, char **endptr);
*A nptr - A pointer to the string to be converted.
*A endptr - A pointer to the location which is to receive a
pointer to the rest of the string.
*R the converted value if the conversion is successful. If no
conversion is possible, %bstrtod()%b returns zero. If the result would
cause overflow the value HUGE_VAL (with the correct sign) is returned.
*E If the result would cause overflow, errno is set to ERANGE and
the value HUGE_VAL is returned. If the result would cause underflow, errno
is set to ERANGE and zero is returned.
*D %bstrtod()%b converts the initial part of the string
pointed to by %snptr%s to a number represented as a double. %bstrtod()%b
expects the string to consist of:
*p 1. Leading white space (optional).
*p 2. A plus or minus sign (optional).
*p 3. A sequence of decimal digits, which may contain a decimal point.
*p 4. An exponent (optional) consisting of an 'E' or 'e' followed by an
optional sign and a string of decimal digits.
*p 5. One or more unrecognised characters (including the null string
terminating character).
*p %bstrtod()%b ignores the leading white space, and converts all the
recognised characters. If there is no decimal point or exponent part in
the string, a decimal point is assumed after the last digit in the string.
*p The string is invalid if the first non-space character in the string is
not one of the following characters:
*c=+ - . 0 1 2 3 4 5 6 7 8 9
*p If %sendptr%s is not null, and the conversion took place, a pointer to
the unrecognised part of the string is stored in the location pointed to
by %sendptr%s. If conversion did not take place, the location is set to
the value of %snptr%s.
*c= int main(void)
*c= {
*c=  char *array;
*c=  char *number_end;
*c=  double x;
*c=
*c=  array = "97824.3E+4Goodbye";
*c=  x = strtod(array, &number_end);
*c=  printf("strtod gives %f\n", x);
*c=  printf(Number ended at %s\n", number_end);
*c= }
*c=
*c= /*
*c= Prints  strtod gives 978243000.000000
*c=          Number ended at Goodbye
*c= */
*x atof
*x atoi
*x atol
*x strtol
*q strtod
*q Convert initial part of string to double - see strtod
*q Initial part of string to double, convert - see strtod
*q String to double, convert - see strtod
*q Double, convert from initial part of string - see strtod
#
*n strtok\C library function
*P Converts a string consisting of delimited tokens into a series
of strings with the delimiters removed.
*I <string.h>
*F char *strtok(char *s1, const char *s2);
*A s1 - A pointer to the string to be broken up.
*A s2 - A pointer to the delimiter string.
*R a pointer to the first character of a token. A null pointer is
returned if no token was found.
*D %bstrtok()%b is used to break up the string pointed to by
%ss1%s into separate strings. It is assumed that the string to be broken
consists of a series of tokens, separated from one another by one of the
characters in the string pointed to by %ss2%s.
*p When %bstrtok()%b is first called, each character in the string pointed
to by %ss1%s is checked to see if it is also present in the delimiting
string pointed to by %ss2%s. %bstrtok()%b recognises the first character
which is not in the delimiter string as the start of the first token. If
no such character is found it is assumed that there are no tokens in
%ss1%s, and %bstrtok()%b returns a null pointer.
*p Having found the start of a token, the %bstrtok()%b function searches
for the end of the token, represented by a character present in the
delimiting string. If such a character is found, it is overwritten with
the null terminating character and %bstrtok()%b saves a pointer to the
following character for use in a subsequent call. If no such character is
found the token extends to the end of the string. %bstrtok()%b returns a
pointer to the first character of the token.
*p The next token from the string is extracted by calling %bstrtok()%b with
a null pointer as the first parameter. This causes %bstrtok()%b to use the
pointer saved during the previous execution.
*c=int main (void)
*c={
*c=   char *string = "String^of things,to,,be^split);
*c=   char *token;
*c=
*c=   token = strtok(string, "^ ,");
*c=   while (token != NULL)
*c=         {
*c=          printf("Token found = %s\n", token);
*c=          token = strtok(NULL, "^ ,");
*c=         }
*c=
*c=   /*
*c=     Gives the output
*c=          Token found = String
*c=          Token found = of
*c=          Token found = things
*c=          Token found = to
*c=          Token found = be
*c=          Token found = split
*c=   */
*c=}
*q strtok
*q Convert string of delimited tokens into undelimited strings - see strtok
*q String of delimited tokens - convert into undelimited strings
*q Token string - convert into undelimited strings
*q Delimited token string - convert into undelimited strings
*q String comparison - see strtok
#
*n strtol\C library function
*P Converts the initial part of a string to a long int and saves a
pointer to the rest of the string.
*I <stdlib.h>
*F long int strtol(const char *nptr, char **endptr, int base);
*A nptr - A pointer to the string to be converted.
*A endptr - A pointer to the location which is to receive a
pointer to the rest of the string.
*A base - The radix representation of the integer string to be
converted.
*R the converted value if the conversion is successful. If no
conversion is possible, %bstrtol()%b returns zero. If the result would
cause overflow the value LONG_MAX or LONG_MIN is returned (depending on
the sign of the result).
*E If the result would cause overflow the value LONG_MAX or LONG_MIN
is returned (depending on the sign of the result), and errno is set to
ERANGE.
*D %bstrtol()%b converts the initial part of the string
pointed to by %snptr%s to a long int. %bstrtol()%b expects the string to
consist of the following:
*p 1. Leading white space (optional).
*p 2. A plus or minus sign (optional).
*p 3. An octal '0' or hexadecimal '0x' or '0X' prefix (optional).
*p 4. A sequence of digits within the range of the appropriate base. The
letters 'a' to 'z', and 'A' to 'Z' may be used to represent the values 10
to 35. For example, if base is set to 18, the characters for the values 0
to 17 ('0' to '9' and 'a' to 'h' or 'A' to 'H') are permitted.
*p 5. One or more unrecognised characters (including the null string
terminating character).
*p %bstrtol()%b ignores leading blanks, and converts all recognised
characters.
*p The string is invalid if the first non-space character in the string is
not a sign, an octal or hexadecimal prefix, or one of the permitted
characters.
*p If %sendptr%s is not null, and the conversion took place, a pointer to
the rest of the string is stored in the location pointed to by %sendptr%s.
If no conversion was possible, and %sendptr%s is not null, the value of
%snptr%s is stored in that location.
*c= int main(void)
*c= {
*c=  char *array;
*c=  char *number_end;
*c=  int base;
*c=  long l;
*c=
*c=  array = "123456abcGoodbye";
*c=  for(base = 2; base <= 12; base += 3)
*c=      {
*c=       l = strtol(array, &number_end, base);
*c=       printf("base = %d, strtol gives %ld\n", base, l);
*c=       printf("Number ended at %s\n\n", number_end);
*c=      }
*c= }
*c=
*c= /* Prints
*c=            base = 2, strtol gives 1
*c=            Number ended at 23456abcGoodbye
*c=
*c=            base = 5, strtol gives 194
*c=            Number ended at 56abcGoodbye
*c=
*c=            base = 8, strtol gives 42798
*c=            Number ended at abcGoodbye
*c=
*c=            base = 11, strtol gives 2143591
*c=            Number ended at bcGoodbye */
*x atoi
*x atol
*x strtod
*x strtoul
*q strtol
*q String conversions - see strtod, strtok, strtol, strtoul, etc
#
*n strtoul\C library function
*P Converts the initial part of a string to an unsigned long int
and saves a pointer to the rest of the string.
*I <stdlib.h>
*F unsigned long int strtoul(const char *nptr, char **endptr, int
base);
*A nptr - A pointer to the string to be converted.
*A endptr - A pointer to the location which is to receive a
pointer to the rest of the string.
*A base - The radix representation of the integer string to be
converted.
*R the converted value if the conversion is successful. If no
conversion is possible, %bstrtoul()%b returns zero. If the result would
cause overflow the value ULONG_MAX is returned.
*E If the result would cause overflow the value ULONG_MAX is
returned and errno is set to ERANGE.
*D %bstrtoul()%b converts the initial part of the string
pointed to by %snptr%s to an unsigned long int. %bstrtoul()%b expects the
string to consist of the following:
*p 1. Leading white space (optional).
*p 2. An octal '0' or hexadecimal '0x' or '0X' prefix (optional).
*p 3. A sequence of digits within the range of the appropriate base. The
letters 'a' to 'z', and 'A' to 'Z' may be used to represent the values 10
to 35. For example, if base is set to 18, the characters for the values 0
to 17 ('0' to '9' and 'a' to 'h' or 'A' to 'H') are permitted.
*p 4. One or more unrecognised characters (including the null string
terminating character).
*p %bstrtoul()%b ignores the leading white space, and converts all the
recognised characters.
*p The string is invalid if the first non-space character in the string is
not an octal or hexadecimal prefix, or one of the permitted characters
(signs are not permitted). If %sendptr%s is not null, and the conversion
took place, a pointer to the rest of the string is stored in the location
pointed to by %sendptr%s. If no conversion was possible, and %sendptr%s is
not null, the value of %snptr%s is stored in that location.
*x atoi
*x atol
*x strtod
*x strtol
*q strtoul
*q String conversions
*q Convert string to unsigned long int - see strtoul
*q Unsigned long int, convert string to - see strtoul
#
*n strxfrm\C library function
*P Transforms a string according to the locale and copies it into
an array (up to a maximum number of characters).
*I <string.h>
*F size_t strxfrm(char *s1, const char *s2, size_t n);
*A s1 - A pointer to the array used as the copy destination.
*A s2 - A pointer to the string used as the copy source.
*A n - The maximum number of characters to be copied.
*R if the string to be copied fits in the destination string,
%bstrxfrm()%b returns the number of characters copied (excluding the null
terminating character); otherwise it returns 0.
*D %bstrxfrm()%b copies up to %sn%s characters from the source
string (pointed to by %ss2%s) into the destination array (pointed to by
%ss1%s), after transforming the source string according to the program's
locale. Since the only permissible locale is "C", %bstrxfrm()%b is
equivalent to %bstrncpy()%b. The behaviour of %bstrxfrm()%b is undefined
if the source and destination overlap.
*p If the source string is less than %sn%s characters long, the extra
spaces in the destination array will be filled with null characters.
*c= /* Copies the first 20 characters of a string */
*c=
*c= char copy[50], source[50];
*c= size_t result;
*c=
*c= result = strxfrm(copy, source, 20);
*x strncpy
*q strxfrm
*q Transform string - see also strxfrm
*q String, transform - see also strxfrm
#
*n SunView\General interest
*P Supported windowing system for SUN-based systems.
*D The Helios idea of separate windows for the output of
different shells, commands, and so forth fits well on top of the SunView
windowing system. A new SunView window is created for each Helios window.
Data may be cut and pasted between Helios windows and normal Sun windows.
*q Windowing systems
*q SunView
*q Sun
#
*n svopen\Posix library function
*P Creates posix file descriptor for Helios Stream
*I <unistd.h>
*F int svopen(Stream *s, int fd)
*A s - Helios Stream
*A fd - file descriptor
*D The supplied Helios Stream is installed in the posix file
descriptor table as the given descriptor. It may subsequently be accessed
via this descriptor as if it had been opened in the normal way. If the
operation is successful the file descriptor is returned, otherwise -1 is
returned and errno set to indicate the error.
*q svopen
*q Helios posix extensions
#
*n swap_long\Posix library function
*P Swaps the bytes of an argument
*F ulong swap_long(ulong v)
*A v - value to swap
*R byte-swapped value
*D This function returns its argument with the bytes swapped.
If the argument is 0x11223344 the result will be 0x44332211. This routine
is used by the htonl() macro.
*q swap_long
*q swap_short
*x swap_short
*q htonl
#
*n swap_short\Posix library function
*P Swaps the bytes of an argument
*F ushort swap_short(ushort v);
*A v - value to swap
*R byte-swapped value
*D This function returns its argument with the bytes swapped.
If the argument is 0x1122 the result will be 0x2211. This routine is used
by the htonl() macro.
*x swap_long
*q swap_long
*q swap_short
*q htonl
#
*n switch\Helios command
*P Introduces a switch
*F switch (<string>) ; case <casestring-1>: ; <command-1> ; breaksw
; case <casestring-2>: ; <command-2> ; breaksw ; ... ; case
<casestring-n>: ; <command-n> ; breaksw ;default: ; <default> ; breaksw]
; endsw
*D The %bswitch%b command is a shell command flow construct
that acts like a C switch. %bswitch%b takes and reads a number of possible
alternative eventualities (cases) each of which it compares in turn with
%sstring%s to determine the action it must take. If %scasestring-1%s
matches %sstring%s, %bswitch%b executes %scommand-1%s; otherwise, it
compares %scasestring-2%s with %sstring%s, and then if that matches, it
executes %scommand-2%s; if not, it compares the next case string, and so
on. If none of the case strings match the given string, %bswitch%b
executes the default command, %sdefault%s. However, if there is no default
case, execution continues after the %bendsw%b command. Because the lines
are read sequentially, the %sdefault%s must come after the last %scase%s;
otherwise any following case would be ignored.
*p Before %bswitch%b reads or compares its given cases, it first does any
necessary expansion on %sstring%s (see the %sHelios%s %sShell%s document
for further details on filename and command expansion), and then it does
variable expansion on any file metacharacters in the case labels (for
example, `*', `?', and so on).
*p %bbreaksw%b marks the end of each set of commands in the sequence. It
breaks the action out of the switch and continues execution immediately
after the %bendsw%b command.
*p Here is an example of the use of %bswitch%b, %bcase%b, %bbreaksw%b,
%bendsw%b and %bdefault%b commands. The set of commands would normally be
held in a shell script file, possibly the loginrc file which is executed
whenever a new user logs in. The example always displays a single line
message. Which of the four messages is displayed depends on the value of
the shell variable `user'. Note the use of patterns in the third case
command. If the value contains a digit, for instance `C3PO', then this
case is executed. The default case picks up any values that have not been
catered for by the first three cases.
*c=switch ($user)
*c=case charles:
*c=echo Hello Mr Babbage
*c=breaksw
*c=case ada:
*c=echo Hello Ms Lovelace
*c=breaksw
*c=case *[0-9]*:
*c=echo Hello you must be a robot
*c=breaksw
*c=default:
*c=echo Hello $user
*c=breaksw
*c=endsw
*p Make sure that each case and default label appears at the beginning of a
line and that the sequence terminates with a %bendsw%b on a line by
itself.
*q Shell commands
*x breaksw
*x case
*x default
*x endsw
*q switch
*q Shell scripts
#
*n sysconf\Posix library function
*P Gets configurable system variables
*I <posix.h> ; <unistd.h>
*F int sysconf(int name);
*A name - name of the system variable in question
*R Current value for %sname%s. If %sname%b is invalid, it sets
errno and returns -1. Other errors return -1 without setting errno.
*E Returns -1 and sets errno, as follows:
*l [EINVAL]
*t Invalid argument.
*D Finds and returns the current value of a configurable
system limit or option. The variables, can be found in %s<unistd.h>%s.
Here is a quick reminder:
*l %bVariable%b
*t %bSymbolic constant%b
*l [ARG_MAX]
*t _SC_ARG_MAX (Runtime value of ARG_MAX = 65535; minimum value = 4096)
*l [CHILD_MAX]
*t _SC_CHILD_MAX (Minimum value = 6)
*l [CLK_TCK]
*t _SC_CLK_TCK (Runtime value = 100)
*l [NGROUPS_MAX]
*t _SC_NGROUPS_MAX (0)
*l [OPEN_MAX]
*t _SC_OPEN_MAX (Minimum value = 16)
*l [_POSIX_JOB_CONTROL]
*t _SC_JOB_CONTROL
*l [_POSIX_SAVED_IDS]
*t _SC_SAVED_IDS
*l [_POSIX_VERSION]
*t _SC_VERSION
*q sysconf
*x pathconf
#
*n system\C library function
*P Passes a string to the host environment.
*I <stdlib.h>
*F int system(const char *string);
*A *string - A pointer to the string to be passed to the host
environment.
*R a non-zero value if %sstring%s is a null pointer (to indicate
that there is a command processor).
*D %bsystem()%b passes the string pointed to by %sstring%s to
the host environment to be executed by a command processor.
*p If %sstring%s is a null pointer the call to %bsystem()%b is an enquiry
as to whether there is a command processor.
*q system
*q Pass string to host environment - see system
*q String - pass to host environment
*q Host environment, pass string to - see system
#
*n system\Posix library function
*P Gives a Helios Shell command
*I <stdlib.h>
*F int system( const char *string);
*A string - Pointer to string
*R Exit status of the Shell.
*D This function acts in the same way as typing in a Shell
command at your terminal by issuing a Shell command, indicated by
%sstring%s. It waits for the Shell to complete execution of that command
and then returns the exit status of the Shell. Notice that in order for
this command to work, the Helios shell program must reside in
%s/helios/bin%s.
*q system
*q Shell
#
*n tail\Helios command
*P Displays the end of a file
*F tail [-c|-l] [-f] [-n <number>] [<file>]
*D %btail%b is the converse of %bhead%b: it copies the last
part of a file with pathname %sfile%s to stdout, starting at the point
specified by the options. The default action is to print out the last ten
lines of the file.
*p The options to %btail%b are as follows:
*l -c
*t Causes %snumber%s to refer to number of bytes of output. (Note: %sc%s
used to refer to characters in earlier versions of %btail%b.)
*l -l
*t Causes %snumber%s to refer to number of lines of output.
*l -f
*t Prints out the last part of file then enters an infinite loop and prints
out any further bytes added to %sfile%s after %btail%b was initiated.
*l -n %snumber%s
*t Introduces the number of lines or bytes of output (lines is the
default). %snumber%s is a signed integer, where + means relative to
start-of-file, - means relative to end-of-file, and no sign also means
relative to start-of-file.
*p The %b-f%b option causes the %btail%b command not to terminate after
printing to stdout. Instead it goes into an infinite loop: it sleeps for a
second, reads any further bytes of information that may have been appended
to %sfile%s since it was initiated and then, if it finds any, copies them
directly to stdout; it then goes to sleep and repeats the same action
again. To break the loop and terminate %btail%b, press CTRL-C. If %sfile%s
is not a regular file (if it is a pipe, for example), then this option is
ignored.
*p Here are some command line examples that demonstrate some of the options
listed above:
*c=tail -c -n 1500 bill
*p prints out the file `bill' beginning at a point 1500 bytes from the
start of the file. To print out the last 150 lines of the file `bill', you
might type:
*c=tail -l -n -150 bill
*p which is equivalent to
*c=tail -n 150 bill
*p using the defaults.
*p %bNote:%b If you are used to the deprecated version of %btail%b (that
is, %stail [-|+[<number>][l|c|f]] [<file>]%s), you may use it under Helios
1.2; however, the version described in full above is the preferred version
of this command.
*q tail
*q Displaying last part of file
*x head
#
*n tan\C library function
*P Calculates the tangent of the argument.
*I <math.h>
*F double tan(double x);
*A x - A number in radians.
*R the tangent of %sx%s.
*D %btan()%b calculates the tangent of %sx%s (given in
radians).
*q tan
*q Calculates tangent
*q Tangent - see tan
#
*n tanh\C library function
*P Calculates the hyperbolic tangent of the argument.
*I <math.h>
*F double tanh(double x);
*A x - A number.
*R the hyperbolic tangent of %sx%s.
*D %btanh()%b calculates the hyperbolic tangent of %sx%s.
*q tanh
*q Calculates hyperbolic tangent
*q Hyperbolic tangent - see tanh
*q Tangent (hyperbolic) - see tanh
#
*n tar\Helios command
*P Provides a way to save many files in a single archive for later
retrieval
*F tar [-b <n>] [-BchiklmopRstvx] [-f <name>] [-T <name>]
[<name>...]
*D %btar%b stood originally for %bt%bape %bar%bchiver,
although now it can be used to save and restore multiple files to and from
any long-term I/O storage medium, such as a floppy disc, a cartridge or a
tape. You can also store your archive in another file, send it over the
network, or even pipe it to another program.
*p The %sname%ss referred to by the %btar%b command can be files, pipes,
fifos, or directories. When a %sname%s refers to a directory, %btar%b
always acts on any files and (recursively) on any subdirectories within
that directory. If no %sname%s is given, %btar%b reads from the standard
input and writes to the standard output (stdin and stdout).
*p The following table lists the %btar%b options currently supported by
Helios and their effect. You must give at least one of the options %b-c%b,
%b-t%b, %b-d%b or %b-x%b, but you can use any of the other options
whenever you choose.
*l %b-b%b %s<n>%s
*t Specifies a blocking factor for the archive. The block size will be
%sn%s x 512bytes. Larger blocks typically run faster, and allow you to
store more data on tape. The default blocking factor is usually 20, but it
can be set when %btar%b is compiled. The maximum block size is limited
only by the memory space available, and by the ability of the device
containing the archive to read and write the size you wish to use.
*l %b-B%b
*t Re-blocks an archive as you read it. %btar%b usually reads each block
with a single %bRead()%b, but this does not work when you are reading from
a pipe, because the command read will only give you the data that has
arrived so far. If you use the -B option, however, %btar%b will carry out
the read repeatedly to fill out to a record boundary, rather than
reporting an error. (The -B option is in fact the default when you are
reading an archive from standard input.)
*l %b-c%b
*t Creates an archive from a list of files (%s<name>...%s).
*l %bD%b
*t Dumps a directory to archive without dumping the files within that
directory.
*l %b-f%b %s<name>%s
*t Introduces the %sname%s of the archive file. If you give a hyphen (-)
for %sname%s, %btar%b reads from the standard input or writes to the
standard output. If you omit the %b-f%b option, and the environment
variable TAPE exists, then %btar%b would use its value as the archive
filename; otherwise, it would use a default determined at compile time
(for example, %s/tape%s). The default is usually set to the first tape
drive, or to another transportable I/O medium on your system.
*l %b-h%b
*t Treats symbolic links specially: if it comes across a symbolic link when
creating an archive, %btar%b dumps the file or directory pointed at by the
symbolic link, rather than dumping it as a symbolic link.
*l %b-i%b
*t Ignores blocks of zeros in the archive. (Normally, a block of zeros
indicates the end of an archive, but they can sometimes be found in the
middle of a damaged archive, or at intervals in an archive made up of
several other archives, so in these cases this option allows %btar%b to
continue unhindered.) Note that with the %b-i%b option set, %btar%b will
read right to the end of your file, thus eliminating any possible problems
with multi-file tapes.
*l %b-k%b
*t Ensures that when you extract a file from an archive, you keep the
existing files, rather than overwriting them with the versions from the
archive.
*l %b-l%b
*t Allows you to stay inside the local file system of the directory whose
contents you are dumping to archive. This option will only affect the
files you dump because they are in a %sdumped directory%s, and not those
files which are named on the command line. (The latter are always dumped,
and they can be from various file systems.) The %b-l%b option is useful
for making full dump archival backups of your file system. Any files which
are skipped while you are using this option will be listed on the standard
error (stderr).
*l %b-m%b
*t Sets the modified timestamp of each file to the current time when
extracting files from archive, rather than extracting the timestamps
individually.
*l %b-o%b
*t Writes an old format archive (one which does not include any information
about directories, pipes, fifos, contiguous files or device files) when
creating an archive. You would rarely need to use this option. In most
cases a new format archive can be read by an old format tar program
without any difficulty.
*l %b-p%b
*t Restores extracted files to the same permissions that they had inside
the archive. If you omit this option, the current unmask will limit the
permissions of the files you extract.
*l %b-R%b
*t Prints the record number inside the archive where a message occurred
whenever %btar%b produces a message. This option is useful when you are
reading damaged archives, as it helps you to locate any damaged sections.
*l %b-s%b
*t Sorts filenames into the same order as on the tape. You might use this
when you wished to extract a number of files from an archive, or when you
wished to simply list their names. Using this option, you can call for
very long lists even if you are using a small machine, because the entire
list need not be read into memory at once. (Notice that you can also
create a sorted list with %b-t%b.)
*l %b-t%b
*t Draws up a table of contents for one of your existing archives. If you
specify any filenames, only the files matching those names will be listed.
This listing will appear on the standard output (stdout).
*l %b-T%b %s<name>%s
*t Ensures that %btar%b reads any filenames or regular expressions from the
file %sname%s. This file contains a list with one name or expression per
line. If you give a hyphen (-) for %sname%s, %btar%b reads directly from
the standard input (stdin). By using this option in conjunction with
%b-s%b, you can process longer lists of files, and you can pipe them to
tar.
*l %b-v%b
*t Stands for %sverbose%s. The default action for archive creation, file
extraction and differencing is to be %ssilent%s. This option produces a
listing of the %bls -l%b type. The output from this option appears on the
standard output (stdout), except when creating an archive, in which case
it goes to the standard error (stderr) output.
*l %b-x%b
*t Extracts files from an existing archive. If filenames are specified,
only files which match the specified names will be extracted; otherwise,
all the files in the archive will be extracted.
*p %bNote:%b %btar%b will continue even if it encounters an error. This is
different from earlier versions of the program, which required you to give
the %bi%b option so that you could continue reading.
*p After giving your options, you must give %btar%b the name of the file
you want it to work on (or names of the files, if you want it to work on
more than one - if you have a large number of files, remember that you can
use %b-t%b to read in a file of names). If you specify the name of a
directory, %btar%b will process it and all the files it contains
recursively. If you specify a full pathname when you are creating an
archive, it will be written to that archive without the initial forward
slash (/), when those files are later read into a location different from
the one where they were dumped %btar%b will print a warning. If you
attempt to extract files from an archive which contains full pathnames,
then %btar%b will only extract them in relation to the current directory,
and, once again, a warning message will appear.
*p When you are extracting or listing files, %btar%b will treat the
filenames as regular expressions, mainly using the same syntax as the
Shell. The Shell itself will separately match each substring between a
forward slash (/), but %btar%b will match the whole string at once, so do
not be surprised if some anomalies occur. (For example, a star (*) or a
question mark (?) can match a forward slash.) If you wish to specify a
regular expression as an argument to %btar%b, you must remember to place
it inside quotation marks (that is, "%s<expr%s>"), so that the Shell will
not attempt to expand it.
*p Note that, for compatibility reasons, the hyphen preceding the options
is optional and need not be given.
*p Further documentation can be found on the Unsupported Software disc.
*q tar
*q Tape archiver - see tar
*q File archiver - see tar
*q Archiving files
*q Saving files
*q Backing up files
*q Backup copies
*q Retrieving saved files
*q File storage
*k I/O storage media
*x Expressions
#
*n Task\General interest
*P Provides the usual unit of execution under Helios.
*D A task is the usual unit of execution under Helios. It is
roughly equivalent to, but different from, a Unix process.
*p A single task is made up of one or more %bthreads%b, which are also
known as Helios %bprocesses%b. Two or more tasks acting together in
parallel are called a %btask force%b.
*p A single task runs on one %bprocessor%b only. It is possible, however,
to multi-task under Helios, running more than one task per processor. The
tasks in a task force may be confined to one processor or spread over many
processors, or a combination of both.
*p Each component task within a task force acts as a discrete program and
is compiled and linked separately. The way in which these component tasks
are to interact and how they are to be distributed over the available
processing resources is set up with a %bCDL%b script. The script is
processed by the CDL compiler and passed to a special Helios program known
as the Task Force Manager (TFM). The TFM analyses the model described by
the script and, taking into account the current activities on the network
of processors, distributes the various component tasks in the task force
amongst the available processors and sets up the communication pipes
between them.
*p Notice that input and output passes directly between interacting
components of a task force by way of %bpipes%b. That is to say, I/O is
written to, and read from, a connecting pipe; occam channels and Helios
messages are not used. All supported programming languages perform this
I/O via the Posix library. When a task starts up, all pipes and other
streams specified by the CDL script are opened automatically at the Posix
level and can be written to directory using the Posix %bread()%b and
%bwrite()%b functions; only some of the streams are opened at the language
level (for example, stdin, stdout, and stderr in C). To use the streams
that are not opened at the language level, you must convert a Posix file
descriptor in to the specific language file descriptor. In C, for
instance, the function %bfdstream()%b can be used to convert the Posix file
descriptor to a pointer to a C object of type FILE. If this is done, care
must be taken to allow for the internal buffering of some language I/O
functions, such as %bfwrite()%b.
*p The Helios message passing routines %bPutMsg()%b and %bGetMsg()%b are
not designed for transferring data between various tasks within a task
force, and there is no simple way of using them for this purpose. Message
passing is mainly used internally by Helios for client-server
interactions. The system library takes care of message passing for client
programs (applications). Servers need to handle message passing. Standard
servers are provided with Helios; however, server design is not simple and
so further server programs should only be created by experts.
*p A single task can contain many threads (processes). These threads are
created with the Helios routine %bFork()%b. All threads created in this
way will run on the same shared processor (remember that a task can only
run on one processor), will share the same memory space and will interact
via this shared memory. %bSemaphores%b provide a means of synchronising
these threads and controlling access to shared memory.
*q fwrite
*q fdstream
*q Message passing
*q Memory, shared
*q Tasks
*q Process
*q Posix library
*q System library
*q Task force
*q CDL
*q Thread
*q Multi-tasking
*x fdstream
*x CDL
*x Thread
*x Process
#
*n Task-Force-Manager\General interest
*P Distributes task force over available network of processors
*D The Task Force Manager (TFM) is a special service that
takes each task within a task force and distributes them over the
available network of processors. Each task may run on a separate
processor, or more than one may share a processor. The Task Force Manager
uses information supplied by the user in the resource map to decide how
best to distribute the task force. The Task Force Manager is started
automatically by the Network Server.
*p For further information, see the CDL Guide.
*q Task Force Manager
*q Taskforce
*q Network Server
*q TFM
*q Resource map
*x CDL
#
*n TaskData\System library
*P Get or set information associated with the current Task
*I <syslib.h>
*F WORD TaskData( word code, void value );
*A code - Special code for item to be accessed
*A value - Pointer to suitable container for item
*R Error code
*D This function allows a task to get or set information about
itself in a machine independent manner. The code identifies which item is
to be accessed:
*l TD_Program
*t returns base address of program code
*l TD_Port
*t returns task's own message port
*l TD_Parent
*t returns task's parent's message port
*l TD_HeapBase
*t returns base of task's heap area
*p At present there are no items which may be set.
*q Current task data - see TaskData
#
*n TaskInit\System library
*P Create a new task
*I <task.h>
*F WORD TaskInit( Task *task );
*A task - Pointer to task structure.
*R Error code
*D This function creates the task described by the Task
structure. A memory block sufficient to hold the module table, static
data, initial heap and stack of the program is allocated and initialised. A
process is then set running on the stack executing at the main entry point
of the code. This is primarily for use by the Processor Manager.
*x KillTask
*x CallException
*q Create new task
*q New task, create - see TaskInit
*q Task, create - see TaskInit
#
*n tcdrain\Posix library function
*P Wait until output is transmitted to %sfd%s
*I <termios.h>
*F int tcdrain (int fd);
*A fd - File descriptor or device
*R Zero on successful completion; otherwise, it returns a value of
-1 and sets errno to indicate the error that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function.
*l [EIO]
*t A physical I/O error has occurred.
*D %btcdrain()%b waits until all output transmitted to %sfd%s
has been transmitted.
*x tcsendbreak
*x tcflow
*x tcflush
*q Terminal interface
*q Line control
#
*n tcflow\Posix library function
*P suspend transmission or reception of data to or by %sfd%s
*I <termios.h>
*F int tcflow( int fd, int action );
*A fd - File descriptor or device
*A action - Action (see below)
*R Zero on successful completion; otherwise, it returns a value of
-1 and sets errno to indicate the error that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function, or the value of %saction%s
argument is not valid.
*l [EIO]
*t A physical I/O error has occurred.
*D %btcflow()%b suspends the transmission or the reception of
data on the object associated with %sfd%s according to the value of
%saction%s:
*l TCOOF
*t Suspend output
*l TCOON
*t Restart output
*x tcdrain
*x tcsendbreak
*x tcflush
*q Terminal interface
*q Line control
*q Suspend data transmission
*q Suspend data reception
*q Transmission of data, suspend
*q Reception of data, suspend
#
*n tcflush\Posix library function
*P Discard data, according to given conditions
*I <termios.h>
*F int tcflush (int fd, int qselect);
*A fd - File descriptor or device
*A qselect - Action (see below)
*R 0 if successful; otherwise, returns -1 and sets errno.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function, or the value of %sqselect%s
argument is not valid.
*l [EIO]
*t A physical I/O error has occurred.
*D %btcflush()%b discards data written to the object
associated with %sfd%s but not yet transmitted, or data received but not
read, according to the value of %sqselect%s:
*l TCIFLUSH
*t Flush data received but not read
*l TCOFLUSH
*t Flush data written but not transmitted
*l TCIOFLUSH
*t Flush data received but not read and data written but not transmitted
*x tcdrain
*x tcsendbreak
*x tcflow
*q Terminal interface
*q Line control
*q Discard data written but not transmitted
*q Data written but not transmitted, discard
*q Discard data received but not read
*q Data received but not read, discard
#
*n tcgetattr\Posix library function
*P Get the terminal attributes associated with a file descriptor
*I <termios.h>
*F int tcgetattr (int fd, struct termios *t);
*A fd - File descriptor or device
*A t - Pointer to %stermios%s structure
*R Zero on successful completion; otherwise, it returns a value of
-1 and sets errno to indicate the error that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function.
*l [EINVAL]
*t A physical I/O error has occurred.
*D This function gets the parameters associated with the
object referred to by %sfd%s and stores them in the %stermios%s structure
pointed at by %st%s.
*x cf_getispeed
*q tcsetattr
*q Terminal state
*q Terminal attributes
*q Terminal interface
*q Get terminal state
#
*n tcgetpgrp\Posix library function
*P Returns foreground group id
*I <posix.h> ; <termios.h>
*F pid_t tcgetprgrp (int fd);
*A fd - terminal file descriptor
*D %btcgetpgrp()%b returns the value of the process group id
for the foreground process group associated with the terminal.
*q tcgetpgrp
*x tcsetpgrp
#
*n tcp\Helios command
*P Copies text files between filing systems
*F tcp <source> <destination>
*F tcp <source> [<source>] <destination directory>
*D This command does a text copy. %bcp%b does a binary copy,
which means that it does not work well when you wish to copy text files
across different filing systems. For instance, to copy a text file from
your MS-DOS host filing system to a Helios based filing system, such as
/ram, you should use %btcp%b rather than %bcp%b. This is because the
MS-DOS filing system stores line breaks as <CR><LF>, whereas Helios (and
other Unix-like filing systems) store line breaks as <LF>.
*x cp
*x xlatecr
#
*n tcsendbreak\Posix library function
*P Send a break.
*I <termios.h>
*F int tcsendbreak (int fd, int duration);
*A fd - File descriptor or device
*A duration - A positive value
*R Zero on successful completion; otherwise, it returns a value of
-1 and sets errno to indicate the error that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function.
*l [EINVAL]
*t A physical I/O error has occurred.
*D %btcsendbreak()%b sends a break to the device pointed at by
the file descriptor %sfd%s. That is to say, it sends a continuous stream
of zero-valued bits for a given amount of time. The value of the argument
%sduration%s affects the duration of the bit stream. If %sduration%s is
greater than zero, it sends the bits for 0.25 seconds; if %sduration%s is
zero, it sends the bits for 0.1 seconds.
*x tcdrain
*x tcflow
*x tcflush
*q Terminal interface
*q Line control
*q Send terminal break
*q Terminal break, send
*q Break - terminal - see tcsendbreak
#
*n tcsetattr\Posix library function
*P Set the terminal attributes associated with a file descriptor
*I <termios.h>
*F int tcsetattr (int fd, int actions, struct termios *t);
*A fd - File descriptor or device
*A actions - Affects when and how the change shall occur
*A *t - Pointer to %stermios%s structure
*R Zero on successful completion; otherwise, it returns a value of
-1 and sets errno to indicate the error that occurred.
*E
*l [EBADF]
*t %sfd%s is not a valid file descriptor.
*l [EINVAL]
*t The device does not support this function, or the %sactions%s argument
is not set to a valid value.
*l [EIO]
*t A physical I/O error has occurred.
*D This function sets the parameters associated with the
object referred to by %sfd%s (the terminal) from the %stermios%s structure
pointed at by %st%s according to the value of %sactions%s. Here are some
possible values for %sactions%s:
*l TCSANOW
*t Set the new parameters at once
*l TCSADRAIN
*t Set the new parameters after all output written to the terminal has been
transmitted. This should be used when changing parameters that affect
output
*l TCSADFLUSH
*t Set the new parameters after all output written to the terminal has been
transmitted, discarding all input that has been received but not read
first
*x tcgetattr
*q Terminal interface
*q Set terminal attributes
*q Terminal attributes, set
*q Set terminal state
#
*n tcsetpgrp\Posix library function
*P Sets foreground group id
*I <posix.h> ; <termios.h>
*F int tcsetprgrp (int fd, pid_t pid);
*A fd - terminal file descriptor
*A pid - process id
*D %btcsetpgrp()%b is intended to set the foreground process
group id of terminal in a Posix job control option. Under Helios, this
function establishes the current task as the break event handler for the
given stream. All events arriving at the task will be converted into
SIGINT signals.
*q tcsetpgrp
*q Break event handler for stream
*q SIGINT signals
*q Process group id - see also Task group id
*x tcgetpgrp
#
*n tee\Helios command
*P Copies stdin to file(s) and to stdout
*F tee [-a] [<file>...]
*D The %btee%b command always reads from the standard input
stream, and copies data to the standard output stream. Any data copied is
also sent to all the files specified in the list.
*p In many ways %btee%b is similar to %bcat%b, except that whereas %bcat%b
copies all the input files to the standard output, %btee%b copies the
standard input stream to the standard output as well as to the specified
files. For example,
*c=cat abc def | tee anextracopy
*p reads the standard input consisting of the contents of the files `abc'
and `def'; copies this to the standard output (in this case the terminal)
and also places a copy in the file `anextracopy'.
*p The %btee%b command normally overwrites the files specified in the
command line; the -a flag causes %btee%b to append data to the files
specified rather than overwriting them.
*q tee
*q Piping files
*q Files, piping
*x cat
#
*n Terminate\System library
*P Terminate Helios
*I <link.h>
*F void Terminate( void );
*D This function causes the kernel to inform its neighbours
that it is about to terminate and then it goes into a high priority loop.
This is for use by system programs when some part of the network is to be
evacuated (to run an occam program directly on the hardware, for example).
*q Terminating Helios
#
*n test\Helios command
*P Evaluates an expression to test if a condition is true or false
*F [test]
[<op><file>]|[[<op>]<string>]|[<str1><op><str2>]|[<n1><op><n2>]
*D %btest%b evaluates a given expression. If that expression
evaluates to TRUE, it returns 0; otherwise, if it evaluates to FALSE, it
returns 1. If given no expression to evaluate, %btest%b returns FALSE. An
expression can be given without the command name, in which case any
surrounding square brackets to the expression are treated as separate
arguments.
*p The following operators may be used:
*l -d %s<file>%s
*t if %s<file>%s exists and is a directory, %btest%b returns TRUE
*l -f %s<file>%s
*t if %s<file>%s exists and is a regular file, %btest%b returns TRUE
*l -g %s<file>%s
*t if %s<file>%s exists and its set group ID is set, %btest%b returns TRUE
*l -p %s<file>%s
*t if %s<file>%s is a named pipe, %btest%b returns TRUE
*l -r %s<file>%s
*t if %s<file>%s exists and is readable, %btest%b returns TRUE
*l -s %s<file>%s
*t if %s<file>%s exists and its size is >0, %btest%b returns TRUE
*l -w %s<file>%s
*t if %s<file>%s exists and is writable (write flag is set), %btest%b
returns TRUE
*l -x %s<file>%s
*t if %s<file>%s exists and is executable (execute flag is set), %btest%b
returns TRUE. If %s<file>%s represents a directory, a TRUE return
indicates that this directory can be searched.
*l -t [%s<fd>%s]
*t if a file represented by the file descriptor number %s<fd>%s (default 1)
is open and associated with a terminal, %btest%b returns TRUE
*l -n %s<string>%s
*t if the length of %s<string>%s is nonzero, %btest%b returns TRUE
*l -z %s<string>%s
*t if the length of %s<string>%s is 0, %btest%b returns TRUE
*l %s<string>%s
*t if %s<string>%s is not the null string, %btest%b returns TRUE
*l %s<str1>%s = %s<str2>%s
*t if string %s<str1>%s is exactly the same as %s<str2>%s, %btest%b returns
TRUE
*l %s<str1>%s != %s<str2>%s
*t if string %s<str1>%s is not the same as %s<str2>%s, %btest%b returns
TRUE
*l %s<n1>%s -eq %s<n2>%s
*t if the integer %s<n1>%s is algebraically equal to the integer %s<n2>%s,
%btest%b returns TRUE
*l %s<n1>%s -ne %s<n2>%s
*t if the integer %s<n1>%s is not algebraically equal to the integer
%s<n2>%s, %btest%b returns TRUE
*l %s<n1>%s -gt %s<n2>%s
*t if the integer %s<n1>%s is algebraically greater than the integer
%s<n2>%s, %btest%b returns TRUE
*l %s<n1>%s -ge %s<n2>%s
*t if the integer %s<n1>%s is algebraically greater than or equal to the
integer %s<n2>%s, %btest%b returns TRUE
*l %s<n1>%s -lt %s<n2>%s
*t if the integer %s<n1>%s is algebraically less than the integer %s<n2>%s,
%btest%b returns TRUE
*l %s<n1>%s -le %s<n2>%s
*t if the integer %s<n1>%s is algebraically less than or equal to the
integer %s<n2>%s, %btest%b returns TRUE
*p The simple expressions listed above may be combined with the following
operators:
*l ! %s<expr>%s
*t if the simple expression %s<expr>%s is not true (false), %btest%b
returns TRUE
*l %s<expr1>%s -a %s<expr2>%s
*t if the simple expressions %s<expr1>%s and %s<expr2>%s are both true,
%btest%b returns TRUE
*l %s<expr1>%s -o %s<expr2>%s
*t if either %s<expr1>%s or %s<expr2>%s are true, %btest%b returns TRUE
*l ( %s<expr>%s )
*t if %s<expr>%s is true, %btest%b returns TRUE
*p Notice that the AND operator, -a, has higher precedence than the OR
operator, -o.
*q test
*q Conditions, test
*q Expressions, evaluate and test
#
*n TestSemaphore\System library
*P Test the value of a semaphore
*I <sem.h>
*F WORD TestSemaphore( Semaphore *sem );
*A sem - Semaphore to test
*R Value of semaphore count
*D This function returns the value of the semaphore count
field. This function allows for possible concurrent access to the
semaphore and is therefore safer than simply reading the count field of
the structure.
*x Wait
*x Signal
*x InitSemaphore
*x TestWait
*q Semaphore value, test
#
*n TestWait\System library
*P Tests and waits on a semaphore
*I <sem.h>
*F bool TestWait(Semaphore *sem);
*A sem - semaphore
*R whether semaphore locked
*D If the semaphore is available (sem->Count > 0) then a
Wait() operation is performed and the function returns TRUE. If the
semaphore is not available (sem->Count <= 0) the function returns FALSE.
This function solves a potential race condition which could exist if
TestSemaphore() and Wait() were used by the application.
*q TestWait
*x Wait
*x TestSemaphore
*x Signal
#
*n Thread\General interest
*P Synonym for lightweight process
*D Helios supports the concept of both threads and tasks.
*p A thread is created by a call to %bFork%b, and creates another
process running on the same processor. This thread shares all
global memory with the one which created it, and it is timesliced with all
other running threads by the scheduler. In order to achieve
synchronisation between threads, semaphores are provided in the form of
calls to %bSignal%b and %bWait%b.
*p A task is created by the CDL, or from the shell, or from a program by a
combination of %bvfork%b and %bexec%b. A task may be created in a
different processor, and even if it is created in the same processor all
communication between tasks must still be via made via message passing.
*p The only recommended way of using the Helios message passing mechanism
is via sending blocks of data via pipes (or sockets) using the low level
Posix compliant calls such as %bread%b or %bwrite%b. This is efficient as
a single message will be sent for every 64K bytes specified in the call to
%bread%b or %bwrite%b. The data is sent without any redundant buffering.
*q Threads
*q Tasks
*q Message passing
*q Shared memory
*q Memory, shared
*q Semaphores
*x CDL
*x Task
#
*n time\C library function
*P Reads the current time.
*I <time.h>
*F time_t time(time_t *timer);
*A timer - A pointer to a location where the current time can be
stored.
*R the value of the current time. If the current time is not
available, %btime()%b returns -1, cast to %stime_t%s.
*E %btime()%b returns (%stime_t%s)-1, if the current time is not
available.
*D %btime()%b returns the closest possible approximation to
the current time, and loads it into the location pointed to by %stimer%s,
unless %stimer%s is null.
*x mktime
*x clock
*q time
*q Read current time
*q Current time, read
*q Time, read
#
*n time\Posix library function
*P Get current system date and time
*I <posix.h> ; <sys/types.h> ; <unistd.h>
*F time_t time (time_t *tloc);
*A tloc - Pointer to the location of the system date and time
*R The value of the system time. On failure, it returns the value
((time_t)-1) and sets errno to indicate the error.
*D The %btime()%b function obtains the current time from the
system. It returns the value of the system time in seconds since 00:00:00
GMT, January 1, 1970.
*q Get current date and time - see time
*q Current date and time, get - see time
*q Date and time, get current - see time
*q System time, get - see time
#
*n times\Posix library function
*P Store time-accounting information
*F <sys/types.h> ; <sys/time.h>
*F clock_t times (struct tms *buffer);
*A buffer - Pointer to buffer to be filled with time-accounting
information
*R The elapsed real time, in CLK_TCKths of a second, since a
particular time (for example, since system startup). Each invocation of
%btimes()%b within the task will use the same point in time as a starting
point. The return value may overflow the possible range of type
%sclock_t%s. If %btimes()%b fails, a value of ((clock_t)-1) is returned
and errno set to indicate the error.
*D %btimes()%b fills the structure pointed at by %sbuffer%s
with time-accounting information. The %stms%s structure is defined within
the header file <sys/time.h>; it contains the following members:
*f Type\Name\Description
*f clock_t \tms_utime\User CPU time
*f clock_t\tms_stime\System CPU time
*f clock_t\tms_cutime\User CPU time of descendants
*f clock_t\tms_cstime\System CPU time of descendants
*p All times are expressed in CLK_TCKths of a second. Further data elements
may be declared in this structure. All elements of the structure begin
with the prefix `tms_'.
*p The times of a child task are included in the timings of its parent when
a %bwait()%b or %bwait2()%b function returns the task ID of a terminated
child. If a child task has not waited for its terminated children, then
their times are not included.
*p The value %stms_utime%s is the CPU time used while executing
instructions in the use space of the calling task.
*p The value %stms_stime%s is the CPU time used by the system on behalf of
the calling task.
*p The value %stms_cutime%s is the sum of the %stms_utimes%s and
%stms_cutimes%s of the child tasks.
*p The value %stms_cstime%s is the sum of the %stms_stimes%s and
%stms_cstimes%s of the child tasks.
*x exec
*x time\000643
*x wait
*q Storing time-accounting information - see times
*q Time-accounting information, store - see times
#
*n tmpfile\C library function
*P Creates a temporary binary file.
*I <stdio.h>
*F FILE *tmpfile(void);
*R a pointer to the newly created file stream. A null pointer is
returned if the file could not be created.
*D %btmpfile()%b creates a temporary binary file, and opens it
for update. The file will automatically be removed when the program
terminates or the temporary file is explicitly closed.
*x tmpnam
*q tmpfile
*q Create temporary binary file - see tmpfile
*q Temporary binary file, create - see tmpfile
*q Binary file, create temporary - see tmpfile
#
*n tmpnam\C library function
*P Creates a unique filename.
*I <stdio.h>
*F char *tmpnam(char *s);
*A s - A pointer to the destination string for the filename.
*R if %ss%s is a null pointer, %btmpnam()%b returns a pointer to
an internal object containing the new filename. Otherwise the new filename
is put in the string pointed to by %ss%s, and %btmpnam()%b returns the
unchanged value %ss%s. In this case %ss%s must point to an array of at
least %sL_tmpnam%s characters.
*E The effect of calling %btmpnam()%b more than TMP_MAX times is
undefined.
*D %btmpnam()%b creates a unique filename (that is, one which
does not match any existing filename). A different string is created each
time %btmpnam()%b is called. %btmpnam()%b may be called up to TMP_MAX
times.
*x tmpfile
*q tmpnam
*q Create unique filename - see tmpnam
*q Unique filename, create a - see tmpnam
*q Filename, unique - see tmpnam
#
*n tolower\C library function
*P Converts an upper-case letter to its lower-case equivalent.
*I <ctype.h>
*F int tolower(int c);
*A c - The character to be converted.
*R the lower-case equivalent of the given character. If the given
character is not an upper-case letter it is returned unchanged.
*D %btolower()%b converts the character %sc%s to its
lower-case equivalent. If %sc%s is not an upper-case letter it is not
converted. Valid upper-case letters are as follows:
*c= `A' to `Z'
*x toupper
*q tolower
*q Convert upper-case letters to lower-case - see tolower
*q Upper-case letters to lower-case, convert - see tolower
*q Lower-case letters from upper-case, make - see tolower
#
*n touch\Helios command
*P Updates the date stamp on a file
*F touch [-c] [-f] <filelist>
*D This command sets the `last altered' date on each file
given as argument to the current date and time. It is usually used in
conjunction with the %bmake%b command, where an automatic recompilation
can be forced by updating all the files' date stamps, as in:
*c=touch *.c
*p If a file does not exist and %s-c%s is not specified, %btouch%b creates
a new zero-length file. The %s-c%s option stops %btouch%b creating a file
if it does not exist.
*p %s-f%s has been included for compatibility with Unix (it does not
actually do anything).
*q Datestamp
*q touch
#
*n toupper\C library function
*P Converts a lower-case letter to its upper-case equivalent.
*I <ctype.h>
*F int toupper(int c);
*A c - The character to be converted.
*R the upper-case equivalent of the given character. If the given
character is not a lower-case letter it is returned unchanged.
*D %btoupper()%b converts the character %sc%s to its
upper-case equivalent. If %sc%s is not a lower-case letter, it is not
converted. Valid lower-case letters are as follows:
*c= `a' to `z'
*x tolower
*q toupper
*q Convert lower-case letters to upper-case - see toupper
*q Lower-case letters to upper-case, convert - see toupper
*q Upper-case letters from lower-case, make - see toupper
#
*n _Trace\System library
*P Place information in the trace vector
*F _Trace( word a,b,c);
*A a,b,c - Data to be recorded
*D This function acts like %b_Mark()%b except that it also
records up to three words of data.
*x _Mark
*q Trace vector - place info in
#
*n true\Helios command
*P Generates a TRUE condition
*F true
*D The %btrue%b command returns the status value TRUE (zero)
from a dummy program to say that it has succeeded. It is mainly used in
Shell scripts.
*p %btrue%b is the converse of %bfalse%b.
*q true
*q Shell scripts
*x false
#
*n tty\Helios command
*P Displays terminal's name on the standard output
*F tty [-s]
*D The %btty%b command outputs the name of the terminal
associated with the standard input (stdin) to the standard output
(stdout). The name %btty%b returns should be the same as that returned by
the function %bttyname()%b. The output, if %b-s%b is not specified, should
be a single line, containing an absolute pathname that represents the
standard input to this command; for example,
*c=/IO/window/newuser
*p This command is particularly useful for finding out the controlling
terminal for the current task.
*p The option %b-s%b ensures that the terminal name is not written to the
standard output. The option affects the exit status (where valid exit
values are: 0 stdin is a terminal; 1 stdin is not a terminal; >1 an
undefined error). It is like using the function %bisatty()%b.
*q Terminal name
*q tty
*x ttyname
*x test
*x isatty
#
*n ttyname\Posix library function
*P Determine the terminal device name
*I <posix.h> ; <unistd.h>
*F char *ttyname (int fd);
*A fd - File descriptor
*R A NULL pointer if %sfd%s is not a valid file descriptor
associated with the terminal device.
*D %bttyname()%b returns a pointer to a string containing the
null-terminated pathname of the terminal associated with the file
descriptor %sfd%s. Notice that the pointer indicates a static area of
memory that will be overwritten by the next call to %bttyname()%b.
*p %bttyname()%b may point to static data that is overwritten by each call.
*q Terminal device name, find - see ttyname
#
*n umask\Posix library function
*P Set a file mode creation mask
*I <sys/types.h> ; <sys/stat.h>
*F int umask(mode_t cmask);
*A cmask - File mode creation mask
*R The previous value of the file mode creation mask.
*D %bumask()%b sets the file mode creation mask of the task to
the value corresponding to the argument %scmask%s. Only the following file
permission bits of %scmask%s are used:
*l S_IRWXU
*t Read, write, and execute permission for the file owner
*l S_IRUSR
*t Read permission is granted to file owner
*l S_IWUSR
*t Write permission is granted to file owner
*l S_IXUSR
*t Execute permission is granted to file owner
*l S_IRWXG
*t Read, write, and execute permission granted for group
*l S_IRGRP
*t Read permission is granted to group owner
*l S_IWGRP
*t Write permission is granted to group owner
*l S_IXGRP
*t Execute permission is granted to group owner
*l S_IRWXO
*t Read, write, and execute permission granted for other tasks
*l S_IROTH
*t Read permission is granted for other tasks
*l S_IWOTH
*t Write permission is granted for other tasks
*l S_IXOTH
*t Execute permission is granted for other tasks
*p where `file owner' is equivalent to the effective user ID of the task,
and `group owner' is the owner of the file, which may not necessarily
match the effective user ID of the task, but where the file group matches
the effective group ID of the task or one of its supplementary group IDs.
`Other tasks' are where the owner ID of the file is not the same as the
effective user ID of the task, and the group ID of the file matches
neither the effective group ID nor any of the supplementary group IDs.
*p Mode creation masks are used in %bopen()%b, %bcreat()%b, %bmkdir()%b,
and %bmkfifo()%b. Notice that bit positions set in %scmask%s are cleared
in the mode of the created file.
*x open
*x creat
*x mkfifo
*x chmod\000075
*x mkdir\000403
*q File mode creation mask, set - see umask
*q Creation mask - see umask
*q Mask - see umask
#
*n unalias\Helios command
*P Removes all aliases that match a given pattern
*F unalias <pattern>
*D You can use the %balias%b shell command to create an alias.
You can then remove the %sname%s you specified as an alias with the
%bunalias%b command. %bunalias%b looks for aliases whose names match
%spattern%s and then removes them. If nothing matches %spattern%s, it does
nothing. For further details on this subject, see the document %sHelios%s
%sShell%s, in the %sHelios%s %sOperating%s %sSystem%s manual.
*p You can remove all aliases by specifying * as %spattern%s.
*q Shell commands
*q Pattern matching
*q unalias
*x alias
#
*n uname\Posix library function
*P Store information identifying the current operating system
*I <sys/utsname.h>
*F int uname (struct utsname *name);
*A name - Pointer to structure holding information.
*R A value that is >=0 on the successful completion of the
function; otherwise, it returns -1 and sets errno to indicate the error
that occurred.
*D %buname()%b stores information identifying the current
operating system in the structure pointed at by the argument %sname%s.
*p The operating system info structure %sutsname%s, used by %buname()%b, is
defined in the header <sys/utsname.h>.
*q uname
*q System identification info, store - see uname
*q Information on the system, store - see uname
*q Storing system identification info - see uname
*q Operating system identification info, store - see uname
*q Current o/s id information, store - see uname
#
*n ungetc\C library function
*P Pushes a character back onto a file stream.
*I <stdio.h>
*F int ungetc(int c, FILE *stream);
*A c - The character to be returned.
*A stream - A pointer to a file stream.
*R the pushed back character if successful, or EOF if
unsuccessful.
*E %bungetc()%b returns EOF if unsuccessful.
*D %bungetc()%b converts %sc%s to an unsigned char and pushes
it back onto the input stream pointed to by %sstream%s. A character must
previously have been read from the file stream. The next use of the
%bgetc()%b family of calls will return %sc%s, unless a repositioning
function has been called in between (%bfflush()%b, %bfseek()%b,
%brewind()%b or %bfsetpos()%b).
*p If %bungetc()%b is called repeatedly on the same stream, without the
file stream being read in the interim, the operation may fail.
*c=#include <stdio.h>
*c= /* Function to read a decimal number from stdin.
*c=    Leaves the next character to be read
*c=    as the one immediately after the number
*c= */
*c=
*c= int get_number(void)
*c= {
*c=  int dec = 0;
*c=  int ch;
*c=
*c=  while (isdigit(ch = getc(stdin))
*c=   {
*c=    dec = dec * 10 + ch - '0';
*c=   }
*c=  ungetc(ch,stdin);
*c=  return(dec);
*c=  }
*x getc
*x fflush
*q ungetc
*q Push character back onto file stream - see ungetc
*q Character - push back onto file stream - see ungetc
*q File stream, push character back onto - see ungetc
#
*n unhash\Helios command
*P Disables internal hash table look up
*F unhash
*D An internal hash table enables you to look up the exact
location of an executed program quickly and efficiently. The %bunhash%b
shell command turns off the hash table facility. This means that you can
then try out new commands without recomputing the hash table.
*q Shell commands
*q unhash
*x rehash
#
*n Unlink\System library
*P Removes an object from a directory
*I <servlib.h>
*F void Unlink(ObjNode *obj, bool dirlocked);
*A obj - pointer to object node
*A dirlocked - specifies locked condition
*D %bUnlink()%b is used to remove an object and a directory.
It performs the inverse operation of Insert(). The directory may be locked
during this operation to prevent other processes seeing an inconsistent
state. If the directory has already been looked (by %bGetTargetDir()%b,
for example) then %sdirlocked%s should be TRUE; otherwise, it should be
FALSE.
*q Insert
*q Unlink
*x Insert
*x GetTargetDir
#
*n unlink\Posix library function
*P Delete a link or a file
*I <posix.h> ; <unistd.h>
*F int unlink(char *path);
*A path - Pointer to file pathname
*R Zero on successful completion; otherwise, it returns -1 and
sets the variable errno to indicate the error.
*E
*l [EACCES]
*t A component of the pathname prefix denies search permission, or write
permission is not available for the directory containing the link to be
removed.
*l [ENOENT]
*t The file indicated by %spath%s does not exist or %spath%s points to an
empty string.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [EPERM]
*t The file named by %spath%s is a directory and the system restricts the
unlinking of directories to tasks with appropriate privileges, and the
calling task does not have these appropriate privileges.
*l [EROFS]
*t The directory entry to be unlinked is part of a read-only file system.
*l [EBUSY]
*t The file indicated by %spath%s cannot be unlinked because it is being
used elsewhere by the system or by another task.
*l [ENAMETOOLONG]
*t %spath%s corresponds to a string that is greater in length than the
value associated with PATH_MAX.
*D This function destroys a link associated with the file
whose pathname is indicated by %spath%s. An open file cannot be unlinked
although its directory entry can be deleted. %bunlink()%b removes the link
for the existing file and decrements its link count by one.
*p When the file's link count becomes zero and no task has the file open,
the space occupied by the file is freed and the file ceases to exist. If
one or more tasks have the file open when the last link is removed, the
removal is postponed until all references to the file have been closed.
*p %spath%s must exist and should not be a directory. Directories can be
removed with %brmdir()%b.
*p If %bunlink()%b fails, nothing happens.
*p %bunlink()%b affects the time-related fields in %sstat struct%s, as
follows:
*l %sst_atime%s
*t Not affected
*l %sst_ctime%s
*t Updated
*l %sst_mtime%s
*t Not affected
*p These times, where applicable, are set to the time %bunlink()%b was
successfully executed on the file. Files on read-only file systems are not
affected.
*x close
*x link
*x open
*x rmdir\000506
*x rename\000496
*q Directory entry, remove - see unlink
*q Delete link - see unlink
*q Delete file - see also unlink
*q Link, delete - see unlink
*q File, delete - see also unlink
#
*n unset\Helios command
*P Removes shell variables with names matching a given pattern
*F unset <pattern>
*D This shell command removes one or more shell variables
whose %sname%ss (see the format for %bset%b) match the pattern
%spattern%s. For example,
*c=unset p*
*p removes all your shell variables starting with the letter `p', such as
`path'. If nothing matches %spattern%s, %bunset%b does nothing; this is
not an error.
*p You can remove more than one %spattern%s on the same command line:
*c=unset abcd *[0-9] *z*
*p %bunset%b compares each %spattern%s in turn, removing any matching
variable(s). The above example removes the shell variable `abcd' as well
as any ending with a digit or including a `z'.
*p You can remove all variables if you specify * as %spattern%s. However,
this is not necessarily such a good idea.
*q Shell commands
*q unset
*x set
*x setenv
*x unsetenv
*x printenv
#
*n unsetenv\Helios command
*P Removes environment variables
*F unsetenv <name>
*D This shell command removes the environment variable with
the name %sname%s. For example,
*c=unsetenv USER
*p removes the environment variable USER. It is not an error for the
variable not to exist.
*q Shell commands
*q unsetenv
*q Removing environment variables
*q Environment variables
*x printenv
*x setenv
*x Environment
#
*n uptime\Helios command
*P Indicates how long a Helios network has been running.
*F uptime
*D the uptime command may be used to find out how long a
Helios network has been running. A typical example might be:
*q Time
*k Days
*k Hours
*k Date
*k Minutes
*k Seconds
*c=% uptime
*c=Mon Nov 12 16:35:05 1990 : up 23 days, 2:06.37
*p The output specifies the current time and date, followed by the number
of days, hours, minutes, and seconds that the system has been up.
#
*n users\Helios command
*P Lists all logged-in users
*F users
*D this command gives a compact list of all the users logged
in to Helios. The command takes no arguments. A typical usage would be:
*c=% users
*c=bart jon jon.1 nick
*c=%
*q users
#
*n utime\Posix library function
*P Set access and modification times for a given file
*I <sys/types.h> ; <utime.h>
*F int utime(char *path, struct utimbuf *times);
*A path - Pointer to file pathname
*A times - Pointer to structure
*R Zero on the successful completion of the function; otherwise,
it returns -1 and sets the variable errno to one of the following codes to
indicate the error.
*E
*l [EACCES]
*t Search permission is denied for a component of the path prefix, or the
value of %stimes%s is NULL and the effective user ID of the task fails to
match the file owner and write access is denied.
*l [ENOENT]
*t The named file does not exist or %spath%s points to an empty string.
*l [ENOTDIR]
*t A component of the pathname prefix is not a directory.
*l [EPERM]
*t The value of the %stimes%s argument is NULL and the effective user ID of
the calling task fails to match the file owner and the calling task does
not possess the appropriate privileges.
*l [EROFS]
*t The named file is on a read-only file system.
*l [ENAMETOOLONG]
*t The argument %spath%s's length is greater than PATH_MAX.
*D This function sets the access and modification times for
the file whose pathname is pointed to by %spath%s.
*p If the %stimes%s argument is NULL, the file's access and modification
times are set to the current time. The calling task must be the owner of
the file or have write permission to do this.
*p If %stimes%s is not NULL, it points to %sstruct utimbuf%s and sets the
access and modification times to the values contained in that structure.
*p %sutimbuf%s is defined in the header file <utime.h>, which includes the
following members:
*f %bType%b\%bName%b\%bDescription%b
*f time_t \actime\Access time
*f time_t\modtime\Modification time
*p The times in this structure are in seconds since 00:00:00 GMT, January
1, 1970.
*p If successful, %butime()%b updates the %sstruct stat st_ctime%s field.
*p It affects the time-related fields in %sstruct stat%s, as follows:
*l st_atime
*t Updated
*l st_ctime
*t Not affected
*l st_mtime
*t Updated
*p Files on read-only file systems are not affected by this function.
*x stat
*q Set access time for file - utime
*q Access time, set - see utime
*q Set modification time for file - utime
*q Modification time, set - see utime
#
*n va_arg\C library function
*P Accesses a variable number of function arguments in a function
definition.
*I <stdarg.h>
*F type va_arg(va_list ap, type);
*A ap - An argument pointer used by the %bva_start()%b,
%bva_arg()%b and %bva_end()%b macros.
*A type - A C type (char, int, float, etc)
*R the first call of %bva_arg()%b, after %bva_start()%b, returns
the value of the next parameter in the parameter list after %sparmN%s.
Subsequent calls to %bva_arg()%b return the values of subsequent
parameters.
*E If the type specified in %bva_arg()%b disagrees with the type of
the parameter in the parameter list (that is, on the stack), the effects
are undefined.
*D Each invocation of %bva_arg()%b extracts a single parameter
value from a variable length parameter list. %bva_arg()%b must have been
initialised by a previous call to %bva_start()%b. %bva_arg()%b should be
followed by a call to %bva_end()%b to ensure a clean termination.
%bva_arg()%b can only be used when there is at least one fixed argument in
the variable length parameter list.
*p For example,
*c= void var_string_print( int number_of_strings, ...)
*c= {
*c=  va_list ap;
*c=
*c=  va_start(ap, number_of_strings);
*c=  while (number_of_strings-- >0)
*c=        + puts(va_arg(ap, char *));
*c=  va_end(ap);
*c= }
*p sends the number of strings defined in number_of_strings, and given in
the parameter list, to standard output.
*x va_start
*x va_end
*x vfprintf
*x vprintf
*x vsprintf
*q va_arg
*q va_start
*q Variable numbers of function arguments, access - see va_arg
*q Accessing variable numbers of function arguments - see va_arg
*q Access variable number of arguments in function definition
*q va_end
#
*n va_end\C library function
*P Clears up after accessing variable arguments.
*I <stdarg.h>
*F void va_end(va_list ap);
*A ap - An argument pointer used by the %bva_start()%b,
%bva_arg()%b and %bva_end()%b macros.
*D %bva_end()%b tidies up after the use of %bva_arg()%b. If it
is not used, abnormal function return may occur.
*p %bva_end()%b can only be used when there is at least one fixed argument
in the variable length parameter list.
*x va_start
*x va_arg
*q va_end
*q Clear up after accessing variable arguments - see va_end
*q Accessing variable arguments, clear up after - see va_end
*q Variable arguments - clearing up after accessing - see va_end
#
*n va_start\C library function
*P Initialises a pointer to a variable number of function
arguments in a function definition.
*I <stdarg.h>
*F void va_start(va_list ap, parmN);
*A ap - An argument pointer used by the %bva_start()%b,
%bva_arg()%b and %bva_end()%b macros.
*A parmN - The name of the last fixed argument in the function
definition.
*R no value is returned.
*E The effects are undefined if the second parameter, %sparmN%s, is
of storage class register.
*D %bva_start()%b is used in conjunction with %bva_arg()%b and
%bva_end()%b. It is an initialisation macro for %bva_arg()%b.
%bva_start()%b can only be used when there is at least one fixed argument
in the variable length parameter list. (See %bva_arg()%b for an example.)
*x va_arg
*x va_end
*q va_start
*q Initialise pointer to variable number of arguments in function
definition- see va_start
*q Pointer to variable number of function arguments - see va_start
*q va_arg
*q va_end
*q Variable number of function arguments - see va_start
*q Function arguments, variable number of - see va_start
#
*n version\Helios command
*P Prints the version number of the shell
*F version
*D The %bversion%b command prints the date of compilation and
version number of the shell. It is useful to check which copy of the
Helios shell you are running.
*q Shell commands
*q version
#
*n vfork\Posix library function
*P Create a new child task which is a copy of its parent
*I <posix.h> ; <unistd.h>
*F int vfork ( void );
*R Zero to the child task and the pid of the child to the parent.
On failure, it sets the errno variable to indicate the error.
*E
*l [EAGIN]
*t No available resources to create a new task or the user's limit has been
exceeded.
*l [ENOMEM]
*t It requires more space than the system can supply.
*D %bvfork()%b is similar to the Unix fork and can be used in
much the same way. It is useful when you wish to create a new system
context for %bexecve%b. It causes the creation of a new child task without
fully copying the address space of the old parent task, which is
hopelessly inefficient in a multi-processor environment. The resulting
child task has a different task identifier from its parent (like all
tasks, its task id is unique). It also has a different parent task
identifier from its parent's parent task identifier (that is, its parent
task id is its parent's task id).
*p While the child task is using its resources, the parent task is
suspended. In the child's task, returning from the procedure that called
%bvfork()%b does not work, because the eventual return from the function
in the parent task would then return to a non-existent stack frame.
Exiting from a block in which local variables are declared and contain
useful values also does not work, for much the same reasons. If you cannot
%bexecve()%b, call %b_exit()%b rather than %bexit()%b, as %bexit()%b
flushes and closes I/O channels, which would throw the parent's standard
I/O data structures into disarray.
*p To facilitate portability and to avoid changing sources, %bfork()%b is
defined as %bvfork()%b in Helios 1.2.
*q Create child task - see also vfork
*q Task creation - see also vfork
*q Child task, create - see also vfork
*x exec
#
*n vfprintf\C library function
*P An alternative form of %bfprintf()%b using a variable argument
list
*I <stdarg.h> ; <stdio.h>
*F int vfprintf(FILE *stream, const char *format, va_list arg);
*A stream - An output file stream.
*A format - A format string.
*A arg - A pointer to a list of variable arguments, initialised
by %bva_start()%b.
*q va_start
*R the number of characters written, or a negative value if an
output error occurs.
*E Returns a negative value if an output error occurs.
*D %bvfprintf()%b is a form of %bfprintf()%b, but the variable
arguments are replaced by a variable argument list. %bva_start()%b should
be called before %bvfprintf()%b, and %bva_end()%b after it.
*c= void write_file(FILE*, char *,...);
*c=
*c= int main(void)
*c= {
*c=  FILE *stream;
*c=  int a = 10;
*c=  char *b = "String";
*c=
*c=  stream = fopen("newfile","w");
*c=  write_file(stream, "%d, %s", a, b);
*c=  fclose(stream);
*c=  return 0;
*c= }
*c=
*c= void write_file(FILE *stream, char *format, ...)
*c= {
*c=  va_list apo;
*c=
*c=  va_start(apo, format);
*c=  fputs("WRITE_FILE TEXT ", STREAM);
*c=  vfprintf(STREAM, format, apo);
*c=  va_end(apo);
*c= }
*c=
*c= /*
*c=   Writes the string "WRITE_FILE TEXT 10, String" to the file newfile
*c= */
*x fprintf
*x vsprintf
*x vprintf
*x va_arg
*x va_start
*x va_end
*q vfprintf
*q Write formatted string to file - see fprintf, vfprintf
*q Formatted strings - see fprintf, vfprintf
*q String format - see fprintf, vfprintf
*q fprintf
#
*n vi\Helios command
*P Text editor
*D A public domain version of the Unix %bvi%b is provided,
called %bstevie%b.
*x stevie
#
*n vprintf\C library function
*P An alternative form of %bprintf()%b using a variable argument
list.
*I <stdarg.h> ; <stdio.h>
*F int vprintf(const char *format, va_list arg);
*A format - A format string
*A arg - A pointer to a list of variable arguments, initialised
by %bva_start()%b.
*R the number of characters written, or a negative value if an
output error occurred.
*E %bvprintf()%b returns a negative value if an output error
occurred. If the format string does not match the variable argument list,
undefined results will occur.
*D %bvprintf()%b is a form of %bprintf()%b, but the variable
arguments are replaced by a variable argument list. %bva_start()%b should
be called before %bvprintf()%b, and %bva_end()%b after it.
*c= void date_printf(char *format, ...)    /* causes any information to be  */
*c= {                                      /* written in a formatted output */
*c=  va_list args;                         /* and preceded by date_string.  */
*c=  va_start(args, format);
*c=  puts(date_string);
*c=  vprintf(format, args);
*c=  va_end(args);
*c= }
*x printf
*x vsprintf
*x vfprintf
*x va_arg
*x va_start
*x va_end
*q vprintf
*q Write formatted string to standard output - see printf, vprintf
*q Formatted strings - see printf, vprintf
*q I/O
*q printf
#
*n vsprintf\C library function
*P A variation of %bsprintf()%b using a variable argument list.
*I <stdarg.h> ; <stdio.h>
*F int vsprintf(char *s, const char *format, va_list arg);
*A s - The string that the formatted string is written to.
*A format - A format string.
*A arg - A pointer to a list of variable arguments, initialised
by %bva_start()%b.
*R the number of characters written, or a negative value if an
output error occurred
*E %bvsprintf()%b returns a negative value if an output error
occurred. If the format string does not match the variable argument list,
undefined results will occur.
*D %bvsprintf()%b is a form of %bsprintf()%b, but the variable
arguments are replaced by a variable argument list. %bva_start()%b should
be called before %bvsprintf()%b, and %bva_end()%b after it.
*c= /* Takes the first string argument from a variable length
*c=    argument list, and concatenates the second two arguments
*c=   into a single string.
*c= */
*c=
*c= void write_secondstring(char *, char *,...);
*c=
*c= int
*c= main( void )
*c= {
*c=  char array[200];
*c=  char *a = "first string";
*c=  char *b = "second string";
*c=  char *c = "third string";
*c=
*c=  write_secondstring(array, "%s %s", a, b, c);
*c=  return 0;
*c= }
*c=
*c= void write_secondstring(char *stringpointer, char *format, ...)
*c= {
*c=  va_list apo;
*c=  char *firststring;
*c=
*c=  va_start(apo, format);
*c=
*c=  /* Move the first argument into firststring */
*c=  firststring = va_arg(apo, char *);
*c=
*c=  /* Write the rest of the arguments to a single string */
*c=  vsprintf(stringpointer, format, apo);
*c=  va_end(apo);
*c=
*c=  /* Display the results */
*c=  printf("vsprintf has %s - va_arg has %s\n", stringpointer, firststring);
*c= }
*c=
*c= /*
*c=   Outputs the string:
*c=   "vsprintf has second string third string - va_arg has first string"
*c= */
*x sprintf
*x vsprintf
*x vfprintf
*x va_arg
*x va_start
*x va_end
*q vsprintf
*q Write formatted string - see sprintf, vsprintf
*q Formatted strings - see sprintf, vsprintf
*q Strings, formatted - see Formatted strings
#
*n Wait\System library
*P Perform a wait operation on a semaphore
*I <sem.h>
*F void Wait ( Semaphore *semaphore );
*A semaphore - Pointer to Semaphore structure
*R Nothing
*D This function decrements the semaphore counter. If the
result is less than zero, it suspends the process until a %bSignal%b is
performed. %bSignal()%b and %bWait()%b are used in a multi-threaded
environment, to stop concurrent access to shared resources, or to allow
not more than a fixed number of threads to access the resource at one
time. Semaphores can also be used to synchronise the activities of
multiple threads.
*x InitSemaphore
*x Signal
*q Semaphore structure
*q Multiple threads
*q Shared resources
*q Concurrent access
*q Perform semaphore wait operation on semaphore
*q Semaphore wait operation - perform on semaphore
#
*n wait\Posix library function
*P Waits for process termination
*I <sys/wait.h> ; <sys/types>
*F pid_t wait( int *stat_loc );
*A stat_loc - pointer to location where information on status of
the child process is stored
*R If a child process is available, %bwait()%b returns its ID. If
%bwait()%b is interrupted by a signal, it returns -1 and sets errno to
[EINTR]. If any other error occurs, %bwait()%b also returns -1 and sets
errno accordingly.
*E
*l [ECHILD]
*t No child process.
*l [EINTR]
*t Interrupted system call. (Value of %s*stat_loc%s left undefined.)
*D %bwait()%b is like %bwaitpid()%b. It suspends the calling
process until any of its child processes are terminated, stopped or
interrupted by a signal. If there is more than one child, the one which
%bwait()%b gets the status of is undefined.
*p %bwait()%b stores the reason for the child's termination in
%s*stat_loc%s. This information can be interrupted by the following
macros, defined by <sys/wait.h>:
*l WIFEXITED(%ss%s)
*t TRUE if the process terminated normally.
*l WEXITSTATUS(%ss%s)
*t Returns exit status passed by child if terminated normally.
*l WIFSIGNALED(%ss%s)
*t TRUE if the child process was interrupted and terminated by a signal.
*l WTERMSIG(%ss%s)
*t Evaluates to the number of the signal that interrupted the child if
WIFSIGNALED is TRUE.
*l WIFSTOPPED(%ss%s)
*t TRUE if the child process was stopped.
*l WSTOPSIG(%ss%s).
*t Evaluates to the number of the signal that stopped the child if
WIFSTOPPED is TRUE.
*p The argument %ss%s in each of these macros is the integer value pointed
at by %sstat_loc%s.
*p If a parent terminates before all of its children, the remaining child
or children will be allocated a new parent process ID.
*q wait
*x wait2
*x wait3
*x waitpid
#
*n wait2\Posix library function
*P Force a parent task to suspend its execution until its child
has terminated (a variant of %bwait()%b)
*I <sys/wait.h>
*F int wait2 (int *stat_loc, int options);
*A stat_loc - Pointer to the location of the status code
*A options - Options modifying the behaviour of the call.
*R A value of -1 (the default) and sets errno to the error. If the
WNOHANG option (see below) is used, and there are no stopped or terminated
child tasks, it returns zero.
*E
*l [ECHILD]
*t No unwaited-for child tasks.
*l [EINTR]
*t %bwait2()%b terminated by a signal. The value pointed to by %sstat_loc%s
may be undefined.
*l [EINVAL]
*t %bwait2()%b called with an invalid %soptions%s value.
*D %bwait2()%b is a variant of %bwait()%b. It suspends the
action of a task until one of its children has terminated. There are two
options available that affect the action of this call. These options are
defined in <sys/wait.h>, as follows:
*l Constant
*t Action
*l WNOHANG
*t Return immediately if no children
*l WUNTRACED
*t Return and return status for stopped children
*p The options may be combined by forming their bitwise inclusive OR.
*p WNOHANG prevents %bwait2()%b from suspending the calling task even if
there are children to wait for. It returns a value of zero to indicate
that there are no children stopped or terminated. WUNTRACED, when set,
returns when the children of the current task are stopped because they
have received a SIGTTIN, SIGTTOU, SIGSTP, or SIGSTOP signal. If a child
task has been stopped by one of these signals, the %sstatus%s information
is interpreted in the following manner. The high order 8 bits of
%sstatus%s (corresponding to the hexadecimal value 0xFF00) will contain
the number of the signal that caused the child task to stop and the low
order 8 bits corresponding to the hexadecimal value 0x00ff will be set to
127.
*x wait
*x wait3
*q Waiting for task termination
*q Task termination
*q Termination of a task
*q Suspending task execution - see wait2
*q Task execution, suspend - see wait2
#
*n wait3\Posix library function
*P Waits or polls for child process termination
*I <sys/wait.h> ; <sys/resource.h>
*F int wait3( int *stat_loc, int options, struct rusage *rusage );
*A stat_loc - location for child termination status
*A options - behaviour of the call
*A rusage - Pointer to the structure %srusage%s.
*D This function behaves exactly like wait2(). It is present
to maintain compatibility with BSD4.3 sources only. The %srusage%s
structure is not filled in.
*x wait2
*x wait
*x waitpid
*q wait3
#
*n waitfor\Helios command
*P Suspends execution until the given server is initialised
*F waitfor <servername>
*D This command mimics the operation of the the waitfor
command in the %setc/initrc%s file. The command waits for the specified
server to be loaded before it terminates. It allows shell scripts to
suspend until the specified server has be initialised.
*q Server initialisation, wait for
*q waitfor
*x sleep\000572
#
*n waitpid\Posix library function
*P Waits for process (task) termination
*I <sys/types.h>; <sys/wait.h>
*F pid_t waitpid(pid_t pid, int * stat_loc, int options)
*A pid - task id
*A stat_loc - pointer to location storing child status
*A options - bitwise inclusive OR of zero or more of flags
defined in <sys/wait.h>
*R If child available, returns value equal to id; otherwise zero.
*D %bwaitpid()%b enables a calling task to get status
information on a child task. It suspends execution until information on
the given child is available. It works like %bwait()%b if %spid%s is -1
and %soptions%s is zero. Other values of pid that affect the action of
%bwaitpid()%b are as follows:
*l >0
*t Specifies task id of single child task
*l 0
*t Requests status on any child task with equal id to calling task
*l <-1
*t Requests status on any child task with equal id to absolute value of pid
*x wait
#
*n WalkList\System library
*P Apply a function to a list
*I <queue.h>
*F word WalkList( List *list, WordfnPtr fn, ...);
*A list - List to be walked
*A fn - Function to apply
*A ... - Optional argument to be used as the second argument to
%sfn%s
*R The sum of the return values of the function %sfn%s
*D %bWalkList()%b scans the supplied list, %slist%s, applying
the function %sfn%s to each node in turn, and returns the sum of the words
returned by its application. %sfn%s itself takes two arguments, a pointer
to the current Node and, optionally, the argument passed to
%bWalkList()%b. Care is taken to obtain a pointer to the next node in the
list before the function is applied so the node may be removed from the
list if desired.
*x SearchList
#
*n wall\Helios command
*P Broadcasts a message to all logged-in users
*F wall
*D The %bwall%b command can be used to send a message to all
users currently logged in. The message will appear on all users' login
windows. The commands reads lines from standard input into a buffer until
end-of-file is reached. The buffer is then written to all login windows.
This command is used mainly just before shutting down the system, for
example
*c=% wall
*c=Warning, I am shutting the machine down in ten minutes.
*c=<CTRL-D>
*c=%
*p Every user would see the following message on their login window.
*c=Broadcast message from shutdown at 13:50
*c=Warning, I am shutting the machine down in ten minutes.
*p For large messages it is conventional to type the message into a file
and then use this file as the standard input for the wall command, for
example:
*c= wall < message
*q login window
*q wall
#
*n wc\Helios command
*P Counts the number of words in a file
*F wc [-l] [-w] [-c] [<filelist>]
*D The %bwc%b command counts items within each of the files
given as arguments, or in the standard input if no arguments are given.
The items counted depend on the flags specified: %s-c%s causes characters
to be counted, %s-w%s counts words and %s-l%s counts lines. If the options
are omitted then %bwc%b assumes %s-lwc%s and counts all of them. If more
than one file is specified then the totals for all of them are also
displayed.
*q wc
*q Word count
#
*n which\Helios command
*P Locates a command
*F which <command1> [<command2>] ...
*D The %bwhich%b command locates where the command names given
are found on disc. When you have a long PATH environment variable set up
there may be some commands with the same name that are in different
directories. The %bwhich%b command tells you which particular command will
be loaded when you issue its name to the shell. For example,
*c=which ls
*p would cause the response:
*c=/helios/bin/ls
*p showing that %bls%b would be loaded from the directory /helios/bin.
*q which
*q PATH environment variable
*q SHELL environment variable
#
*n while\Helios command
*P Executes while a given expression evaluates TRUE
*F while (<expression>) ; <command>... ; end
*D While the specified expression evaluates non-zero (TRUE),
the %bwhile%b shell command continues to execute any commands up to
%bend%b, looping around the command loop until %sexpression%s evaluates to
zero, whereupon execution moves to after %bend%b. Two special commands
affect the usual flow of execution: %bbreak%b and %bcontinue%b. A
%bbreak%b will terminate the loop at any point before %bend%b, moving the
execution to after %bend%b; a %bcontinue%b will continue the loop,
immediately returning execution to the line containing %bwhile%b. If you
input a %bwhile%b sequence at the terminal, it prompts you with a `?' the
first time it passes through the loop. The following example:
*c=% set i=1
*c=% while ($i <= 10)
*c=? echo $i
*c=? @ i=$i + 1
*c=? end
*p displays the integers 1 to 10. Note the use of %bset%b to initialise the
shell variable `i'. This is necessary to prevent the while command
producing an error because it cannot find the shell variable `i'. The
%b@%b command is used to increment `i' by one each time round the loop.
See the description of %b@%b for a full specification of this command.
*q Shell commands
*q while
*x @
*x end
*x foreach
#
*n who\Helios command
*P Shows who is currently logged in to Helios
*F who [am I]
*D this command gives details of which users are currently
logged in to Helios, and the dates when they logged in. For example,
*c=% who
*c=bart                       Nov 12 15:51
*c=jon                        Nov 11 12:40
*c=jon.1                      Nov 12 15:30
*c=nick                       Sep  5 10:20
*p An additional usage of the who command is to give the two arguments [am
I]. The output produced is the same as for the whoami command.
*x whoami
#
*n whoami\Helios command
*P Shows who is logged in at a window
*F whoami
*D This command may be typed in at a shell prompt to display
the current user name. If the command is able to validate the user name it
will be displayed.
*c=% whoami
*c=bart
*p If the command is unable to validate the current user name for some
reason, it may try to guess the current user name.
*c=% whoami
*c=whoami: warning, failed to validate name
*c=whoami: name is probably jon
*x who
#
*n Wildcards\General interest
*P Produces a set of filenames that match a given pattern
*D Whenever you can give a filename as an argument to a
command run from the shell, you can use wildcards as a shorthand method
for entering the name or server names. One of these wildcards is %b*%b,
which instructs the shell to match with as many characters as are
necessary to produce a valid filename. Another wildcard character, %b?%b,
has a similar meaning, but will only match with a single character. You
can also use %b[%b%sabc%s%b]%b to match a single character, but will only
match with a character listed within the brackets.
*p When substituting for wildcards, the shell will use any characters which
are adjacent to the wildcard (if any) to generate a pattern which will be
compared with each of the filenames in a directory. A list of filenames
which match this pattern is then generated and inserted into the command
line in place of the word which contained the wildcard.
*p To determine which directories are searched during wildcard
substitution, you will need to consider the wildcard's position within the
command line. If the character appears within a command name then each of
the directories which have been assigned to the shell variable, path, will
be searched. If, however, the wildcard appears within a command's argument
then only the current directory will be searched.
*p A few examples of wildcard usage are given below.
*l Character
*t Action
*l %b*%b
*t General wildcard. Represents a sequence of characters. For example, to
delete all files in the current directory, type:
*d rm *
*t to delete all files whose name ends with `.c', type:
*d rm *.c
*t and to delete all files in the current directory whose name starts with
`Pe' and ends with `.c':
*d rm Pe*.c
*l %b?%b
*t Wildcard for one character only. For example,
*d ls ?a.c
*t lists all files whose name consists of four characters, where the last
three characters are known to be `a.c', matching aa.c, ba.c, etc.
*l %b[%b...%b]%b
*t Wildcard for one character, but only matches with the specified
characters. For example,
*d od t.[abc]
*t displays the contents of the files t.a, t.b and t.c (if they exist).
*d od t.[a-c]
*t displays the contents of the files t.a, t.b and t.c
*q Wildcards
*q Pattern matching
#
*n Window\General interest
*P Destination for textual output.
*D Helios uses the idea of a text window for all of its
output. These windows are either represented directly on top of a true
windowing system, such as the X Window System or SunView, or else they are
simulated on a text-only terminal or a PC screen. In any of these cases
different windows are used for different outputs: for example, the output
from two different shells, or the output of a command and the debugger,
will go to two separate windows.
*q Windowing systems
*x PC-windows
*x SunView
#
*n Window-server\General interest
*P Provides windowing.
*F /window
*D Unless Helios is running the X Window System, the I/O
server provides a window server called /window. This server provides
either real windowing by way of SunView or a limited type of fixed-size
text window system on a PC. If X is running, the X terminal emulator,
which is itself an X client, runs on a processor somewhere on the network
and it provides its own /window server. In that case, the I/O server's
/window can be disabled.
*q Devices
#
*n Write\System library
*P Write a buffer full of data to the stream
*I <syslib.h>
*F WORD Write ( Stream *stream, BYTE *buffer, WORD size, WORD
timeout );
*A stream - Pointer to stream
*A buffer - Pointer to buffer
*A size - Size of data to be written
*A timeout - Timeout in microseconds
*R Number of bytes actually written.
*D This function writes data to the stream and returns the
number of bytes actually written. If it returns the value -1, an error
occurred during the write. You may pass -1 as the timeout to set the
timeout to infinity.
*q Write buffer full of data to stream
*q Buffer full of data - write to stream
*x Write
*x write\000693
#
*n write\Helios command
*P Sends a message to another user
*F write <user>
*D The %bwrite%b command can be used to send a message to
another user logged into Helios. The message will appear on that user's
login window. The command reads lines from standard input and sends each
line to the other user's window, until end-of-file is reached. If the
message is being typed in as it is sent then pressing CTRL-D will end the
conversation.
*p For example, suppose user bart types the following command:
*c=% write jon.1
*c=Fancy a pub lunch today ?
*c=<ctrl-D>
*c=%
*p Then user jon.1 would see the following message displayed on the login
window.
*c=Message from bart at 12:32
*c=Fancy a pub lunch today ?
*c=EOF
*p If user bart had wished to run a command in the middle of typing in a
message, he could have done this by typing an exclamation mark at the
beginning of a line. For example,
*c=% write jon.1
*c=Fancy a pub lunch in
*c=! date
*c=Date : Mon Nov 12 12:40:04 1990
*c=about ten minutes.
*c=<CTRL-D>
*p For large messages, it is usual to type the message into a file first
and then use this file as the standard input for the write command.
*c= write jon.1 < message
*p The command will refuse to run unless it can validate the user name.
#
*n write\Posix library function
*P Write data to a file from a buffer
*I <posix.h> ; <unistd.h>
*F int write(int fd, char *buf, int nbyte);
*A fd - File descriptor
*A buf - Pointer to buffer
*A nbyte - Number of bytes to be written (not greater than
INT_MAX)
*R The number of bytes actually written, which may not be greater
than %snbyte%s. In the event of failure, it returns a value of -1 and sets
errno to indicate the error that occurred.
*E
*l [EAGAIN]
*t The O_NONBLOCK flag is set for %sfd%s and this would delay the write
operation.
*l [EBADF]
*t %sfd%s is not a valid file descriptor open for writing.
*l [EFBIG]
*t An attempt was made to write to a file extending it to greater in size
than the system maximum (FCHR_MAX).
*l [EINTR]
*t The operation was terminated prematurely on the receipt of a signal.
*l [EINVAL]
*t The value %snbyte%s was greater than PIPE_MAX when writing to a pipe or
FIFO special file.
*l [ENOSPC]
*t No free space left on the device containing the file.
*l [EPIPE]
*t An attempt made to write to a pipe or FIFO that is not open for reading
by any task. A SIGPIPE signal is sent to the task.
*D This function writes %snbyte%ss of data from %sbuf%s to the
file indicated by the open file descriptor %sfd%s.
*p When %sfd%s is associated with a regular file or a file that supports
seeking, the write operation starts from the position indicated by the
file pointer associated with that file. Each write then increments the
file pointer by the number of bytes actually written. If a files does not
support seeking, %bwrite()%b starts to write at the end of the file.
*p If the O_APPEND flag is set, the file pointer is set to the end of the
file before each write operation.
*p %bwrite()%b should only request a %snbyte%s that is equal to or less
than the amount of space available to hold the data being written.
*p If %bwrite()%b receives a signal before writing any data, then it fails,
returns a value of -1 and sets errno to [EINTR]. If %bwrite()%b receives a
signal after starting to write, it can fail and set errno to [EINTR] or it
can simply return the number of bytes actually written, which will be less
than %snbyte%s. For instance, if %bwrite()%b receives a signal while
writing to a pipe, and %snbyte%s is equal to or less than PIPE_BUF, then
it will return the number of bytes written rather than return an error as
above.
*p %bwrite()%b requests to pipes or FIFOs are treated in much the same way
as %bwrite()%bs to other files. There are certain exceptions, however.
There is no file pointer associated with a pipe, and so each write is
appended to the end of the pipe. If %snbyte%s is greater than PIPE_MAX,
%bwrite()%b returns -1 and sets errno to [EINVAL]. Write requests of less
than or equal to PIPE_BUF may not be interleaved with data from other
tasks writing to the same pipe. Writes of greater than PIPE_BUF may have
data interleaved, on arbitrary boundaries, with writes from other tasks,
whether or not the O_NONBLOCK flag of the file status has been set. If
O_NONBLOCK is clear, a write request may cause the task to block, but
normally it returns %snbyte%s. If O_NONBLOCK is set, %bwrite()%b will not
block the task. If %snbyte%s is greater than PIPE_BUF, and some data can
be written without blocking the task, %bwrite()%b writes what it can and
returns the number of bytes actually written; otherwise, it returns -1 and
sets errno to [EAGAIN].
*p If O_NONBLOCK is clear for a file descriptor that supports nonblocking
writes but which cannot accept data immediately, %bwrite()%b blocks until
the file can accept the data. If O_NONBLOCK is set for the same file, and
if some data can be written without blocking the task, the %bwrite()%b
writes what it can and returns the number of bytes actually written;
otherwise, it returns -1 and sets errno to [EAGAIN].
*p This function affects the time-related fields of the %sstat%s structure,
as follows:
*l st_atime
*t Not affected
*l st_ctime
*t Updated
*l st_mtime
*t Updated
*p These times, where applicable, are set to a time greater than or equal
to the time %bwrite()%b actually transferred some data and equal to or
less than the time of the last %bclose()%b of the file. Files on read-only
systems are not affected.
*x Write
*x pipe
*x creat
*x dup
*x fcntl
*x pipe
*x signal\000564
*x open
*x lseek
*x read
*q Write data to file from buffer
*q Data to file from buffer, write
#
*n wsh\Helios command
*P Creates a new shell window
*F wsh [<processor>]
*D When you issue this command the shell creates a new child
shell in a window on the screen and sets you in it. Each time you repeat
the command on a machine with a graphics screen, it creates a new window
until there is no more room for any more windows. To move from window to
window, you can use the mouse to move the cursor over the desired window.
The window currently in use is indicated by a different foreground colour
in the title bar at the top of the window; other windows have their title
bar in the background colour.
*p If you are using a machine without a graphics screen %bwsh%b still
causes a new window to be created, although you cannot actually see a
window created. In this case you can select the next window by pressing
the key combination ALT-F1. This combination of keys cycles you around each
of the virtual windows, displaying the current window name, until you
reach the window you want.
*p You can issue commands within a new window in just the same way as you
can from the initial window; each window runs its own shell which may be
located within a different current directory, have its own shell variables
and so on. If you type a command which takes a long time in one window
then you can switch to another window and issue another command.
*p It is possible to use %bwsh%b to create a window and shell combination
running on another processor. Simply specify the processor name after the
%bwsh%b command. In this case a window is created by the local window
manager, but the shell is created in the processor specified. Any command
issued in that shell will execute in parallel with any command issued in
the original shell. %bwsh%b can be used therefore to run different windows
connected to different shells, each in its own processor.
*q wsh
*q Shell windows
*q Windows
*q Child shells
#
*n XchMsg\System library
*P Exchanges a message with a peer
*I <message.h>
*F word XchMsg(MCB *txmcb, MCB *rxmcb);
*A txmcb - message to send
*A rxmcb - destination for received message
*R Helios error code
*D This function exchanges a pair of messages with some other
process. First the message in %btxmcb%b is sent, then the function waits
for a message in return, using %brxmcb%b. XchMsg() will retry the
transmission if the reception times out, or gets any other recoverable
error (such as Congestion). If a message is received successfully, or a
more serious error occurs, the error or FnRc field is returned.
*p If XchMsg() is called either with %btxmcb == rxmcb%b or %brxmcb == NULL%b then the same MCB will be used correctly for both transmission and
reception.
*q XchMsg
*x PutMsg
*x GetMsg
#
*n xlatecr\Helios command
*P Translates CR/LF sequences to LF and the other way about
*F xlatecr [-r] [<filelist>]
*D %bxlatecr%b translates carriage return/linefeed sequences
(CR/LF) in its argument files into linefeeds (LF). The -r option puts
%bxlatecr%b into reverse, translating LFs into CR/LFs.
*p If you do not specify any input files, %bxlatecr%b reads stdin and sends
the translated output to stdout.
*p It is not usually necessary to use %bxlatecr%b on host systems such as
MS-DOS, as CR/LF sequences in text files are automatically translated when
read.
*q xlatecr
#
*n ZapProcess\System library
*P Frees the space used by a process.
*I <nonansi.h>
*F void ZapProcess(void *process);
*A process - A pointer returned by NewProcess.
*q RunProcess
*q NewProcess
*D %bZapProcess()%b may be used on the result of a call to
%bNewProcess()%b as an alternative to %bRunProcess()%b. It releases the
space used by the process without attempting to execute it.
*p %bCAUTION:%b %bZapProcess()%b must not be used after a call to
%bRunProcess()%b has activated the process, or the system will almost
certainly crash.
*x Fork\000232
*x RunProcess
*x NewProcess
*q ZapProcess
*q Free space used by process - see ZapProcess
*q Space used by process, free - see ZapProcess
*q Process space, free - see ZapProcess
#
*n  bsplit\Helios command
*P  Split a large file into manageable chunks
*F  bsplit [-<number>] [-d] [-j] <filename> [filename]
*D  Given a very large file such as a tar archive it may
    sometimes be necessary to split the file into a number of smaller
    chunks, for example to write it onto floppy discs or to send it via
    electronic mail. The bsplit program may be used to do this. It can also
    be used to join the resulting files back together to reproduce the
    original.
*p  The number specifies the size of the output files in bytes. The
    default size is 700000,  resulting in output files which can be
    written to ordinary 3.5'' floppy discs.
*p  The %b-d%b option can be used to enable diagnostics.
*p  The %b-j%b option specifies that a set of files should be joined
    together to rebuild a large file, rather than splitting a large file
    into smaller ones.
*p  The first filename specifies the file to be split, or the target file
    for the join. For example, the command line:
*c=split backup.tar
*p  can be used to take the file %bbackup.tar%b and generate a number of
    split files %bxaa%b, %bxab%b, and so on. The command line:
*c=split -j backup.tar
*p  takes the files %bxaa%b, %bxab%b, and so on and combines them to
    rebuild the file %bbackup.tar%b.
*p  It is possible to specify an alternative output file base instead of
    %bx%b. For example, the following command line:
*c=split -350000 backup.tar backup.
*p  would take the file %bbackup.tar%b and split it into smaller files
    %bbackup.aa%b, %bbackup.ab%b, and so on, each file taking 350000 bytes
    to fit onto a 5.25'' floppy disc.
*x compress
*x atob
*x btoa
*x tar
#
*n  buildinc\Helios command
*P  build an include disc binary image.
*F  buildinc
*D  To speed up compilations of C programs Helios has a %b /include%b
    server. This server can be run while the system is booting up, reads
    in the include disc binary image %b/helios/lib/incdisk%b, and
    provides a simple file server with the standard C header files. The Helios
    compiler driver %bc%b will check for the presence of a
    %b/include%b server in the network and will use it in preference
    to any disc-based header files. As a result the number of file accesses
    during a typical compilation is greatly reduced, with corresponding
    performance benefits.
*p  The include disc binary image has to be generated before the %b/include%b
    server can be run. This is the purpose of the %bbuildinc%b program.
*p  No arguments are required.
*p  The %bbuildinc%b program is not supplied in a compiled form. Instead
    the sources may be found in the directory
*c=/helios/users/guest/examples/servers/include
*p  together with the sources of the %b/include%b server itself.
*x include
#
*n  colrm\Helios command
*P  to remove selected columns from a text file
*F  colrm [startcol] [endcol]
*D  The %bcolrm%b program reads textual data from its
    standard input, processes this data one line at a time, and writes the
    result to standard output. In each line the specified columns are
    removed. If only the start column is specified then all text from the
    start column to the end of the line is removed. Column numbering starts
    with 1.
#
*n  comm\Helios command
*P  to read in two files containing sorted data and display the
    lines in command and the lines not in common.
*F comm [-1 | -2 | -3 | -12 | -13 | -23] <file1> <file2>
*D  the %bcomm%b command reads in two files which are assumed to
    be sorted in ASCII sequence and produces information about the lines these
    two files have in common and the lines that are different. It is possible
    to specify %b-%b instead of a file name to specify that the command
    should use standard input for one of the files.
*p  By default the command produces three columns of output. The first
    column lists those lines which only occur in the first file. The second
    column lists those lines which only occur in the second file. The last
    column lists those lines which occur in both files. It is possible
    to suppress particular columns of output by specifying them on the command
    line. For example, the command:
*c=comm -12 orig.srt new.srt
*p  takes the two files %borig.srt%b and %bnew.srt%b and lists the
    lines which are common to both files.
*x sort
*x diff
*x cmp
*x uniq
#
*n  diag_sm\Helios command
*P  to control diagnostics options in the Session Manager
*F  diag_sm
*F  diag_sm redirect > logfile
*F  diag_sm revert
*F  diag_sm most
*F  diag_sm all
*F  diag_sm none
*D  The Session Manager is the component of Helios responsible
    for the various user sessions running in a multi-user system. The
    %blogin%b program interacts with the Session Manager to create a new
    session. When a user logs out it is the Session Manager that is
    responsible for running another instance of the %blogin%b program,
    allowing another user to log in.
*p  The diag_sm command can be used to manipulate various diagnostics
    options in the Session Manager. By default the command gives a simple
    menu listing the options currently enabled and allowing the user to
    toggle particular options. A help option is available to describe the
    various diagnostics.
*p  By default the Session Manager will send its diagnostics to its
    standard output stream, typically the error logger or a console window.
    It is possible to redirect this output to a file or some other device
    using the %bredirect%b option. The %brevert%b option causes the
    Session Manager to switch back to the original output destination.
*p  It is possible to bypass the menu using the %bmost%b, %ball%b, or
    %bnone%b options on the command line.
*x diag_ns
*x diag_tfm
#
*n  fold\Helios command
*P  to fold long lines in a text file
*F  fold [-width] [file]
*D  The fold command reads in the specified file or files, or
    the standard input if no files are specified. All lines in the file that
    are longer than the specified width are folded, in other words broken up
    over two or more lines. The default width is 80 columns. The output is
    sent to standard output.
*p  If the input data contains tab characters then the specified width
    should be multiple of eight columns.
#
*n  include\Helios command
*P  to speed up the compilation of C programs.
*D  To speed up compilations of C programs Helios has a %b/include%b server.
    This server can be run while the system is booting up, reads in the
    include disc binary image %b/helios/lib/incdisk%b, and provides a
    simple file server containing the standard C header files. The Helios
    compiler driver %bc%b will check for the presence of this server and
    will use it in preference to any disc-based  header files. As a result
    the number of file accesses during a typical compilation is greatly
    reduced, with corresponding performance benefits.
*p  The include disc binary image has to be generated before the
    %b/include%b server can be run. This is the purpose of the
    %bbuildinc%b program.
*p  The include server is usually started up from inside the network
    resource map, for example:
*c=Processor SCSI { ~01, ~02, ~03, ~04; system;
*c=    # start other servers, for example a file server
*c=    run /helios/lib/include;
*c=}
*p  Please note that the server does not require any environment information,
    and hence it cannot be run from the shell.
*p  The %binclude%b server is not supplied in a compiled form. Instead
    the sources may be found in the directory
*c=/helios/users/guest/examples/servers/include
*p  together with the sources of the %bbuildinc%b program.
*x buildinc
#
*n  rev\Helios command
*P  to reverse the characters on a line
*F  rev [filename]
*D  The %brev%b command reads in the specified files one
    line at a time, or from standard input if no files are specified.
    The order of characters on each line is then reversed, and the results
    are written to standard output.
#
*n  sysbreak\Helios command
*P  to split a Helios nucleus into its components.
*F  sysbreak <nucleus> <components>
*D  The standard Helios nucleus consists of a number of
    components. It is possible to construct custom nuclei which
    contain additional software. For example, if a network of processors is
    going to be used solely for running C programs then it may be desirable
    to embed the Posix and C libraries into the nucleus, thus avoiding
    delays while resident libraries are loaded into memory dynamically. The
    sysbuild command can be used to construct a custom nucleus.

*p  Before a custom nucleus can be constructed it is necessary to
    extract the main components from some existing nucleus. This can
    be done with the %bsysbreak%b command. Typically this command
    is used as follows:
*c=sysbreak /helios/lib/nucleus kernel.i syslib.i servlib.i \
*c=     util.i nboot.i procman.i loader.i
*p  This would split the standard Helios nucleus into its components,
    which would be written to files in the current directory.
*x sysbuild
#
*n  sysbuild\Helios command
*P  to construct a Helios nucleus from its components
*F  sysbuild <nucleus> <components>
*D  Helios provides a facility for building a custom nucleus.
    There are two main uses for this. First, when building a Helios system
    that boots from a ROM it is necessary to construct a special nucleus
    which incorporates a ROM filing system. Second, for some networks
    it may be possible to improve performance by building and using a
    custom nucleus. For example, if a network is used mainly for running
    taskforces written in C then it is possible to construct a custom
    nucleus which contains the resident C and Posix libraries as well
    as the pipe server, thus avoiding the cost of loading these into
    memory at run-time. There will be a small time penalty during the
    bootstrap phase because of the larger nucleus, but this will be
    more than offset by the faster application load times.
*p  To construct a custom nucleus it is first necessary to break up an
    existing nucleus into its components. This can be done with the
    %bsysbreak%b command. A new nucleus can then be constructed
    with %bsysbuild%b, for example:
*c=sysbuild /helios/lib/nucleus.C kernel.i syslib.i \
*c=    servlib.i  util.i nboot.i procman.i loader.i \
*c=    /helios/lib/pipe /helios/lib/Posix \
*c=    /helios/lib/Clib /helios/lib/FpLib.t8
*p  The %bhost.con%b file or the network resource map can then
    be modified to use this new nucleus in preference to the
    existing one.
*x sysbreak
#
*n  yes\Helios command
*P  To be repetitive
*F  yes [word]
*p  By default this command will continuously output %by%b to its
    standard output stream. If a word is specified then this is used
    instead of %by%b. The command continues running until interrupted
    by a signal.
#
*n ftp\Helios command
*P Enables users to transfer files between network hosts.
*F ftp [-v] [-d] [-i] [-n] [-g] [host]
*D %bftp%b is the user interface to the ARPANET standard File Transfer Protocol.
*p %shost%s is the name of the client host. If specified, %bftp%b will
open a connection to the corresponding %bftpd%b on that machine.
If you omit %shost%s, %bftp%b will start up the command interpreter
to handle commands locally.
You can find out what commands are available by giving the command
%bhelp%b or by typing a question mark on a line by itself. Here is
a quick list, similar to what would be displayed if you requested such
general assistance.
*c=!           delete      mdelete     proxy       runique
*c=$           debug       mdir        sendport    send
*c=account     dir         mget        put         size
*c=append      disconnect  mkdir       pwd         status
*c=ascii       form        mls         quit        struct
*c=bell        get         mode        quote       sunique
*c=binary      glob        modtime     recv        system
*c=bye         hash        mput        remotehelp  tenex
*c=case        help        nmap        rstatus     trace
*c=cd          image       nlist       rhelp       type
*c=cdup        lcd         ntrans      rename      user
*c=close       ls          open        reset       verbose
*c=cr          macdef      prompt      rmdir       ?
*p To find out specific details about a particular command, specify the
command's name as an argument to %bhelp%b.
Most commands affect files or directories on the remote machine. For example,
%bcd%b changes your directory to a directory on the remote machine
to which you are connected. To change directory to a directory on your
local machine, use %blcd%b.
*p To terminate %bftp%b, type %bquit%b or %bbye%b. To close
a connection without terminating the session, use %bclose%b or
%bdisconnect%b.
*p To abort a file transfer, press CTRL-C (terminal interrupt). If %bftp%b
is waiting for a remote reply, it will ignore the interrupt until it is
ready. You may find in some circumstances, however, that
you have to kill %bftp%b instead.
*p To retrieve remote files, use %brecv%b, %bget%b or %bmget%b.
To send a local file to a remote machine, use %bsend%b,
%bput%b or %bmput%b.
*p Notice that the %bm%b before the %bput%b or %bget%b
commands in %bmput%b and %bmget%b
means that %bftp%b should expect multiple file transfers.
Most commands expect to affect a single file; this may be confusing
with familiar commands such as %brm%b, which under %bftp%b will
only remove one remote file given as argument.
*p %bftp%b processes filename arguments according to the following rules:
*l If you specify - in place of a filename, %bftp%b takes input from
%sstdin%s or sends output to
%sstdout%s, depending on context.
*l If the first character of the filename is |, %bftp%b interprets the
remainder of the argument as a shell command to which the output is piped.
*l If `globbing' is enabled, it expands
local filenames according to %bglob%b shell command rules.
*l If the %brecv%b, %bmget%b and %bget%b commands are not given
local filenames, the local filename is considered to be the same as
the remote filename.
*l If the %bsend%b, %bmput%b and %bput%b commands are not
given remote filenames, the remote filename is considered to be the same as
the local filename.
*p Parameters that affect file transfer are as follows:
*l %stype%s
*t This may be ascii or image (binary).  Ascii is the default type.
*l %smode%s, %sform%s, and %sstruct%s
*t These take default values only: %sstream%s mode, %sstream%s structure and %sfile%s format.
*p You may specify the following
options at the command line, or to the
command interpreter:
*l %b-v%b
*t Turns verbose mode on. All responses from the remote server will be shown and data transfer statistics will be reported in full.
*l %b-n%b
*t Stops auto-login on connection.
If auto-login is enabled, %bftp%b consults the user's %b.netrc%b for an entry for the remote machine.  If it cannot find such an entry, it will prompt the user for a login id and, if necessary, for a password as well.
*l %b-i%b
*t Stops interactive prompting.
*l %b-d%b
*t Enables debugging.
*l %b-g%b
*t Disables filename globbing.
#
*n  ping\Helios command
*P  A diagnostic tool that sends echo requests over the network.
*F  ping [-r] [-v] host [packetsize] [count]
*D  %bping%b is a network maintenance tool that can be used to isolate
 inter-network problems.
*p  %bping%b acts by sending an ICMP/IP echo request datagram (a %bping%b)
 to other network hosts to provoke an echo response from a host or gateway.
 Each ECHO_REQUEST datagram has an IP and
 ICMP header, a %btimeval%b datastructure, and lastly a number
 of bytes of padding to fill out the rest of the packet. (The
 default length for a datagram is 64 bytes, but it can be changed
 using the %bpacketsize%b option.)
*p  The arguments are as follows:
*l -r
*t  Bypasses the usual %brouting%b tables, sending
 the %bping%b directly to a host on an attached network. An error occurs
 if the target host is not on a network that is attached
 directly to the originating host's network.
*l  -v
*t  Provokes %bverbose%b output; that is, it lists any ICMP packets other than
 ECHO_RESPONSE that it receives.
*l  host
*t  Represents the target host (IP address or host name string). The
 identification must match a known host in the %bhosts%b file.
*l  packetsize
*t  Allows you to specify a different byte size for the datagram packet
 (the default is 64).
*l  count
*t  Represents the number of times the request is to be sent (optional).
*p  %bping%b sends one echo request datagram per second, and then
 returns one line of output for each corresponding response it receives.
 You can specify %bcount%b number of requests.  In which case, as
 %bping%b only produces output if it gets a response from a request,
 you should get exactly %bcount%b number of responses and %bcount%b number of lines of
 output if all is going well.
*p  %bping%b continues until it has:
*l -
*t Received all the responses it expects
*l -
*t Timed out
*l -
*t Terminated after receiving an interrupt signal
*p  Each successful response provokes one line of output.
*k ethernet
#
*n  rcp\Helios command
*P  copies files between machines
*F  rcp filename1 filename2
*F  rcp [-r] filename ... dirname
*p  %brcp%b stands for remote copy. It carries out remote file copying over
 the network in the same way that %bcp%b does within one machine.
 The arguments %bfilename%b, %bfilename1%b, %bfilename%b
 and %bdirname%b refer to remote or local filenames or directory names.
 Remote names are given as
*c=  hostname:pathname
*c=  hostname.remoteusername:pathname.
*p  Local names are as usual, although they must
 not include a colon character so as not to be confused with a remote file
 description.
*p  The optional flag %b-r%b indicates that the copying should be recursive,
 repeatedly copying the contents of any subdirectories below %bfilename%b.
 If more than one file is being copied, its destination name must be that
 of a directory.
*p  Within a remote filename description, %bpathname%b is usually assumed to be relative to your home login directory
 on the remote host %bhostname%b. Your local user id must match exactly
 with one on remote host %bhostname%b for the remote copy to take place,
 unless you specify %bremoteusername%b as being the name of the
 file owner on remote host %bhostname%b.
*x cp
*k ethernet
#
*n  rlogin\Helios command
*P  attempts to login on a remote host.
*F  rlogin rhost [-ec ] [-l user] [-8] [-L]
*D  %brlogin%b connects your terminal to remote host %brhost%b.
*p Each host has a file %b/helios/etc/hosts.equiv%b which contains a list of
    the names of trusted remote hosts and users. If you are listed as
    being trusted on the %bhosts.equiv%b file on the remote machine, you
    will not need to give your password in order to login. The
    %b.rhosts%b file is a private version of %bhosts.equiv%b and can
    override the entries given there to effect automatic login.
    If your username or %buser%b is not listed as being trusted, %brlogin%b
    will send the login prompt and request a password.
*p  The options accepted by %brlogin%b are as follows:
*l  -8
*t  Allows an eight-bit input data path.
*l  -L
*t  %blitout%b mode (provided for compatibility with 4BSD).
*l  -e%sc%s
*t  Sets up escape character %sc%s. There should be
    no space between option flag %b-e%b and character %sc%s.
*x telnet
*x rsh
*k ethernet
#
*n  rsh\Helios command
*P  runs a command in a remote shell.
*F  rsh host [-l user] [[-n] command]
*D  %brsh%b opens a connection to %bhost%b, and executes %bcommand%b.
*p The local stdin will then go directly to the remote command, the remote
    command's stdout will go to the local stdout, and the stderr of the remote
    command will go to the local stderr. Any interrupts generated locally
    will go automatically to the remote shell.
*l  %bhost%b
*t  This argument must match a name given in %bhelios/etc/hosts%b.
*l  %buser%b
*t  This is only necessary if the name is different from
    the local username. Notice that, unlike %brlogin%b, %brsh%b will not
    check passwords.
*l  %bcommand%b
*t  If you run %brsh%b without giving %bcommand%b, %brsh%b
    will act like %brlogin%b
*p  Any quoted shell metacharacters are interpreted on the remote machine; unquoted
    shell metacharacters are interpreted on the local machine.
    If a link is made to %brsh%b using the name of a machine, then
    the program will detect this and use this as the destination host name.
    On files systems which cannot support links, this can be simulated by copying
    %brsh%b to files of the appropriate name at the expense of extra disc usage.
    Additionally if no command is given then %brsh%b executes %brlogin%b.
*p These features may be combined to make remote execution a little more natural.
    For example, suppose you have a remote machine %bsparky%b which you use
    frequently. Put a link to, or copy of, %brsh%b, called %bsparky%b,
    into one of your command directories. Now, commands can be executed on
    %bsparky%b by: %bsparky <command>%b
    and you can log into %bsparky%b with the simple command %bsparky%b
*x rlogin
*x telnet
*k ethernet
#
*n  setterm\Helios command
*F  sets the tty server terminal type.
*F  setterm ttytype
*D  This program tells the ttyserver to change to a new terminal type.
*p The single argument must be a terminal name which will match an entry in
    the termcap file. The program must be run in a window supported by the
    tty server.
*p  Under Helios all programs use ANSI standard escape
    sequences to interact with terminals. The IO server implements these
    codes directly, but serial lines and remote sessions may have some other
    form of terminal attached to them. In order for the tty server to present
    the effect of any ANSI sequence it must be informed what kind of terminal
    it is dealing with and translate the codes accordingly. In the case of
    remote sessions the tty type will by set automatically, but in the case
    of serial line sessions, the type must be set by the user.
*k ethernet
#
*n  telnet\Helios command
*P  provides a user interface to the TELNET protocol.
*F  telnet [host [port]]
*D  %btelnet%b is used to communicate with another host using the TELNET
    protocol.
*p If it is invoked without any arguments, %btelnet%b
    enters command mode and displays the prompt %btelnet>%b. If invoked
    with arguments it opens a connection to the given host in exactly the
    same way as it would if the internal command %bopen%b
    (given below) was invoked.
*p  Once a connection has been opened %btelnet%b enters input mode, which
    can be line by line or character by character, depending on what the
    remote host requires.
*p  The internal commands are as follows:
*c=  ?        close    display   mode
*c=  open     quit     send      set
*c=  status   toggle   z
*l  %b?%b %s[command]%s
*t  Displays a summary of available commands.
*l  %bclose%b
*t  Closes a %btelnet%b session.
*l  %bdisplay%b %s[arg ...]%s
*t  Displays %bset%b or %btoggle%b values.
*l  %bmode%b %bline%b | %bcharacter%b
*t  Sets the mode type to line-by-line or characters.
*l  %bopen%b %shost [port]%s
*t  Opens a connection to a named host via either a named port or the default
    one.
*l  %bquit%b
*t  Closes a session and exits.
*l  %bsend%b %sarg...%s
*t  Sends one or more special character sequences to the remote host.
    A full description of all the accepted arguments to %bsend%b
    can be found in the summary for %btelnet%b in the reference
    section or in the BSD reference documentation or that of SUNOS or Unix 5.4.
    However, they include:
*l
*t  %bescape%b (sends the current Escape character)
*l
*t  %bsynch%b (sends the SYNCH sequence)
*l
*t  %bbrk%b (sends the Break sequence)
*l
*t  %bip%b (sends the Interrupt Process sequence)
*l
*t  %bao%b (sends the Abort Output sequence)
*l
*t  %bayt%b (sends the Are You There sequence)
*l
*t  %bec%b (sends the Erase Character sequence)
*l
*t  %bel%b (sends the Erase Line sequence)
*l
*t  %bga%b (sends the Go Ahead sequence)
*l
*t  %bnop%b (sends the No OPeration sequence)
*l  %bset%b %sarg value%s
*t  Sets a telnet variable to the given value. A full description can be
    found in the full formal documentation of %btelnet%b.  Here is a
    quick list of the possible variables: %becho%b, %beof%b, %berase%b,
    %bescape%b, %bflushoutput%b, %binterrupt%b, %bkill%b and %bquit%b.
*l  %bstatus%b
*t  Shows the current status of %btelnet%b.
*l  %btoggle%b %sarg...%s
*t  Toggles between TRUE and FALSE for the various arguments to control telnet's
    response to events. Here is a quick list of the possible arguments:
*l
*t  %blocalchars%b Initially TRUE for line-by-line and FALSE for character at
    a time mode.
*l
*t  %bautoflush%b Initially TRUE.
*l
*t  %bautosynch%b Initially FALSE.
*l
*t  %bcrmod%b (Carriage return mode) Initially FALSE.
*l
*t  %bdebug%b Initially FALSE.
*l
*t  %boptions%b Initially FALSE.
*l
*t  %bnetdata%b Initially FALSE.
*l  %bz%b
*t  Suspends %btelnet%b from the shell.
*x rlogin
*x rsh
*k ethernet
#
*n  ttyserv\Helios command
*P  to provide terminal functions on a stream
*F  /helios/lib/ttyserv [-i path] [-o path] [-l path] [-n name] [-d device]
   [-w] [-s] [-p] [-u]
*D  This is a server which provides terminal emulation, including line
    editing, ANSI escape sequence interpretation and multiple full screen
    windows.
*p The exact form of the supporting device is determined by the
    driver loaded into the tty server. Two drivers are currently supplied:
    %btpseudo.d%b which emulates Unix pseudo terminals, and %btserial.d%b
    which uses a serial stream.
*p  The options are as follows:
*l  %b-i%b %spath%s
*t  Use the stream %spath%s for keyboard input.
*l  %b-o%b %spath%s
*t  Use the stream %spath%s for screen output.
*l  %b-l%b %spath%s
*t  Use the stream %spath%s for input and output.
*l  %b-n%b %sname%s
*t  Use %sname%s as the server name, if this option is absent
    the name used will be %btty.N%b where %bN%b is the lowest
    integer not already in use. If the pseudo-tty device is being
    used, it will use the same server name with the first character
    changed to a `p' (for example %bpty.0%b for %btty.0%b).
*l  %b-t%b %stype%s
*t  Initialize the ttyserver to use the %stype%s entry from the
    %btermcap%b file. If this is not present then it will
    attempt to use the termcap entry defined by the TERMCAP
    environment variable.
*l  %b-d%b %sdevice%s	
*t  Use device %sdevice%s.
*l  %b-w%b		
*t  Write the server pathname onto the output at startup. This is
    used by some pseudo-terminal clients.
*l  %b-s%b
*t  Equivalent to %b-d tserial.d%b.
*l  %b-p%b
*t  Equivalent to %b-d tpseudo.d -w%b
*l  %b-u%b		
*t  Print a usage message.
*p  When the pseudo-tty driver is used, the tty server needs to be started from
 a program, this is what %brlogind%b and %btelnetd%b do. A serial
 line server can be created from the command line by the following:
*c=  /helios/lib/ttyserv -l /rs232/default -s -t vt100 &
*p  A shell, or any other command can now be run with:
*c=  shell </tty.0/Shell >&/tty.0/Shell &
*p  To add an extra login terminal you can add the following lines to your
 initrc file:
*c=  run -e /helios/lib/ttyserv ttyserv -l /rs232/default -s -t vt100
*c=  waitfor /tty.0
*c=  console /tty.0 User1
*c=  run -e /helios/bin/newuser newuser
*p  Any program which may be run on the IO server windows may be run in a tty
 server window. New full screen windows may be created in exactly the same
 way with %bwsh%b or %brun%b. For this to be usable the termcap file
 entry must contain definitions of the screen switching keys %b%5%b and %b%8%b.
*x wsh
*x run
*k ethernet
#
*n nfs\General interest
*P Provides access to the file systems of remote machines
*D The Helios Network file server (NFS) server provides access to the
 file systems of remote machines which provide an NFS server interface.
*p At present Helios only provides the client side of NFS, allowing Helios
 programs to access remote discs.  Remote access to Helios file systems
 is not yet supported.
*p Because of the differences between Helios and Unix access controls,
 some aspects of NFS protection are only partially supported.
*p When the Helios NFS server is run, it contains a fixed user and
 group id pair which are used in all NFS requests.  By default these
 both have a value of zero, which is normally the superuser.  To prevent
 NFS clients getting superuser privileges most NFS hosts translate this
 to a dummy user id with only public access to the file system.  The -u
 option to the Helios NFS server causes it to use the user
 and group id of an entry in the password file for all requests.
*p To allow such things as directory listings to correctly reflect the
 user's access rights, a simple translation from NFS access rights
 (which are equivalent to Unix access rights) to Helios access matrix
 categories is used.  The owner access rights are mapped
 into the V category of the matrix, the group access rights are mapped
 into both the X and Y categories, and the public access rights are
 mapped into the Z category.  Additionally, the V category is given the
 Alter access right, and the V, X and Y categories are all given the
 Delete right.  If the object is a directory, the V category is given V
 access right, the X and Y categories are given both X and Y rights, and
 the Z category is given Z access rights.  An equivalent translation is
 made in the reverse direction, although the NFS group access rights are
 derived only from the X category.
*p See the manual provided with the Helios Ethernet II package
 for further details.
*x nfs\000718
*x Protection
*x Servers
*x chmod\000074
*k ethernet
#
*n nfs\Helios command
*P Provides access to the file systems of remote machines through the Ethernet.
*F /helios/lib/nfs [-u user] [-s RW] <fsname> <host> <root>
*D %bnfs%b mounts a remote file system, thereby providing
   access to the file system of remote machines which
   provide an NFS server interface across a network (such as an ethernet).
*p The arguments are as follows:
*l Option
*t Description
*l %b-u%b
*t makes the server use the uid and gid from the passwd file for the given
   user. These must correspond to the values used on <host>.
   At present only one gid is used, so choose carefully.
   All the nfs accesses will use the same uid/gid set.
*l %b-s%b
*t Set read and write block sizes. R and W are single digits ranging from
   1 to 8 and represent the number of Kbytes per read or write respectively.
   The default is 5K reads and 8K writes. Note, however, that a limitation
   in PC IO servers before V1.2.2 means that writes greater than 1K will
   not work through PC ethernet cards. Such cards are also unable to
   read more than 5K due to a lack of hardware buffering.  There are no
   such restrictions for transputer based ethernet hardware (Parsytec
   or Inmos cards), so -s88 should work.
*l %b<fsname>%b
*t is the Helios server name by which the remote file system will be known.
*l %b<host>%b
*t is the server machine.
*l %b<root>%b
*t is the root of the directory tree on <host> to be mounted.
*p Example:
*c=/helios/lib/nfs -u nick /giga sparky /giga
*p This mounts the %b/giga%b disc on the host sparky.
*p The directory %b/giga/users/nick%b may now be accessed via
   exactly the same name from Helios.
*x nfs\000717
*x Servers
*x hmount
*k ethernet
#
*n hmount\Helios command
*P Clear an NFS host's mount table
*F hmount <host>
*p The argument is as follows:
*l %b<host>%b
*t The host whose table is to be cleared.
*D Most NFS hosts maintain a table of active clients.  This table
   is maintained for information only (it is not essential to the
   operation of NFS) however it can fill with obsolete entries.
*p %bhmount%b is a simple program which clears a given server's
   mount table of all the entries for the calling client machine.  It
   is good practice to invoke this program for all the NFS
   hosts used at system shutdown.  Alternatively, using it just
   before starting the Helios NFS servers is also acceptable.
*p Example:
*c=hmount sparky
*p Clears the mount table on sparky of all entries for this machine.
*p Note: This command was known as %bumount%b in early releases of the Ethernet
 II Software package.
*x nfs\000717
*k umount
*k ethernet
#
*n Line-printing\General interest
*P Provide access to the printing services of remote machines
*D The Helios line printing system provides access to the printing
   services of remote machines.  Directly connected printing devices are not
   supported.  Printers can only be accessed through a remote line
   printer daemon.  The system comprises a line printer daemon (lpd)
   and a number of commands that may be used to submit, examine and
   remove print jobs.  A line printer control program is also provided
   to administer the operation of the local line printing system.
*p Print jobs are created in a printer's local spool area with the
   lpr command.  A print request is then sent to the local line printer
   daemon which is responsible for transferring the job to the remote system
   for subsequent printing.  The lpq and lprm commands (examine
   printer queue and remove jobs, respectively) operate on both the
   local and remote spool queues.  The printer control program, lpc,
   does not affect the operation of the remote line printer system.
*p All operations take lp as the default printer if none is specified.
   This can be overridden by setting the environment variable PRINTER.
*p For more details refer to the manual supplied with the Helios Ethernet
   II package.
*x lpd
*x lpq
*x lprm
*x lpc
*x lpr
*x lptest
*k ethernet
#
*n lpc\Helios command
*P Line printer control program.
*F lpc [command [argument ...]]
*D %blpc%b is used to control the local line printing system.
   The operation of the remote system is unaffected by this program.
   If no arguments are given, the program will prompt for commands from
   the standard input.  Commands may be abbreviated.
*p Recognized commands are as follows:
*l ? [command ...]
*l help [command ...]
*t Print a brief description of the specified command.
*l abort {all | printer ...}
*t Kill the active printer daemon (if it exists) and disable printing.
*l clean {all | printer ...}
*t Remove unprintable control and data files from the specified printer's
   spool queue.
*l disable {all | printer ...}
*t Disable queuing.
*l down {all | printer} message ...
*t Disable queuing and printing, and write message to the printer status file.
*l enable {all | printer ...}
*t Enable queuing.
*l exit | quit
*t Exit from lpc.
*l restart {all | printer ...}
*t Activate a new printer daemon and process any print requests that
   may be queued.
*l start {all | printer ...}
*t Enable printing and activate a printer daemon.
*l status {printer ...}
*t Display the status of the local spool queue.
*l stop {all | printer ...}
*t Kill the active printer daemon (if it exists) and disable printing.
*l topq printer [jobnum ...] [user ...]
*t Move the specified jobs to the top of the queue.
*l up {all | printer ...}
*t Enable queuing and printing, and activate a printer daemon
   (opposite of down).
*p Example:
*c=lpc status lp
*p Displays the status of the default printer queue (that is whether
   queuing and printing are enabled or disabled) and the number of
   jobs currently in the queue.
*x lpd
*x lpr
*x lpq
*x lprm
*x lptest
*x Line-printing
*k ethernet
#
*n lpd\Helios command
*P Line printer daemon.
*F /helios/lib/lpd [-l]
*D The line printer daemon waits for local print requests.  On
   receiving a request, it activates an auxiliary program,
   %b/helios/lib/lpd_aux%b, which is responsible for transferring the
   request to the remote system.  When %blpd%b is started, it examines
   the spool areas of the printers defined in the printer capability
   database (%b/helios/etc/printcap%b) and processes all queued requests.
*p The arguments are as follows:
*l Option
*t Description
*l %b-l%b
*t Extra logging information. Gives SYSLOG notification of daemon
   activation and print requests.
*x lpc
*x lpr
*x lpq
*x lprm
*x lptest
*x Line-printing
*k ethernet
#
*n lpq\Helios command
*P Examine printer spool queue.
*F lpq [-l] [-P printer] [job# ...] [user ...]
*D %blpq%b displays the status of the jobs in a printer's spool area.
   %blpq%b first examines the local printer queue, and then reports on
   the status of the remote queue.  The arguments are as follows:
*l Option
*t Description
*l %b-l%b
*t extended listing.
*l %b-P%b %sprinter%s
*t list jobs in %sprinter%s spool queue.
*l %bjob#%b
*t list specified job numbers.
*l %buser%b
*t list jobs belonging to user.
*p Example:
*c=lpq -P qms craig
*p Lists all jobs in the qms printer queue that belong to user craig.
*x lpc
*x lpd
*x lpr
*x lprm
*x lptest
*x Line-printing
*k ethernet
#
*n lpr\Helios command
*P Line printer program
*F lpr [-Pprinter] [-#num] [-C class] [-J job] [-T title] [-i[numcols]] [-wnum] [-pltndgvcfrmh] [name ...]
*D %blpr%b creates print jobs in a printer's local spool area.
   Files to be printed are represented as data and control files.  %blpr%b
   sends a print request to the local line printer daemon which is
   responsible for transferring the job to the remote system for
   subsequent printing.
*p The arguments are as follows:
*l Option
*t Description
*l %b-P%b%sprinter%s
*t send output to %sprinter%s.
*l %b-#%b%snum%s
*t %snum%sber of copies.
*l %b-C%b %sclass%s
*t job %sclass%sification.
*l %b-J%b %sjob%s
*t job name.
*l %b-r%b
*t remove file on completion.
*l %b-m%b
*t send mail on completion.
*l %b-i%b%s[numcols]%s
*t indent output by %snumcols%s characters.
*l %b-h%b
*t suppress printing of burst page.
*l %b-l%b
*t use a filter that prints control characters and suppress page breaks.
*l %bname ...%b
*t the name of the file to be printed. If not specified, %blpr%b will
   take the standard input terminated by EOF.
*p pr options:
*l %b-p%b
*t use remote pr program to format the output.
*l %b-T%b %stitle%s
*t title string used by pr.
*l %b-w%b%snum%s
*t page width used by pr.
*p Note: It is assumed that pr does in fact reside on the remote host
*p Filter options
*l %b-c%b
*t use cifplot data filter
*l %b-d%b
*t use TeX data filter
*l %b-g%b
*t use graph data filter
*l %b-n%b
*t use ditroff data filter
*l %b-r%b
*t use FORTRAN style filter
*l %b-t%b
*t use troff data filter
*l %b-v%b
*t use raster image filter
*p Example:
*c=lpr -Pqms -r -m /c/note
*p Sends the file /c/note to the remote qms printer.
   The file will be deleted and the remote line printer daemon will send
   a mail message on completion of printing.
*x lpc
*x lpd
*x lpq
*x lprm
*x lptest
*x Line-printing
*k ethernet
#
*n lprm\Helios command
*P Remove jobs from printer spool queue.
*F lprm [-Pprinter] [-] [job# ...] [user ...]
*D %blprm%b is used to remove jobs from a printer's spool area.
   If the specified job is not resident in the local printer queue,
   %blprm%b will attempt to remove the job from the remote queue.
   If no arguments are specified, %blprm%b will remove the currently
   active job (if it exists and is owned by the user invoking the operation).
*p The arguments are as follows:
*l Option
*t Description
*l %b-P%b%sprinter%s
*t remove job from %sprinter%s queue.
*l %b-%b
*t remove all owned jobs.
*l %bjob#%b
*t remove specific job from queue.
*l %buser%b
*t remove all jobs belonging to user.
*p Example:
*c=lprm -Pqms craig
*p Removes all jobs from the qms printer queue that belong to user craig.
*x lpc
*x lpd
*x lpq
*x lpr
*x lptest
*x Line-printing
*k ethernet
#
*n lptest\Helios command
*p Generate test output
*F lptest [length [count]]
*D %blptest%b writes a test pattern using all of the printable ASCII
   characters to the standard output.
*p The arguments are as follows:
*l %blength%b
*t output line length (default is 79).
*l %bcount%b
*t number of lines (default is 200).
*p Example:
*c=lptest 20 30
*p Generates a pattern 30 lines long and 20 characters wide.
*x lpc
*x lpd
*x lpq
*x lpr
*x lprm
*x Line-printing
*k ethernet
#
*n Mail\General interest
*P Provide a means of communication with users/groups on remote machines.
*D The Helios mail system provides a means of communicating with a
   remote sendmail daemon.
*p The system comprises a local mail daemon
   (%b/helios/lib/sendmail%b) and a program (%b/helios/bin/mail%b) for composing
   and reading mail messages.  The function of sendmail is to communicate
   with the remote mail daemon (using the Simple Mail Transfer Protocol
   (SMTP)).  Incoming messages from the remote machine are received by the
   sendmail daemon, which then invokes mail to perform the local delivery.
*p sendmail is also responsible for re-directing outgoing mail (either
   composed using mail or fed directly into sendmail) to the remote mail
   system which is then responsible for routing the messages to the
   specified recipient.  Messages that are sent between local users (users
   within the same Helios network) obviously need not be routed via the
   remote system; these are delivered directly.
*p For further details, refer to the manual provided with the Helios Ethernet
   II package.
*x sendmail
*x mail
*k ethernet
#
*n mail\Helios command
*P Process mail messages.
*F mail [-b] [-q] [-f filename]
*F mail [-v] [[address] ...]
*D %bmail%b is a program for generating and reading mail messages.
   Outgoing messages are sent to %bsendmail%b for delivery to the
   remote system; incoming messages are received by %bsendmail%b
   and passed on to %bmail%b for local delivery.
*p If no arguments are specified, %bmail%b tests for the presence of
   mail by examining the file %b/helios/local/spool/mail/<username>%b.
   If there is mail, the first message is immediately printed out.
   Mail messages are, by default, displayed in a last-in, first-out order.
*p The following commands may be used to process messages:
*l Command
*t Description
*l %bx%b
*t exit without changing mail.
*l %bp%b
*t print current message.
*l %bs%b [%sfile%s]
*t save current message to %sfile%s (default is <home>/mbox) and
   remove from mail file.
*l %bw%b [%sfile%s]
*t save message without `From' line.
*l %b-%b
*t go to previous message.
*l %b+%b
*t go to next message.
*l %bd%b
*t delete current message.
*l %bm%b %suser%s
*t send current message to %suser%s and remove from mail file.
*l %b!%b %scmd%s
*t execute %scmd%s.
*l %b?%b
*t display the above list.
*p The arguments to mail are:
*l %b-f filename%b
*t use /helios/local/spool/mail/filename as the mail file.
*l %b-b%b
*t reverse order of the processing mail file (FIFO).
*l %b-p%b
*t print all messages in the mail file.
*l %b-v%b
*t print version and send verbose flag to sendmail.
*l %baddress ...%b
*t take the standard input (terminated by EOF or '.') and send it
   via sendmail to each recipient.
*p Examples:
*c=mail -f /helios/local/spool/postmaster
*p Tests whether there is any mail for user postmaster
*c=mail craig nick@sparky < note
*p Mails the contents of the file note to the local user craig and also
   the user nick on the machine sparky.
*x sendmail
*k ethernet
#
*n sendmail\Helios command
*P Send mail messages to the remote system.
   Receive mail messages from the remote system.
*F /helios/lib/sendmail [-l] [-bd]
*F /helios/lib/sendmail [-v] [-l] [-bs] [[address] ...]
*D When running as a daemon, sendmail waits for notification of
   incoming mail messages from the remote system.
*p On receipt of a
   message, sendmail activates an auxiliary program, %b/helios/lib/smtp%b,
   which collects the contents of the mail message from the remote machine.
   %bsmtp%b then invokes %b/helios/bin/mail%b to perform the actual delivery.
*p %bsendmail%b is also used to send mail messages to the remote system.
   A connection with the remote sendmail daemon is set up and the messages
   are transferred to the remote machine.  It is then the responsibility
   of the remote mail system to route the messages to the specified
   recipient(s).
*p The arguments are as follows:
*l Argument
*t Description
*l %b-bd%b
*t run as a daemon.
*l %b-bs%b
*t use SMTP.  This allows the user to explicitly specify the sender,
   recipient and text of the mail message, using the SMTP commands
   listed below.
*l %b-l%b
*t extra logging information.  Gives SYSLOG notification of process
   activation, and the sender and recipients of in-coming and outgoing mail.
*l %b-v%b
*t verbose mode.
*l %baddress ...%b
*t takes the standard input (terminated by EOF or '.') and sends it
   to each recipient.  Local mail is delivered by %b/helios/bin/mail%b
   and external mail is sent to the remote system for subsequent delivery.
*p SMTP Commands :
*l %bHELP [<topic>]%b
*t give help information.
*l %bHELLO <hostname>%b
*t introduce yourself.
*l %bMAIL FROM: <sender>%b
*t specify sender.
*l %bRCPT TO: <recipient>%b
*t specify recipient(s).
*l %bDATA%b
*t collect message text.
*l %bRESET%b
*t reset the system.
*l %bQUIT%b
*t exit SMTP.
*l %bNOOP%b
*t do nothing.
*p Example:
*c=/helios/lib/sendmail -v craig@craigpc
*p Takes the standard input and sends it to the user craig on
   the machine craigpc, displaying the SMTP dialogue between the
   local and remote mail systems.
*x mail
*k ethernet
#
*n route\Helios command
*P Manually manipulate network routing tables.
*F route add | delete [net | host] destination gateway [metric]
*D %broute%b is a program for modifying the TCP/IP network routing tables.
   This makes it possible to access other TCP/IP networks through a
   local gateway.
*p route takes the following arguments:
*l Argument
*t Description
*l %badd%b
*t add route.
*l %bdelete%b
*t delete route.
*l %b[net | host]%b
*t interpret destination as network or host.
*l %bdestination%b
*t address of destination host or network.
*l %bgateway%b
*t address of network gateway through which packets should be sent.
*l %b[metric]%b
*t maximum number of hops to destination (required for %badd%b commands).
   Must be zero if destination is on a directly attached network.
*p Examples: Consider the following scenario.  A Helios machine
   with a TCP/IP address 12.34.56.78 is on a class B network, 12.34.
   There is a second class B network, 12.90, which is accessible through
   a local gateway with local leg address 12.34.56.254.  The command:
*c=route add net 12.90.0.0 12.34.56.254 1
*p will enable access to the machines in the second class B network
   through the gateway.
*k ethernet
#
*n  Farm-Library\General interest
*p  The Helios farm library is a parallel programming support library.
    Its purpose is to facilitate the development of parallel applications
    that use the Processor Farm model of computation. The library is
    extensively documented in %sThe Farm Library%s.
*p  If a particular problem can be solved using the farm model then
    the user need only write a single program and link this with the
    farm library. The library takes care of distributing the program
    over the network, performing the necessary communication, coping
    with the majority of errors, and many of the other problems associated
    with writing parallel software. This approach contrasts with the CDL
    way of producing parallel software where it is necessary to write
    several different programs and a separate CDL script to indicate how
    the programs should communicate and possibly how they should be mapped
    on to the network.
*p  Writing the application program that uses the farm library is essentially
    a case of filling in a standard template for farms. The programmer needs
    to write four bits of code.
*l  1
*t  The application has to configure the farm library when it starts
    up and call the library initialization routine %bFmInitialise%b.
*l  2
*t  A producer routine is required to generate job packets. These
    jobs will be distributed over the network by the farm library.
*l  3
*t  A worker routine is required to accept job packets, process them,
    and generate replies. These workers are distributed over the network and
    will run in parallel.
*l  A consumer routine has to accept reply packets from the various
*t  workers in the network and process the results produced.
*p  The library contains facilities for automatic load-balancing, broadcasting,
    fault tolerance, use of fast on-chip memory, optimizing buffer usage,
    and a whole range of other features.
*x Farms
*x FmInitialise
*x FmProducer
*x FmConsumer
*x FmWorker
*k Farm Library
#
*n  Farms\General interest
*p  Processor farms are a particular model of parallel computation.
    They involve a single controller running somewhere in the network and
    some number of workers distributed over the network. The controller
    sends out job packets to the various workers. These jobs are processed
    in parallel by the workers which then generate replies. The replies
    are sent back to the controller to be combined in some application-specific
    way.
*p  Farms have a number of very desirable features for developing parallel
    applications.
*l  1
*t  First and most important, farms are relatively easy to implement.
*l  2
*t  Farms tend to scale up well to different-sized networks. It is often
    possible to develop a farm on a small network and run it on a much larger
    one with a corresponding speed-up. The size of a farm is usually limited
    only by I/O bandwidth.
*l  3
*t  For many applications it is possible to produce farms that perform
    automatic load-balancing, making very efficient use of the network.
*l  4
*t  Farms potentially have a high degree of fault tolerance.
    For many applications it is possible to implement farms that can
    continue running even when one or more of the processors running the
    farm fails.
*p  Helios provides a parallel programming support library specifically
    for implementing such applications, the farm library. Alternatively
    the CDL language can be used to implement a farm and distribute it
    over the network.
*x CDL
*k Farm Library
#
*n  FmGetInfo\System library
*P  to obtain additional information from the provider routine
*I  <farmlib.h>
*F  void *FmGetInfo(void *);
*p  This function is part of the Helios farm library. For some farm
    applications it is necessary for workers to obtain additional
    information from the controller in order to process a particular job.
    This is achieved by filling in an information request, sending it off
    to the information provider routine within the controller, and getting
    back the reply.
*p  The %bFmGetInfo()%b function performs the interaction with the provider routine.
    It takes a single argument which should be the result of a recent call
    to %bFmGetInfoRequestBuffer()%b filled in by the application with the
    details needed by the information provider routine. This buffer is sent
    off to the controller program where it will be received by the
    application-specific provider routine. The provider should construct
    a suitable reply and send it off with a call to %bFmSendInfoReply()%b.
    A copy of this reply buffer will be received by the worker and will be
    returned as the result of %bFmGetInfo()%b.
*p  The reply buffer will be released automatically when the application
    next calls %bFmGetInfo()%b. If the buffer consumes a large amount of memory,    and if the information in the buffer is no longer required, and the
    application may not call %bFmGetInfo()%b again for some time, then it is
    possible to release the buffer early by a call to %bFmFreeInfoReplyBuffer()%b.
*x  Farm-Library
*x  FmProvider
*x  FmGetInfoRequestBuffer
*x  FmFreeInfoReplyBuffer
#
*n  FmProducer\System library
*P  to specify the application's producer routine.
*I  <farmlib.h>
*F  VoidFnPtr FmProducer; int FmProducerStack;
*p  The %bproducer%b routine is one of the essential components of an application
    that uses the farm library. It is responsible for generating job
    packets that can be sent off to the various workers in the network to
    be processed. A typical producer routine would look like this:
*c=  static void pi_producer(void)
*c=  { int      number_intervals;
*c=   int      i;
*c=   Pi_Job  *job;
*c=
*c=   printf("Farm Library version of Pi on %d workers.\n",
*c=          FmNumberWorkers);
*c=   printf("Please specify the number of intervals per worker : ");
*c=   fflush(stdout);
*c=   scanf("%d", &number_intervals);
*c=
*c=   for (i = 0; i < FmNumberWorkers; i++)
*c=    { job = FmGetJobBuffer(sizeof(Pi_Job));
*c=      job->WorkerNumber  = i;
*c=      job->NumberWorkers = FmNumberWorkers;
*c=      job->Intervals     = number_intervals;
*c=      FmSendJob(i, TRUE, job);
*c=    }
*c= }
*p  This producer routine obtains some information from the user.
    It then generates one job packet per worker, fills in the necessary
    information, and sends off each job.
*p  The farm library needs to be informed about the producer routine
    during its configuration phase, by setting the %bFmProducer%b variable.
*c= static void pi_producer(void);
*c=
*c= int main(int argc, char **argv)
*c= {
*c=   /* ... */
*c=
*c=  FmProducer = &pi_producer;
*c=
*c=  /* ... */
*c=
*c=  FmInitialise();
*c= }
*p  In the library's initialization phase the program will be distributed
    over the network. The original program will be designated as the
    controller and all copies will be workers. Inside the controller program
    a thread will be spawned to run the producer routine. By default
    this thread will have a stack of 5000 bytes, but an alternative stack
    size can be specified using the %bFmProducerStack%b variable.
*p  The thread running the producer routine will share its
    address space with the consumer routine, and possibly also with a worker
    and an information provider routine. If the producer is going to access
    the same global variables as any of these other routines, or if
    it is going to call the same library functions such as printf, then
    it will usually be necessary to have a semaphore lock to control
    access to this global data.
*p  If the number of job packets to be generated is known in advance
    then the producer routine can return as soon as the last job
    has been sent off. Otherwise the producer routine will normally
    have to interact with the consumer, typically synchronising using
    a semaphore. In such cases the producer routine does not usually
    return as the application will be terminated from inside the
    consumer.
*x  Farm-Library
*x FmGetJobBuffer
*x FmSendJob
*x FmInitialise
*k Farm Library
#
*n  FmConsumer\System library
*P  to specify the application's consumer routine
*I  <farmlib.h>
*F  VoidFnPtr FmConsumer; int FmConsumerStack;
*p  The %bconsumer%b routine is one of the essential components of an application
    that uses the farm library. It is responsible for accepting reply
    packets sent by the various workers in response to jobs. A typical
    consumer routine would look like this:
*c= static void pi_consumer(void)
*c= { Pi_Reply     *reply;
*c=   int           i;
*c=   double        total = 0.0;
*c=
*c=   for (i = 0; i < FmNumberWorkers; i++)
*c=    { reply  = FmGetReply(i);
*c=      total += reply->PartialArea;
*c=    }
*c=
*c=   printf("Pi is approximately %g.\n", total);
*c= }
*p  In this case the consumer routine accepts a single reply from each
    worker and adds up the results produced by the workers. This is
    the desired result that the application should produce so it is output.
*p  The farm library needs to be informed about the consumer routine
    during its configuration phase by setting the %bFmConsumer%b variable.
*c= static void pi_consumer(void);
*c=
*c= int main(int argc, char **argv)
*c= {
*c=
*c=   /* ... */
*c=
*c=   FmConsumer = &pi_consumer;
*c=
*c=   /* ... */
*c=
*c=   FmInitialise();
*c= }
*p  In the library's initialization phase the program will be
    distributed over the network. The original program will be designated
    as the controller and all copies will be workers. Inside the controller
    program a thread will be spawned to run the consumer routine. By
    default this thread will have a stack of 5000 bytes, but an alternative
    stack size can be specified using the %bFmConsumerStack%b variable.
*p  The thread running the consumer routine will share its address space with
    the producer routine, and possibly also with a worker and an
    information provider routine. If the consumer is going to access the
    same global variables as any of these other routines, or if it
    is going to call the same library functions such as %bprintf%b, then it
    will usually be necessary to have a semaphore lock to control access
    to this global data.
*p  If the consumer routine returns then the application as a whole will
    terminate.
*x  Farm-Library
*x FmGetReply
*x FmInitialise
*k Farm Library
#
*n  FmWorker\System library
*P  to specify the application's worker routine.
*I  <farmlib.h>
*F  VoidFnPtr FmWorker; int FmWorkerStack;
*p  The worker routine is one of the essential components of an
    application that uses the farm library. It is responsible for
    accepting job packets generated by the producer, processing these
    job packets, and sending back replies that will be received by
    the consumer. The farm library has to be informed about the worker
    routine by setting the FmWorker variable during the configuration
    phase.
*c= static void pi_worker(void);
*c=
*c= int main(int argc, char **argv)
*c= {
*c=   /* ... */
*c=
*c=   FmWorker = &pi_worker;
*c=
*c=   /* ... */
*c=
*c=   FmInitialise();
*c= }
*p  A typical worker routine would loop forever. In each iteration it
    would call %bFmGetJob()%b to obtain another job generated by the
    producer routine. If this job merely contains information and
    no reply is expected then the information should be stored locally.
    Otherwise the worker routine should allocate a reply buffer using
    %bFmGetReplyBuffer()%b, process the job and generate a reply in this
    buffer, and send the reply off to the consumer routine using
    %bFmSendReply%b.
*p  During the library's initialization phase the program will be
    distributed over the network. The original program will be designated
    as the controller and all copies will be workers. Inside all the
    workers a separate thread will be spawned to run the worker routine.
    In addition, if the %bFmOverloadController%b flag has been set then
    a worker thread will be started in the controller. By default these
    threads will have a stack of 5000 bytes, but an alternative stack
    size can be specified using the FmWorkerStack variable.
*p  In most applications the worker routine will loop forever accepting
    jobs from the producer and sending back replies to the consumer.
    The workers will terminate automatically when appropriate.
*x  Farm-Library
*x FmGetJob
*x FmSendReply
*x FmInitialise
*k Farm Library
#
*n  FmGetJobBuffer\System library
*P  to allocate a new job buffer
*I  <farmlib.h>
*F  void *FmGetJobBuffer(int size);
*p  This routine is called
    from inside the producer routine to allocate space for a job buffer,
    which can then be sent off to one or all of the workers. For example:
*c=  typedef struct Pi_Job {
*c=         int    NumberWorkers;
*c=         int    WorkerNumber;
*c=         int    Intervals;
*c= } Pi_Job;
*c=
*c= static void pi_producer(void)
*c= { int      i;
*c=   Pi_Job  *job;
*c=
*c=   for (i = 0; i < FmNumberWorkers; i++)
*c=    { job = FmGetJobBuffer(sizeof(Pi_Job));
*c=      job->NumberWorkers = FmNumberWorkers;
*c=      job->WorkerNumber  = i;
*c=      job->Intervals     = Global_Intervals;
*c=      FmSendJob(i, TRUE, job);
*c=    }
*c= }
*p  The routine allocates a buffer of the requested size, usually
    corresponding to an application-specific data structure.
    If an application involves mainly or exclusively jobs of
    a specific size then the library can pre-allocate a suitable
    number of buffers during its initialization phase, speeding
    up the operation of the producer routine. To enable this
    option the variable %bFmJobSize%b should be set to the size
    of a default packet.
*p  %bFmGetJobBuffer()%b will never fail. If there is not enough memory
    for a buffer of the requested size then the routine will block
    until such time as there is enough memory available again.
    This may cause the application to lock up.
*p  The farm library will automatically release the job buffer
    when it is no longer required. This will happen some time
    after the job has been sent off. The application should
    never access a job buffer after it has been passed to
    FmSendJob, and there is no need for the application to
    release the buffer.
*x  Farm-Library
*x FmProducer
*x FmSendJob
*k Farm Library
#
*n  FmSendJob\System library
*P  to send a job to one or all workers
*I  <farmlib.h>
*F  void FmSendJob(int destination, bool reply, void *job)
*p  This routine is called
    from inside the producer routine to send a job to one or more workers.
    For example:
*c= static void pi_producer(void)
*c= { int     i;
*c=   Pi_Job *job;
*c=
*c=   for (i = 0; i < FmNumberWorkers; i++)
*c=    { job = FmGetJobBuffer(sizeof(Pi_Job));
*c=      job->NumberWorkers = FmNumberWorkers;
*c=      job->WorkerNumber  = i;
*c=      job->Intervals     = Global_Intervals;
*c=      FmSendJob(i, TRUE, job);
*c=
*c=    }
*c= }
*p  The routine takes three different arguments. The first is a destination
    for this particular job. It can take three types of value:
*l  Fm_All
*t  This destination is used to broadcast a packet to all
    the workers.
*l  Fm_Any
*t  This option uses the farm library's built-in load
    balancing facilities. The library chooses a worker to process this
    particular job. If there are no free workers at the moment then the
    call to %bFmSendJob()%b will block.
*l  worker
*t  It is possible to send a job to a particular worker,
    by specifying the number associated with that worker. This should
    be in the range %b0 <= destination < FmNumberWorkers%b.
*p  The second argument indicates whether or not a reply is expected.
    Usually the only type of job that does not involve a reply is an
    information broadcast.
*p  The third argument is a job as returned by a previous call to
    %bFmGetJobBuffer%b.
*p  The routine %bFmSendJob()%b is defined not to fail. If a destination is
    currently unable to accept another job then the routine will block
    until the worker is ready. If a particular worker is no longer running
    then the job will just be discarded and it is up to the consumer routine
    to detect that the worker has failed.
*x FmProducer
*x  Farm-Library
*x FmGetJobBuffer
*k Farm Library
#
*n  Load balancing\General interest
*p  Load balancing is one of the major problems when writing parallel software.
    Given a network of processors it is generally desirable to keep all the
    processors as busy as possible. If just one of the processors in a network
    is doing useful work and the remaining ones are idle, waiting for that
    one processor, then the network is being used very inefficiently.
*p  In general load balancing is a problem for the application programmer.
    It is very difficult, if not impossible, for the system to work out
    what the application is doing and automatically rearrange things so that
    the network is used more efficiently. However, for certain types of
    applications Helios load balancing can be relatively easy
    and suitable facilities are provided. This is particularly true of applications
    that can be implemented using the farm model of parallel computation.
    The Helios farm library contains load balancing facilities. For
    CDL-based farms Helios provides a separate load balancer program.
*x  Farm-Library
*x Farms
*k Farm Library
#
*n  Broadcasting\General interest
*p  Broadcasting means sending some item of data to all of a set of
    destinations. For example, in a multi-user system when the system administrator
    needs to shut down the machine it is usual to give the users some advance
    warning. The wall command can be used to broadcast a text message to
    all the users currently logged in, telling them when the machine is
    going down.

*p  When writing parallel programs it is often necessary to send some
    global information to all the component programs distributed over the
    network. For example, in a ray tracing application it is necessary
    to send details of the scene being traced to all the component programs
    that are performing the ray tracing. Parallel programming support
    libraries such as the farm library provide facilities to do this.
*x wall
*x  Farm-Library
*k Farm Library
#
*n  FmNumberWorkers\System library
*P  to specify or indicate the number of workers
*I  <farmlib.h>
*F  int FmNumberWorkers;
*p  This variable is provided by the farm library to indicate the number
    of workers that make up the parallel application. It serves two
    purposes:
*l  1
*t  In the farm library configuration phase it is possible to specify
    that the application should run on a specific number of processors.
    To achieve this the %bFmFloodOption%b variable should be set to
    %bFm_Fixed%b and %bFmNumberWorkers%b should be set to the required number
    of workers.
*l  2
*t  Following the configuration phase the variable FmNumberWorkers
    will be set to the number of workers actually started up by the
    farm library. This variable can be read from inside the producer, consumer,
    worker and provider routines.
*x  Farm-Library
*x FmInitialise
*k Farm Library
#
*n  FmWorkerNumber\System library
*P  to let a worker identify itself
*I  <farmlib.h>
*F  int FmWorkerNumber
*p  The %bFmWorkerNumber%b variable is provided by the Farm library to allow
    workers to determine their position within the farm. It will be set
    to a small positive integer in the range
    %b0 <= FmWorkerNumber < FmNumberWorkers%b.
    The variable's value is defined only inside worker routines. The variable
    should not be accessed outside the worker routine.
*x  Farm-Library
*x FmWorker
*x FmNumberWorkers
*k Farm Library
#
*n  FmGetReply\System library
*P  to receive a reply message from a worker
*I  <farmlib.h>
*F  void *FmGetReply(int where-from)
*p  The %bFmGetReply()%b routine is
    called from inside the consumer routine to receive a reply message
    from a worker. For example:
*c= static void pi_consumer(void)
*c= { Pi_Reply *reply;
*c=   int       i;
*c=   double    total = 0.0;
*c=
*c=   for (i = 0; i < FmNumberWorkers; i++)
*c=    { reply  = FmGetReply(i);
*c=      total += reply->Result;
*c=    }
*c=
*c=   printf("Pi is approximately %g.\n", total);
*c= }
*p  The routine takes a single argument. This can be %bFm_Any%b to accept a
    reply from any of the workers, or it can identify a particular worker.
    It returns a reply packet as sent by a worker.
*p  Unusually for farm library functions, %bFmGetReply()%b is allowed to fail.
    If the %bFmFaultHandling%b flag has been enabled, if a particular worker
    has been specified, and if that worker has failed for some reason,
    then %bFmGetReply()%b will return NULL. It is up to the application to
    cope with this error.
*p  The reply buffer returned by %bFmGetReply()%b will be freed automatically
    during the next call to %bFmGetReply()%b. Applications should not attempt
    to access an old buffer. On the other hand, applications need not worry
    about explicitly releasing the memory.
*x  Farm-Library
*x FmConsumer
*k Farm Library
#
*n  FmGetJob\System library
*P  to receive a job from the producer routine
*I  <farmlib.h>
*F  void *FmGetJob();
*p  The %bFmGetJob()%b routine is called
    from inside the worker routine to receive a job generated by the producer.
    For example:
*c= static void pi_worker(void)
*c= { Pi_Job    *job;
*c=   Pi_Reply  *reply;
*c=
*c=   forever
*c=    { job   = FmGetJob();
*c=      reply = FmGetReplyBuffer(job, sizeof(Pi_Reply));
*c=      reply->Result = eval(job);
*c=      FmSendReply(reply);
*c=    }
*c= }
*p  The routine %bFmGetJob()%b does not take any arguments. It will return the
    next job sent to this particular worker by the producer routine, or
    the next job allocated by the library's load balancing facilities if those
    are being used. The routine does not provide any information about the
    type of the job, for example whether it is a broadcast message or a job
    allocated specifically to this worker. If the worker routine needs this
    sort of information then the producer should include it as part of the
    job.
*p  The routine %bFmGetjob()%b is defined not to fail. If no further jobs are
    currently available then the routine will block until a job is
    ready. If the application is exiting then this will happen automatically,
    and the worker routine cannot detect this.
*x  Farm-Library
*x FmWorker
*x FmGetReplyBuffer
*x FmSendReply
*k Farm Library
#
*n  FmGetReplyBuffer\System library
*P  to obtain a buffer for the reply to a job
*I  <farmlib.h>
*F  void *FmGetReplyBuffer(void *job, int size);
*p  This routine is called
    from inside the worker routine to allocate space for a reply buffer
    which can then be sent off to the consumer. For example:
*c= static void pi_worker(void)
*c= { Pi_Job    *job;
*c=  Pi_Reply  *reply;
*c=
*c=   forever
*c=    { job   = FmGetJob();
*c=      reply = FmGetReplyBuffer(job, sizeof(Pi_Reply));
*c=      reply->Result = eval(job);
*c=      FmSendReply(reply);
*c=    }
*c= }
*p  The routine takes two arguments. The first identifies the job that
    is being replied to. There can be at most one reply per job, and
    workers cannot send replies except in response to an incoming job.
    The second argument specifies the size of the reply message, usually
    corresponding to an application-specific data structure. If an
    application involves mainly or exclusively jobs of a specific size
    then the library can pre-allocate a suitable number of buffers during
    its initialization phase, speeding up the option of both the worker and
    the consumer routines. To enable this option the variable
    %bFmReplySize%b should be set to the size of a default packet.
*p  %bFmGetReplyBuffer()%b will never fail. If there is not enough memory
    for a buffer of the requested size then the routine will block
    until such time as there is enough memory available again.
*p  The farm library will automatically release the reply buffer when it
    is no longer required. This will happen once the reply has been sent
    off and is ready for the consumer routine. The application should never
    access a reply buffer after it has been passed to FmSendReply, and
    there is no need for the application to release the buffer.
*x  Farm-Library
*x FmWorker
*x FmSendReply
*k Farm Library
#
*n  FmSendReply\System library
*P  to send a reply to the consumer routine
*I  <farmlib.h>
*F  void FmSendReply(void *reply);
*p  This routine forms is called
    from inside the worker routine to send a reply back to the consumer.
    For example:
*c= static void pi_worker(void)
*c= { Pi_Job    *job;
*c=   Pi_Reply  *reply;
*c=
*c=   forever
*c=    { job   = FmGetJob();
*c=     reply = FmGetReplyBuffer(job, sizeof(Pi_Reply));
*c=     reply->Result = eval(job);
*c=     FmSendReply(reply);
*c=    }
*c= }
*p  The routine takes a single argument which must be a reply buffer previously
    allocated with a call to %bFmGetReplyBuffer()%b. It is defined not to fail.
    If the controller is not currently able to accept another reply message
    then the call to %bFmSendReply()%b will block until the controller is ready
    again.
*x  Farm-Library
*x FmWorker
*x FmGetJob
*x FmGetReplyBuffer
*k Farm Library
#
*n  FmFaultHandling\System library
*P  to enable the farm library's fault tolerance features
*I  <farmlib.h>
*F  bool FmFaultHandling
*p  The %bFmFaultHandling%b flag is provided by the Farm library. It should be
    set in the library's configuration phase if the application is capable
    of running in a fault-tolerant fashion. This can happen in two main ways:
*l  1
*t  If the application makes use only of the broadcasting and load
    balancing facilities then the library can automatically bypass
    any workers that fail while the application is running. Broadcasts
    will ignore that worker. Any jobs currently being processed by that
    worker will be reallocated to other workers.
*l  2
*t  If the application can cope with not receiving replies to some
    of the jobs then the fault handling can be enabled. In this case
    any calls to %bFmGetReply()%b involving a failed worker will
    return NULL. Monte Carlo simulations often fall into this category.
*p  If the %bFmFaultHandling%b flag is not set during the configuration phase
    then the application will just abort if one of the workers fails.
*x  Farm-Library
*x FmInitialise
*k Farm Library
#
*n  FmInitialise\System library
*P  to terminate configuration and initialize the farm library
*I  <farmlib.h>
*F  void FmInitialise();
*p  The %bFmInitialise()%b routine is part of the Helios farm library.
    It should be called at the end of the library configuration phase.
*c= int main(int argc, char **argv)
*c= {
*c=   FmProducer = &pi_producer;
*c=   FmConsumer = &pi_consumer;
*c=   FmWorker   = &pi_worker;
*c=
*c=   /* Other configuration options */
*c=
*c=   FmInitialise();
*c= }
*p  The %bFmInitialise()%b routine does not take any arguments and it will
    never return. Instead it is responsible for distributing the program
    over the network, initialising the communication, and starting up
    the producer, worker, and consumer threads.
*p  The following configuration options are available:
*l  %bFmProducer%b
*t  This variable must be set to the address of the
    application's routine that produces job packets.
*l  %bFmConsumer%b
*t  This variable must be set to the address of the
    application's routine that accepts reply packets.
*l  %bFmWorker%b
*t  This variable must be set to the address of the
    application's routine that processes job packets and generates replies.
*l  %bFmControllerInitialise%b
*t  If necessary the controller may
    have a separate initialization routine which will be called after the
    application has been distributed over the network but before the
    producer and consumer threads have been spawned off.
*l  %bFmWorkerInitialise%b
*t  If necessary a worker can have its own
    initialization routine which will be called after the application has been
    distributed over the network but before the worker thread has been
    spawned off.
*l  %bFmControllerExit%b
*t  If the controller needs to take some special
    action when it terminates then it can install an exit routine by setting
    this variable. Typically this is used to shut down an I/O connection,
    for example a connection to an X terminal.
*l  %bFmWorkerExit%b
*t  If a worker needs to take some special action when
    it terminates then it can install an exit routine by setting this variable.
*l  %bFmProvider%b
*t  For some applications it may be desirable to let
    worker routines query the controller for some piece of information.
    If so the FmProvider variable should be set to the address of a routine
    which can provide such information.
*l  %bFmProducerStack%b
*t  The producer routine runs in separate thread
    spawned off inside the controller program. By default this thread
    has a stack size of 5000 bytes. The size can be changed using this
    variable.
*l  %bFmConsumerStack%b
*t  The consumer routine also runs in a
    separate thread. The default stack size of 5000 bytes can be changed
    using the %bFmConsumerStack%b variable.
*l  %bFmWorkerStack%b
*t  The worker routine runs as a separate thread
    within the various worker components of the application, and
    within the controller as well if the %bFmOverloadController%b option
    is used. The default stack size of 5000 bytes can be
    changed using the %bFmWorkerStack%b variable.
*l  %bFmProviderStack%b
*t  If the application makes use of an information
    provider then the provider routine also runs as a separate thread
    within the controller, and its default stack size of 5000 bytes can
    be changed.
*l  %bFmFloodOption%b
*t  This option is used to control how the application
    will be distributed over the network. The default is to flood the
    whole network with workers.
*l  %bFmSelectedNetwork%b
*t  If the network flooding option being used
    involves a specific set of processors then
    this variable should be set to an %bRmNetwork%b
    value, as returned by a call to %bRmGetNetwork()%b or %bRmGetDomain%b.
*l  %bFmFaultHandling%b
*t  If the application is such that it can make use
    of the fault-tolerance features of the farm library then this flag
    should be enabled. By default the fault handling is disabled.
*l  %bFmFastStack%b
*t  This option can be used to speed up the various
    worker routines, by running them with their stack in fast on-chip memory.
*l  %bFmFastCode%b
*t  This option can be used to speed up the various
    worker routines by moving their code to fast on-chip memory.
*l  %bFmOverloadController%b
*t  By default the controller component of an
    application only produces jobs and consumes replies, it does not perform
    any of the computation. If the application is not I/O bound then it
    may be possible to improve performance by running a worker routine
    within the controller as well.
*l  %bFmJobSize%b
*t  If all or most of the job packets generated by the
    producer routine are the same size then it is possible to let the
    farm library perform some optimization in its buffer management code.
    This option is enabled by setting the variable %bFmJobSize%b to the size
    of the default job.
*l  %bFmReplySize%b
*t  If all or most of the reply packets generated by
    the worker routine are the same size then it is possible to let the
    farm library perform some optimization in its buffer management code.
    This option is enabled by setting the variable %bFmReplySize%b to the
    size of a default reply.
*l  %bFmSeed%b
*t  This variable can be used to initialize the random
    number generator provided by the farm library.
*p  The only compulsory library variables that have to be set are %bFmProducer%b,
    %bFmConsumer%b and %bFmWorker%b. All other variables and flags are optional.
    The variables and flags must be set only during the configuration phase,
    before the call to FmInitialise. If any of these variables are changed
    subsequent to %bFmInitialise%b then the behaviour of the application is undefined.
    Note that the configuration phase happens in the controller and in all
    of the workers, and it is only inside %bFmInitialise()%b that the programs
    diverge. If it is desirable to know in advance whether or not the
    program is running as the controller or as a worker then the routine
    %bFmInWorker()%b may be used.
*x FmProducer
*x  Farm-Library
*x FmConsumer
*x FmWorker
*x FmControllerInitialise
*x FmWorkerInitialise
*x FmControllerExit
*x FmWorkerExit
*x FmProvider
*x FmFloodOption
*x FmFaultHandling
*x FmFastStack
*x FmFastCode
*x FmOverloadController
*x FmGetJobBuffer
*x FmGetReplyBuffer
*x FmRand
*x FmInWorker
*k Farm Library
#
*n  FmInWorker\System library
*P  to determine whether or not the current program is a worker
*I  <farmlib.h>
*F  bool FmInWorker()
*p  This routine is provided by the farm library to determine whether
    the current program is running as the controller or as one of the
    workers. If the program is the controller then this routine will
    return FALSE, otherwise it will return TRUE. The main use of this
    routine is in the configuration phase of the farm library in cases
    where determining the configuration involves I/O of some sort.
    The routine can be used to ensure that this I/O only happens in
    the controller program.
*x  Farm-Library
*x FmInitialise
*k Farm Library
#
*n  FmFloodOption\System library
*P  to control the distribution of a farm application through the network
*I  <farmlib.h>
*F  int FmFloodOption; int FmNumberWorkers; RmNetwork RmSelectedNetwork;
*p  This variable is part of the Farm library. During the initialization
    phase of an application linked with the farm library the program is
    replicated throughout the network to turn the application into a
    parallel one. By default the program will be replicated onto every
    suitable processor in the network. However, different flooding options
    are available and the FmFloodOption can be used to choose
    the desired option.
*l  %bFm_Network%b
*t  This is the default option. The farm library examines
    the current network and replicates the program onto every suitable free
    processor. In other words, the application completely floods the network
    leaving no processors available for other users.
*l  %bFm_Domain%b
*t  If this option is enabled then the farm library
    restricts itself to the processors in the user's current domain.
    Typically this would be used in a multi-user environment where users
    are expected to pre-allocate the appropriate number of processors using
    the domain command.
*l  %bFm_Fixed%b
*t  This option causes the farm library to run a fixed
    number of workers controlled by the %bFmNumberWorkers%b variable.
*l  %bFm_Processors%b
*t  this causes the farm library to use only those
    processors that have been specifically selected by the application.
    The farm library variable %bFmSelectedNetwork%b should be set a
    suitable RmNetwork data structure.
*x FmInitialise
*x  Farm-Library
*x domain
*k Farm Library
#
*n  FmCountProcessors\System library
*P  to determine the probable number of processors currently available
*I  <farmlib.h>
*F  int FmCountProcessors();
*D Determines the probable number of processors that could be used
    to run the application
*p This information can be used
    to tune the size of the application to the network. Typically
    this routine is used when the %bFmFloodOption%b variable is set to
    %bFm_Fixed%b, during the applications configuration phase.
*p  The routine takes a single argument, which can be %bFm_Network%b or
    %bFm_Domain%b. In the first case the routine examines all the processors
    in the network to produce a result. In the second case the routine
    limits itself to the processors in the user's current domain.
    It returns a single integer, the number of processors that are currently
    available and believed suitable.
*x  Farm-Library
*x FmFloodOption
*k Farm Library
#
*n  FmControllerInitialise\System library
*P  to specify an optional application-specific initialization routine
*I  <farmlib.h>
*F  VoidFnPtr FmControllerInitialise;
*p  This variable is part of the Helios farm library.
    In many applications there is a large amount of one-off initialization
    to be done. For example, in graphical applications it is necessary
    to connect to an X terminal and open one or more windows. When using the
    farm library it is not usually possible to perform this initialization
    from inside %bmain()%b because %bmain()%b is executed from inside all the
    workers as well as from inside the controller.
*p  To avoid these problems the farm library provides a mechanism for
    installing an application-specific initialization routine that will
    be invoked only inside the controller. This routine should not
    take any arguments and its result will be ignored. The routine
    is installed by setting the %bFmControllerInitialise%b variable.
*p  The initialization routine will run on the same stack as %bmain()%b,
    as opposed to most other application routines that will run in
    separate threads with their own stacks. If the initialization routine
    needs a very large amount of stack then the program's default stack size
    should be changed.
*x  Farm-Library
*x FmInitialise
*x FmWorkerInitialise
*k Farm Library
#
*n  FmWorkerInitialise\System library
*P  to specify an optional application-specific initialization routine
*I  <farmlib.h>
*F  VoidFnPtr FmWorkerInitialise;
*p  This variable is part of the Helios farm library. In many applications there
    is a large amount of one-off initialization to be done. For example,
    in graphical applications it is necessary to connect to an X terminal
    and open one or more windows. When using the farm library it is not
    usually possible to perform such initialization from inside %bmain()%b
    because %bmain()%b is executed in all the workers as well as inside the controller.
*p  To avoid these problems the farm library provides a mechanism for
    installing an application-specific initialization routine that will
    be invoked only inside the workers and not from inside the controller.
    This routine should not take any arguments and its result will be
    ignored. The routine is installed by setting the %bFmWorkerInitialise%b variable.
*p  The initialization routine will run on the same stack as %bmain()%b,
    as opposed to most other application routines that will run in separate
    threads with their own stacks. If the initialization routine needs a
    very large amount of stack then the program's default stack size should
    be changed.
*x  Farm-Library
*x FmInitialise
*x FmControllerInitialise
*k Farm Library
#
*n  FmControllerExit\System library
*P  to specify an optional applications-specific termination routine
*I  <farmlib.h>
*F  VoidFnPtr FmControllerExit;
*p  This variable is part of the Helios farm library. Applications using the
    farm library can terminate under a number of circumstances:
*l  %b1%b
*t  The consumer routine returns, leaving the application with no
    way to handle replies to any jobs.
*l  %b2%b
*t  The consumer routine has called %bFmGetReply()%b when the producer
    routine has returned and there are no outstanding jobs in any of the
    workers.
*l  %b3%b
*t  Some part of the controller, usually the consumer, calls %bexit()%b
*l  %b4%b
*t  One of the workers has failed and the %bFmFaultHandling%b flag
    has not been enabled.
*p  When writing applications a common requirement is to perform some
    tidying up when the application finishes. Given the various different ways
    in which a farm library application can finish this can be quite difficult.
    Hence the farm library provides facilities whereby the application can
    install a routine which will be called during program termination.
    If the %bFmControllerExit%b variable has been set to the address of a routine
    during the library configuration phase then this routine will be invoked
    when the controller component of the application terminates.
    The routine should not take any arguments and its result will be ignored.
*x  Farm-Library
*x FmInitialise
*x FmWorkerExit
*k Farm Library
#
*n  FmWorkerExit\System library
*P  to specify an optional application-specific termination routine
*I  <farmlib.h>
*F   VoidFnPtr FmWorkerExit;
*p   This variable is part of the Helios farm library. Applications using the
     farm library can terminate under a number of circumstances:
*l  %b1%b
*t  The consumer routine returns, leaving the application with no
    way to handle replies to any jobs.
*l  %b2%b
*t  The consumer routine has called %bFmGetReply()%b when the producer
    routine has returned and there are no outstanding jobs in any of the
    workers.
*l  3
*t  Some part of the controller, usually the consumer, calls %bexit()%b
*l  4
*t  One of the workers has failed and the %bFmFaultHandling%b flag
    has not been enabled.
*p  When writing applications a common requirement is to perform some
    tidying up when the application finishes. Given the various different ways
    in which a farm library application can finish this can be quite difficult.
    Hence the farm library provides facilities whereby the application can
    install a routine which will be called during program termination.
    If the %bFmWorkerExit%b variable has been set to the address of a routine
    during the library configuration phase then this routine will be invoked
    in all of the worker components of the application.
    The routine should not take any arguments and its result will be ignored.
*x  Farm-Library
*x FmInitialise
*x FmControllerExit
*k Farm Library
#
*n  FmFastStack\System library
*P  to make worker routines use on-chip memory
*I  <farmlib.h>
*F  bool FmFastStack;
*p  This flag is part of the Helios farm library. It can be used to
    speed up the operation of the various worker components
    under certain circumstances, by moving the stack of those workers
    to fast on-chip memory. If this option is to be used then the flag
    should be set during the farm library configuration phase.
*p  The flag is only effective if there is enough on-chip memory
    available. The various worker routines all run in separate threads
    with their own stack, and the size of this stack is controlled
    by the variable %bFmWorkerStack%b. The default size is 5000 bytes which
    is usually too large to fit into on-chip memory. Hence it will usually be
    necessary to change the worker stack size as well.
*p  Even if the stack size is reduced there may not be enough on-chip
    memory available. The %bFmFastcode%b flag can be used to move code
    to on-chip memory. The application may use the underlying system
    calls %bAccelerate()%b and %bAccelerateCode()%b directly. Alternatively a
    worker may share a processor with some other application which makes
    use of on-chip memory.
*x  Farm-Library
*x FmInitialise
*x FmFastCode
*x Accelerate
*k Farm Library
#
*n  FmFastCode\System library
*P  to make worker routines use on-chip memory
*I  <farmlib.h>
*F  bool FmFastCode;
*p  This flag is part of the Helios farm library. It can be used to speed
    up the operation of the various worker components by moving the code
    of those workers to fast on-chip memory. If this option is to be used
    then the flag should be set during the farm library configuration phase.
*p  The flag is only effective if there is enough on-chip memory available
    to hold the code of the worker routine. In fact the underlying system
    call %bAccelerateCode()%b does not move just the worker routine into
    on-chip memory, it moves the entire module containing the worker
    routine. Hence it is usual to keep the worker routine in a separate
    source file, together with any routines called by it, compile
    this separately and then link the application together. This minimizes
    the amount of code in the module containing the worker and hence
    increases the probability that there will be enough on-chip memory
    to hold this module.
*x  Farm-Library
*x FmInitialise
*x AccelerateCode
*k Farm Library
#
*n  FmOverloadController\System library
*P  to run a worker routine in the controller program
*I  <farmlib.h>
*F  bool FmOverloadController
*p  This flag is part of the Helios farm library. If an application program uses
    the farm library then the program will be distributed over the network.
    The original problem is known as the controller, and all the copies are
    known as workers. Inside the controller program threads will be spawned
    to run the producer and consumer routines, and the provider routine if
    used. Inside all the workers threads will be spawned to run the worker
    routine. By default the controller program does not run the worker
    routine and hence it is not involved in useful computation, only in
    the administrative chores of generating jobs and handling replies.
*p  Producing jobs and/or handling the replies can be I/O intensive.
    For some farm applications this I/O is the main bottleneck and it
    is desirable to leave the controller free to perform its administration.
    For other applications the controller will be idle for most of the run
    and it is desirable to make this program perform some computation as well.
    If the %bFmOverloadController%b flag is set then the controller component
    will spawn a thread to run a worker routine, in addition to the producer,
    consumer, and provider routines. This means that there will be one
    more processor performing computation.
*x  Farm-Library
*x FmInitialise
*k Farm Library
#
*n  FmRunningWorkers\System library
*P  to indicate the number of workers still running
*I  <farmlib.h>
*F  int FmRunningWorkers;
*p  This variable is part of the Helios farm library. Its value is an indication
    of the number of workers currently running in the farm. When the application
    starts up this value will be %bFmNumberWorkers%b, and every time a worker
    fails this variable will be decremented. This assumes that the
    flag %bFmFaultHandling%b has been enabled - if not the application will
    terminate when the first worker fails.
*p  The value of %bFmRunningWorkers%b should be checked only in the producer
    and consumer routines. Its value may change at any time, asynchronously
    to the normal execution of these routines. Hence the value must be
    used with great care to avoid deadlock conditions.
*x  Farm-Library
*x FmNumberWorkers
*k Farm Library
#
*n  FmIsRunning\System library
*P  to determine whether or not a particular worker is still running
*I  <farmlib.h>
*F  bool FmIsRunning(int worker);
*p  This routine is part of the Helios farm library. It can be used in the
    producer and consumer routines to determine the current status of a
    particular worker. The routine takes a single argument,
    an integer in the range %b0 <= arg < FmNumberWorkers%b, specifying a worker.
    If that worker is currently believed to be running the routine will
    return TRUE, otherwise it will return FALSE.
*x  Farm-Library
*x FmFaultHandling
*k Farm Library
#
*n  FmRand\System library
*P  to generate pseudo-random numbers
*I  <farmlib.h>
*F  int FmSeed; int FmRand();
*p  This routine is part of the Helios farm library. A common use for
    processor farm applications is in Monte Carlo simulations. Such
    applications require access to a pseudo-random number generator such that
    the various worker routines running in the farm get different sequences
    of numbers. The %bFmRand()%b routine provides a random number generator
    that meets this requirement.
*p  In the library configuration phase it is possible to set the initial
    seed for the random number generator by assigning a value to the
    library variable %bFmSeed%b. If the application does not set the seed then
    the farm library will automatically generate one.
    The library ensures that all the workers
    use the same seed. The various worker routines can then call %bFmRand()%b
    to obtain suitable random numbers.
*p  The routine %bFmRand()%b does not take any arguments. It returns an integer
    in the range %b0 <= FmRand() < Fm_MaxRand%b.
*k Farm Library
#
*n  FmProvider\System library
*P  to specify an information provider routine
*I  <farmlib.h>
*F  VoidFnPtr FmProvider; int FmProviderStack
*p  For some applications it may be impossible or undesirable for all
    the workers to be given all the global information they might
    require. To cope with such cases the farm library has the concept
    of an information provider facility. The various worker routines
    distributed throughout the network can send back special information
    requests to the controller while processing a job. If this facility
    is to be used then the application should install an information
    provider routine using the %bFmProvider%b variable. The provider routine
    will be run in a separate thread within the controller, like the
    producer and consumer routines. The default stack size for this is
    5000 bytes, but an alternative stack size can be specified using
    the %bFmProviderStack%b variable.
*p  A typical information provider routine has the following structure:
*c= static void pi_provider(void)
*c= { PiInfoRequest *request;
*c=   PiInfoReply   *reply;
*c=
*c=   forever
*c=    { request = FmGetInfoRequest();
*c=      reply   = FmGetInfoReplyBuffer(request, sizeof(PiInfoReply));
*c=
*c=     /* Fill in the reply buffer */
*c=
*c=      FmSendInfoReply(reply);
*c=    }
*c= }
*p  Usually the provider routine will never terminate. When the application
    terminates the provider will be in a call to %bFmGetInfoRequest()%b, and
    it will terminate automatically.
*x  Farm-Library
*x FmInitialise
*x FmGetInfo
*x FmGetInfoRequest
*x FmGetInfoReplyBuffer
*x FmSendInfoReply
*k Farm Library
#
*n  FmGetInfoRequest\System library
*P  to receive an information request
*I  <farmlib.h>
*F  void *FmGetInfoRequest(void)
*p  This function is normally called from inside an application-specific
    information provider routine running within the controller of a farm.
    The function waits until one of the workers sends an information
    request. A copy of this request is returned. The function is defined
    not to fail: if no worker has sent an information request then the
    function will just block; if the application is terminating then this
    will happen inside the call to %bFmGetInfoRequest()%b.
*p  The request buffer returned by %bFmGetInfoRequest()%b is freed automatically
    by the farm library during the next call of %bFmGetInfoRequest()%b. The
    application need not free it explicitly, and must not access an earlier buffer
    after a call to %bFmGetInfoRequest()%b.
*x  Farm-Library
*x FmProvider
*x FmGetInfo
*k Farm Library
#
*n  FmGetInfoReplyBuffer\System library
*P  to obtain a reply buffer for an information request message
*I  <farmlib.h>
*F  void *FmGetInfoReplyBuffer(void *request, int size);
*p  This function is normally called from inside an application-specific
    information provider routine running within the controller of a
    farm. When the provider routine has received a request from a worker
    it needs to construct a reply message, and it needs a buffer in which
    to construct this reply. This function provides the required buffer.
*p  The function takes two arguments. The first is the information request
    being replied to, which should be the result of a recent call to
    %bFmGetInfoRequest()%b. The second is the size of the reply buffer, usually
    related to the size of a data structure. The function returns a
    suitable buffer. If there is not enough memory currently available
    the function will block until it can obtain sufficient memory.
*p  There is no need to free the buffer returned by a call to
    %bFmGetInfoReplyBuffer()%b. The buffer will be freed automatically when
    it has been sent off to the worker requesting the information using
    %bFmSendInfoReply()%b.
*x  Farm-Library
*x FmProvider
*x FmGetInfoRequest
*x FmSendInfoReply
*k Farm Library
#
*n  FmSendInfoReply\System library
*P  to send a reply to an information request
*I  <farmlib.h>
*F  void FmSendInfoReply(void *);
*D Send the reply to an earlier %bFmGetInfo%b request from a worker.
*p  This function is normally called from inside an application-specific
    information provider routine running within the controller of a farm.
    When the provider routine has received an information request from
    a worker, obtained a buffer for the reply, and filled in the reply buffer,
    this buffer can be sent off using %bFmSendInfoReply()%b. The routine takes
    a single argument which should be a buffer previously returned by a
    call to %bFmGetInfoReplybuffer()%b. The function is defined not to fail.
*x  Farm-Library
*x FmProvider
*x FmGetInfo
*x FmGetInfoReplyBuffer
*k Farm Library
#
*n  FmGetInfoRequestBuffer\System library
*P  to obtain a buffer for holding an information request
*I  <farmlib.h>
*F  void *FmGetInfoRequestBuffer(int size);
*p For some farm
    applications it is necessary for workers to obtain additional
    information from the controller in order to process a particular job.
    This is achieved by filling in an information request, sending it off
    to the information provider routine within the controller, and getting
    back the reply.
*p  The %bFmGetInfo()%b function performs the interaction with the provider
    routine.
    It takes a single argument which should be the result of a recent call
    to %bFmGetInfoRequestBuffer()%b filled in by the application with the
    details needed by the information provider routine. This buffer is sent
    off to the controller program where it will be received by the
    application-specific provider routine. The provider should construct
    a suitable reply and send it off with a call to %bFmSendInfoReply()%b.
    A copy of this reply buffer will be received by the worker and will be
    returned as the result of %bFmGetInfo()%b.
*p  The reply buffer will be released automatically when the application
    next calls %bFmGetInfo()%b. If the buffer consumes a large amount of memory,
    and if the information in the buffer is no longer required, and the
    application may not call %bFmGetInfo()%b again for some time, then it is
    possible to release the buffer early by a call to %bFmFreeInfoReplyBuffer()%b.
*x  Farm-Library
*x FmProvider
*x FmGetInfoRequestBuffer
*x FmFreeInfoReplyBuffer
*k Farm Library
#
*n  FmFreeInfoReplyBuffer\System library
*P  to release an information reply buffer early
*I  <farmlib.h>
*F  void FmFreeInfoReplyBuffer(void *);
*D Release early a buffer returned by %bFmGetInfo%b.
*p  For some farm applications
    it is necessary for workers to obtain additional information from the
    controller in order to process a particular job. This is achieved by
    sending an information request to the controller and getting back a
    suitable reply, using %bFmGetInfo()%b.
*p  The buffer returned by %bFmGetInfo()%b will be freed automatically when the
    worker routine next calls %bFmGetInfo()%b. If the buffer consumes a large
    amount of memory, and if the information in the buffer is no longer
    required, and the application may not call %bFmGetInfo()%b again for
    some time, then it is possible to release the buffer early by a call
    to %bFmFreeInfoReplyBuffer()%b. This routine takes a single argument, which
    should be a buffer returned by a recent call to %bFmGetInfo()%b.
*x  Farm-Library
*x FmProvider
*x FmGetInfo
*k Farm Library
#
*n  passadm\Helios command
*P  to administer the password database
*F  passadm
*D  the %bpassadm%b program is intended for use by system
    administrators. It allows the existing entries in the password file
    to be examined and edited, new entries to be added, and existing entries
    to be deleted.
*p  %bpassadm%b is menu-based. Further help information can be obtained while
    the program is running by pressing H.
*p  Although intended for use by system administrators, the program can be
    run by any user and does not make any checks as to which user is running
    it. The program does not have any special access to the password file,
    and users should make sure that the file is writable before attempting
    to make any changes.
#
*n sort\Helios command
*P sort a file of lines
*F sort [-findcrumb] [-tc] [+beg_pos[opts] [-end_pos]] [-o outfile] [file]
*D the %bsort%b command sorts lines of a file (or standard input if no file specified) according to a range of options. With no options, lines will be sorted in ascending ASCII order, starting at the beginning of each line.
*A
*p %bsort%b accepts the following arguments :
*l %b-f%b
*t Fold upper case to lower.
*l -n Sort to numeric value (optional decimal point) implies -b
*l %b-b%b
*t Skip leading blanks
*l %b-i%b
*t Ignore chars outside ASCII range (040 - 0176)
*l %b-r%b
*t Reverse the sense of comparisons.
*l %b-d%b
*t Sort to dictionary order. Only letters, digits, commas and points are compared.
*p Any of these flags can be used in [opts], when they override all global ordering for this field.
*p %bsort%b accepts the following flags for I/O control : 
*l %b-u%b
*t Print unique lines only once.
*l %b-c%b
*t Check if files are sorted in order.
*l %b-m%b
*t Merge already sorted files.
*l %b-o outfile%b
*t Name of output file. (Can be one of the input files). Default is stdout.
*l %b-%b
*t Take stdin as input.
*p TO select which fields are to be used in comparisons, the following arguments can be used :
*l %b-tc%b : Field separating character is c
*l %b+a.b%b : Start comparing at field 'a' with offset 'b'. A missing 'b' is taken to be 0.
*l %b-a.b%b : Stop comparing at field 'a' with offset 'b'. A missing 'b' is taken to be 0.
*p A missing -a.b means the rest of the line.
*p For example, to sort the password file into numerically descending order of user id :
*c=sort -rnt: +2 /helios/etc/passwd
#
*n join \ Helios command
*P  join lines of two files on a common field
*F join
[-a 1|2] [-v 1|2] [-e empty-string] [-o field-list...] [-t char]
[-j[1|2] field] [-1 field] [-2 field] file1 file2
*D
This manual page
documents the GNU version of
join.
join
prints to the standard output a line for each pair of input lines, one
each from
file1
and
file2 ,
that have identical join fields.  Either filename (but not both) can
be `-', meaning the standard input.
file1
and
file2
should be already sorted in increasing order (not numerically) on the
join fields; unless the
-t
option is given, they should be sorted ignoring blanks at the start of
the line, as
sort
does when given the
-b
option.
*p
The defaults are: the join field is the first field in each line;
fields in the input are separated by one or more blanks, with leading
blanks on the line ignored; fields in the output are separated by a
space; each output line consists of the join field, the remaining
fields from
file1 ,
then the remaining fields from
file2 .
*A
*l -a file-number
*t Print a line for each unpairable line in file
file-number
(either 1 or 2), in addition to the normal output.
*l -e string
*t Replace empty output fields (those that are missing in the input) with
string .
*l -1, -j1 field
*t Join on field
field
(a positive integer) of file 1.
*l -2, -j2 field
*t Join on field
field
(a positive integer) of file 2.
*l -j field
*t Equivalent to
-1 field -2 field .
*l -o field-list...
*t Construct each output line according to the format in
field-list .
Each element in
field-list
consists of a file number (either 1 or 2), a period, and a field
number (a positive integer).  The elements in the list are separated
by commas or blanks.  Multiple
field-list
arguments can be given after a single
-o
option; the values of all lists given with
-o
are concatenated together.
*l -t char
*t Use character
char
as the input and output field separator.
*l -v file-number
*t Print a line for each unpairable line in file
file-number
(either 1 or 2), instead of the normal output.
*p
The long-named options can be introduced with `+' as well as `--',
for compatibility with previous releases.  Eventually support for `+'
will be removed, because it is incompatible with the POSIX.2 standard.
#
*n uniq \ Helios command
*P  remove duplicate lines from a sorted file
*F uniq
[-cdu] [-f skip-fields] [-s skip-chars] [-w check-chars]
[-#skip-fields] [+#skip-chars] [--count] [--repeated] [--unique]
[--skip-fields=skip-fields] [--skip-chars=skip-chars]
[--check-chars=check-chars] [infile] [outfile]
*D
This manual page
documents the GNU version of
uniq.
uniq
prints the unique lines in a sorted file, discarding all but one of a
run of matching lines.  It can optionally show only lines that appear
exactly once, or lines that appear more than once.
uniq
requires sorted input because it compares only consecutive lines.
*p
If the output file is not specified,
uniq
writes to the standard output.  If the input file is not specified, it
reads from the standard input.
*A
*l -u, --unique
*t Only print unique lines.
*l -d, --repeated
*t Only print duplicate lines.
*l -c, --count
*t Print the number of times each line occurred along with the line.
*l -, -f, --skip-fields=number
*t In this option, number is an integer representing the number of
fields to skip over before checking for uniqueness.  The first
number fields, along with any blanks found before number
fields is reached, are skipped over and not counted.  Fields are
defined as a strings of non-space, non-tab characters, that are
separated from each other by spaces and tabs.
*l --, -s, +skip-chars=number
*t In this option, number is an integer represent the number of
characters to skip over before checking for uniqueness.  The first
number characters, along with any blanks found before
number characters is reached, are skipped over and not counted.
If you use both the field and character skipping options, fields are
skipped over first.
*l -w, +check-chars=number
*t Specify the number of characters to compare in the lines, after
skipping any specified fields and characters.  Normally the entire
rest of the lines are compared.
*p
The long-named options can be introduced with `+' as well as `--',
for compatibility with previous releases.  Eventually support for `+'
will be removed, because it is incompatible with the POSIX.2 standard.
#
*n BSD-compatibility\General interest
*D To ease the problems of porting public domain programs and to provide compatibility with BSD UNIX, the Helios BSD compatibility library is provided.
No documentation
is supplied for these routines. They are all documented by Berkeley. The
following is a list of the contents of this library:
*c=alloca()        bcmp()         bcopy()          bzero()
*c=closelog()      ffs()          ftruncate()      getopt()
*c=getpass()       getw()         getwd()          index()
*c=inet_addr()     inet_lnaof()   inet_makeaddr()  inet_netof()
*c=inet_network()  inet_ntoa()    initgroups()     insque()
*c=ioctl()         mktemp()       openlog()        pclose()
*c=perror()        popen()        psignal()        putw()
*c=rcmd()          readlink()     readv()          remque()
*c=rexec()         rindex()       rresvport()      ruserok()
*c=seekdir()       setegid()      seteuid()        setgroups()
*c=setlinebuf()    setlogmask()   setrgid()        setruid()
*c=sigblock()      sigpause()     sigsetmask()     sigstack()
*c=sigvec()        strcasecmp()   strncasecmp()    syslog()
*c=telldir()       truncate()     writev()
*p The library also contains the following variables or tables.
*c=sys_errlist      sys_nerr      sys_siglist
*p For implementation purposes, the following routines are in the Posix library.
*c=getdtablesize()   gettimeofday()   lstat()
*c=wait2()           wait3()
*p Some extra headers have been added to the %binclude%b directories
to support BSD compatibility. These are listed below:
*c=sgtty.h       strings.h        sys/dir.h      sys/errno.h
*c=sys/file.h    sys/ioctl.h      sys/param.h    sys/resource.h
*c=sys/time.h    sys/ttychars.h   sys/ttydev.h   sys/un.h
*c=varargs.h
*p BSD compatibility features have been added to the following headers.
*c=errno.h        fcntl.h        pwd.h        signal.h
*c=stdio.h        string.h       sys/stat.h   sys/types.h
*c=sys/wait.h     unistd.h
*p The BSD compatibility features in the existing headers are only enabled if
the macro %b_BSD%b is defined. The BSD only headers will generate an error message
if they are included when %b_BSD%b has not been defined. Care must be taken when
mixing Posix and BSD specific code, because the headers redefine some things
for the BSD option.
 
The support for %bioctl()%b is limited. For terminals it is implemented on top of the Posix termios system, and it only implements the common features. The
most commonly used attributes: RAW, ECHO and TANDEM are implemented. The
ability to change the special characters is not currently implemented. All
ioctls to internet sockets are implemented with the exception of SIOCGIFCONF.
The following ioctls each correspond to their BSD
equivalent.
*c=FIONREAD     FIONBIO     TIOCGETD     TIOCGETP
*c=TIOCSETP     TIOCSETN    TIOCFLUSH    TIOCGETC
*c=TIOCLSET     TIOCLGET    TIOCGPGRP    TIOCSPGRP
*c=TIOCGLTC     TIOCSTOP    TIOCSTART    TIOCGWINSZ
*c=TIOCOUTQ
*p Some of these (TIOCFLUSH for instance) simply call the
equivalent Posix routine, which may not be implemented. Those ioctls
mentioned in the headers but not in this list will do nothing, and
return zero.
*q BSD compatibility, Berkeley
*k alloca
*k bcmp
*k bcopy
*k bzero
*k closelog
*k ffs
*k ftruncate
*k getopt
*k getpass
*k getw
*k getwd
*k index
*k inet_addr
*k inet_lnaof
*k inet_makeaddr
*k inet_netof
*k inet_network
*k inet_ntoa
*k initgroups
*k insque
*k ioctl
*k mktemp
*k openlog
*k pclose
*k perror
*k popen
*k psignal
*k putw
*k rcmd
*k readlink
*k readv
*k remque
*k rexec
*k rindex
*k rresvport
*k ruserok
*k seekdir
*k setegid
*k seteuid
*k setgroups
*k setlinebuf
*k setlogmask
*k setrgid
*k setruid
*k sigblock
*k sigpause
*k sigsetmask
*k sigstack
*k sigvec
*k strcasecmp
*k strncasecmp
*k syslog
*k telldir
*k truncate
*k writev
*k sys_errlist
*k sys_nerr
*k sys_siglist
*k getdtablesize
*k gettimeofday
*k lstat
*k wait2
*k wait3
*k FIONREAD
*k FIONBIO
*k TIOCGETD
*k TIOCGETP
*k TIOCSETP
*k TIOCSETN
*k TIOCFLUSH
*k TIOCGETC
*k TIOCLSET
*k TIOCLGET
*k TIOCGPGRP
*k TIOCSPGRP
*k TIOCGLTC
*k TIOCSTOP
*k TIOCSTART
*k TIOCGWINSZ
*k TIOCOUTQ
