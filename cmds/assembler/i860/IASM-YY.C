#define YY_DEFAULT_ACTION YY_FATAL_ERROR( "flex scanner jammed" );
#define FLEX_USE_ECS
#define FLEX_USE_MECS
#define FLEX_INTERACTIVE_SCANNER
/* A lexical scanner generated by flex */
#ifdef PCNAMES
#include "flexskdf.h"
#else
#include "flexskeldef.h"
#endif

#define INITIAL 0
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "iasm.h"
#ifdef PCNAMES
#include "iasm_tab.h"
#else
#include "iasm.tab.h"
#endif
extern YYSTYPE yylval;
bool comment_at_start = 0;

AFILE *currentfile;
AFILE *nextcurrentfile;
AFILE  filestack[MAXGETFILES];
int    filenum;
int   skipping_level = 0;

int mygets( char *buf, int maxsize );
Symbol *macrolabel(char *s, int l);
Symbol *locallabel(char *text, int l);
Symbol *label(char *text, int l);
TextSeg *macroarg(char *s, int l, bool comment);
Symbol *lastlabel;

#undef YY_INPUT
#define YY_INPUT(buf, result, maxsize ) \
         result = mygets( buf, maxsize )
#undef yywrap
int yywrap(void);

#define COMMENT 2
#define INSTR 4
#define MACROARGS 6
#define MACRODEF 8
#define SKIPPING 10
#define YY_JAM 171
#define YY_JAM_BASE 561
#define YY_TEMPLATE 172
static signed char l[172] =
    {   0,
       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
       -2,   -2,   68,   44,   67,   68,   68,   48,   54,   57,
       46,   47,   52,   50,   45,   51,   17,   53,    6,    7,
       61,   68,   60,   68,   18,   58,   18,   18,   18,   59,
       66,   44,   17,   53,    6,    7,   18,   18,   18,   18,
        3,    4,   31,   30,   30,   31,   35,   33,   36,   34,
       38,   39,   38,   43,   41,   43,   43,   43,   44,    0,
       65,    0,   49,   18,    2,   16,    6,    7,    0,   55,
       63,   64,   62,   56,   18,    0,   18,   18,   18,   44,
        0,    0,    0,   18,   14,    1,   16,    6,    7,   18,

       18,   18,   20,   19,   23,   22,   24,   21,   29,   33,
       33,   38,    0,    0,    0,   42,    8,   15,    5,   18,
       18,   18,    0,    0,   14,   13,   15,   18,   18,   18,
       27,   28,   26,   25,   32,   38,   40,    0,    0,   42,
        0,   18,   18,   18,    0,   12,   18,   18,   18,   32,
       32,   32,   37,   18,    9,   18,   18,    9,   18,   32,
       18,   10,   18,   10,   18,   18,   18,   18,   11,   11,
        0
    } ;

static signed char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
       19,   19,   19,   19,   19,   20,   20,   21,    1,   22,
       23,   24,    1,   25,   26,   26,   26,   26,   26,   26,
       27,   27,   27,   27,   27,   27,   27,   27,   27,   27,
       27,   27,   27,   27,   27,   27,   27,   28,   27,   27,
        1,    1,    1,   29,   27,    1,   30,   31,   32,   33,

       34,   35,   36,   27,   37,   27,   27,   38,   39,   40,
       41,   27,   42,   43,   44,   45,   46,   27,   27,   28,
       27,   47,    1,   48,    1,   49,    1
    } ;

static signed char m[50] =
    {   0,
        1,    2,    3,    1,    4,    1,    4,    4,    4,    4,
        4,    4,    4,    1,    4,    5,    2,    6,    6,    6,
        7,    4,    1,    4,    1,    8,    9,    9,    4,    8,
        8,    8,    8,    8,    8,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    4,    1
    } ;

static short int b[188] =
    {   0,
        0,   49,  314,  313,   97,   99,  115,  164,  100,  101,
      105,  107,  561,  103,  561,  292,    0,  561,  561,  561,
      561,  561,  561,  300,  561,  561,    0,  295,  130,  107,
       84,  287,   88,    0,    0,  561,  293,  269,   87,  561,
      561,  143,  286,  289,  162,  136,  284,  130,  132,  136,
      561,  561,  561,  561,  561,  160,  561,  287,  561,  561,
      299,  561,  144,  561,  561,  283,   92,  264,  157,  279,
      561,  290,  561,    0,  561,  269,  176,  181,    0,  561,
      561,  561,  561,  561,    0,    0,  263,  260,  258,  201,
      269,  272,  190,  267,  266,  561,  151,  204,  207,  185,

      154,  195,  561,  561,  196,  561,  561,  197,  561,  269,
      268,  204,    0,  240,  250,  198,  277,  561,    0,  245,
      237,  239,  257,  211,  561,  561,  256,  212,   88,  112,
      561,  561,  561,  561,  248,  214,    0,  242,  243,  561,
      241,  238,  227,  221,  242,  561,  213,  214,  218,    0,
      297,  346,  255,  213,    0,  217,  222,  230,  221,  395,
      213,    0,  224,  191,  132,  223,  139,  225,    0,  102,
      561,  444,  453,  462,  471,  480,  489,  493,  498,  506,
      510,  518,  522,  525,  534,  543,  552
    } ;

static short int d[188] =
    {   0,
      171,  171,  172,  172,  173,  173,  174,  174,  175,  175,
      176,  176,  171,  171,  171,  171,  177,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  178,  171,  171,  171,
      171,  171,  171,  179,  178,  171,  178,  178,  178,  171,
      171,  180,  181,  171,  171,  171,  181,  181,  181,  181,
      171,  171,  171,  171,  171,  171,  171,  182,  171,  171,
      175,  171,  175,  171,  171,  171,  171,  171,  171,  171,
      171,  177,  171,  178,  171,  171,  171,  171,  183,  171,
      171,  171,  171,  171,  178,  179,  178,  178,  178,  180,
      184,  171,  171,  181,  171,  171,  171,  171,  171,  181,

      181,  181,  171,  171,  171,  171,  171,  171,  171,  182,
      182,  175,  185,  171,  171,  171,  177,  171,  183,  178,
      178,  178,  184,  171,  171,  171,  171,  181,  181,  181,
      171,  171,  171,  171,  186,  175,  185,  171,  171,  171,
      171,  178,  178,  178,  171,  171,  181,  181,  181,  187,
      186,  186,  175,  178,  178,  178,  181,  181,  181,  186,
      178,  178,  181,  181,  178,  181,  178,  181,  178,  181,
    -32767,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171
    } ;

static short int n[611] =
    {   0,
       13,   14,   15,   16,   17,   18,   13,   19,   20,   21,
       22,   23,   24,   25,   26,   27,   28,   29,   30,   30,
       13,   31,   32,   33,   34,   35,   35,   35,   36,   35,
       35,   35,   37,   35,   35,   35,   38,   35,   39,   35,
       35,   35,   35,   35,   35,   35,   35,   40,   41,   13,
       42,   15,   16,   17,   18,   13,   19,   20,   21,   22,
       23,   24,   25,   26,   43,   44,   45,   46,   46,   13,
       31,   32,   33,   34,   47,   47,   47,   36,   47,   47,
       47,   48,   47,   47,   47,   49,   47,   50,   47,   47,
       47,   47,   47,   47,   47,   47,   40,   41,   54,   55,

       54,   55,   62,   62,   69,   80,   81,   65,   95,   65,
       83,   84,   56,   76,   56,   57,   88,   59,   57,   70,
       57,   66,   95,   66,   78,   78,   78,   89,   60,  114,
      148,  115,   95,   63,   63,   57,   76,   57,   67,   57,
       67,   68,   97,   68,   90,   86,  171,   77,   77,   78,
       95,  149,   95,   99,   99,   99,   95,   79,   69,   92,
       93,   93,   93,   57,   57,  101,   59,   57,   97,   57,
      100,  126,  169,   70,   95,  127,  102,   60,  167,   98,
       98,   99,   76,  112,   57,  129,   57,   76,   57,   79,
      103,  104,  105,   77,   77,   78,  124,  106,   78,   78,

       78,  107,   90,  108,  109,   95,  171,   93,   93,   93,
       97,   95,   57,   97,  128,   95,  171,   92,   93,   93,
       93,   98,   98,   99,   99,   99,   99,  130,  131,  133,
      140,  126,   95,   95,   95,  145,  136,  141,   95,  132,
      134,   95,   95,   95,   95,   95,  157,  147,  150,  165,
       95,  150,  153,  150,  158,  162,  161,  171,  170,  164,
      166,  150,  146,  159,  152,  163,  156,  155,  150,  168,
      150,  154,  150,  140,  140,  140,  146,   95,  144,  143,
      142,  117,  139,  138,  135,  111,  125,   95,   96,   95,
      122,  121,  120,  118,  117,   75,  150,  150,  116,  113,

      150,  171,  150,  111,   95,   96,   95,   87,   86,   82,
      150,   75,   73,  160,   71,   52,   52,  150,  171,  150,
      171,  150,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  150,  150,  171,  171,  150,
      171,  150,  171,  171,  171,  171,  171,  171,  171,  150,
      171,  171,  152,  171,  171,  171,  150,  171,  150,  171,
      150,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  150,  150,  171,  171,  150,  171,

      150,  171,  171,  171,  171,  171,  171,  171,  150,  171,
      171,  152,  171,  171,  171,  150,  171,  150,  171,  150,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  150,   51,   51,   51,   51,   51,   51,
       51,   51,   51,   53,   53,   53,   53,   53,   53,   53,
       53,   53,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       64,   64,   64,   64,   64,   64,   64,   64,   64,   72,
       72,  171,   72,   72,   72,   72,   72,   72,   74,  171,

       74,   74,   85,  171,  171,   85,   85,   91,  171,  171,
       91,   91,  171,   91,   91,   94,   94,   94,   94,  110,
      171,  110,  110,  110,  171,  110,  110,  119,  171,  119,
      123,  123,  123,  123,  137,  137,  171,  137,  137,  137,
      137,  137,  137,  151,  151,  171,  151,  151,  151,  151,
      151,  151,  150,  150,  171,  150,  150,  150,  150,  150,
      150,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,

      171,  171,  171,  171,  171,  171,  171,  171,  171,  171
    } ;

static short int c[611] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    5,    5,

        6,    6,    9,   10,   14,   31,   31,   11,  129,   12,
       33,   33,    5,   30,    6,    7,   39,    7,    7,   14,
        7,   11,  170,   12,   30,   30,   30,   39,    7,   67,
      129,   67,  130,    9,   10,    7,   29,    7,   11,    7,
       12,   11,   46,   12,   42,   48,   63,   29,   29,   29,
       48,  130,   49,   46,   46,   46,   50,   29,   69,   42,
       42,   42,   42,    7,    8,   50,    8,    8,   45,    8,
       49,   97,  167,   69,  101,   97,   50,    8,  165,   45,
       45,   45,   77,   63,    8,  101,    8,   78,    8,   45,
       56,   56,   56,   77,   77,   77,   93,   56,   78,   78,

       78,   56,   90,   56,   56,  100,  112,   93,   93,   93,
       98,  164,    8,   99,  100,  102,  136,   90,   90,   90,
       90,   98,   98,   98,   99,   99,   99,  102,  105,  108,
      116,  124,  128,  147,  148,  124,  112,  116,  149,  105,
      108,  159,  157,  166,  163,  168,  147,  128,  135,  161,
      158,  135,  136,  135,  148,  156,  154,  153,  168,  159,
      163,  135,  145,  149,  135,  157,  144,  143,  135,  166,
      135,  142,  135,  141,  139,  138,  127,  123,  122,  121,
      120,  117,  115,  114,  111,  110,   95,   94,   92,   91,
       89,   88,   87,   76,   72,   70,  135,  151,   68,   66,

      151,   61,  151,   58,   47,   44,   43,   38,   37,   32,
      151,   28,   24,  151,   16,    4,    3,  151,    0,  151,
        0,  151,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,  151,  152,    0,    0,  152,
        0,  152,    0,    0,    0,    0,    0,    0,    0,  152,
        0,    0,  152,    0,    0,    0,  152,    0,  152,    0,
      152,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,  152,  160,    0,    0,  160,    0,

      160,    0,    0,    0,    0,    0,    0,    0,  160,    0,
        0,  160,    0,    0,    0,  160,    0,  160,    0,  160,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,  160,  172,  172,  172,  172,  172,  172,
      172,  172,  172,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  174,  174,  174,  174,  174,  174,  174,  174,
      174,  175,  175,  175,  175,  175,  175,  175,  175,  175,
      176,  176,  176,  176,  176,  176,  176,  176,  176,  177,
      177,    0,  177,  177,  177,  177,  177,  177,  178,    0,

      178,  178,  179,    0,    0,  179,  179,  180,    0,    0,
      180,  180,    0,  180,  180,  181,  181,  181,  181,  182,
        0,  182,  182,  182,    0,  182,  182,  183,    0,  183,
      184,  184,  184,  184,  185,  185,    0,  185,  185,  185,
      185,  185,  185,  186,  186,    0,  186,  186,  186,  186,
      186,  186,  187,  187,    0,  187,  187,  187,  187,  187,
      187,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,

      171,  171,  171,  171,  171,  171,  171,  171,  171,  171
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin, *yyout, *yyerr;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;




    if ( yy_init )
	{
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	yyin = YY_STDIN;
	yyout = YY_STDOUT;
	yyerr = YY_STDERR;
	}

    goto get_next_token;

do_action:
    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
{ comment_at_start = 1;
                BEGIN COMMENT;
              }
	YY_BREAK
case 2:
BEGIN COMMENT;
	YY_BREAK
case 3:
;
	YY_BREAK
case 4:
{ BEGIN 0;
                if( comment_at_start )
                { outlistline();
                  comment_at_start = 0;   /* Go for next line */
                }
                else return NEWLINE;
              }
	YY_BREAK
case 5:
{ yylval.ival = (int32)strtoul(yytext+2,NULL,16);
            return NUMBER;
          }
	YY_BREAK
case 6:
{ yylval.ival  = (int32)strtoul(yytext,NULL,8);
            return NUMBER;
          }
	YY_BREAK
case 7:
{ yylval.ival  = strtol(yytext, NULL, 10);
            return NUMBER;
          }
	YY_BREAK
case 8:
{  yylval.text = aalloc(yyleng-1);
            memcpy(yylval.text, yytext+1, yyleng-2);
            yylval.text[yyleng-2] = '\0';
            return STRING;
         }
	YY_BREAK
case 9:
{  BEGIN MACRODEF;
            return MACROSTART;
         }
	YY_BREAK
case 10:
{ return MODNUM; }
	YY_BREAK
case 11:
{ return IMAGESIZE; }
	YY_BREAK
case 12:
{
            yylval.symbol = macrolabel(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 13:
{
            yylval.symbol = locallabel(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 14:
{
            yylval.symbol = label(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 15:
{ yylval.symbol = macrolabel(yytext,yyleng);
            return SYMBOL;
          }
	YY_BREAK
case 16:
{ yylval.symbol = locallabel(yytext,yyleng);
            return SYMBOL;
          }
	YY_BREAK
case 17:
return DOT;		/* Must be before {SYMSTART} */
	YY_BREAK
case 18:
{
            bool dim;
            Symbol *sym = NULL;
            bool at;

/* '@' and 'd.' are mutually exclusive */

            if( yytext[0] == '@' )
               at = 1, yytext++,yyleng--;
            else
               at = 0;

            if( yytext[0] == 'd' && yytext[1]== '.' )
            {  sym = lookup(yytext+2, yyleng-2, 0, S_INSTR );
               if( sym ) dim = 1;
            }
            else
               dim=0;

            if( sym == 0 )
               sym = lookup(yytext,yyleng,1,S_NULL);

            switch( sym->symtype )
            {
            case S_INSTR:
              {
                yylval.instr = newexpression();
                yylval.instr->exprtype = E_INSTR;
                yylval.instr->e1.symbol = sym;
                yylval.instr->e2.insmodifiers = (dim)? I_DIM:0;
                dim = 0;
                BEGIN INSTR;
                break;
              }
            case S_IREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return IREGISTER;
              }
            case S_FREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return FREGISTER;
              }
            case S_CREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return CREGISTER;
              }
            case S_MACRO:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                BEGIN MACROARGS;
                return MACRO;
              }
            case S_EQU: case S_SET:
            case S_LABEL: case S_NULL:
            case S_DATA:
              {
                yylval.symbol = sym;
                if( at )
                {  if( sym->symtype == S_NULL )
                   {  sym->symtype = S_DATA;
                      return AT;
                   }
                   else
                   {  if( sym->symtype == S_DATA ) return AT;
                      else
                         return JUNK;
                   }
                }
                return SYMBOL;
              }

            }
          }
	YY_BREAK
case 19:
{ char *sname = yylval.instr->e1.symbol->name;
              char *newsym = NULL;
              BEGIN 0;
/* This is a horrid kludge ! */
              if( sname[0] == 'l' && sname[1] == 'd' )
                  newsym = "ld.c";
              if( sname[0] == 's' && sname[1] == 't' )
                  newsym = "st.c";
              if( newsym )
                  yylval.instr->e1.symbol = lookup(newsym,4,0,S_INSTR);
              yylval.instr->e2.insmodifiers = I_CM; return INSTRUCTION;
            }
	YY_BREAK
case 20:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_BM; return INSTRUCTION;
	YY_BREAK
case 21:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SM; return INSTRUCTION;
	YY_BREAK
case 22:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_LM; return INSTRUCTION;
	YY_BREAK
case 23:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DM; return INSTRUCTION;
	YY_BREAK
case 24:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_QM; return INSTRUCTION;
	YY_BREAK
case 25:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SSM; return INSTRUCTION;
	YY_BREAK
case 26:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SDM; return INSTRUCTION;
	YY_BREAK
case 27:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DDM; return INSTRUCTION;
	YY_BREAK
case 28:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DSM; return INSTRUCTION;
	YY_BREAK
case 29:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_TM;return INSTRUCTION;
	YY_BREAK
case 30:
BEGIN 0; yyless(yyleng-1); return INSTRUCTION;
	YY_BREAK
case 31:
BEGIN 0;yylval.instr->e2.insmodifiers |= I_BADM; return INSTRUCTION;
	YY_BREAK
case 32:
{
            yylval.textseg = macroarg(yytext,yyleng,1);
            return MACROARG;
         }
	YY_BREAK
case 33:
{
            yylval.textseg = macroarg(yytext,yyleng,0);
            return MACROARG;
         }
	YY_BREAK
case 34:
return COMMA;
	YY_BREAK
case 35:
return JUNK;
	YY_BREAK
case 36:
{ BEGIN 0;
                 return NEWLINE;
               }
	YY_BREAK
case 37:
BEGIN 0; return MACROEND; 
	YY_BREAK
case 38:
{ yylval.textseg = aalloc(sizeof(TextSeg)+yyleng);
                 memcpy(yylval.textseg->text, yytext, yyleng);
                 yylval.textseg->text[yyleng] = '\0';
                 yylval.textseg->cdr = NULL;
                 return MACROLINE;
               }
	YY_BREAK
case 39:
return NEWLINE;
	YY_BREAK
case 40:
;
	YY_BREAK
case 41:
{ listing_flags |= LF_NOCODE;
                 return NEWLINE;
               }
	YY_BREAK
case 42:
{
                listing_flags |= LF_NOCODE;
                yylval.instr = newexpression();
                yylval.instr->exprtype = E_INSTR;
                yylval.instr->e1.symbol = lookup(yytext,yyleng,0,S_INSTR);
                yylval.instr->e2.insmodifiers = 0;
                return INSTRUCTION;
               }
	YY_BREAK
case 43:
;
	YY_BREAK
case 44:
;
	YY_BREAK
case 45:
return COMMA;
	YY_BREAK
case 46:
return LPAREN;
	YY_BREAK
case 47:
return RPAREN;
	YY_BREAK
case 48:
return HASH;
	YY_BREAK
case 49:
return AUTOINC;
	YY_BREAK
case 50:
return PLUS;
	YY_BREAK
case 51:
return MINUS;
	YY_BREAK
case 52:
return TIMES;
	YY_BREAK
case 53:
return DIVIDE;
	YY_BREAK
case 54:
return MOD;
	YY_BREAK
case 55:
return LSHIFT;
	YY_BREAK
case 56:
return RSHIFT;
	YY_BREAK
case 57:
return AND;
	YY_BREAK
case 58:
return XOR;
	YY_BREAK
case 59:
return OR;
	YY_BREAK
case 60:
return GT;
	YY_BREAK
case 61:
return LT;
	YY_BREAK
case 62:
return GE;
	YY_BREAK
case 63:
return LE;
	YY_BREAK
case 64:
return EQ;
	YY_BREAK
case 65:
return NE;
	YY_BREAK
case 66:
return NOT;
	YY_BREAK
case 67:
return NEWLINE;
	YY_BREAK
case 68:
return JUNK;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_DO_DEFAULT:
YY_DEFAULT_ACTION;
break;

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
			break;
			}
		    }

		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	/* if we got this far, then we didn't find any accepting
	 * states
	 */

	/* so that the default applies to the first char read */
	++yy_c_buf_p;

	yy_act = YY_DO_DEFAULT;
	}
	}

    /*NOTREACHED*/
    }


static int unput( c )
char c;

    {
    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
	{
	register int i;
	register int yy_buf_pos = YY_BUF_MAX;

	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
	    {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	    }

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
	}

    if ( yy_c_buf_p <= 0 )
	YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] = c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


static int input()

    {
    int c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
	{ /* need more input */
	int yy_n_chars;

	/* we can throw away the entire current buffer */
	if ( yy_saw_eof )
	    {
	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;
	    }

	yy_b_buf_p = 0;
	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

	if ( yy_n_chars == YY_NULL )
	    {
	    yy_saw_eof = 1;

	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;

	    return ( input() );
	    }

	yy_c_buf_p = -1;
	yy_e_buf_p = yy_n_chars - 1;
	}

    c = yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }


int yywrap(void)
{
   if( currentfile->flags & ff_macro )
      afree(currentfile->io.macro);
   else
   {
      fclose(currentfile->io.file.stream);
      afree(currentfile->io.file.buf);
   }
   currentfile--, filenum--;
   if( filenum == 0 )
   {  yy_init = 1;      /* Re-initialise yylex on next token request */
      return 1;
   }
   else
      return 0;
}

int mygets( char *buf, int maxsize)
{
   int r;

   if( nextcurrentfile != NULL )
   {  currentfile = nextcurrentfile;
      nextcurrentfile = NULL;
   }

   if( currentfile->flags & ff_macro )
      r = arg_subs(buf, currentfile->io.macro, maxsize );
   else
   {
     if( fgets(buf, maxsize, currentfile->io.file.stream) != 0 )
     {
	r = strlen(buf);
     }
     else
	r = 0;
   }

   if( r == 0 ) return 0;

   if( currentfile->flags & ff_nlfound )
   {  currentfile->lineno++;
      currentfile->flags &= ~ff_nlfound;
   }

   if( buf[r-1] == '\n' )
      currentfile->flags |= ff_nlfound;
   addtosrcline(buf,r);
   return r;
}

int arg_subs( char *buf, Macro *macro, int maxsize )
{  char *mtext;
   int r=0;
   char ch;
   bool argcont;     /* argument continuation flag */

   if( macro->argtext )
   {  mtext = macro->argtext;
      macro->argtext = NULL;
      argcont = 1;
   }
   else
   {
      mtext = macro->tptr;
      argcont = 0;
   }

   if( debugflags & DEBUG_MACRO )
   {  int i=1;
      TextSeg *arg = macro->args;
      for( ; arg; arg = arg->cdr,i++ )
         fprintf(stderr,"Macro arg %d = \"%s\"\n",i,arg->text);
   }

   if( mtext == NULL ) return 0;

   while( (ch = *mtext) != '\0' && r < maxsize-1 )
   {
      if( ch == '$' && !argcont )
      {  char *substr = NULL;

         switch ( *(++mtext) )
         {
         case '$':
            *buf++ = '$';
            mtext++, r++;
            break;

         case '@':
            *buf++ = '$';
            r++;        /* Don't use @ yet - it may not fit */
            break;

         default:
            {  char *np;
               int argno,i;
               TextSeg *arg;
   
               arg = macro->args;
               i = argno = strtol(mtext, &np, 10);
      
               mtext = np;    /* Should check valid number */
      
               while(--i && (arg != NULL) )
                  arg = arg->cdr;
      
               if( arg == NULL )
                  error("Can't find arg %d", argno);
               else
                  substr = arg->text;

               break;
            }
         }
         if( substr )
         {  int copysize;
            int substrl = strlen(substr);

            if( substrl >= maxsize-r )
            {
/* The next line will exit the loop                      */
               copysize       = maxsize-r-1;
               macro->argtext = substr + copysize;
            }
            else
               copysize = substrl;

            memcpy(buf, substr, copysize);
            buf += copysize;
            r += copysize;
         }
      }
      else
         *buf++ = *mtext++, r++;
   }

   if( *mtext != '\0' )
   {
      if( argcont )
         macro->argtext = mtext;    /* Rest of argument string */
      else
         macro->tptr = mtext;       /* Rest of macro string */
   }
   else
   {
      if( !argcont )
      {  if( macro->argtext == 0 )
         {
            *buf = '\n'; r++;
            if( (macro->line = macro->line->cdr) != NULL )
               macro->tptr = macro->line->text;    /* Next line */
            else
               macro->tptr = NULL;                 /* No next line */
         }
         else
            macro->tptr = mtext; /* Save current position in macro text */
      }
   }
   return r;
}

static int macrolabelnum;

Symbol *macrolabel(char *s, int l)
{  Symbol *r;
   char labname[50];

   if( !(currentfile->flags & ff_macro) )
   {  error("$@ not in macro");
      return 0;
   }

   l -= (s[l-1] == ':' )? 2: 1;

   while( isspace(*s) ) s++,l--;

   if( !(currentfile->flags & ff_macrolabelvalid) )
   {
      sprintf(currentfile->io.macro->label,"%d", macrolabelnum++);
      currentfile->flags |= ff_macrolabelvalid;
   }

   memcpy(labname,s,l); labname[l] = '\0';
   strcat(labname+l,currentfile->name);
   strcat(labname+l,"$");
   strcat(labname+l,currentfile->io.macro->label);

   r = lookup(labname,strlen(labname),1,S_LABEL);
   r->symflags |= sf_invisible;
   return r;
}

Symbol *locallabel(char *text, int l)
{
   char localname[20];
   Symbol *sym;
   int l1 = sprintf(localname,"%s$",lastlabel->name);

   if( text[l-1] == ':' ) l--;

   memcpy(localname+l1,text,l);
   localname[l1+l] = '\0';
   sym = lookup(localname,l1+l,1,S_LABEL);
   sym->symflags |= sf_invisible;
   return sym;
}

void start_skipping(void)
{
   skipping_level++;
   BEGIN SKIPPING;
}

void stop_skipping(void)
{
   if( --skipping_level == 0 ) BEGIN 0;
}

void lexinit(void)
{
   lastlabel = lookup("$$$",3,1,S_LABEL);
   resolvesym(lastlabel,0,S_LABEL);
   lastlabel->symflags |= sf_invisible;
   macrolabelnum = 0;
   yy_init = 1;
}

Symbol *label(char *s, int l)
{  Symbol *r;
   bool exported = 0;

   if( s[l-1] == ':' ) l--;
   if( s[l-1] == ':' ) l--,exported=1;

   while( (*s == '\t') || (*s == ' ') ) s++,l--;
   r = lookup(s,l,1,S_NULL);  /* Do not set to label - it might be resolved */
                              /* to something else later */
   if( exported ) r->symflags |= sf_exported;
   return r;
}

TextSeg *macroarg(char *s, int l, bool comment)
{  TextSeg *r;

   if( comment )
   {  char *es = strstr(s,"//");
      l = es-s;
   }

   while( isspace(*s) && l > 0) s++,l--;
   while( isspace(s[l-1]) && l > 0) l--;

   r = aalloc(sizeof(TextSeg)+l);
   memcpy(r->text, s, l);
   r->text[l] = '\0';
   r->cdr = NULL;
   return r;
}
