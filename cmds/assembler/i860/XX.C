#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */
#ifdef PCNAMES
#include "flexskdf.h"
#else
#include "flexskeldef.h"
#endif

# line 1 "iasm.l"
#define INITIAL 0
# line 2 "iasm.l"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "iasm.h"
#ifdef PCNAMES
#include "iasm-tab.h"
#else
#include "iasm.tab.h"
#endif
extern YYSTYPE yylval;
bool comment_at_start = 0;

AFILE *currentfile;
AFILE *nextcurrentfile;
AFILE  filestack[MAXGETFILES];
int    filenum;
int   skipping_level = 0;

int mygets( char *buf, int maxsize );
Symbol *macrolabel(char *s, int l);
Symbol *locallabel(char *text, int l);
Symbol *label(char *text, int l);
TextSeg *macroarg(char *s, int l, bool comment);
Symbol *lastlabel;

#undef YY_INPUT
#define YY_INPUT(buf, result, maxsize ) \
         result = mygets( buf, maxsize )
#undef yywrap
int yywrap(void);

#define COMMENT 2
#define INSTR 4
#define MACROARGS 6
#define MACRODEF 8
#define SKIPPING 10
# line 47 "iasm.l"
#define YY_JAM 150
#define YY_JAM_BASE 423
#define YY_TEMPLATE 151
static signed char l[151] =
    {   0,
       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
       -2,   -2,   66,   41,   65,   66,   66,   45,   51,   54,
       43,   44,   49,   47,   42,   48,   64,   50,    6,    7,
       58,   66,   57,   66,   16,   55,   16,   16,   56,   63,
       41,   50,    6,    7,   13,   13,   13,    3,    4,   28,
        0,   32,   30,   33,   31,   35,   36,   35,   40,   38,
       40,   40,   40,   41,    0,   62,    0,   46,    2,   15,
        6,    7,    0,   52,   60,   61,   59,   53,   16,   16,
        0,   16,   16,   41,    0,    0,    0,    1,   12,    6,
        7,   13,   13,   13,   13,   18,   17,   21,   20,   22,

       19,   27,   30,   30,   35,    0,    0,    0,   39,    8,
       14,    5,   16,   16,    0,    0,   12,   11,   13,   13,
       13,   25,   26,   24,   23,   29,   35,   37,    0,    0,
       39,    0,   16,   16,    0,   11,   13,   13,   29,   29,
       29,   34,    9,   16,    9,   13,   29,   10,   10,    0
    } ;

static signed char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
       19,   19,   19,   19,   19,   20,   20,   21,    1,   22,
       23,   24,    1,   25,   26,   26,   26,   26,   26,   26,
       27,   27,   27,   27,   27,   27,   27,   27,   27,   27,
       27,   27,   27,   27,   27,   27,   27,   28,   27,   27,
        1,    1,    1,   29,   27,    1,   30,   31,   32,   33,

       34,   35,   27,   27,   36,   27,   27,   37,   38,   39,
       40,   27,   41,   42,   43,   44,   45,   27,   27,   28,
       27,   27,    1,   46,    1,   47,    1
    } ;

static signed char m[48] =
    {   0,
        1,    2,    3,    1,    4,    1,    4,    4,    4,    4,
        4,    4,    4,    1,    4,    1,    2,    5,    5,    5,
        6,    4,    1,    4,    1,    7,    8,    8,    4,    7,
        7,    7,    7,    7,    7,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    4,    1
    } ;

static short int b[166] =
    {   0,
        0,   47,  287,  286,   93,   95,  111,  158,   96,   97,
       99,  103,  423,  101,  423,  265,    0,  423,  423,  423,
      423,  423,  423,  273,  423,  423,  423,  267,  122,  103,
       82,  260,   84,    0,    0,  423,  264,   98,  423,  423,
      149,  262,  137,  166,  257,  103,  150,  423,  423,  423,
      156,  423,  260,  423,  423,  273,  423,  110,  423,  423,
      258,  106,  239,  146,  256,  423,  267,  423,  423,  246,
      184,  188,    0,  423,  423,  423,  423,  423,    0,    0,
        0,  238,  236,  158,  251,  191,  246,  423,  171,  194,
      208,  245,  244,  197,  149,  423,  423,  187,  423,  423,

      188,  423,  247,  246,  191,    0,  219,  228,  113,  255,
      423,    0,  216,  217,  198,  233,  423,  226,  423,  105,
      195,  423,  423,  423,  423,  234,  214,    0,  212,  213,
      423,  211,  203,  197,  218,  423,  201,  204,    0,  281,
      220,  230,    0,  194,  133,  215,  136,    0,   80,  423,
      328,  336,  344,  352,  360,  362,  366,  373,  377,  384,
      388,  391,  399,  407,  415
    } ;

static short int d[166] =
    {   0,
      150,  150,  151,  151,  150,  150,  152,  152,  153,  153,
      154,  154,  150,  150,  150,  150,  155,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  156,  157,  150,  157,  157,  150,  150,
      158,  150,  150,  150,  159,  159,  159,  150,  150,  150,
      150,  150,  160,  150,  150,  153,  150,  153,  150,  150,
      150,  150,  150,  150,  150,  150,  155,  150,  150,  150,
      150,  150,  161,  150,  150,  150,  150,  150,  157,  157,
      156,  157,  157,  158,  150,  150,  162,  150,  150,  150,
      150,  159,  150,  159,  159,  150,  150,  150,  150,  150,

      150,  150,  160,  160,  153,  163,  150,  150,  150,  155,
      150,  161,  157,  157,  150,  162,  150,  150,  150,  159,
      159,  150,  150,  150,  150,  164,  153,  163,  150,  150,
      150,  150,  157,  157,  150,  150,  159,  159,  165,  164,
      140,  153,  157,  157,  159,  159,  140,  157,  159,-32767,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150
    } ;

static short int n[471] =
    {   0,
       13,   14,   15,   16,   17,   18,   13,   19,   20,   21,
       22,   23,   24,   25,   26,   27,   28,   29,   30,   30,
       13,   31,   32,   33,   34,   35,   35,   35,   36,   35,
       35,   35,   37,   35,   35,   35,   35,   38,   35,   35,
       35,   35,   35,   35,   35,   39,   40,   13,   41,   15,
       16,   17,   18,   13,   19,   20,   21,   22,   23,   24,
       25,   26,   27,   42,   43,   44,   44,   13,   31,   32,
       33,   34,   45,   45,   45,   36,   45,   45,   45,   46,
       45,   45,   45,   45,   47,   45,   45,   45,   45,   45,
       45,   45,   39,   40,   50,   50,   50,   50,   57,   57,

       93,   60,   64,   74,   75,   60,   77,   78,   51,   70,
       51,   52,  150,   54,   52,   61,   52,   65,   81,   61,
       72,   72,   72,   93,   55,   93,   52,   82,   70,   58,
       58,   52,   62,   52,   63,   52,   62,   83,   63,   71,
       71,   72,  107,   89,  108,  131,  137,   64,  105,   73,
       84,  132,  141,   93,   90,   90,   91,   52,   52,   84,
       54,   52,   65,   52,   73,   85,   86,   86,   86,   93,
       93,   55,   89,   52,   85,   86,   86,   86,   52,   94,
       52,  121,   52,   91,   91,   91,   96,   97,   98,   95,
       70,  117,   99,  150,   70,  118,  100,  115,  101,  102,

       89,   71,   71,   72,   52,   72,   72,   72,   86,   86,
       86,   90,   90,   91,   89,   93,  150,   93,  117,  122,
      124,   93,  135,  127,   93,   91,   91,   91,  120,  123,
      125,  148,  150,  138,  139,   93,  141,  139,  136,  139,
      145,  144,  143,  131,  131,  131,  136,  139,  146,  139,
      141,  142,  149,   93,  139,  134,  139,  133,  139,  110,
      130,  129,  126,  104,  119,   93,   93,   88,  114,  113,
      111,  110,   69,  109,  106,  150,  104,   93,   88,   81,
      139,  139,   76,   69,  139,   68,  139,   66,   49,   49,
      150,  150,  150,  150,  139,  150,  139,  147,  150,  150,

      150,  139,  150,  139,  150,  139,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  139,   48,   48,
       48,   48,   48,   48,   48,   48,   53,   53,   53,   53,
       53,   53,   53,   53,   56,   56,   56,   56,   56,   56,
       56,   56,   59,   59,   59,   59,   59,   59,   59,   59,
       67,   67,  150,   67,   67,   67,   67,   67,   79,   79,
       80,  150,   80,   80,   87,  150,  150,   87,  150,   87,
       87,   92,   92,   92,   92,  103,  150,  103,  103,  150,
      103,  103,  112,  150,  112,  116,  116,  116,  116,  128,

      128,  150,  128,  128,  128,  128,  128,  140,  140,  150,
      140,  140,  140,  140,  140,  139,  139,  150,  139,  139,
      139,  139,  139,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150
    } ;

static short int c[471] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    5,    5,    6,    6,    9,   10,

      149,   11,   14,   31,   31,   12,   33,   33,    5,   30,
        6,    7,   58,    7,    7,   11,    7,   14,   46,   12,
       30,   30,   30,   46,    7,  120,    7,   38,   29,    9,
       10,    7,   11,    7,   11,    7,   12,   38,   12,   29,
       29,   29,   62,   43,   62,  109,  120,   64,   58,   29,
       41,  109,  147,  145,   43,   43,   43,    7,    8,   84,
        8,    8,   64,    8,   43,   41,   41,   41,   41,   95,
       47,    8,   44,    8,   84,   84,   84,   84,    8,   47,
        8,   95,    8,   44,   44,   44,   51,   51,   51,   47,
       71,   89,   51,  105,   72,   89,   51,   86,   51,   51,

       90,   71,   71,   71,    8,   72,   72,   72,   86,   86,
       86,   90,   90,   90,   91,  121,  127,   94,  115,   98,
      101,  137,  115,  105,  138,   91,   91,   91,   94,   98,
      101,  144,  142,  121,  126,  146,  141,  126,  135,  126,
      137,  134,  133,  132,  130,  129,  118,  126,  138,  126,
      126,  127,  146,  116,  126,  114,  126,  113,  126,  110,
      108,  107,  104,  103,   93,   92,   87,   85,   83,   82,
       70,   67,   65,   63,   61,   56,   53,   45,   42,   37,
      126,  140,   32,   28,  140,   24,  140,   16,    4,    3,
        0,    0,    0,    0,  140,    0,  140,  140,    0,    0,

        0,  140,    0,  140,    0,  140,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,  140,  151,  151,
      151,  151,  151,  151,  151,  151,  152,  152,  152,  152,
      152,  152,  152,  152,  153,  153,  153,  153,  153,  153,
      153,  153,  154,  154,  154,  154,  154,  154,  154,  154,
      155,  155,    0,  155,  155,  155,  155,  155,  156,  156,
      157,    0,  157,  157,  158,    0,    0,  158,    0,  158,
      158,  159,  159,  159,  159,  160,    0,  160,  160,    0,
      160,  160,  161,    0,  161,  162,  162,  162,  162,  163,

      163,    0,  163,  163,  163,  163,  163,  164,  164,    0,
      164,  164,  164,  164,  164,  165,  165,    0,  165,  165,
      165,  165,  165,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
      150,  150,  150,  150,  150,  150,  150,  150,  150,  150
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;




    if ( yy_init )
	{
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:
    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
# line 49 "iasm.l"
{ comment_at_start = 1;
                BEGIN COMMENT;
              }
	YY_BREAK
case 2:
# line 53 "iasm.l"
BEGIN COMMENT;
	YY_BREAK
case 3:
# line 55 "iasm.l"
;
	YY_BREAK
case 4:
# line 57 "iasm.l"
{ BEGIN 0;
                if( comment_at_start )
                { outlistline();
                  comment_at_start = 0;   /* Go for next line */
                }
                else return NEWLINE;
              }
	YY_BREAK
case 5:
# line 65 "iasm.l"
{ yylval.ival = (int32)strtoul(yytext+2,NULL,16);
            return NUMBER;
          }
	YY_BREAK
case 6:
# line 69 "iasm.l"
{ yylval.ival  = (int32)strtoul(yytext,NULL,8);
            return NUMBER;
          }
	YY_BREAK
case 7:
# line 73 "iasm.l"
{ yylval.ival  = strtol(yytext, NULL, 10);
            return NUMBER;
          }
	YY_BREAK
case 8:
# line 77 "iasm.l"
{  yylval.text = aalloc(yyleng-1);
            memcpy(yylval.text, yytext+1, yyleng-2);
            yylval.text[yyleng-2] = '\0';
            return STRING;
         }
	YY_BREAK
case 9:
# line 83 "iasm.l"
{  BEGIN MACRODEF;
            return MACROSTART;
         }
	YY_BREAK
case 10:
# line 87 "iasm.l"
{ return MODNUM; }
	YY_BREAK
case 11:
# line 89 "iasm.l"
{
            yylval.symbol = macrolabel(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 12:
# line 94 "iasm.l"
{
            yylval.symbol = locallabel(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 13:
# line 99 "iasm.l"
{
            yylval.symbol = label(yytext,yyleng);
            return LABEL;
          }
	YY_BREAK
case 14:
# line 104 "iasm.l"
{ yylval.symbol = macrolabel(yytext,yyleng);
            return SYMBOL;
          }
	YY_BREAK
case 15:
# line 108 "iasm.l"
{ yylval.symbol = locallabel(yytext,yyleng);
            return SYMBOL;
          }
	YY_BREAK
case 16:
# line 112 "iasm.l"
{
            bool dim;
            Symbol *sym = NULL;
            bool at;

/* '@' and 'd.' are mutually exclusive */

            if( yytext[0] == '@' )
               at = 1, yytext++,yyleng--;
            else
               at = 0;

            if( yytext[0] == 'd' && yytext[1]== '.' )
            {  sym = lookup(yytext+2, yyleng-2, 0, S_INSTR );
               if( sym ) dim = 1;
            }
            else
               dim=0;

            if( sym == 0 )
               sym = lookup(yytext,yyleng,1,S_NULL);

            switch( sym->symtype )
            {
            case S_INSTR:
              {
                yylval.instr = newexpression();
                yylval.instr->exprtype = E_INSTR;
                yylval.instr->e1.symbol = sym;
                yylval.instr->e2.insmodifiers = (dim)? I_DIM:0;
                dim = 0;
                BEGIN INSTR;
                break;
              }
            case S_IREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return IREGISTER;
              }
            case S_FREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return FREGISTER;
              }
            case S_CREGISTER:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                return CREGISTER;
              }
            case S_MACRO:
              {
                yylval.symbol = sym;
                if( at ) return JUNK;
                BEGIN MACROARGS;
                return MACRO;
              }
            case S_EQU: case S_SET:
            case S_LABEL: case S_NULL:
            case S_DATA:
              {
                yylval.symbol = sym;
                if( at )
                {  if( sym->symtype == S_NULL )
                   {  sym->symtype = S_DATA;
                      return AT;
                   }
                   else
                   {  if( sym->symtype == S_DATA ) return AT;
                      else
                         return JUNK;
                   }
                }
                return SYMBOL;
              }

            }
          }
	YY_BREAK
case 17:
# line 193 "iasm.l"
{ char *sname = yylval.instr->e1.symbol->name;
              char *newsym = NULL;
              BEGIN 0;
/* This is a horrid kludge ! */
              if( sname[0] == 'l' && sname[1] == 'd' )
                  newsym = "ld.c";
              if( sname[0] == 's' && sname[1] == 't' )
                  newsym = "st.c";
              if( newsym )
                  yylval.instr->e1.symbol = lookup(newsym,4,0,S_INSTR);
              yylval.instr->e2.insmodifiers = I_CM; return INSTRUCTION;
            }
	YY_BREAK
case 18:
# line 205 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_BM; return INSTRUCTION;
	YY_BREAK
case 19:
# line 206 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SM; return INSTRUCTION;
	YY_BREAK
case 20:
# line 207 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_LM; return INSTRUCTION;
	YY_BREAK
case 21:
# line 208 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DM; return INSTRUCTION;
	YY_BREAK
case 22:
# line 209 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_QM; return INSTRUCTION;
	YY_BREAK
case 23:
# line 210 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SSM; return INSTRUCTION;
	YY_BREAK
case 24:
# line 211 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_SDM; return INSTRUCTION;
	YY_BREAK
case 25:
# line 212 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DDM; return INSTRUCTION;
	YY_BREAK
case 26:
# line 213 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_DSM; return INSTRUCTION;
	YY_BREAK
case 27:
# line 214 "iasm.l"
BEGIN 0;yylval.instr->e2.insmodifiers |= I_TM;return INSTRUCTION;
	YY_BREAK
case 28:
# line 215 "iasm.l"
BEGIN 0; yyless(yyleng-1); return INSTRUCTION;
	YY_BREAK
case 29:
# line 217 "iasm.l"
{
            yylval.textseg = macroarg(yytext,yyleng,1);
            return MACROARG;
         }
	YY_BREAK
case 30:
# line 221 "iasm.l"
{
            yylval.textseg = macroarg(yytext,yyleng,0);
            return MACROARG;
         }
	YY_BREAK
case 31:
# line 226 "iasm.l"
return COMMA;
	YY_BREAK
case 32:
# line 227 "iasm.l"
return JUNK;
	YY_BREAK
case 33:
# line 228 "iasm.l"
{ BEGIN 0;
                 return NEWLINE;
               }
	YY_BREAK
case 34:
# line 232 "iasm.l"
BEGIN 0; return MACROEND; 
	YY_BREAK
case 35:
# line 233 "iasm.l"
{ yylval.textseg = aalloc(sizeof(TextSeg)+yyleng);
                 memcpy(yylval.textseg->text, yytext, yyleng);
                 yylval.textseg->text[yyleng] = '\0';
                 yylval.textseg->cdr = NULL;
                 return MACROLINE;
               }
	YY_BREAK
case 36:
# line 240 "iasm.l"
return NEWLINE;
	YY_BREAK
case 37:
# line 242 "iasm.l"
;
	YY_BREAK
case 38:
# line 243 "iasm.l"
{ listing_flags |= LF_NOCODE;
                 return NEWLINE;
               }
	YY_BREAK
case 39:
# line 246 "iasm.l"
{
                listing_flags |= LF_NOCODE;
                yylval.instr = newexpression();
                yylval.instr->exprtype = E_INSTR;
                yylval.instr->e1.symbol = lookup(yytext,yyleng,0,S_INSTR);
                yylval.instr->e2.insmodifiers = 0;
                return INSTRUCTION;
               }
	YY_BREAK
case 40:
# line 254 "iasm.l"
;
	YY_BREAK
case 41:
# line 256 "iasm.l"
;
	YY_BREAK
case 42:
# line 258 "iasm.l"
return COMMA;
	YY_BREAK
case 43:
# line 259 "iasm.l"
return LPAREN;
	YY_BREAK
case 44:
# line 260 "iasm.l"
return RPAREN;
	YY_BREAK
case 45:
# line 261 "iasm.l"
return HASH;
	YY_BREAK
case 46:
# line 262 "iasm.l"
return AUTOINC;
	YY_BREAK
case 47:
# line 263 "iasm.l"
return PLUS;
	YY_BREAK
case 48:
# line 264 "iasm.l"
return MINUS;
	YY_BREAK
case 49:
# line 265 "iasm.l"
return TIMES;
	YY_BREAK
case 50:
# line 266 "iasm.l"
return DIVIDE;
	YY_BREAK
case 51:
# line 267 "iasm.l"
return MOD;
	YY_BREAK
case 52:
# line 268 "iasm.l"
return LSHIFT;
	YY_BREAK
case 53:
# line 269 "iasm.l"
return RSHIFT;
	YY_BREAK
case 54:
# line 270 "iasm.l"
return AND;
	YY_BREAK
case 55:
# line 271 "iasm.l"
return XOR;
	YY_BREAK
case 56:
# line 272 "iasm.l"
return OR;
	YY_BREAK
case 57:
# line 273 "iasm.l"
return GT;
	YY_BREAK
case 58:
# line 274 "iasm.l"
return LT;
	YY_BREAK
case 59:
# line 275 "iasm.l"
return GE;
	YY_BREAK
case 60:
# line 276 "iasm.l"
return LE;
	YY_BREAK
case 61:
# line 277 "iasm.l"
return EQ;
	YY_BREAK
case 62:
# line 278 "iasm.l"
return NE;
	YY_BREAK
case 63:
# line 279 "iasm.l"
return NOT;
	YY_BREAK
case 64:
# line 280 "iasm.l"
return DOT;
	YY_BREAK
case 65:
# line 282 "iasm.l"
return NEWLINE;
	YY_BREAK
case 66:
# line 284 "iasm.l"
return JUNK;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_DO_DEFAULT:
YY_DEFAULT_ACTION;
break;

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
			break;
			}
		    }

		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	/* if we got this far, then we didn't find any accepting
	 * states
	 */

	/* so that the default applies to the first char read */
	++yy_c_buf_p;

	yy_act = YY_DO_DEFAULT;
	}
	}

    /*NOTREACHED*/
    }


static int unput( c )
char c;

    {
    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
	{
	register int i;
	register int yy_buf_pos = YY_BUF_MAX;

	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
	    {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	    }

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
	}

    if ( yy_c_buf_p <= 0 )
	YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] = c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


static int input()

    {
    int c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
	{ /* need more input */
	int yy_n_chars;

	/* we can throw away the entire current buffer */
	if ( yy_saw_eof )
	    {
	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;
	    }

	yy_b_buf_p = 0;
	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

	if ( yy_n_chars == YY_NULL )
	    {
	    yy_saw_eof = 1;

	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;

	    return ( input() );
	    }

	yy_c_buf_p = -1;
	yy_e_buf_p = yy_n_chars - 1;
	}

    c = yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }
# line 286 "iasm.l"


int yywrap(void)
{
   if( currentfile->flags & ff_macro )
      afree(currentfile->io.macro);
   else
   {
      fclose(currentfile->io.file.stream);
      afree(currentfile->io.file.buf);
   }
   currentfile--, filenum--;
   if( filenum == 0 )
   {  yy_init = 1;      /* Re-initialise yylex on next token request */
      return 1;
   }
   else
      return 0;
}

int mygets( char *buf, int maxsize)
{
   int r;

   if( nextcurrentfile != NULL )
   {  currentfile = nextcurrentfile;
      nextcurrentfile = NULL;
   }

   if( currentfile->flags & ff_macro )
      r = arg_subs(buf, currentfile->io.macro, maxsize );
   else
   {
     if( fgets(buf, maxsize, currentfile->io.file.stream) != 0 )
     {
	r = strlen(buf);
     }
     else
	r = 0;
   }

   if( r == 0 ) return 0;

   if( currentfile->flags & ff_nlfound )
   {  currentfile->lineno++;
      currentfile->flags &= ~ff_nlfound;
   }

   if( buf[r-1] == '\n' )
      currentfile->flags |= ff_nlfound;
   addtosrcline(buf,r);
   return r;
}

int arg_subs( char *buf, Macro *macro, int maxsize )
{  char *mtext;
   int r=0;
   char ch;
   bool argcont;     /* argument continuation flag */

   if( macro->argtext )
   {  mtext = macro->argtext;
      macro->argtext = NULL;
      argcont = 1;
   }
   else
   {
      mtext = macro->tptr;
      argcont = 0;
   }

   if( debugflags & DEBUG_MACRO )
   {  int i=1;
      TextSeg *arg = macro->args;
      for( ; arg; arg = arg->cdr,i++ )
         fprintf(stderr,"Macro arg %d = \"%s\"\n",i,arg->text);
   }

   if( mtext == NULL ) return 0;

   while( (ch = *mtext) != '\0' && r < maxsize-1 )
   {
      if( ch == '$' && !argcont )
      {  char *substr = NULL;

         switch ( *(++mtext) )
         {
         case '$':
            *buf++ = '$';
            mtext++, r++;
            break;

         case '@':
            *buf++ = '$';
            r++;        /* Don't use @ yet - it may not fit */
            break;

         default:
            {  char *np;
               int argno,i;
               TextSeg *arg;
   
               arg = macro->args;
               i = argno = strtol(mtext, &np, 10);
      
               mtext = np;    /* Should check valid number */
      
               while(--i && (arg != NULL) )
                  arg = arg->cdr;
      
               if( arg == NULL )
                  error("Can't find arg %d", argno);
               else
                  substr = arg->text;

               break;
            }
         }
         if( substr )
         {  int copysize;
            int substrl = strlen(substr);

            if( substrl >= maxsize-r )
            {
/* The next line will exit the loop                      */
               copysize       = maxsize-r-1;
               macro->argtext = substr + copysize;
            }
            else
               copysize = substrl;

            memcpy(buf, substr, copysize);
            buf += copysize;
            r += copysize;
         }
      }
      else
         *buf++ = *mtext++, r++;
   }

   if( *mtext != '\0' )
   {
      if( argcont )
         macro->argtext = mtext;    /* Rest of argument string */
      else
         macro->tptr = mtext;       /* Rest of macro string */
   }
   else
   {
      if( !argcont )
      {  if( macro->argtext == 0 )
         {
            *buf = '\n'; r++;
            if( (macro->line = macro->line->cdr) != NULL )
               macro->tptr = macro->line->text;    /* Next line */
            else
               macro->tptr = NULL;                 /* No next line */
         }
         else
            macro->tptr = mtext; /* Save current position in macro text */
      }
   }
   return r;
}

static int macrolabelnum;

Symbol *macrolabel(char *s, int l)
{  Symbol *r;
   char labname[50];

   if( !(currentfile->flags & ff_macro) )
   {  error("$@ not in macro");
      return 0;
   }

   l -= (s[l-1] == ':' )? 2: 1;

   while( isspace(*s) ) s++,l--;

   if( !(currentfile->flags & ff_macrolabelvalid) )
   {
      sprintf(currentfile->io.macro->label,"%d", macrolabelnum++);
      currentfile->flags |= ff_macrolabelvalid;
   }

   memcpy(labname,s,l); labname[l] = '\0';
   strcat(labname+l,currentfile->name);
   strcat(labname+l,"$");
   strcat(labname+l,currentfile->io.macro->label);

   r = lookup(labname,strlen(labname),1,S_LABEL);
   r->symflags |= sf_invisible;
   return r;
}

Symbol *locallabel(char *text, int l)
{
   char localname[20];
   Symbol *sym;
   int l1 = sprintf(localname,"%s$",lastlabel->name);

   if( text[l-1] == ':' ) l--;

   memcpy(localname+l1,text,l);
   localname[l1+l] = '\0';
   sym = lookup(localname,l1+l,1,S_LABEL);
   sym->symflags |= sf_invisible;
   return sym;
}

void start_skipping(void)
{
   skipping_level++;
   BEGIN SKIPPING;
}

void stop_skipping(void)
{
   if( --skipping_level == 0 ) BEGIN 0;
}

void lexinit(void)
{
   lastlabel = lookup("$$$",3,1,S_LABEL);
   resolvesym(lastlabel,0,S_LABEL);
   lastlabel->symflags |= sf_invisible;
   macrolabelnum = 0;
   yy_init = 1;
}

Symbol *label(char *s, int l)
{  Symbol *r;
   bool exported = 0;

   if( s[l-1] == ':' ) l--;
   if( s[l-1] == ':' ) l--,exported=1;

   while( (*s == '\t') || (*s == ' ') ) s++,l--;
   r = lookup(s,l,1,S_NULL);  /* Do not set to label - it might be resolved */
                              /* to something else later */
   if( exported ) r->symflags |= sf_exported;
   return r;
}

TextSeg *macroarg(char *s, int l, bool comment)
{  TextSeg *r;

   if( comment )
   {  char *es = strstr(s,"//");
      l = es-s;
   }

   while( isspace(*s) && l > 0) s++,l--;
   while( isspace(s[l-1]) && l > 0) l--;

   r = aalloc(sizeof(TextSeg)+l);
   memcpy(r->text, s, l);
   r->text[l] = '\0';
   r->cdr = NULL;
   return r;
}
