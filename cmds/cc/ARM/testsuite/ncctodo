-------------------------------------------------------------------------------
NorCroft Helios C compiler todo list:

Arthur, this is/should be a list of the bugs and features of the compiler
that we would like you to act upon:

16th March 1990 (using "ncc345 Apr 3 1990")
-------------------------------------------

C1)	Change fatal error message to generic (rather than Acorn) "Bug 9".

C2)	Change "-help" messages to better describe the Helios world.
	Remove references to the "-arthur" "-super" and "-pcc" options.

C3)	Change default header include path to "/helios/include".

C4)	"Bug 4" as discussed - causes fatal error when in normal mode
	(ie. non "-zr").

C5)	Additional option to provide switch to enable short offset mode (what
	we currently have). The default should generate code to reference
	any amount of static data (even though this may generate non-optimal
	referencing code).
	Our initial suggestion is:
		The compiler should generate multiple "PATCHARMDPREST" patches
		for each additional instruction after the initial
		"PATCHARMDPLSB" patch. The linker will generate a warning if
		a new "PATCHARMDPLSB" patch is encountered while information
		is held waiting for a "PATCHARMDPREST" patch.
	Would this cover your requirements? At the moment 12bits of data are
	passed from the compiler to the linker in the rotate/immediate fields
	of the original "PATCHARMDPLSB" instruction. This value is added to
	the patch offset generated by the linker. If the compiler is using
	this value (as it seems to be) to index the true static data sections
	from a compiler generated label then 12bits will not suffice to
	describe the complete memory range. Either the compiler will have to
	reference the correct label in the "PATCHARMDPLSB", always passing
	a 12bit value of 0 through to the linker, or a new patch form will
	need to be created to allow a 32bit compiler generated offset to be
	passed through to the linker.
	A QUICK RESPONSE ON THIS WOULD BE USEFUL, SINCE IT INVOLVES POSSIBLE
	CHANGES TO "armlink" AND ASSOCIATED TOOLS.

C6)	A very minor addition may be the placing of the compiler version
	number into the "Version" field of the module header, rather than
	the constant 1. It will allow us to tie external binaries to a
	particular compiler (I realise that the current compiler version
	number we receive from you is random(?!?), but it would still be
	useful).

-------------------------------------------------------------------------------
The following are all problems with "ncc345 Apr 3 1990" with the "-zs"
option selected (Split Module Table code generation):

SMT1)	The module header is incorrectly constructed. The compiler currently
	produces a "MaxData" field containing the sum of the sizes of the
	static data area and code pointer area. The "MaxCodeP" field is
	missing. Referring to document "Active Book Split Module Table Scheme",
	version 1, 20/11/89 by P. A. Beskeen:

		typedef struct Module {
				       word Type ;
				       word Size ;
				       char Name[32] ;
				       word Id ;
				       word Version ;
				       word MaxData ;
				       RPTR Init ;
				       word MaxCodeP ;
				      } Module ;

SMT2)	The initialisation code currently ignores the "Init" parameter
	passed in "r0/a1". The initialisation code is also constructed
	incorrectly. The "static data area" and the "code pointer area"
	should be initialised seperately. An init parameter of 2 should
	initialise the code tables, a parameter of 0 or 1 should initialise
	the data area. The following code fragments would be a possible
	solution:
	
			; INIT code (referenced by Init field of module header)
			; dp = Module table pointer. Slots are now multiples
			;      of 8. The first word in the slot references the
			;      static data area. The second word in the slot
			;      references the code pointer area.
			; a1 = Initialisation option
			; a2 = Temporary register
			; a3 = Temporary register
			; a4 = Temporary register
			; ip = Temporary register
			CMP	a1,#&03		; one more than largest index
			ADDCC	pc,pc,a1,LSL #2	; call the relevant code
			MOVS	pc,lk		; invalid argument return
			B	init_code	; a1 == 0
			B	init_code	; a1 == 1
			B	init2_code	; a1 == 2

		init_code	; static data area initialisation
			LDR	ip,[dp,#0]	; "SHIFT 2 MODNUM" patch
			MOV	a2,#&FFFFFFFF	; some initial value
		per_data_entry
			STR	a2,[ip],#4
		end_per_data_entry
			MOVS	pc,lk

		init2_code	; code pointer area initialisation
			LDR	ip,[dp,#4]	; "SHIFT 2 MODNUM" patch
			; the above relies on the linker adding the immediate
			; offset of 4 onto the calculate patch value.
		per_function
			SUB	a2,pc,#offset	; address of function 0
			STR	a2,[ip],#4
		end_per_function
			MOVS	pc,lk

	The thing to note though is that slot numbers are shared/overloaded
	between the static data slot entries and the code pointer entries.

	Aside: It does seem that the compiler correctly spots non-initialised
	"static data area" locations and does not NULL them itself.

SMT3)	Stub functions are incorrectly generated. The following code should
	be generated for an external call to "printf()":
		._printf
			LDR	ip,[dp,#4]	; "DATAMODULE __printf" patch
			LDR	ip,[ip,#0]	; "CODESYMB __printf" patch
			MOV	pc,ip		; call function
	The only difference between this code and that currently produced
	is the loading of the the immediate field of the "DATAMODULE" patched
	"PATCHARMDT" instruction. This offset of 4 is combined with that
	calculated by the linker (ie. "DATAMODULE" patches are multiples
	of 8 rather than 4).

SMT4)	Related to SMT2. The compiler seems to use different temporary
	registers for initialising the "static data area" sections (a3) and
	the "code pointer area" sections (a2). Surely this is unnecessary,
	even though they are both in the corruptable part of the PCS.

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
General
-------
Also note you should have a new version of the "objdump" utility. It now
provides the extra flags "-d" and "-i":
	-d	provide ARM disassembly
	-i	provide image and module table size information only

-------------------------------------------------------------------------------
								PAB 24/5/90

Hi Arthur,

I Have noticed a couple of bugs in the old ncc332 (not the latest ncc345
SMT version).

1) Two functions with the same name cause the compiler to fall over with
   a fatal error (after correctly identifying the problem). e.g.:

	---------------------------------------------------------------

	void die()
	{
		return;
	}

	void die()
	{
		return;
	}

	---------------------------------------------------------------


2)  If ^L (FormFeed's) are present in a source file, all error/warning line
    numbers are incremented erroneously by the number of previously occuring
    formfeeds (Formfeeds are treated as two lines).


Cheers,
Paul.
