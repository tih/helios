head     1.1;
branch   1.1.1;
access   ;
symbols  ncc:1.1.1.1 ncc:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     93.07.21.14.07.09;  author nick;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     93.07.21.14.07.10;  author nick;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@/*{{{  Includes */
/* $Id: cg2.c,v 1.2 90/10/17 16:02:13 nick Exp $ */
#ifdef __old
#include "cchdr.h"
#include "AEops.h"
#include "util.h"
#include "xpuops.h"
#include "cg.h"
#else
#include "globals.h"
#include "builtin.h"
#include "store.h"
#include "util.h"
#include "aeops.h"
#include "xpuops.h"
#include "cg.h"
#endif
/*}}}*/
/*{{{  Comment */
/* This file contains code for generating assignment statements and accessing
   variables (in particular indexed or indirected variables).
   
   Also the translation between AEops and transputer instructions
*/
/*}}}*/
/*{{{  Externs and fwd defs */

extern int maxssp;
extern int ssp;
extern int maxcall;
extern int depth();

extern bool is_same();

/* forward references */
void cg_storein();
void cg_var();

static int loadOp, storeOp, loadAddressOp;

struct AssignInfo
{
	Expr	*Target;
	int	TargetUsed;
	Expr	*Source;
	int	SourceEval;
} Assign = { 0, 0, 0, 0 };


#define islocalvar_(b)\
	(h0_(b) == s_binder && (bindstg_((Binder *)b) & bitofstg_(s_auto))) 
/*}}}*/
/*{{{  set_binder_ops */

Binder *set_binder_ops( Binder *b )
{
	switch( bindstg_(b) & PRINCSTGBITS )
	{
	case bitofstg_(s_auto):
	        loadOp = p_ldvl;
	        storeOp= p_stvl;
	        loadAddressOp = p_ldvlp;
	        b = (Binder *)bindxx_(b);
	        break;

	case bitofstg_(s_extern):
	        loadOp = p_ldx;
	        storeOp= p_stx;
	        loadAddressOp = p_ldxp;
		break;

	case bitofstg_(s_static):
	        loadOp = p_lds;
	        storeOp= p_sts;
	        loadAddressOp = p_ldsp;
		break;
	
	default:
		syserr("Funny storage class %#x\n",bindstg_(b));

	}
	return b;
}
/*}}}*/
#if 0
/*{{{  cg_scalarAssign */

/* We have found a scalar assignment statement,
   this is either s_assign    e.g.  a = ...;
   or             s_displace  e.g.  a++;
   
   in addition valneeded may or may not be set depending on whether we
   need to leave the value in the register as well
   e.g. a = b = 3;
   vs.  a = 3;

   This is part of an attempt to improve the code for simple assignments
   etc. More work is intended to be done here. In particular evaluating
   the depth of the two sides, to evaluate them in the best order, and
   dealing with valneeded by using dup when we know it is safe...
   For expediency at the moment, this just calls the old routines.
   This should also check for (e.g.) float x, y; x = y
   and generate ldl y stl x rather than ldlp y fpldnlsn  ldlp x fpstnlsn
*/
void cg_scalarAssign(x,valneeded)
Expr *x;
bool valneeded;
{
    int mclength  = mcrepofexpr(x);
    int mcmode    = (mclength>>24) & 0xff;
    Expr *target  = arg1_(x), *source = arg2_(x);
/*  int td = depth(target), sd = depth(source); */
    AEop targetOp = h0_(target);
    RegSort rsort = (mclength &= 0x00ffffff,
	(mcmode!=2) ? INTREG : (mclength==4 ? FLTREG : DBLREG ));

    Expr *ATSave;
    int ATUSave;
    int atu;
	
    push_trace("cg_scalarAssign");
    
    if(debugging(DEBUG_CG))
    {
       trace("Cg_scalarAssign: %s valneeded %d",symbol_name_(h0_(x)),valneeded);
       trace("mcmode %x targetmode %x sourcemode %x",(mcmode<<24)|mclength,
       		mcrepofexpr(target),mcrepofexpr(source));
#if 0
       eprintf("Target "); pr_expr(target);
       eprintf("\nSource "); pr_expr(source);eprintf("\n");
#endif
    }

    /* A displace in a void context can be replaced with a simple */
    /* assignment.						  */
    if( h0_(x) == s_displace && !valneeded ) h0_(x) = s_assign;

    /* This is where we should be much more subtle about depths etc */

    if( !floatingHardware && rsort == DBLREG ) 
    {
	cg_doubleassign( target, source, h0_(x), valneeded );
	pop_trace(); return;
    }

    if( !valneeded && targetOp == s_binder && h0_(source) == s_cond )
    {
	/* convert a = b ? c : d into b ? (a = c) : (a = d)	*/

	TypeExpr *t = typeofexpr(target);
	Expr *e = mk_expr3(s_cond,
			   t,
			   arg1_(source),
			   mk_expr2(s_assign, t, target, arg2_(source)),
			   mk_expr2(s_assign, t, target, arg3_(source)));
	pp_expr(e,0);
	cg_exprvoid(e);	   	    
	pop_trace(); return;
    }

    ATSave		= AssignTarget;
    ATUSave		= AssignTargetUsed;
    AssignTarget 	= target;
    AssignTargetUsed	= FALSE;

    cg_expr(source);

    atu			= AssignTargetUsed;
    AssignTarget	= ATSave;
    AssignTargetUsed	= ATUSave;

    if( !atu )
    {
	if (targetOp != s_binder)
		cg_storein( target, h0_(x), valneeded);
	else 
		cg_var(  target, h0_(x), mcmode, mclength, valneeded);
    }

       
   pop_trace();
}
/*}}}*/
/*{{{  cg_indirect */

/* The code generated here is not really very clever. It should be
 * improved later, so that it extracts constants from the index expression
 * into the base offset. It should also make use of wsubdb. These improvements
 * are probably better done in the pre parser (or at least supported there).
 * More attention should be paid to the context in which this procedure is
 * called.
 * At present something like short a[]; a[i] = a[j]; generates a move from a[j]
 * to a temp and then a move from this to a[i] where a direct move a[j] to a[i]
 * is obviously what is needed.
 * In general this, cg_scalarAssign, cg_var, cg_storein and cg_addr all 
 * need a total re-think and re-write.
 */
void cg_indirect(x,flag,mcmode,mclength,valneeded)
Expr *x;
int flag, mcmode, mclength,valneeded;
{
	VLocal *v1 = NULL;
	VLocal *v2 = NULL;
	Expr *x1, *x2 = NULL;
	int offset = 0, postinc = 0;
	const RegSort rsort = mcmode!=2 ? INTREG : 
				(mclength==4 ? FLTREG : DBLREG);
	int x1len, x1mode;
	int d = depth(x);
	int scaled = FALSE;

	/* if this is a T4 and we are trying to get a single precision	*/
	/* float, lie about it and load an integer instead.		*/
	if( !floatingHardware && rsort==FLTREG )
	{
		mcmode = 0;
		mclength = 4;
		rsort==INTREG;
	}

	push_trace("cg_indirect");
	
        if(debugging(DEBUG_CG))
	{ 
	    trace("Cg_indirect: %x %s flag %d mcmode %d mclength %d",
		x,symbol_name_(h0_(x)),flag,mcmode,mclength);
	    trace("valneeded %d depth %d",valneeded,d);
	}
	
	/*{{{  Calculate address and index expressions */
		switch( h0_(x))
		{
		case s_plus:
		/* test for (x + n), common case for structure and array access */
			x1 = arg1_(x); x2 = arg2_(x);
			if(integer_constant(x1) ) offset=result2, x1=x2, x2=NULL, d=depth(x1);
			else if(integer_constant(x2) ) offset=result2, x2 = NULL, d=depth(x1);
			else if( h0_(x2) == s_times && mclength == 4 )
			{/* check for (x + (y * 4)), common case for array access */
				if( integer_constant(arg1_(x2)) && result2 == 4 )
					scaled = TRUE, x2 = arg2_(x2);
				else if( integer_constant(arg2_(x2)) && result2 == 4 )
					scaled = TRUE, x2 = arg1_(x2);
			}
			break;
	
		case s_minus:
			x1 = arg1_(x); x2 = arg2_(x);
			if( integer_constant(x2) ) offset= -result2, x2 = NULL,d=depth(x1);
			else x1 = x, x2 = NULL;
			break;
	
		case s_displace:
		{
			Expr *v = arg1_(x), *x3 = arg2_(x);
			if( h0_(x3)==s_plus &&
				is_same(arg1_(x3),v) && integer_constant(arg2_(x3)))
			{ /* i.e. something like *p++ */
				postinc = result2;
				x = v;
				d = depth(x);
			}
		}
			/* drop through */
		
		default:
			x1 = x; x2 = NULL;
			break;
	
		} /* end of switch */
	/*}}}*/

	/* Here x1 is the expression to generate the address,	*/
	/* x2 is the offset, unless it is NULL in which case	*/
	/* there is a constant integer offset in offset. If the */
	/* expression contains a displace, there will be a post */
	/* increment in postinc.				*/

	if(debugging(DEBUG_CG))
		trace("x1 %s x2 %s offset %d postinc %d",
			x1?symbol_name_(h0_(x1)):"<NULL>",
			x2?symbol_name_(h0_(x2)):"<NULL>",
			offset,postinc);

	/*{{{  Make sufficient stack depth */
		if( !lxxAllowed && mcmode != 2 && mclength == 2 )
		{
			/* access to shorts on T4/8 always uses all registers */
			if( flag==s_assign||flag==s_displace ) v2 = pushtemp( INTREG );
			if( ida < 3 ) v1 = pushtemp( INTREG );
		}
		else if( mcmode != 2 || !floatingHardware )
		{
			/* integers and others */
			switch( flag )
			{
			case s_content:
				break;
			case s_assign:
				if( valneeded || idepth(d) > 2 ) v2 = pushtemp(INTREG);
				if( v2 && idepth(d) < 3 )
				{
					emit(p_ldvl, v2);
					pushInt();
				}
				break;
			case s_displace:
				if( idepth(d) > 2) v2 = pushtemp(INTREG);
				if( v2 && ida < 3 ) v1 = pushtemp(INTREG);
				break;
			}
		}
		else if ( mcmode == 2 )
		{
			/* floats and doubles, in T800 only */
			switch( flag )
			{
			case s_content:
				break;
			case s_assign:
				if( valneeded ) duplicate( FLTREG );
				break;
			case s_displace:
				break;
			}
		}
	/*}}}*/

	if( x2 != NULL ) 
	{
		int oldae = addrexpr;
		addrexpr = TRUE;
		cg_binary(s_nothing,x2,x1,0,INTREG);
		addrexpr = oldae;
	}
	else cg_addrexpr(x1);

	switch( mcmode )
	{
	case 0:
	case 1:
	case 4:
		/* integer-like things	*/
	    switch( mclength )
	    {
	    case 1:		/* byte sized pieces 		*/
		/*{{{  bytes */
			if( x2 ) emit(f_opr, op_bsub ), popInt(); 
			else if( offset ) emit( f_adc, offset ); 
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
			switch( flag )
			{
			case s_content:
				if( lxxAllowed )
				{
					if( mcmode == 0 ) emit(f_opr, op_lbx);
					else emit(f_opr, op_lb );
				}
				else
				{
					emit(f_opr, op_lb );
					if( strict_casts && mcmode == 0 )
					{
						emit(f_ldc, 0x80 );
						emit( f_opr, op_xword );
					}
				}
				break;
		
			case s_displace:
			{
			/* The following code is NASTY. We enter with A=address	*/
			/* and B = new value. We want to store the new value and*/
			/* return the original value. While there are enough 	*/
			/* registers for this, at some point we would want to   */
			/* swap B and C without touching A.			*/
				VLocal *v = pushtemp(INTREG);
		
				emit( p_ldvl, v ); pushInt();
				if( lxxAllowed ) emit(f_opr, mcmode==0?op_lbx:op_lb );
				else emit(f_opr, op_lb );
				emit(f_opr, op_rev );
				poptemp(v, INTREG);
				emit(f_opr, op_sb ); popInt(); popInt();
				if( !lxxAllowed && strict_casts && mcmode == 0 )
				{
					emit(f_ldc, 0x80 );
					emit( f_opr, op_xword );
				}
				break;
			}
				
			case s_assign:
				emit(f_opr, op_sb );popInt(); popInt();
				break;
			}
		/*}}}*/
		break;
	
	    case 2: 	/* short (16 bit) integers	*/
		/*{{{  shorts */
		#if 0	    
		    	x1len = mcrepofexpr(x1);
		    	x1mode = (x1len>>24) & 0xFF;
		    	x1len = x1len & 0xFFFFFF;
		#endif
			if( x2 ) emit(f_opr, op_bsub ), popInt(); 	
		
			if( lxxAllowed )
			{
				/*{{{  T9000 support */
					if( offset ) emit( f_adc, offset ); 
					if( v2 != NULL && d > 2 )
					{
					   emit(p_ldvl, v2);
					   emit(f_opr, op_rev );
					   pushInt();
					}
					switch( flag )
					{
					case s_content:
						if( mcmode == 0 ) emit(f_opr, op_lsx);
						else emit(f_opr, op_ls );
					break;
				
					case s_displace:
					{
					/* The following code is NASTY. We enter with A=address	*/
					/* and B = new value. We want to store the new value and*/
					/* return the original value. While there are enough 	*/
					/* registers for this, at some point we would want to   */
					/* swap B and C without touching A.			*/
						VLocal *v = pushtemp(INTREG);
				
						emit( p_ldvl, v ); pushInt();
						emit(f_opr, mcmode==0?op_lsx:op_ls );
						emit(f_opr, op_rev );
						poptemp(v, INTREG);
						emit(f_opr, op_ss ); popInt(); popInt();
						break;
					}
						
					case s_assign:
						emit(f_opr, op_ss );popInt(); popInt();
						break;
					}
				/*}}}*/
			}
			else switch( flag ) 
			{
			/* Shorts are done using move. This is VERY expensive	*/		
			case s_content:
			    {
				if( !move_shorts )
				{
					/*{{{  defunct? */
								/* offset is a constant, we can use this to try	*/
								/* and optimise the access. This code assumes	*/
								/* that the base address is word oriented. This	*/
								/* will be true for most cases, but is false	*/
								/* for a pointer halfway through a word in an	*/
								/* array of bytes. How can I detect this ??	*/
								emit( f_ldnl, offset>>2);
								if( (offset & 3) == 0 ) 
								{
									emit( f_ldc, 0xFFFF );
									emit( f_opr, op_and );
								}
								else
								{
									emit( f_ldc, 16 );
									emit( f_opr, op_shr );
								}
								if( mcmode == 0 )
								{
									emit(f_ldc, 0x8000 );
									emit( f_opr, op_xword );
								}
					/*}}}*/
				}
				else
				{
		#if 0
					Binder *b;
					int direct_assign;
		
					if( AssignTarget != NULL && h0_(AssignTarget) == s_binder )
					{
						direct_assign = 1;
						AssignTargetUsed = 1;
						b = set_binder_ops((Binder *)AssignTarget);
					}
					else
					{
						direct_assign = 0;				
						loadOp = p_ldvl;
						storeOp = p_stvl;
						loadAddressOp = p_ldvlp;
						b = (Binder *)allocatetemp(INTREG);
					}
					if( offset ) emit( f_adc, offset );
					emit( f_ldc, 0 );
					emit( storeOp, b );
					emit( loadAddressOp, b);
					emit( f_ldc, 2 );
					emit( f_opr, op_move );
					if( !direct_assign )
					{
						emit( loadOp, b );
						setInt(FullDepth-1);
		
						if( mcmode == 0 )
						{
							emit(f_ldc, 0x8000 );
							emit( f_opr, op_xword );
						}
						freetemp(b);
					}
					else setInt(FullDepth);
					
		#else
					VLocal *v = allocatetemp(INTREG);
					if( offset ) emit( f_adc, offset );
					emit( f_ldc, 0 );
					emit( p_stvl, v );
					emit( p_ldvlp, v);
					emit( f_ldc, 2 );
					emit( f_opr, op_move );
					emit( p_ldvl, v );
					setInt(FullDepth-1);
		
					if( mcmode == 0 )
					{
						emit(f_ldc, 0x8000 );
						emit( f_opr, op_xword );
					}
					freetemp(v);
		#endif
				}
				break;
			    }
		
			case s_displace:
			    {
				VLocal *p;
				VLocal *v1;
		
				if( offset ) emit( f_adc, offset );
				p = pushtemp(INTREG);
				v1 = allocatetemp(INTREG);
					
				emit( f_ldc, 0 );
				emit( p_stvl, v1 );
				emit( p_ldvl, p );
				emit( p_ldvlp, v1);
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
				emit( p_ldvlp, v2);
				emit( p_ldvl, p );
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
		
				emit( p_ldvl, v1 );
				setInt(FullDepth-1);
		
				if( mcmode == 0 )
				{
					emit(f_ldc, 0x8000 );
					emit( f_opr, op_xword );
				}
		
				freetemp(v1);
				freetemp(p);
				break;	
			    }
				
			case s_assign:
			    {
		trace("assign v2 %x",v2);
				if( offset ) emit( f_adc, offset );
				emit( p_ldvlp, v2 );
				emit( f_opr, op_rev );
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
				setInt(FullDepth);
				break;
			    }
			}
		/*}}}*/
		break;
	

	    case 4:		/* normal ints			*/
		/*{{{  ints */
		
			if( x2 ) 
			{
				if( scaled ) emit(f_opr, op_wsub );
				else emit(f_opr, op_sum );
				popInt();
			}
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
			switch( flag )
			{
			case s_content:
				emit( f_ldnl, offset / 4 );
				break;
				
			case s_displace:
			    {
			/* More yukky code, see comment above.			*/
				VLocal *v = pushtemp(INTREG);
					
				emit( p_ldvl, v ); pushInt();
				emit( f_ldnl, offset / 4 );
				emit(f_opr, op_rev );
				poptemp(v, INTREG);
				emit( f_stnl, offset / 4 ); popInt();popInt();
				break;
			    }
		
			case s_assign:
				emit( f_stnl, offset / 4 ); popInt();popInt();
				break;
			}
		/*}}}*/
	    } /* mclength */
	    break;


	case 2:
		/* real numbers		*/
		/*{{{  reals */
			if( x2 ) 
			{
				if( scaled ) emit(f_opr, op_wsub );
				else emit(f_opr, op_sum );
				popInt();
			}
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
		
			switch( flag )
			{
			case s_content:
			    if( floatingHardware )
			    {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, rsort == FLTREG ? 
						op_fpldnlsn: op_fpldnldb);
				popInt(); pushFloat();
			    }
			    else emit( rsort==FLTREG?f_ldnl:f_ldnlp, offset / 4 );
			    break;
				
			case s_displace:
			/* More yukky code, see comment above.			*/
			   if( floatingHardware )
			   {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, op_dup ); pushInt();
		           	emit(f_opr, rsort == FLTREG ? op_fpldnlsn: op_fpldnldb);
		           	popInt(); pushFloat();
		           	emit(f_opr, op_fprev );
		           	emit(f_opr, rsort == FLTREG ? op_fpstnlsn: op_fpstnldb);
		           	popInt(); popFloat();
			   }
			   else {
				syserr("cg_indirect: attempt to use double in T4");
			   }
			   break;
				
			case s_assign:
			    if( floatingHardware )
			    {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, rsort == FLTREG ? op_fpstnlsn:op_fpstnldb);
				popInt(); popFloat();
			    }
			    else {
				syserr("cg_indirect: attempt to use double in T4");
			    }
			    break;
			}
		/*}}}*/
		
		break;
	} /* mcmode */

	/* if there was a displace within the indirection, do the	*/
	/* update part here. 						*/

	if( postinc ) 
	{
		cg_addrexpr( x1 );		/* @@@@@@ side effects ??? */
		emit( f_adc, postinc );
		cg_storein( x1 , s_assign, 0 );
	}


	if( v1 != NULL ) poptemp( v1, INTREG );
	if( v2 != NULL && flag==s_assign && valneeded ) poptemp( v2, INTREG );
	
	pop_trace();
}
/*}}}*/
/*{{{  cg_var */

/* I don't like the way this generates things if the value is required,
 * I would prefer to do a dup on the value before saving it away.
 * This saves a store cycle !!! FIX THIS LATER ! Jim.
 */
void cg_var(b,flag,mcmode,mclength,valneeded)
Binder *b;
AEop flag;
int mcmode,mclength,valneeded;
{

	push_trace("cg_var");
	         
	if(debugging(DEBUG_CG)) 
	    trace("Cg_var: %s flag %d mcmode %d mclength %d valneeded %d ida %d",
			_symname(bindsym_(b)),flag,
			mcmode,mclength,valneeded,ida);

	b = set_binder_ops(b);				
	
	if( mcmode < 2 || mcmode == 4 || (!floatingHardware && mcmode==2 && mclength==4) )
	{ /* all integer-like objects are stored in 1 word */
	  /* also all 4 byte floats in T414 */
#if 1
		if( !strict_casts ) switch(flag)
		{
		case s_displace: 
			emit( loadOp,  b);pushInt();
		        emit(f_opr, op_rev );
			emit(  storeOp, b);popInt();
			break;

		case s_assign:
			emit( storeOp, b );popInt();
		        if (!valneeded) break;
			/* drop through to re-load */
				
		case s_content:
		        if (valneeded)
		        {  
		        /* Check that higher up sets valneeded if volatile */
	        	   emit( loadOp, b); pushInt();
		        }
		        break;
		    
		default:
			syserr("Unknown flag %x8 in cg_var",flag);
		}
		else
#endif
	  	switch( mclength )
	  	{
	  	case 1:			/* chars */
	  	{
	  		int ldbop = op_lb;

	  		if( lxxAllowed && mcmode == 0 ) ldbop = op_lbx;
	  		
	  		switch( flag )
	  		{
	  		case s_displace:
	  		{
	  			if( ida < 2 )
	  			{
		  			VLocal *v;
		  			emit( loadAddressOp, b ); pushInt();
		  			emit( f_opr, ldbop );
		  			v = pushtemp(INTREG);
					if( strict_casts )
					{
	  					emit( loadAddressOp, b ); pushInt();
	  					emit( f_opr, op_sb );popInt();popInt();
	  				}
	  				else { emit( storeOp, b );popInt(); }
	  				
		  			poptemp(v, INTREG);	
	  			}
	  			else
	  			{
		  			emit( loadAddressOp, b ); pushInt();
		  			emit( f_opr, ldbop );
				        emit(f_opr, op_rev );
				        if( strict_casts )
				        {
	  					emit( loadAddressOp, b ); pushInt();
	  					emit( f_opr, op_sb );popInt();popInt();
	  				}
	  				else { emit( storeOp, b );popInt(); }
	  			}
				break;		        
			}

			case s_assign:
				emit( storeOp, b );popInt();
			        if (!valneeded) { pop_trace(); return; }
				/* drop through to re-load */
				
			case s_content:
			        if (valneeded)
			        {  
			        /* Check that higher up sets valneeded if volatile */
			           if( strict_casts )
			           {
		        	   	emit( loadAddressOp, b); pushInt();
		        	   	emit( f_opr, ldbop );
		        	   }
		        	   else { emit( loadOp, b );pushInt(); }
			        }
			        else { pop_trace(); return; }
			        break;
			    
			default:
				syserr("Unknown flag %x8 in cg_var",flag);
	  		}

	  		if( !lxxAllowed )
	  		{
	  			/* extend sign if this is a signed char */
	  			if( strict_casts && mcmode == 0 )
	  			{
	  				if( ida == 0 )
	  				{
	  					VLocal *v;
	  					emit( f_opr, op_rev );
	  					v = pushtemp( INTREG );
				  		emit( f_ldc, 0x80 );
				  		emit( f_opr, op_xword );
						poptemp(v, INTREG );
	  					emit( f_opr, op_rev );
	  				}
	  				else {
				  		emit( f_ldc, 0x80 );
				  		emit( f_opr, op_xword );
				  	}
				}
	  		}
	  		break;
	  	}

	  	case 2:				/* shorts */
	  	    if( shortAllowed )
	  	    {
	  	    	int ldsop = op_ls;
	  	    	int stsop = op_ss;

	  	    	if ( mcmode == 0 ) ldsop = op_lsx;
	  	    	
	  		switch( flag )
	  		{
	  		case s_displace:
	  		{
	  			if( ida < 2 )
	  			{
		  			VLocal *v;
		  			emit( loadAddressOp, b ); pushInt();
		  			emit( f_opr, ldsop );
		  			v = pushtemp(INTREG);
	  				emit( loadAddressOp, b ); pushInt();
	  				emit( f_opr, stsop );popInt();
		  			poptemp(v, INTREG);	
	  			}
	  			else
	  			{
		  			emit( loadAddressOp, b ); pushInt();
		  			emit( f_opr, ldsop );
				        emit(f_opr, op_rev );
	  			/*
					emit( loadAddressOp, b ); pushInt();
	  				emit( f_opr, stsop );popInt();
	  			*/
	  				emit( storeOp, b );
	  			}
				break;		        
			}

			case s_assign:
				emit( storeOp, b );popInt();
			        if (!valneeded) { pop_trace(); return; }
				/* drop through to re-load */
				
			case s_content:
			        if (valneeded)
			        {  
			        /* Check that higher up sets valneeded if volatile */
		        	   emit( loadAddressOp, b); pushInt();
		        	   emit( f_opr, ldsop );
			        }
			        else { pop_trace(); return; }
			        break;
			    
			default:
				syserr("Unknown flag %x8 in cg_var",flag);
	  		}

	  	    }
	  	    else
	  	    {
		        switch (flag)
			{
			case s_displace: 
				emit( loadOp,  b);pushInt();
			        emit(f_opr, op_rev );
				emit(  storeOp, b);popInt();
				break;

			case s_assign:
				emit( storeOp, b ); popInt();
			        if (!valneeded) { pop_trace(); return; }
				/* drop through to re-load */
				
			case s_content:
			        if (valneeded)
			        {  
			        /* Check that higher up sets valneeded if volatile */
		        	   emit( loadOp, b); pushInt();
			        }
			        else { pop_trace(); return; }
			        break;
			    
			default:
				syserr("Unknown flag %x8 in cg_var",flag);
			}
	  		
	  		/* on loading a short; mask, and extend sign to	*/
	  		/* full width if needed.			*/

	  		if( !strict_casts ) break;
	  		
  			if( ida == 0 )
  			{
  				VLocal *v;
  				emit( f_opr, op_rev );
  				v = pushtemp( INTREG );
		  		emit( f_ldc, 0xFFFF );
		  		emit( f_opr, op_and );
	  			if( mcmode == 0 )
	  			{
			  		emit( f_ldc, 0x8000 );
			  		emit( f_opr, op_xword );
			  	}
				poptemp(v, INTREG );
  				emit( f_opr, op_rev );
  			}
  			else {
		  		emit( f_ldc, 0xFFFF );
		  		emit( f_opr, op_and );
	  			if( mcmode == 0 )
	  			{
			  		emit( f_ldc, 0x8000 );
			  		emit( f_opr, op_xword );
			  	}
			}
		    }
	  		break;
	  		
	  	case 4:				/* ints/longs	*/
		        switch (flag)
			{
			case s_displace: 
				emit( loadOp,  b);pushInt();
			        emit(f_opr, op_rev );
				emit(  storeOp, b);popInt();
				break;

			case s_assign:
				emit( storeOp, b );popInt();
			        if (!valneeded) break;
				/* drop through to re-load */
				
			case s_content:
			        if (valneeded)
			        {  
			        /* Check that higher up sets valneeded if volatile */
		        	   emit( loadOp, b); pushInt();
			        }
			        break;
			    
			default:
				syserr("Unknown flag %x8 in cg_var",flag);
			}
		}        
	}
	else 
	{ 
	     if( !floatingHardware )
	     {
		/* Only doubles get through to here			*/
		/* doubles are always represented by a pointer to the	*/
		/* actual value in store.				*/
		switch( flag )
		{
		case s_assign:
		{
			/* copy both words 1 by 1 */
			VLocal *v = pushtemp(INTREG);
			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 0 );
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 0 ); popInt(); popInt();

			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 1 ); 
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 1 ); popInt(); popInt();
			if( valneeded )
			{
				emit( loadAddressOp, b );
				pushInt();
			}
			freetemp( v );
			break;
		}
		case s_displace:
		{
			/* copy both words 1 by 1 */
			VLocal *v = pushtemp(INTREG);
			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 0 );
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 0 ); popInt(); popInt();

			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 1 ); 
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 1 ); popInt(); popInt();

			/* Return original pointer */
			emit( p_ldvl, v ); pushInt();

			freetemp( v );
			break;
		}
		case s_content:
			/* simply return address of variable */
			emit( loadAddressOp, b); pushInt();
		 	break;
		} /* end of switch */
		{ pop_trace(); return; }
	     }
	     /* floating objects, T8 only at present */
	     emit( loadAddressOp, b); pushInt();
	     switch (flag)
             {
	 	  case s_displace:
	  	       emit(f_opr,op_dup); pushInt();
		       emit(f_opr,mclength == 4 ? op_fpldnlsn:op_fpldnldb);
		       popInt(); pushFloat();
		       emit(f_opr,op_fprev);
		       emit(f_opr,mclength == 4 ? op_fpstnlsn:op_fpstnldb);
		       popInt(); popFloat();
		       break;
		  case s_assign:
		       if (valneeded)
	  	       {
		          emit(f_opr, op_fpdup );
	   	          pushFloat();
		       }
		       emit(f_opr,mclength == 4 ? op_fpstnlsn:op_fpstnldb);
		       popInt(); popFloat();
	 	       break;
		  case s_content:
		      emit(f_opr,mclength == 4 ? op_fpldnlsn:op_fpldnldb);
		      popInt(); pushFloat();
		      break;
		  default:
		      syserr("Unexpected flag in cg_var #%x8",flag);
		}
	}
	pop_trace();
}
/*}}}*/
#else
/*{{{  cg_scalarAssign */

/* We have found a scalar assignment statement,
   this is either s_assign    e.g.  a = ...;
   or             s_displace  e.g.  a++;
   
   in addition valneeded may or may not be set depending on whether we
   need to leave the value in the register as well
   e.g. a = b = 3;
   vs.  a = 3;

   This is part of an attempt to improve the code for simple assignments
   etc. More work is intended to be done here. In particular evaluating
   the depth of the two sides, to evaluate them in the best order, and
   dealing with valneeded by using dup when we know it is safe...
   For expediency at the moment, this just calls the old routines.
   This should also check for (e.g.) float x, y; x = y
   and generate ldl y stl x rather than ldlp y fpldnlsn  ldlp x fpstnlsn
*/
void cg_scalarAssign(x,valneeded)
Expr *x;
bool valneeded;
{
    int mclength  = mcrepofexpr(x);
    int mcmode    = (mclength>>24) & 0xff;
    Expr *target  = arg1_(x), *source = arg2_(x);
/*  int td = depth(target), sd = depth(source); */
    AEop targetOp = h0_(target);
    RegSort rsort = (mclength &= 0x00ffffff,
	(mcmode!=2) ? INTREG : (mclength==4 ? FLTREG : DBLREG ));

    struct AssignInfo aisave;
    int atu;

    int evalsource = TRUE;
	
    push_trace("cg_scalarAssign");
    
    if(debugging(DEBUG_CG))
    {
       trace("Cg_scalarAssign: %s valneeded %d",symbol_name_(h0_(x)),valneeded);
       trace("mcmode %x targetmode %x sourcemode %x",(mcmode<<24)|mclength,
       		mcrepofexpr(target),mcrepofexpr(source));
#if 0
       eprintf("Target "); pr_expr(target);
       eprintf("\nSource "); pr_expr(source);eprintf("\n");
#endif
    }

    /* The following seems wrong, I would have expected source to	*/
    /* contain an appropriate cast if it differed from target. It does	*/
    /* not always appear to do so.					*/
    if( mcrepofexpr(source) != mcrepofexpr(target) )
    	source = mk_expr1( s_cast, typeofexpr(target), source );
    	
    /* A displace in a void context can be replaced with a simple */
    /* assignment.						  */
    if( h0_(x) == s_displace && !valneeded ) h0_(x) = s_assign;

    if( mcmode < 2 && mclength < 4 && h0_(source) == s_cast )
    {
    	/* An assignment of the form a = (cast)b. If a is a shorter int	*/
    	/* eliminate the cast, since the value will be converted when	*/
    	/* stored.							*/
    	/* int srcmode = mcrepofexpr(arg1_(source)); */
    	source = arg1_(source);
    }
    
    /* This is where we should be much more subtle about depths etc */

    if( !floatingHardware && rsort == DBLREG ) 
    {
	cg_doubleassign( target, source, h0_(x), valneeded );
	pop_trace(); return;
    }
    
	/*{{{  optimise a = b ? c : d */
	
	    if( !valneeded && targetOp == s_binder && h0_(source) == s_cond )
	    {
		/* convert a = b ? c : d into b ? (a = c) : (a = d)	*/
	
		TypeExpr *t = typeofexpr(target);
		Expr *e = mk_expr3(s_cond,
				   t,
				   arg1_(source),
				   mk_expr2(s_assign, t, target, arg2_(source)),
				   mk_expr2(s_assign, t, target, arg3_(source)));
		pp_expr(e,0);
		cg_exprvoid(e);	   	    
		pop_trace(); return;
	    }
	/*}}}*/
	/*{{{  optimise a = b = c */
	    if( h0_(x) == s_assign && h0_(source) == s_assign )
	    {
	    	/* convert a = b = c; into b = c; a = c; if c is a	*/
	    	/* local or a constant					*/
	
	    	Expr *c = arg2_(source);
	    	if( islocalvar_(c) || h0_(c) == s_integer )
	    	{
	    		TypeExpr *t = typeofexpr(source);
	    		Expr *e = mk_expr2(s_assign, t, arg1_(source), c);
			pp_expr(e,0);
			cg_exprvoid(e);
	    		e = mk_expr2(s_assign, t, target, c);
			pp_expr(e,0);
			cg_exprvoid(e);
			if( valneeded ) cg_expr(c);
			pop_trace(); return;
	    	}
	    }
	/*}}}*/
	/*{{{  optimise a = b for same-size shorts vars */
	
	    if( mclength < 4 && h0_(target) == s_binder && h0_(source) == s_binder )
	    {
	    	/* handle direct assignment of shorter int variables as if	*/
	    	/* they were full width ints. This is safe because variables	*/
	    	/* are always kept zero padded in memory and are sign extended	*/
	    	/* on load.							*/
		if( mcrepofexpr(target) == mcrepofexpr(source) )
		{
	    		cg_var( source, s_content, mcmode, 4, TRUE );
	    		cg_var( target, h0_(x), mcmode, 4, valneeded );
	    		pop_trace(); return;
	    	}
	    }
	/*}}}*/
	/*{{{  optimise a->b = c for shorts */
	    /* Try to optimise short assignement of a variable to an	*/
	    /* indirection						*/
	    if( !lxxAllowed && (mclength == 2) && h0_(source) == s_binder &&
		( h0_(target) == s_dot || h0_(target) == s_content ) )
			evalsource = FALSE;
	/*}}}*/
	/*{{{  optimise a->b = c->d for shorts */
	
	    /* Try to optimise the assignment of an indirection to an	*/
	    /* indirections for shorts					*/
	    if( !lxxAllowed && mclength == 2 &&
		(h0_(source) == s_dot || h0_(source) == s_content) &&
		( h0_(target) == s_dot || h0_(target) == s_content ) )
	    {
	    	VLocal *v = NULL;
	    	if( ida != 3 ) v = pushtemp( INTREG );
	    	cg_binary( s_nothing,
			take_address(source),
			take_address(target),
			0, INTREG );
	    	emit( f_ldc, 2 );
	    	emit( f_opr, op_move );
	    	setInt(FullDepth);
	    	if( valneeded ) cg_expr(source);
	    	if( v != NULL ) poptemp(v);
	    	pop_trace(); return;
	    }
	/*}}}*/
	/*{{{  optimise a = b++ */
	#if 1
	    if( h0_(x) == s_assign &&
		(
		   h0_(source) == s_displace ||
		  (h0_(source) == s_cast && h0_(arg1_(source)) == s_displace)
	        )
	      )
	    {
		Expr *x = target;
	    	Expr *y = arg1_(source);
	    	Expr *c = NULL;
	    	Expr *s = NULL;
		TypeExpr *t = typeofexpr(x);
		Expr *e, *e1;
	
		/* jump over cast, but remember it */
		if( h0_(source) == s_cast )
		{
			c = source;
			s = arg2_(y);
			y = arg1_(y);
		}
		else
		{
			c = NULL;
			s = arg2_(source);
		}
	trace("x %d mode %x",x,mcrepofexpr(x));
	trace("y %d mode %x",y,mcrepofexpr(y));
	trace("s %d mode %x",s,mcrepofexpr(s));
	if( c ) trace("c %d mode %x",c,mcrepofexpr(c));
	
		if( islocalvar_(y) )
		{
			/* If y is local				*/
		    	/* convert x = y++; into x = (cast)y, y = y+1;	*/
	
			/* include cast in assignement if needed	*/
			if( c != NULL )
			{
				e1 = mk_expr2( s_assign, t, x,
					mk_expr1( s_cast, typeofexpr(c), y ) );
			}
			else e1 = mk_expr2( s_assign, t, target, y );
			
			e = mk_expr2( s_comma,
				    t,
				    e1,
				    mk_expr2( s_assign, typeofexpr(y), y, s)
				  );
			pp_expr(e,0);
			cg_exprvoid(e);
			if( valneeded ) cg_expr(y);
		}
		else if( islocalvar_(x) )
		{
			/* If x is local				*/
		    	/* convert x = y++; into x = (cast)y, y = (cast)x+1;	*/
		    	Expr *e2 = s;
		    	Expr *s2 = s;
	
			/* include cast in assignement if needed	*/
			if( c != NULL )
			{
				e1 = mk_expr2( s_assign, t, x,
					mk_expr1( s_cast, typeofexpr(c), y ) );
			}
			else e1 = mk_expr2( s_assign, t, target, y );
			
			if( h0_(e2) == s_cast )	s2 = e2 = arg1_(e2);
	
		    	if( (h0_(e2) == s_plus || h0_(e2) == s_minus) &&
		    		is_same(arg1_(e2),y)
			  )
		    	{
		    		e2 = mk_expr2(h0_(e2), typeofexpr(e2),
		    			x, arg2_(e2) );
		    	}
			if( s2 != s )
			{
				e2 = mk_expr1(s_cast, typeofexpr(s), e2);
			}
			e = mk_expr2( s_comma,
				    t,
				    e1,
				    mk_expr2( s_assign, typeofexpr(y), y, e2)
				  );
			pp_expr(e,0);
			cg_exprvoid(e);
			if( valneeded ) cg_expr(x);
		}
		else /* Neither are local variables */
		{
			/* generate: let t = y; x = (cast)t; y = t+1 */
			TypeExpr *tmptype;
			Binder *tmp;
			Expr *s2 = s;
			Expr *e2 = s;
	
			if( h0_(e2) == s_cast )	s2 = e2 = arg1_(e2);
	
			tmptype = typeofexpr(y);
			tmp = gentempbinder(tmptype);
	trace("tmp %d mode %x",tmp,mcrepofexpr(tmp));
	trace("s2 %d mode %x",s2,mcrepofexpr(s2));
	
			/* include cast in assignment if needed	*/
			if( c != NULL )
			{
				e1 = mk_expr2( s_assign, t, x,
					mk_expr1( s_cast, typeofexpr(c), tmp ) );
			}
			else e1 = mk_expr2( s_assign, tmptype, x, (Expr *)tmp );
	
			/* replace y with tmp in source expression	*/
		    	if( (h0_(e2) == s_plus || h0_(e2) == s_minus) &&
		    		is_same(arg1_(e2),y)
			  )
		    	{
		    		e2 = mk_expr2(h0_(e2), tmptype,
		    			(Expr *)tmp, arg2_(e2) );
		    	}
	
			if( s2 != s ) e2 = mk_expr1(s_cast, typeofexpr(s), e2);
	
			e2 = mk_expr2( s_assign, tmptype, y, e2);
	
			if( valneeded ) e2 = mk_expr2(s_comma, tmptype, e2, (Expr *)tmp );
			e = mk_expr2( s_let,
					t,
					(Expr *)mkBindList( 0, tmp),
					mk_expr2(s_comma, tmptype,
						mk_expr2(s_assign, tmptype, (Expr *)tmp, y),
					mk_expr2(s_comma, tmptype,
						e1,
						e2
						))
				    );
			pp_expr(e, 0);
			cg_expr1(e, valneeded);
		}
	    	pop_trace(); return;	
	    }
	#endif
	/*}}}*/
	
    aisave		= Assign;
    Assign.Target 	= target;
    Assign.TargetUsed	= FALSE;
    Assign.Source	= source;
    Assign.SourceEval	= evalsource;
    
    if( evalsource ) cg_expr(source);

    atu			= Assign.TargetUsed;

    if( !atu )
    {
	if (targetOp != s_binder)
		cg_storein( target, h0_(x), valneeded);
	else 
		cg_var(  target, h0_(x), mcmode, mclength, valneeded);
    }

    Assign		= aisave;
       
    pop_trace();
}
/*}}}*/
/*{{{  cg_indirect */

/* The code generated here is not really very clever. It should be
 * improved later, so that it extracts constants from the index expression
 * into the base offset. It should also make use of wsubdb. These improvements
 * are probably better done in the pre parser (or at least supported there).
 * More attention should be paid to the context in which this procedure is
 * called.
 * At present something like short a[]; a[i] = a[j]; generates a move from a[j]
 * to a temp and then a move from this to a[i] where a direct move a[j] to a[i]
 * is obviously what is needed.
 * In general this, cg_scalarAssign, cg_var, cg_storein and cg_addr all 
 * need a total re-think and re-write.
 */
void cg_indirect(x,flag,mcmode,mclength,valneeded)
Expr *x;
int flag, mcmode, mclength,valneeded;
{
	VLocal *v1 = NULL;
	VLocal *v2 = NULL;
	Expr *x1, *x2 = NULL;
	int offset = 0, postinc = 0;
	const RegSort rsort = mcmode!=2 ? INTREG : 
				(mclength==4 ? FLTREG : DBLREG);
	int x1len, x1mode;
	int d = depth(x);
	int scaled = FALSE;

	struct AssignInfo aisave;
	
	/* if this is a T4 and we are trying to get a single precision	*/
	/* float, lie about it and load an integer instead.		*/
	if( !floatingHardware && rsort==FLTREG )
	{
		mcmode = 0;
		mclength = 4;
		rsort==INTREG;
	}

	push_trace("cg_indirect");
	
        if(debugging(DEBUG_CG))
	{ 
	    trace("Cg_indirect: %x %s flag %d mcmode %d mclength %d",
		x,symbol_name_(h0_(x)),flag,mcmode,mclength);
	    trace("valneeded %d depth %d",valneeded,d);
	}
	
	/*{{{  Calculate address and index expressions */
		switch( h0_(x))
		{
		case s_plus:
		/* test for (x + n), common case for structure and array access */
			x1 = arg1_(x); x2 = arg2_(x);
			if(integer_constant(x1) ) offset=result2, x1=x2, x2=NULL, d=depth(x1);
			else if(integer_constant(x2) ) offset=result2, x2 = NULL, d=depth(x1);
			else if( h0_(x2) == s_times && mclength == 4 )
			{/* check for (x + (y * 4)), common case for array access */
				if( integer_constant(arg1_(x2)) && result2 == 4 )
					scaled = TRUE, x2 = arg2_(x2);
				else if( integer_constant(arg2_(x2)) && result2 == 4 )
					scaled = TRUE, x2 = arg1_(x2);
			}
			break;
	
		case s_minus:
			x1 = arg1_(x); x2 = arg2_(x);
			if( integer_constant(x2) ) offset= -result2, x2 = NULL,d=depth(x1);
			else x1 = x, x2 = NULL;
			break;
	
		case s_displace:
		{
			Expr *v = arg1_(x), *x3 = arg2_(x);
			if( h0_(x3)==s_plus &&
				is_same(arg1_(x3),v) && integer_constant(arg2_(x3)))
			{ /* i.e. something like *p++ */
				postinc = result2;
				x = v;
				d = depth(x);
			}
		}
			/* drop through */
		
		default:
			x1 = x; x2 = NULL;
			break;
	
		} /* end of switch */
	/*}}}*/

	/* Here x1 is the expression to generate the address,	*/
	/* x2 is the offset, unless it is NULL in which case	*/
	/* there is a constant integer offset in offset. If the */
	/* expression contains a displace, there will be a post */
	/* increment in postinc.				*/

	if(debugging(DEBUG_CG))
		trace("x1 %s x2 %s offset %d postinc %d",
			x1?symbol_name_(h0_(x1)):"<NULL>",
			x2?symbol_name_(h0_(x2)):"<NULL>",
			offset,postinc);

	/*{{{  Make sufficient stack depth */
		if( !lxxAllowed && mcmode != 2 && mclength == 2 )
		{
			/* access to shorts on T4/8 always uses all registers */
			switch( flag )
			{
			case s_content:
				break;
			case s_assign:
				if( Assign.SourceEval )
					v2 = pushtemp( INTREG );
				break;
			case s_displace:
				v2 = pushtemp( INTREG );
				break;		
			}
			if( ida < 3 ) v1 = pushtemp( INTREG );
		}
		else if( mcmode != 2 || !floatingHardware )
		{
			/* integers and others */
			switch( flag )
			{
			case s_content:
				break;
			case s_assign:
				if( valneeded || idepth(d) > 2 ) v2 = pushtemp(INTREG);
				if( v2 && idepth(d) < 3 )
				{
					emit(p_ldvl, v2);
					pushInt();
				}
				break;
			case s_displace:
				if( idepth(d) > 2) v2 = pushtemp(INTREG);
				if( v2 && ida < 3 ) v1 = pushtemp(INTREG);
				break;
			}
		}
		else if ( mcmode == 2 )
		{
			/* floats and doubles, in T800 only */
			switch( flag )
			{
			case s_content:
				break;
			case s_assign:
				if( valneeded ) duplicate( FLTREG );
				break;
			case s_displace:
				break;
			}
		}
	/*}}}*/

	/* Dispose of AssignInfo while evaluating address	*/
	/* index expressions, in case they contain assignements	*/
	/* of their own.					*/

	aisave			= Assign;	
	Assign.Target	 	= NULL;
	Assign.TargetUsed	= FALSE;
	Assign.Source		= NULL;
	Assign.SourceEval	= FALSE;

	if( x2 != NULL ) 
	{
		int oldae = addrexpr;
		addrexpr = TRUE;
		cg_binary(s_nothing,x2,x1,0,INTREG);
		addrexpr = oldae;
	}
	else cg_addrexpr(x1);

	Assign			= aisave;
	
	switch( mcmode )
	{
	case 0:
	case 1:
	case 4:
		/* integer-like things	*/
	    switch( mclength )
	    {
	    case 1:		/* byte sized pieces 		*/
		/*{{{  bytes */
			if( x2 ) emit(f_opr, op_bsub ), popInt(); 
			else if( offset ) emit( f_adc, offset ); 
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
			switch( flag )
			{
			case s_content:
				if( lxxAllowed )
				{
					if( mcmode == 0 ) emit(f_opr, op_lbx);
					else emit(f_opr, op_lb );
				}
				else
				{
					emit(f_opr, op_lb );
					if( mcmode == 0 )
					{
						emit(f_ldc, 0x80 );
						emit( f_opr, op_xword );
					}
				}
				setTOS(mcmode,mclength);
				break;
		
			case s_displace:
			{
			/* The following code is NASTY. We enter with A=address	*/
			/* and B = new value. We want to store the new value and*/
			/* return the original value. While there are enough 	*/
			/* registers for this, at some point we would want to   */
			/* swap B and C without touching A.			*/
				VLocal *v = pushtemp(INTREG);
		
				emit( p_ldvl, v ); pushInt();
				if( lxxAllowed ) emit(f_opr, mcmode==0?op_lbx:op_lb );
				else emit(f_opr, op_lb );
				emit(f_opr, op_rev );
				poptemp(v, INTREG);
				emit(f_opr, op_sb ); popInt(); popInt();
				if( !lxxAllowed && mcmode == 0 )
				{
					emit(f_ldc, 0x80 );
					emit( f_opr, op_xword );
				}
				setTOS(mcmode,mclength);
				break;
			}
				
			case s_assign:
				emit(f_opr, op_sb );popInt(); popInt();
				break;
			}
		/*}}}*/
		break;
	
	    case 2: 	/* short (16 bit) integers	*/
		/*{{{  shorts */
		#if 0	    
		    	x1len = mcrepofexpr(x1);
		    	x1mode = (x1len>>24) & 0xFF;
		    	x1len = x1len & 0xFFFFFF;
		#endif
			if( x2 ) emit(f_opr, op_bsub ), popInt(); 	
		
			if( lxxAllowed )
			{
				/*{{{  T9000 support */
				{
					int opls = op_ls;
					if( mcmode == 0 ) opls = op_lsx;
				
					if( offset ) emit( f_adc, offset ); 
					if( v2 != NULL && d > 2 )
					{
					   emit(p_ldvl, v2);
					   emit(f_opr, op_rev );
					   pushInt();
					}
					switch( flag )
					{
					case s_content:
						emit(f_opr, opls );
						setTOS(mcmode,mclength);		
						break;
				
					case s_displace:
					{
					/* The following code is NASTY. We enter with A=address	*/
					/* and B = new value. We want to store the new value and*/
					/* return the original value. While there are enough 	*/
					/* registers for this, at some point we would want to   */
					/* swap B and C without touching A.			*/
						VLocal *v = pushtemp(INTREG);
				
						emit( p_ldvl, v ); pushInt();
						emit(f_opr, opls );
						emit(f_opr, op_rev );
						poptemp(v, INTREG);
						emit(f_opr, op_ss ); popInt(); popInt();
						setTOS(mcmode,mclength);
						break;
					}
						
					case s_assign:
						emit(f_opr, op_ss );popInt(); popInt();
						break;
					}
				}
				/*}}}*/
			}
			else switch( flag ) 
			{
			/* Shorts are done using move. This is VERY expensive	*/		
			case s_content:
			    {
				if( !move_shorts )
				{
					/*{{{  defunct? */
								/* offset is a constant, we can use this to try	*/
								/* and optimise the access. This code assumes	*/
								/* that the base address is word oriented. This	*/
								/* will be true for most cases, but is false	*/
								/* for a pointer halfway through a word in an	*/
								/* array of bytes. How can I detect this ??	*/
								emit( f_ldnl, offset>>2);
								if( (offset & 3) == 0 ) 
								{
									emit( f_ldc, 0xFFFF );
									emit( f_opr, op_and );
								}
								else
								{
									emit( f_ldc, 16 );
									emit( f_opr, op_shr );
								}
								if( mcmode == 0 )
								{
									emit(f_ldc, 0x8000 );
									emit( f_opr, op_xword );
								}
					/*}}}*/
				}
				else
				{
		#if 1
					Binder *b;
					int direct_assign;
		
					if( Assign.Target != NULL && h0_(Assign.Target) == s_binder )
					{
						direct_assign = 1;
						Assign.TargetUsed = 1;
						b = set_binder_ops((Binder *)Assign.Target);
					}
					else
					{
						direct_assign = 0;				
						loadOp = p_ldvl;
						storeOp = p_stvl;
						loadAddressOp = p_ldvlp;
						b = (Binder *)allocatetemp(INTREG);
					}
					if( offset ) emit( f_adc, offset );
					if( loadOp == p_ldvl )
					{ /* locals and temps need zeroing	*/
						emit( f_ldc, 0 );
						emit( storeOp, b );
					}
					emit( loadAddressOp, b);
					emit( f_ldc, 2 );
					emit( f_opr, op_move );
					if( !direct_assign )
					{
						emit( loadOp, b );
		
						if( mcmode == 0 )
						{
							emit(f_ldc, 0x8000 );
							emit( f_opr, op_xword );
						}
						freetemp(b);
						setInt(FullDepth-1);
					}
					else setInt(FullDepth);
					
		#else
					VLocal *v = allocatetemp(INTREG);
					if( offset ) emit( f_adc, offset );
					emit( f_ldc, 0 );
					emit( p_stvl, v );
					emit( p_ldvlp, v);
					emit( f_ldc, 2 );
					emit( f_opr, op_move );
					emit( p_ldvl, v );
					setInt(FullDepth-1);
		
					if( mcmode == 0 )
					{
						emit(f_ldc, 0x8000 );
						emit( f_opr, op_xword );
					}
					freetemp(v);
		#endif
				}
				setTOS(mcmode,mclength);		
				break;
			    }
		
			case s_displace:
			    {
				VLocal *p;
				VLocal *v1;
		
				if( offset ) emit( f_adc, offset );
				p = pushtemp(INTREG);
				v1 = allocatetemp(INTREG);
					
				emit( f_ldc, 0 );
				emit( p_stvl, v1 );
				emit( p_ldvl, p );
				emit( p_ldvlp, v1);
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
				emit( p_ldvlp, v2);
				emit( p_ldvl, p );
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
		
				emit( p_ldvl, v1 );
				setInt(FullDepth-1);
		
				if( mcmode == 0 )
				{
					emit(f_ldc, 0x8000 );
					emit( f_opr, op_xword );
				}
		
				freetemp(v1);
				freetemp(p);
				setTOS(mcmode,mclength);
				break;	
			    }
				
			case s_assign:
			    {
		#if 1
				Binder *b;
				int direct_assign;
				if( !Assign.SourceEval && Assign.Source != NULL && h0_(Assign.Source) == s_binder )
				{
					direct_assign = 1;
					b = set_binder_ops((Binder *)Assign.Source);
				}
				else
				{
					direct_assign = 0;				
					loadOp = p_ldvl;
					storeOp = p_stvl;
					loadAddressOp = p_ldvlp;
					b = (Binder *)v2;
				}
		
				if( offset ) emit( f_adc, offset );
				emit( loadAddressOp, b );
				emit( f_opr, op_rev );
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
				setInt(FullDepth);
		#else
				if( offset ) emit( f_adc, offset );
				emit( p_ldvlp, v2 );
				emit( f_opr, op_rev );
				emit( f_ldc, 2 );
				emit( f_opr, op_move );
				setInt(FullDepth);
		#endif
				break;
			    }
			}
		/*}}}*/
		break;
	

	    case 4:		/* normal ints			*/
		/*{{{  ints */
		
			if( x2 ) 
			{
				if( scaled ) emit(f_opr, op_wsub );
				else emit(f_opr, op_sum );
				popInt();
			}
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
			switch( flag )
			{
			case s_content:
				emit( f_ldnl, offset / 4 );
				setTOS(mcmode,mclength);
				break;
				
			case s_displace:
			    {
			/* More yukky code, see comment above.			*/
				VLocal *v = pushtemp(INTREG);
					
				emit( p_ldvl, v ); pushInt();
				emit( f_ldnl, offset / 4 );
				emit(f_opr, op_rev );
				poptemp(v, INTREG);
				emit( f_stnl, offset / 4 ); popInt();popInt();
				setTOS(mcmode,mclength);
				break;
			    }
		
			case s_assign:
				emit( f_stnl, offset / 4 ); popInt();popInt();
				break;
			}
		/*}}}*/
	    } /* mclength */
	    break;


	case 2:
		/* real numbers		*/
		/*{{{  reals */
			if( x2 ) 
			{
				if( scaled ) emit(f_opr, op_wsub );
				else emit(f_opr, op_sum );
				popInt();
			}
			if( v2 != NULL && d > 2 )
			{
			   emit(p_ldvl, v2);
			   emit(f_opr, op_rev );
			   pushInt();
			}
		
			switch( flag )
			{
			case s_content:
			    if( floatingHardware )
			    {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, rsort == FLTREG ? 
						op_fpldnlsn: op_fpldnldb);
				popInt(); pushFloat();
			    }
			    else emit( rsort==FLTREG?f_ldnl:f_ldnlp, offset / 4 );
			    break;
				
			case s_displace:
			/* More yukky code, see comment above.			*/
			   if( floatingHardware )
			   {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, op_dup ); pushInt();
		           	emit(f_opr, rsort == FLTREG ? op_fpldnlsn: op_fpldnldb);
		           	popInt(); pushFloat();
		           	emit(f_opr, op_fprev );
		           	emit(f_opr, rsort == FLTREG ? op_fpstnlsn: op_fpstnldb);
		           	popInt(); popFloat();
			   }
			   else {
				syserr("cg_indirect: attempt to use double in T4");
			   }
			   break;
				
			case s_assign:
			    if( floatingHardware )
			    {
				emit( f_ldnlp, offset / 4 );
				emit(f_opr, rsort == FLTREG ? op_fpstnlsn:op_fpstnldb);
				popInt(); popFloat();
			    }
			    else {
				syserr("cg_indirect: attempt to use double in T4");
			    }
			    break;
			}
		/*}}}*/
		
		break;
	} /* mcmode */

	/* if there was a displace within the indirection, do the	*/
	/* update part here. 						*/

	if( postinc ) 
	{
		cg_addrexpr( x1 );		/* @@@@@@ side effects ??? */
		emit( f_adc, postinc );
		cg_storein( x1 , s_assign, 0 );
	}


	if( v1 != NULL ) poptemp( v1, INTREG );
	if( v2 != NULL && flag==s_assign && valneeded ) poptemp( v2, INTREG );
	
	pop_trace();
}
/*}}}*/
/*{{{  cg_var */

/* I don't like the way this generates things if the value is required,
 * I would prefer to do a dup on the value before saving it away.
 * This saves a store cycle !!! FIX THIS LATER ! Jim.
 */
void cg_var(b,flag,mcmode,mclength,valneeded)
Binder *b;
AEop flag;
int mcmode,mclength,valneeded;
{

	push_trace("cg_var");
	         
	if(debugging(DEBUG_CG))
	{
	    trace("Cg_var: %s flag %d mcmode %d mclength %d valneeded %d ida %d",
			_symname(bindsym_(b)),flag,
			mcmode,mclength,valneeded,ida);
	    trace("binder mode %x",mcrepofexpr((Expr *)b));
	}

	b = set_binder_ops(b);				
	
	if( mcmode < 2 || mcmode == 4 || (!floatingHardware && mcmode==2 && mclength==4) )
	{ /* all integer-like objects are stored in 1 word */
	  /* also all 4 byte floats in T414 */

		switch(flag)
		{
		case s_displace: 
			emit( loadOp,  b);pushInt();
			if( mcmode == 0 && mclength < 4)
			{
				if( lxxAllowed )
				{
					emit( f_opr, mclength==1?op_xbword:op_xsword);
				}
				else
				{
					emit( f_ldc, 1<<(mclength*8-1) );
					emit( f_opr, op_xword );
				}
			}
		        emit(f_opr, op_rev );
			emit(  storeOp, b);popInt();
			setTOS(mcmode,mclength);
			break;

		case s_assign:
			if( mclength < 4 )
			{
				if( lxxAllowed )
				{
					emit( f_opr, mclength==1?op_xbword:op_xsword);
				}
				else
				{
					emit( f_ldc, (1<<(mclength*8))-1 );
					emit( f_opr, op_and );
				}
			}			
			emit( storeOp, b );popInt();
		        if (!valneeded) break;
			/* drop through to re-load */
				
		case s_content:
		        if (valneeded)
		        {  
		            /* Check that higher up sets valneeded if volatile */
	        	    emit( loadOp, b); pushInt();
			    if( mcmode == 0 && mclength < 4)
			    {
				if( lxxAllowed )
				{
					emit( f_opr, mclength==1?op_xbword:op_xsword);
				}
				else
				{
					emit( f_ldc, 1<<(mclength*8-1) );
					emit( f_opr, op_xword );
				}
			    }
			    setTOS(mcmode,mclength);
		        }
		        break;
		    
		default:
			syserr("Unknown flag %x8 in cg_var",flag);
		}
	}
	else 
	{ 
	     if( !floatingHardware )
	     {
		/* Only doubles get through to here			*/
		/* doubles are always represented by a pointer to the	*/
		/* actual value in store.				*/
		switch( flag )
		{
		case s_assign:
		{
			/* copy both words 1 by 1 */
			VLocal *v = pushtemp(INTREG);
			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 0 );
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 0 ); popInt(); popInt();

			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 1 ); 
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 1 ); popInt(); popInt();
			if( valneeded )
			{
				emit( loadAddressOp, b );
				pushInt();
			}
			freetemp( v );
			break;
		}
		case s_displace:
		{
			/* copy both words 1 by 1 */
			VLocal *v = pushtemp(INTREG);
			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 0 );
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 0 ); popInt(); popInt();

			emit( p_ldvl, v ); pushInt();
			emit( f_ldnl, 1 ); 
			emit( loadAddressOp, b ); pushInt();
			emit( f_stnl, 1 ); popInt(); popInt();

			/* Return original pointer */
			emit( p_ldvl, v ); pushInt();

			freetemp( v );
			break;
		}
		case s_content:
			/* simply return address of variable */
			emit( loadAddressOp, b); pushInt();
		 	break;
		} /* end of switch */
		{ pop_trace(); return; }
	     }
	     /* floating objects, T8 only at present */
	     emit( loadAddressOp, b); pushInt();
	     switch (flag)
             {
	 	  case s_displace:
	  	       emit(f_opr,op_dup); pushInt();
		       emit(f_opr,mclength == 4 ? op_fpldnlsn:op_fpldnldb);
		       popInt(); pushFloat();
		       emit(f_opr,op_fprev);
		       emit(f_opr,mclength == 4 ? op_fpstnlsn:op_fpstnldb);
		       popInt(); popFloat();
		       break;
		  case s_assign:
		       if (valneeded)
	  	       {
		          emit(f_opr, op_fpdup );
	   	          pushFloat();
		       }
		       emit(f_opr,mclength == 4 ? op_fpstnlsn:op_fpstnldb);
		       popInt(); popFloat();
	 	       break;
		  case s_content:
		      emit(f_opr,mclength == 4 ? op_fpldnlsn:op_fpldnldb);
		      popInt(); pushFloat();
		      break;
		  default:
		      syserr("Unexpected flag in cg_var #%x8",flag);
		}
	}
	pop_trace();
}
/*}}}*/
/*{{{  cg_cast1 */

#define cg_expr4(x,mode) cg_cast1(x,4,mode)

void cg_cast1(x1,mclength,mcmode)
Expr *x1; const int mclength; const int mcmode;
{
    int arglength = mcrepofexpr(x1);
    int argmode = (arglength>>24) & 0xff;
    RegSort rsort = (mcmode!=2) ? INTREG : mclength==4 ? FLTREG : DBLREG;
    arglength &= 0x00ffffff;

    push_trace("cg_cast");
    
    if(debugging(DEBUG_CG)) 
	trace("Cg_cast: %x op %s mc mode %d l %d  arg mode %d l %d",
		x1,symbol_name_(h0_(x1)),mcmode,mclength,argmode,arglength);

    if (mclength==0) 
    {
       cg_exprvoid(x1);  /* cast to void */
       pop_trace(); return;
    }

    if (mcmode == 4)
    {   /* @@@@@@ LDS 13Aug89 (non-cast) to 'plain' type - i.e. load narrow */
        /* integer in most efficient manner, irrespective of real type.  */
        /* Used to suppress s/u bits on J_LDR[B|W]Xx jopcodes.           */
        /* NOTE: guaranteed that *x1 IS a Binder (by simplify.optimise0) */
        /* so the call to cg_var IS appropriate.                         */

	cg_var((Binder *)x1, s_content, mcmode, arglength, TRUE);
	/* cg_var((Binder *)x1, s_content, argmode, arglength, TRUE); */
	pop_trace(); return;
    }
    
    if (mcmode==3 || argmode==3)
    {   if (mcmode==argmode && mclength==arglength) { pop_trace(); return; }
        else syserr("Illegal cast involving a structure or union");
    }

    if (mcmode==argmode) switch(mcmode)
    {
case 4:	    /* change width of plain */
case 0:     /* change width of integer */
        cg_expr(x1);
/*trace("mclen %d arglen %d ida %d",mclength,arglength,ida);*/

	argmode = TOSmode();
	arglength = TOSlength();
	
	/* values are kept in the evaluation stack as full-width values */
	/* hence widening casts can be ignored.				*/
	if( mclength >= arglength ) { pop_trace(); return; }
	
	/* a narrowing cast requires us to mask and sign extend from	*/
	/* the new width.						*/

	if( !lxxAllowed && ida < 2 )
	{
		/* to sign extend we need 2 stack regs, make space and do it */
		VLocal *v;
		
		emit(f_opr, op_rev );
		v = pushtemp( INTREG );
		emit( f_ldc, (1<<(8*mclength))-1 );pushInt();
		emit(f_opr, op_and );popInt();
		emit( f_ldc, 1<<(8*mclength-1) );pushInt();
		emit(f_opr, op_xword );popInt();
		poptemp( v, INTREG );
		emit(f_opr, op_rev );
	}
	else
	{
		if( lxxAllowed )
		{
			int xwop = op_xbword;
			if( mclength == 2 ) xwop = op_xsword;
			emit( f_opr, xwop );
		}
		else
		{
			emit( f_ldc, (1<<(8*mclength))-1 );pushInt();
			emit(f_opr, op_and );popInt();
			emit( f_ldc, 1<<(8*mclength-1) );pushInt();
			emit(f_opr, op_xword );popInt();
		}
	}
        pop_trace(); return;
case 1:     /* change width of (unsigned) */
        cg_expr(x1);

	argmode = TOSmode();
	arglength = TOSlength();

	/* values are kept in the evaluation stack as full-width values */
	/* hence widening casts can be ignored.				*/
	if( mclength >= arglength ) { pop_trace(); return; }
	
	/* a narrowing cast requires us to mask down to the new width.	*/

	if( ida < 2 )		/* narrow to mclength by masking	*/
	{
		/* to mask we need 2 stack regs, make space and do it	*/
		VLocal *v;

		emit(f_opr, op_rev );
		v = pushtemp( INTREG );
		emit( f_ldc, (1<<(8*mclength))-1 ); pushInt();
		emit(f_opr, op_and ); popInt();
		poptemp( v, INTREG );
		emit(f_opr, op_rev );
	}
	else {
		emit( f_ldc, (1<<(8*mclength))-1 );pushInt();
		emit(f_opr, op_and );popInt();
	}
	
        pop_trace(); return;

case 2:     /* change width of float */
	{

		if( mclength==arglength )
		{
		        cg_expr(x1);
			{ pop_trace(); return; }
		}
		if( floatingHardware )
		{
		        cg_expr(x1);
			if( mclength < arglength ) emit(f_opr, op_fpur64tor32 );
			else emit(f_opr, op_fpur32tor64 );
			pop_trace(); return;
		}
		else
		{
			if( mclength < arglength )
			{
				VLocal *proc = allocatetemp(INTREG);
				VLocal *olddd = doubledest;
				
				doubledest = allocatetemp(DBLREG);
				
				emit( p_ldx, fplib.real64toreal32 );
				emit( p_stvl, proc );
					
			        cg_expr(x1);
				emit( f_ldc, ROUND_NEAREST );
				emit( p_fpcall, proc );
	
				freetemp( doubledest );
				freetemp( proc );
				doubledest = olddd;
			}
			else {
				VLocal *proc = allocatetemp(INTREG);
				
				if( doubledest == NULL )
					syserr("real32 -> real64 with no dest");

				emit( p_ldx, fplib.real32toreal64 );
				emit( p_stvl, proc );
			
			        cg_expr(x1);
				doubleaddr(doubledest);
				emit( p_fpcall, proc );

				freetemp( proc );
				doubleaddr(doubledest);

			}
			setInt(FullDepth-1);
			{ pop_trace(); return; }
		}
	}
default:
        if (mclength!=arglength) 
            syserr("bad mode %d in cast expression", mcmode);
        cg_expr(x1); 
        { pop_trace(); return; }
    }
    else if (mcmode==2)
    {   /* floating something */

/* Earlier parts of the compiler ensure that it is only necessary to     */
/* cope with full 32-bit integral types here. Such things as (float) on  */
/* a character are dealt with as (float)(int)<char> with the inner cast  */
/* explicit in the parse tree.                                           */
/****** FLOATING HARDWARE CHECK ******/
#if 0
        if (arglength!=4)
            syserr("cg_cast(float %d)", arglength);
#endif
        if (argmode == 1)    /* unsigned -> float - simulate with signed */
        {
            /* This is done by an ACN trick ...                          */
            /* xor source, minint                                        */
            /* -> double                                                 */
            /* add in the 2**31 again                                    */
            /* and if necessary round to single                          */
            /* How unpleasant !                                          */
	    if( floatingHardware )
	    {
		VLocal *v;
            	cg_expr4(x1,argmode);             /* Load the argument */
#if 0
            	emit(f_opr, op_mint );pushInt();
            	emit(f_opr, op_xor  );popInt();
            	v = pushtemp( INTREG ); /* Ready to load and float */
            	emit( p_ldvlp, v); pushInt();
            	emit(f_opr, op_fpi32tor64 ); popInt(); pushFloat(); /* Loaded as a double */
            	freetemp(v);
            	emitFpConst( fc_two_31, DBLREG);
            	emit(f_opr, op_fpadd ); popFloat();
#else
            	v = pushtemp( INTREG );
            	emit( p_ldvlp, v); pushInt();
		emit( f_opr, op_fpb32tor64 ); popInt(); pushFloat();
            	freetemp(v);
#endif
            	if (mclength == 4) 
               		emit(f_opr, op_fpur64tor32 );
	    }
	    else {
		VLocal *v = NULL;
		VLocal *proc = allocatetemp(INTREG);

		if( doubledest == NULL )
		{
			if( mclength == 8 ) syserr("unsigned -> double without dest");
			v = doubledest = allocatetemp(DBLREG);	
		}
	
		emit( p_ldx, fplib.int32toreal64 );
		emit( p_stvl, proc );

            	cg_expr4(x1,argmode);		/* Load the argument	*/
            	emit(f_opr, op_mint );		/* subtract 2**31	*/
            	emit(f_opr, op_xor  );
		doubleaddr(doubledest);
		emit( p_fpcall, proc );		/* convert to double	*/
            	emitFpConst( fc_two_31, DBLREG);
		doubleaddr(doubledest);
		codeFpCall( s_plus, 0x02000008 ); /* add in 2**31	*/

            	if (mclength == 4) 		/* convert to single if necc */
		{
			emit( p_ldx, fplib.real64toreal32 );
			emit( p_stvl, proc );
				
			emit( f_ldc, ROUND_NEAREST );
			emit( p_fpcall, proc );
		}
		/* in double case result is in doubledest */
		
		if( v ) freetemp(v), doubledest = NULL;

		freetemp(proc);

		setInt(FullDepth-1);
	    }
        }
	else
        {   /* Check to see whether the value we're converting */
            /* is already in store, in which case load its address */
            /* Else store it to a temp first */
	    if( floatingHardware )
	    {
            	if (instore( x1 )) 
               		cg_addr(x1, TRUE);
            	else
            	{
               		VLocal *temp;
               		cg_expr4(x1,argmode);
               		temp = pushtemp(INTREG);
               		emit( p_ldvlp, temp); pushInt();
               		freetemp(temp); /* Actually after the next instruction ...*/
            	}
            	emit(f_opr,rsort==FLTREG ? op_fpi32tor32:op_fpi32tor64);pushFloat(); popInt();
	    }
	    else
	    {
		if( rsort == FLTREG )
		{	/* signed int to single */
			VLocal *proc = allocatetemp(INTREG);
			emit( p_ldx, fplib.int32toreal32 );
			emit( p_stvl, proc );
			cg_expr4(x1,argmode);
			emit( f_ldc, ROUND_NEAREST );
			emit( p_fpcall, proc );
			freetemp(proc);
		}
		else {	/* signed int to double */
			VLocal *dest = doubledest;
			VLocal *proc = allocatetemp(INTREG);

			if( dest == NULL )
				syserr("int32 -> double with no dest");

			emit( p_ldx, fplib.int32toreal64 );
			emit( p_stvl, proc );
			cg_expr4(x1,argmode);
			doubleaddr(dest);
			emit( p_fpcall, proc );
			freetemp(proc);
			doubleaddr(dest);
		}
		setInt(FullDepth-1);
	    }
	}
        { pop_trace(); return; }
    }
    else if (argmode==2)
    {   /* fixing something THIS CODE IS NOT VERY CLEVER at generating
           int i = fix( xxx ) ; because it doesn't know that the target
           is really a store location, hence it will introduce a temp,
           and then load and store it... FIX LATER ...
        */
        VLocal *v = allocatetemp(INTREG);
        
/* N.B. the mclength==4 test in the next line is to produce shorter code */
/* for (unsigned short)(double)x.  It implies that this is calculated as */
/* (unsigned short)(int)(double)x.                                       */
        if (mcmode != 0 && mclength == 4)
        {
/* Fixing to an unsigned result is HORRIBLE, and is done using lots of   */
/* instructions here. The idea is to subtract 2**31 and fix, and then    */
/* to add back 2**31 to the resulting integer. We can cheat slightly here*/
/* by using round negative so that what we generate is                   */
/*     fixu(x) rounded to zero = fixs(x-2^31) round neg + 2^31           */     
/* The trick only works if I use double precision, (cos 2^31 is not      */
/* precisely representable in SP) so for float I start off by widening the*/
/* input.                                                                */
	    if( floatingHardware )
            {   
                cg_expr(x1);
                if (arglength==4)
                   emit(f_opr,op_fpur32tor64);
                emitFpConst(fc_two_31, DBLREG);
                emit(f_opr,op_fpadd); popFloat();
                emit( p_ldvlp, v); pushInt();
                emit(f_opr,op_fpurm);
                emit(f_opr,op_fprtoi32); 
		emit(f_opr, op_fpstnli32);
		popInt(); popFloat();
                emit(p_ldvl, v); pushInt();
                emit(f_opr, op_mint ); pushInt();
                emit(f_opr, op_xor ) ; popInt();
             }
	     else {
	     	VLocal *dbl = NULL;
	     	extern FloatCon *fc_unsfix;
	     	
	     	if( doubledest == NULL ) 
	     		dbl = doubledest = allocatetemp(DBLREG);
	     	
		if( arglength == 4 )
		{
			emit( p_ldx, fplib.real32toreal64 );
			emit( p_stvl, v );
			
		        cg_expr(x1);
			doubleaddr(doubledest);
			emit( p_fpcall, v );
			doubleaddr(doubledest);
		}
		else cg_expr(x1);
		/* doubedest now contains the value to convert */

                emitFpConst(fc_unsfix, DBLREG);
                codeFpCall(s_minus,0x02000008);
                /* doubledest = doubledest - (2**31+0.5)	*/
                
                emit( p_ldx, fplib.real64toint32 );
                emit( p_stvl, v );
                doubleaddr(doubledest);
                emit(f_ldc,ROUND_NEAREST);
                emit(p_fpcall, v);
		/* we now have (int)doubledest on the stack add back 2**31 */

		emit(f_opr, op_mint);
		emit(f_opr, op_xor );
		
		if( dbl != NULL ) freetemp(dbl), doubledest = NULL;
		
		setInt(FullDepth-1);             
	     }
        }
        else 
        { /* Fix to a signed result is rather easier. */
          /* This is the case where we would like to know the target */
	     if( floatingHardware )
	     {
	             cg_expr(x1);
		     emit(p_ldvlp, v);pushInt();
		     emit( f_opr, op_fpurz );	/* round to zero */
	             emit(f_opr, op_fprtoi32 ); 
		     emit(f_opr, op_fpstnli32);
		     popFloat(); popInt();
        	     emit( p_ldvl, v); pushInt();
	     }
	     else {
		if( arglength == 4 )
		{
			emit( p_ldx, fplib.real32toint32 );
			emit( p_stvl, v );
			cg_expr(x1);
			emit( f_ldc, ROUND_ZERO );
			emit( p_fpcall, v );
		}
		else {
			VLocal *olddd = doubledest;
			doubledest = allocatetemp(DBLREG);
			emit( p_ldx, fplib.real64toint32 );
			emit( p_stvl, v );
			cg_expr(x1);
			emit( f_ldc, ROUND_ZERO );
			emit( p_fpcall, v );
			freetemp( doubledest );
			doubledest = olddd;
		}
		setInt(FullDepth-1);
	     }
        }
        
        freetemp(v);
        
/* If I do something like (short)<some floating expression> I need to    */
/* squash the result down to 16 bits.                                    */
        if (mclength < 4)
        {
            if (mcmode == 0 || mcmode == 4)
            { 
            	if( lxxAllowed )
            	{
			int xwop = op_xbword;
			if( mclength == 2 ) xwop = op_xsword;
			emit( f_opr, xwop );
            	}
            	else
            	{	/* mask and sign extend the correct bit field */
			emit( f_ldc, (1<<(8*mclength))-1 ); pushInt();
			emit(f_opr, op_and );popInt();            
	                emit( f_ldc, 1 << (8*mclength ));  pushInt();
        	        emit(f_opr, op_xword ); popInt();
        	}
            }
            else
            { /* Unsigned case, mask out high significance bits */
                emit(f_ldc, (1<<(8*mclength))-1 ); pushInt();
                emit(f_opr, op_and );popInt();
            }
        }
    } /* End of the FIX cases */
    else if( mclength == arglength && argmode == 4 )
    {
       cg_expr(x1);
       { pop_trace(); return; }
    }
    else if (arglength==4 && mclength==4)
    {   
       cg_expr(x1);
       { pop_trace(); return; }
    }
    else if (mcmode==1)		/* signed -> unsigned		*/
    {   
    	int masklength = mclength;
        cg_expr(x1);

	/* For widening casts we mask the sign bits out down to the */
	/* arglength. When narrowing we mask down to the mclength.  */
	if( mclength >= arglength )
	{
		if( arglength == 4 ) { pop_trace(); return; }
		masklength = arglength;
	}
	
	if( ida < 2 )
	{
		/* to mask we need 2 stack regs, make space and do it */
		VLocal *v;

		emit(f_opr, op_rev );
		v = pushtemp( INTREG );
		emit( f_ldc, (1<<(8*masklength))-1 ); pushInt();
		emit(f_opr, op_and ); popInt();
		poptemp( v, INTREG );
		emit(f_opr, op_rev );
	}
	else {
		emit( f_ldc, (1<<(8*masklength))-1 );pushInt();
		emit(f_opr, op_and );popInt();
	}
        { pop_trace(); return; }
    }
    else if (mcmode==0 || mcmode == 4)	/* unsigned -> signed		*/
    {
        cg_expr(x1);

	if( mclength >= arglength ) { pop_trace(); return; }

	if( !lxxAllowed && ida < 2 )
	{
		/* to sign extend we need 2 stack regs, make space and do it */
		VLocal *v;
		int savessp = ssp;
		emit(f_opr, op_rev );
		v = pushtemp( INTREG );
		emit( f_ldc, (1<<(8*mclength))-1 );pushInt();
		emit(f_opr, op_and );popInt();		
		emit( f_ldc, 1<<(8*mclength-1) );pushInt();
		emit(f_opr, op_xword );popInt();
		poptemp( v, INTREG );
		emit(f_opr, op_rev );
	}
	else {
		if( lxxAllowed )
		{
			int xwop = op_xbword;
			if( mclength == 2 ) xwop = op_xsword;
			emit( f_opr, xwop );
		}
		else
		{
			emit( f_ldc, (1<<(8*mclength))-1 );pushInt();
			emit(f_opr, op_and );popInt();		
			emit( f_ldc, 1<<(8*mclength-1) );pushInt();
			emit(f_opr, op_xword );popInt();
		}
	}
        { pop_trace(); return; }
    }
    else
    {   syserr("cast %d %d %d %d", mcmode, mclength, argmode, arglength);
        { pop_trace(); return; }
    }
}
/*}}}*/
#endif
/*{{{  cg_storein */
void cg_storein(e,flag,valneeded)
Expr *e;
AEop flag; 
int valneeded;
{
	int mclength = mcrepofexpr(e);
	int mcmode = (mclength>>24) & 0xff ;
	mclength &= 0x00ffffff;

	push_trace("cg_storein");
	
	if(debugging(DEBUG_CG))	trace("cg_storein: %s %s mode %d len %d",symbol_name_(h0_(e)),symbol_name_(flag),mcmode,mclength);
		
	switch( h0_(e) )
	{
	case s_binder:
		cg_var( (Binder *)e, flag, mcmode, mclength, valneeded );
		break;
	
	case s_dot:
		e = cg_content_for_dot(e);
		pp_expr(e,valneeded);
		cg_storein( e, flag, valneeded );
                break;
                
	case s_content:
		e = arg1_(e);
		cg_indirect(e , flag, mcmode, mclength, valneeded );
                break;

	case s_cast:
		cg_storein(arg1_(e), flag, valneeded);		
		break;

	default:
		syserr("cg_storein(%d)",h0_(e));
	}
	pop_trace();
}
/*}}}*/
/*{{{  codeOperation */
void codeOperation( op, floating, mode )
AEop op;
bool floating;
int mode;
{
    switch (op)
    {
       case  s_times: 
       		    if( addrexpr && !floating ) emit( f_opr, op_prod );
/*       		    else emit(f_opr, floating ? op_fpmul: op_mul); */
       		    else emit(f_opr, floating ? op_fpmul: op_prod);
                    break;
       case  s_plus: emit(f_opr, floating ? op_fpadd: op_add);
                    break;
       case  s_minus: emit(f_opr, floating ? op_fpsub: op_sub);
                    break;
       case  s_div: emit(f_opr, floating ? op_fpdiv: op_div);
                    break;
       case  s_rem: if (floating)
                        syserr("%% on floating value");
                    emit(f_opr,op_rem);
                    break;       
       case  s_and: if (floating)
                        syserr("& on floating value");
                    emit(f_opr, op_and );
                    break;
       case  s_or:  if (floating)
                        syserr("| on floating value");
                    emit(f_opr, op_or );
                    break;
       case  s_xor: if (floating)
                        syserr("^ on floating value");
                    emit(f_opr, op_xor );
                    break;
       case  s_leftshift: 
                    if (floating)
                        syserr("<< on floating value");
                    emit(f_opr, op_shl );
                    break;
       case  s_rightshift:
                    if (floating)
                        syserr(">> on floating value");
                    emit(f_opr, op_shr );
                    break;
       case  s_equalequal:
                    if (floating)
                        emit(f_opr, op_fpeq);
                    else
                    {
                        emit(f_opr, op_diff );
                        emit(  f_eqc, 0 );
                    }
                    break;
       case  s_diff:if (floating)
                        syserr("diff on floating value");
                    else
                        emit(f_opr, op_diff );
                    break;
       case  s_greater: 
       		    if( (mode>>24) == 1 )
       		    {
       		    	if( gtuAllowed )
       		    	{
       		    		emit( f_opr, op_gtu );
       		    	}
       		    	else
       		    	{
				emit( f_opr, op_mint );
				emit( f_opr, op_xor );
				emit( f_opr,op_rev );
				emit( f_opr, op_mint );
				emit( f_opr, op_xor );
				emit( f_opr,op_rev );
				emit( f_opr, op_gt );
			}
       		    }
                    else emit(f_opr, floating ? op_fpgt: op_gt);
                    break;
       
       default:     syserr("Unexpected aeop %d (%s) in codeOperation",
                             op, symbol_name_(op));
    }
}
/*}}}*/
/*{{{  T4 floating point */

/* The following routines are used to implement floating point emulation on*/
/* the T4. The single precsion float stuff is quite simple, but the double */
/* stuff is seriously complicated by the fact that doubles must always live*/
/* in store, and are passed around as pointers. 			   */

/*{{{  codeFpCall */
void codeFpCall( op, mode1 )
AEop op; int mode1;
{
	VLocal *v;
	int code = 3;

	int dbl = (mode1==0x02000008);

	push_trace("codeFpCall");
	
	if(debugging(DEBUG_CG))
		trace("codeFpCall(%s,%x) dbl = %d doubledest = %x",
			symbol_name_(op),mode1,dbl,doubledest);

	if( !dbl )	/* single precision floating point */
	{
		switch( op )
		{
		case s_plus:  code--;
		case s_minus: code--;
		case s_times: code--;
		case s_div:
		{
			if( real32op == NULL )
				syserr("codeFpCall: real32op not cached");

			/* this is a temporary kludge to get operands	*/
			/* in the right order for - & /. The proper fix	*/
			/* is to generate them correctly in the first	*/
			/* place.					*/
			if( op == s_minus || op == s_div ) emit( f_opr, op_rev );
			
			emit( f_ldc, code );
			emit( f_opr, op_rev );
			emit( p_fpcall, real32op );
			setInt(FullDepth-1);
			break;
		}

#if 0
		/* actually the front end does not allow this to happen */
		case s_rem:
		{
			VLocal *proc = allocatetemp(INTREG);
			emit( p_ldx, fplib.real32rem );
			emit( p_stvl, proc );
			emit( p_fpcall, proc );
			freetemp(proc);
			break;
		}
#endif		
		case s_greater:
		{
			VLocal *proc = allocatetemp(INTREG);
			/* this is a temporary kludge to get operands	*/
			/* in the right order. The proper fix		*/
			/* is to generate them correctly in the first	*/
			/* place.					*/
			emit( f_opr, op_rev );

			emit( p_ldx, fplib.real32gt );
			emit( p_stvl, proc );
			emit( p_fpcall, proc );
			freetemp(proc);
			setInt(FullDepth-1);
			break;
		}

		case s_equalequal:
		{
			VLocal *proc = allocatetemp(INTREG);
			emit( p_ldx, fplib.real32eq );
			emit( p_stvl, proc );
			emit( p_fpcall, proc );
			freetemp(proc);
			setInt(FullDepth-1);
			break;
		}


		default:
			syserr("Unexpected AeOp in codeFpCall: %d %s",
				op,symbol_name_(op));
		}
	}
	else
	{
		switch( op )
		{
		case s_plus:  code--;
		case s_minus: code--;
		case s_times: code--;
		case s_div:
		{
			if( real64op == NULL )
				syserr("codeFpCall: real64op not cached");

			if( doubledest == NULL ) syserr("double operation without dest");

			/* ensure there is enough room */
			if( ssp == maxssp ) maxssp++;

			emit( f_stl, 0 );

			emit( f_ldc, code );
			emit( f_opr, op_rev );
			doubleaddr(doubledest);
			emit( p_fpcall, real64op );
			doubleaddr(doubledest);
			setInt(FullDepth-1);
			break;
		}

#if 0
		/* actually the front end does not allow this to happen */
		case s_rem:
		{
			VLocal *proc = allocatetemp(INTREG);

			if( doubledest == NULL ) syserr("double operation without dest");

			emit( p_ldx, fplib.real64rem );
			emit( p_stvl, proc );
			doubleaddr(doubledest);
			emit( p_fpcall, proc );
			freetemp(proc);
			doubleaddr(doubledest);
			break;
		}
#endif
		default:
			syserr("Unexpected AeOp in codeFpCall: %d %s",
				op,symbol_name_(op));
		}
	}
	
	pop_trace();
}
/*}}}*/
/*{{{  cg_doubleassign */

#define islocal(x) ( (h0_(x) == s_binder) && ( ( bindstg_((Binder *)(x)) & bitofstg_(s_auto) ) != 0 ) )

cg_doubleassign( target, source, flag, valneeded )
Expr *target, *source;
int flag, valneeded;
{
	int code = 3;
	VLocal *prevdest = doubledest;
	VLocal *src = NULL;
	int savessp = ssp;
	int op;

	push_trace("cg_doubleassign");
	
	if(debugging(DEBUG_CG))
		trace("cg_doubleassign(%x,%x,%d,%d) doubledest = %x",
			target,source,flag,valneeded,doubledest);

	if( islocal(target) )
	{
		doubledest = (VLocal *)bindxx_((Binder *)target);
	}
	else {
		if( (h0_(target) == s_content) && islocal(arg1_(target)) )
		{
			doubledest = (VLocal *)bindxx_((Binder *)arg1_(target));
		}
		else {
			cg_addrexpr( target );
			doubledest = pushtemp( INTREG );
		}
	}

	/* If the operation is a displace, copy the old value out first	  */
	/* Note that a displace cannot happen in a void context, so there */
	/* MUST be a previous doubledest set up. If not, winge.		  */
	if( flag == s_displace )
	{
		if( prevdest == NULL )
			syserr("Double displace in void context");
#ifdef LONGCOPY
		doubleaddr(prevdest);
		emit( f_ldnl, 0 );
		doubleaddr(doubledest);
		emit( f_stnl, 0 );

		doubleaddr(prevdest);
		emit( f_ldnl, 1 );
		doubleaddr(doubledest);
		emit( f_stnl, 1 );
#else
		doubleaddr( prevdest );
		doubleaddr( doubledest );
		emit( f_ldc, 8 );
		emit( f_opr, op_move );
#endif
	}

again:
	if(debugging(DEBUG_CG))	
		trace("source op %s",symbol_name_(h0_(source)));
	switch( op=h0_(source) )
	{
	case s_plus:  code--;
	case s_minus: code--;
	case s_times: code--;
	case s_div:
	case s_rem:
	{
		Expr* a1 = arg1_(source);
		Expr* a2 = arg2_(source);
		int d1 = idepth(depth(a1));
		int d2 = idepth(depth(a2));
		VLocal *olddd = doubledest;
		VLocal *temp = NULL;
		VLocal *v1 = NULL;

		if( real64op == NULL )
			syserr("codeFpCall: real32op not cached");

		if(debugging(DEBUG_CG))
			trace("(%s depth %d) %s (%s depth %d)",
				symbol_name_(h0_(a1)),d1,
				symbol_name_(h0_(source)),
				symbol_name_(h0_(a2)),d2);
				
		/* While in theory it should be possible to use doubledest */
		/* as the destination of one of the following expressions  */
		/* there is always the possibility that one of these	   */
		/* expressions uses the value currently in it. 		   */
		/* For safety, therefore, evaluate them onto the stack.	   */
		/* Note that we only need to allocate temps for expressions*/
		/* which have maximum depth, only constants and binders have*/
		/* less depth, and these do not need a destination.	   */
		/* Note also that indirections may require more than 2 regs*/
		/* we detect this case and don't generate a dest.	   */

		if( d1 >= FullDepth )
		{
			if( h0_(a1) == s_content || h0_(a1) == s_dot )
			{
				cg_addrexpr( a1 );
				v1 = pushtemp( INTREG );
			}
			else {
				v1 = doubledest = allocatetemp(DBLREG);
				cg_expr( a1 );
			}
		}
		/* else we can load a1 later */

		doubledest = olddd;

		if( d2 >= FullDepth )
		{
			if( h0_(a2) != s_content && h0_(a2) != s_dot )
				doubledest = allocatetemp(DBLREG);

			cg_expr( a2 );

			if( v1 == NULL ) cg_expr( a1 );
			else doubleaddr( v1 );

			/* if op is not commutable, get args in right order */
			if( (op == s_div) || (op == s_minus) ) 
				emit( f_opr, op_rev);
		}
		else {
			if( v1 == NULL ) cg_expr( a1 );
			else doubleaddr( v1 );

			cg_expr( a2 );
		}

		/* pointers to the two operands should now be on the stack */
		/* with a2 on top.					   */

		/* ensure there is enough room */
		if( ssp == maxssp ) maxssp++;

		emit( f_stl, 0 );

		emit( f_ldc, code ); 
		emit( f_opr, op_rev );

		doubleaddr(olddd);

		emit( p_fpcall, real64op );

		doubledest = olddd;

		break;
	}

	case s_cond:
	/* Convert    a = (b ? c : d) to                          	*/
	/*    (LET double *g,                                           */
	/*       g = &a,                                                */
	/*       b ? (*g = c) : (*g = d))                               */
	/*                                                              */
        {   TypeExpr *t = typeofexpr(target);
            Binder *gen = gentempbinder(ptrtotype_(t));
	    Expr *e = mk_expr2(s_let,
                         t,
                         (Expr *)mkBindList(0, gen),
                         mk_expr2(s_comma,
                                  t,
                                  mk_expr2(s_assign,
                                           ptrtotype_(t),
                                           (Expr *)gen,
                                           take_address(target)),
                                  mk_expr3(s_cond,
                                           t,
                                           arg1_(source),
                                           mk_expr2(s_assign,
                                                    t,
                                                    mk_expr1(s_content,
                                                             t,
                                                             (Expr *)gen),
                                                    arg2_(source)),
                                           mk_expr2(s_assign,
                                                    t,
                                                    mk_expr1(s_content,
                                                             t,
                                                             (Expr *)gen),
                                                    arg3_(source)))));
		pp_expr(e,0);
		cg_exprvoid(e);
		break;		
        }

	case s_cast:
	{
		int mode = cautious_mcrepofexpr( source );
		int argmode = mcrepofexpr(arg1_(source) );
		
		/* this filters out unnecessary casts which can happen	*/
		/* if we have a typedef for double.			*/
		
		if( mode == argmode ) 
		{ source = arg1_(source); goto again; }
		
		cg_cast1( arg1_(source), mode & 0x00ffffff, mode>>24 );

		if( mcrepofexpr(arg1_(source)) != 0x02000008 ) break;
		
		/* here we are casting to or from a typedef, where a 	*/
		/* conversion routine will not be called.		*/
#ifdef LONGCOPY
		src = pushtemp(INTREG);
		
		goto copydouble;
#else
		doubleaddr( doubledest );
		emit( f_ldc, 8 );
		emit( f_opr, op_move );
		break;
#endif
	}

	/* nested assignment, evaluate it and then copy result into our	*/
	/* dest.							*/
	case s_displace:
	case s_assign:
	case s_floatcon:
		cg_expr( source );
		src = pushtemp( INTREG );
		goto copydouble;

	/* for s_dot we convert and treat as content		*/
	case s_dot:
		source = cg_content_for_dot(source);

	/* for s_content we get the address and then copy out	*/
	case s_content:
		if( islocal(arg1_(source)) )
		{
			src = (VLocal *)bindxx_((Binder *)arg1_(source));
		}
		else {
			cg_addrexpr( arg1_(source) );
			src = pushtemp( INTREG );
		}
		goto copydouble;

	case s_binder:
	{
		Binder *b = (Binder *)source;
		if( ( bindstg_(b) & bitofstg_(s_auto) ) != 0 )
		{ 
			/* local -> var 	copy directly */
			src = (VLocal *)bindxx_(b);
		}
		else
		{	
			/* static -> var	go via a local pointer */
			cg_expr( source );
			src = pushtemp(INTREG);
		}
	}

	copydouble:
#ifdef LONGCOPY
		doubleaddr( src );
		emit( f_ldnl, 0 );
		doubleaddr(doubledest);
		emit( f_stnl, 0 );

		doubleaddr( src );
		emit( f_ldnl, 1 );
		doubleaddr(doubledest);
		emit( f_stnl, 1 );
#else
		doubleaddr( src );
		doubleaddr( doubledest );
		emit( f_ldc, 8 );
		emit( f_opr, op_move );
#endif		
		break;

		/* the default is to evaluate the expression with doubledest */
		/* set up as necessary.					     */
	default:
		cg_expr( source );
		break;
#if 0
		syserr("Unexpected AeOp in cg_doubleassign: %d %s",
			op,symbol_name_(op));
#endif
	}

	if( valneeded )
	{
		doubleaddr(doubledest);
		setInt(FullDepth-1);
	}
	else setInt(FullDepth);

	/* dispose of all temps */
	ssp = savessp;
	doubledest = prevdest;
	
	pop_trace();
}
/*}}}*/
/*{{{  cg_doublecmp */

/* When compiling comparisons we may need to supply a destination for the */
/* two sides. We only do this if the depth of the expressions is >= 3 	  */
/* since variables and constant dont need it, and have depth=1.		  */
/* NOTE: a1 & a2 swapped over here to fix a small bug.			  */

void cg_doublecmp( op, a2, a1 )
AEop op;
Expr *a1, *a2;
{
	int d1 = idepth(depth(a1));
	int d2 = idepth(depth(a2));
	int savessp = ssp;
	VLocal *olddd = doubledest;
	Binder *func = op==s_greater ? fplib.real64gt : fplib.real64eq ;
	VLocal *proc = allocatetemp( INTREG );

	push_trace("cg_doublecmp");
	
	if( debugging(DEBUG_CG))
		trace("cg_doublecmp(%s,%x,%x) d1 %x d2 %x",
			symbol_name_(op),a1,a2,d1,d2);

	emit( p_ldx, func );
	emit( p_stvl, proc );

	if( d1 >= FullDepth ) doubledest = allocatetemp( DBLREG );

	cg_expr( a1 );

	doubledest = NULL;

	if( d2 >= FullDepth )
	{
		VLocal *tmp = allocatetemp( INTREG );

		doubledest = allocatetemp( DBLREG );

		emit( p_stvl, tmp ); popInt();

		cg_expr( a2 );

		emit( p_ldvl, tmp );  pushInt();
		if( op == s_greater ) emit( f_opr, op_rev );
	}
	else cg_expr( a2 );

	emit( p_fpcall, proc );

	doubledest = olddd;
	ssp = savessp;

	setInt(FullDepth-1);
	
	pop_trace();
}
/*}}}*/
/*}}}*/
@


1.1.1.1
log
@Initial Import of Norcroft C compiler for Transputer.
@
text
@@
