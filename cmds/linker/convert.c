/*{{{  Comment */

/*---------------------------------------------------------------------------*/
/* AOF to Helios object convertor.
 *
 * Original Author: JGSmith
 *
 * $Revision: 1.30 $
 *   $Author: vlsi $
 *     $Date: 1994/05/05 10:27:14 $
 *
 * Copyright (c) 1993, VLSI Technology Inc. All Rights Reserved.
 *           (c) 1994, Perihelion Software Ltd.  All Rights Reserved.
 *
 * Notes:
 *
 * Since we cannot add or remove instructions from the code, and we
 * cannot safely use r14, we must use branches to reach the address
 * generating code. This means that every data access will have its
 * own stub code. This will increase the code size by 2 instructions
 * for every data access.
 *
 * The current re-entrant APCS includes code to preserve r9(dp/sb/mt)
 * over function calls. This preservation code is not required by the
 * Helios system, since it uses double indirection. Unfortunately this
 * means that the converted code is slightly larger than it need be.
 */
/*---------------------------------------------------------------------------*/

/*}}}*/

/* FIXME : TODO : The generated code would be optimised by NOT
 * including INIT code for libraries when the object has NO
 * initialised data.
 */

/* If "ZERODATA" is defined at compile time then the
 * data-initialisation code will zero the module table memory (BSS).
 * If it is not defined then it is assumed that the module table will
 * already have been zeroed by the task manager. */

/*{{{  #includes */

typedef long int int32;
typedef unsigned long unsigned32;

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <stdlib.h>

#include "convert.h"
#include "endian.h"
#include "link.h"

#include <module.h>

/*}}}*/
/*{{{  #defines */

#define trace if (traceflags & db_aof) _trace

#ifndef TRUE
#define TRUE (1 == 1)
#endif
#ifndef FALSE
#define FALSE (1 == 0)
#endif

/*---------------------------------------------------------------------------*/
/* The convertor generates some "local" symbols to reference code and
 * data created during the conversion process. These manifests control
 * the form of these manufactured symbols.
 */
#define LOCALADDRSYM ".__local_addr_"                  /* prefix */
#define DATAINITSYM  ".__local_data_initialisation"
#define UNIQAREA     "AREA"

/*---------------------------------------------------------------------------*/
/* The Helios object output is buffered. The following manifest
 * controls the size of the code buffer used.
 */
#define BUFFERSIZE (16 << 10) /* bytes */

/* To cope with generating unique local symbols (required when linking
 * library and kernel objects), we allocate a single temporary buffer.
 */
#define TBUFFSIZE (4 << 10) /* should be big enough for very large symbols */

/*---------------------------------------------------------------------------*/
/* Nasty constants that should really be defined in an exported Helios
 * header file.
 */

#define HOF_title_len       (32)   /* length of a standard module name */

/*
 * Funky macro to cpoe with fact that kernel/device driver function names
 * strat with a . rather than a _
 */

#define CodePrefix_()       (bDeviceDriver ? '.' : '_')

/*}}}*/
/*{{{  Types & Macros */

/*---------------------------------------------------------------------------*/
/* Useful ARM manifests */

typedef enum
{
 ccEQ = 0x0,
 ccNE = 0x1,
 ccCS = 0x2,
 ccCC = 0x3,
 ccMI = 0x4,
 ccPL = 0x5,
 ccVS = 0x6,
 ccVC = 0x7,
 ccHI = 0x8,
 ccLS = 0x9,
 ccGE = 0xA,
 ccLT = 0xB,
 ccGT = 0xC,
 ccLE = 0xD,
 ccAL = 0xE,
 ccNV = 0xF
} ARMcondcodes ;

/*---------------------------------------------------------------------------*/
/* ARM instructions generated by Helios updates */

/* "B address" */
#define Branch(a,p)      (0xEA000000 | ((((a) - ((p) + 8)) >> 2) & 0xFFFFFF))

/* "B<cc> address" */
#define BranchCC(a,p,c)      (0x0A000000 | ((c) << 28) | ((((a) - ((p) + 8)) >> 2) & 0xFFFFFF))

/* "LDR <r>,[dp,#&00]" */
#define LDRfromdp(r)     (0xE5990000 | ((r) << 12))

/* "ADD <r>,<r>,#&00" */
#define ADDwithoffset(r) (0xE2800000 | ((r) << 16) | ((r) << 12))

/* "LDR <r>,[<r>,#&00]" */
#define LDRfromoffset(r) (0xE5900000 | ((r) << 16) | ((r) << 12))

/* "LDRB <r>,[<r>,#&00]" */
#define LDRBfromoffset(r) (0xE5D00000 | ((r) << 16) | ((r) << 12))

/* "STR <r>,[<r>,#&00]" */
#define STRtooffset(r) (0xE5800000 | ((r) << 16) | ((r) << 12))

/* "STRB <r>,[<r>,#&00]" */
#define STRBtooffset(r) (0xE5C00000 | ((r) << 16) | ((r) << 12))

/* "MOV r0,r0"        NOP */
#define ARMNOP  (0xE1A00000)            /* do nothing for 1cycle */

/* "MOV pc,ip" */
#define stubCall (0xE1A0F00C)           /* call a function from a stub */

/* "MOV pc,lr" */
#define returnCall (0xE1A0F00E)

/* Exception stub code (nasty constants) */
#define stubPush  (0xE92D5000)          /* "STMFD sp!,{ip,lk}" */
#define stubStore (0xE58DC004)          /* "STR   ip,[sp,#4]"  */
#define stubPop   (0xE8Bd9000)          /* "LDMFD sp!,{ip,pc}" */

/* Address generating stub : "ADD r,r,#0" */
#define addrADD(r)  (0xE2800000 | ((r) << 16) | ((r) << 12))
/* Address generating stub : "ADD r,pc,#0" */
#define addrADDpc(r)  (0xE28F0000 | ((r) << 12))

/* Initialisation */
#define initCMP     (0xE3500002)    /* "CMP  a1,#2"      */
#define initCMP1    (0xE3500001)    /* "CMP  a1,#1"      */
#define initReturn1 (0x01A0F00E)    /* "MOVEQ pc,lr"	 */
#define initLDRfn   (0xE599C004)    /* "LDR  ip,[dp,#4]" */
#define initLDRdata (0xE599C000)    /* "LDR  ip,[dp,#0]" */
#define initSUBfn   (0xE24F1000)    /* "SUB  a2,pc,#0"   */
#define initSUBfn2  (0xE2411000)    /* "SUB  a2,a2,#0"   */
#define initSTRfn   (0xE48C1004)    /* "STR  a2,[ip],#4" */
#define initLDRcopy (0xE4913004)    /* "LDR  a4,[a2],#4" */
#define initSTRdata (0xE48C3004)    /* "STR  a4,[ip],#4" */
#define initSUBS    (0xE2522004)    /* "SUBS a3,a3,#4"   */
#define initMOV     (0xE3A02000)    /* "MOV  a3,#0"      */
#define zeroMOVa4   (0xE3A03000)    /* "MOV  a4,#0"      */
#define initADD     (0xE2822000)    /* "ADD  a3,a3,#0"   */
#define initADDa1   (0xE2800000)    /* "ADD  a1,a1,#0"   */
#define initADDip   (0xE28C0000)    /* "ADD  a1,ip,#0"   */
#define initADDinto (0xE082200C)    /* "ADD  a3,a3,ip"   */
#define initADDmore (0xE2822000)    /* "ADD  a3,a3,#0"   */
#define initADDcode (0xE0822001)    /* "ADD  a3,a3,a2"	 */

#define initSUBr(r)  (0xE24F0000 | ((r) << 12))               /* "SUB r,pc,#0"    */
#define initSUBr2(r) (0xE2400000 | ((r) << 16) | ((r) << 12)) /* "SUB r,r,#0"     */
#define initADDr(r)  (0xE2800000 | ((r) << 16) | ((r) << 12)) /* "ADD r,r,#0"     */
#define initLDR(r,a) (0xE5900000 | ((r) << 12) | ((a) << 16)) /* "LDR rr,[ra,#0]" */
#define initSTR(r,a) (0xE5800000 | ((r) << 12) | ((a) << 16)) /* "STR rr,[ra,#0]" */

/*---------------------------------------------------------------------------*/
/* Reference a NUL terminated piece of text within the string table */
#define FINDSTRING(a,o) (char *)((a)->aofstrt + (o))

/*---------------------------------------------------------------------------*/

/*}}}*/
/*{{{  Local Variables */

/*---------------------------------------------------------------------------*/
/* This is a list of symbols that need exception style calling stubs.
 * It is a bit of a bodge, but unfortunately the AOF symbols have no
 * attributes to mark non-APCS conforming code.
 */
static char *symbol_exceptions[] = {
                                    "__rt_stkovf_split_small",
                                    "__rt_stkovf_split_big",
                                    "__stack_overflow",
                                    "__stack_overflow_1",
                                    NULL
                                   } ;

static unsigned32 maxcodep = 0 ;
static unsigned32 maxdata  = 0 ;

/* For quicker access to a simple temporary string buffer */
static char *tmpbuffer = NULL ;

/*}}}*/
/*{{{  Functions */

/*{{{  write_encoded */

#define ENC_NEG         (0x40)
#define ENC_MORE        (0x80)
#define LO6MASK         (0x3F)
#define LO7MASK         (0x7F)

/* write_encoded
 * -------------
 * Write a number in the coded form required by Helios objects.
 *
 * in:  n  : value to be written.
 *      fp : output file descriptor.
 * out: no conditions.
 */
static void write_encoded(int n,FILE *fp)
{
 int sign = ((n < 0) ? ENC_NEG : 0) ;
 int shift ;
 int mask ;
 int more = 0 ;

 if (sign)
  n = -n ;

 mask = LO6MASK ;
 shift = 0 ;
 while ((n & mask) != n)
  {
   more = ENC_MORE ;
   shift += 7 ;
   mask = ((mask << 7) | LO7MASK) ;
  }

 putc((((n & (LO6MASK << shift)) >> shift) | sign | more),fp) ;
 if (more)
  {
   do
    {
     shift -= 7 ;
     putc((((n & (LO7MASK << shift)) >> shift) | ((shift == 0) ? 0 : ENC_MORE)),fp) ;
    } while (shift != 0) ;
  }

 return ;
}

/*}}}*/
/*{{{  write_byte */

static void write_byte(int val,FILE *fp)
{
 putc(val,fp) ;
 return ;
}

/*}}}*/
/*{{{  write_text */

static void write_text(char *text,int length,FILE *fp)
{
 for (; (length > 0); length--)
  putc(*text++,fp) ;
 return ;
}

/*}}}*/
/*{{{  write_number */

static void write_number(unsigned int num,FILE *fp)
{
 char tbuff[9] ;

 sprintf(tbuff,"%X",num) ;
 write_text(tbuff,strlen(tbuff),fp) ;
 return ;
}

/*}}}*/
/*{{{  write_string */

static void write_string(char *text,int length,FILE *fp)
{
 write_text(text,length,fp) ;
 putc('\0',fp) ;
 return ;
}

/*}}}*/
/*{{{  write_data */

static void write_data(unsigned char *data,int amount,FILE *fp)
{
 if (amount > 0)
  {
   putc(OBJCODE,fp) ; (void)write_encoded(amount,fp) ;
   for (; (amount != 0); amount--)
    putc(*data++,fp) ;
  }
 return ;
}

/*}}}*/
/*{{{  write_padding */

static void write_padding(int amount,FILE *fp)
{
 putc(OBJBSS,fp) ;
 (void)write_encoded(amount,fp) ;
 return ;
}

/*}}}*/
/*{{{  putinbuffer */

static void putinbuffer(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,unsigned32 value,FILE *ofp)
{
 if (((*pboff) + sizeof(unsigned32)) > BUFFERSIZE)
  {
   /* Flush the code buffer */
   if (ofp != NULL)
    write_data(buffer,(int)(*pboff),ofp) ;
   (*pboff) = 0 ;
  }

 PWRITE(0,(unsigned32 *)(buffer + *pboff),value) ;
 (*pboff) += sizeof(unsigned32) ;
 (*pcodepos)++ ;
 return ;
}

/*}}}*/
/*{{{  cf_load */

static void *cf_load(s_aof *oep,char *name)
{
 int   cidx = cf_index(oep->cfhdr,name) ;
 void *buffer = NULL ;

 if (cidx == -1)
  error( "Chunk \"%s\" not found in \"%s\"",name,oep->fname) ;
 else
  {
   int32 csize = cf_entrysize(oep->cfhdr,cidx) ;

   if (csize < 0)
    error( "Unable to read the size of Chunk \"%s\" (index %d) in \"%s\"",name,cidx,oep->fname) ;
   else
    {
     if (csize > 0)
      {
       if (cf_seek(oep->cf,cidx) != 0)
        error("Failed to seek to the start of Chunk %d in \"%s\"",cidx,oep->fname) ;
       else
        if ((buffer = (void *)malloc((int)csize)) == NULL)
         error("Failed to allocate 0x%08X bytes for Chunk %d in \"%s\"",csize,cidx,oep->fname) ;
        else
         if (cf_loadentry(oep->cf,buffer,csize) != 0)
          {
           error("Failed to load Chunk %d data from \"%s\"",cidx,oep->fname) ;
           free(buffer) ;
           buffer = NULL ;
          }
      }
    }
  }

 return(buffer) ;
}

/*}}}*/
/*{{{  rotatable */

static int rotatable(unsigned32 value,unsigned32 *shift,int inv,unsigned32 *imm)
{
 int loop ;

 for (loop = 0; (loop <= 1); loop++)
  {
   *shift = 0 ;
   do
    {
     if (value < 0x100)
      {
       *imm = value ;
       return(TRUE) ;
      }

     if (*shift >= 0x10)
      break ; /* out of the loop */

     value = (value << 2) + (value >> 30) ;
     (*shift)++ ;
    } while (1) ; /* loop around until shift too large, or value found */

   if (!inv)
    return(0) ;

   value ^= -1 ; /* and try again */
  }

 return(0) ;
}

/*}}}*/
/*{{{  geninst */

static void geninst(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,unsigned32 sval,unsigned32 i1,unsigned32 i2)
{
 unsigned32 shift ;
 unsigned32 imm ;
 int        first = TRUE ;
 unsigned32 inst ;

 while (!rotatable(sval,&shift,0,&imm))
  {
   /* Generate intermediate instructions */
   shift = 0 ;

   if (sval == 0)
    error("FATAL: Value of zero failed rotatable test") ;

   while (((sval >> shift) & 0x3) == 0)
    shift += 2 ;

   inst = ((first ? i1 : i2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
   PWRITE(0,(unsigned32 *)(buffer + *pboff),inst); *pboff += sizeof(unsigned32) ; (*pcodepos)++ ;
   first = 0 ;

   sval = (sval & ~(0xFFL << shift)) ;
  }

 /* last instruction */
 inst = ((first ? i1 : i2) | (shift << 8) | imm) ;
 PWRITE(0,(unsigned32 *)(buffer + *pboff),inst); *pboff += sizeof(unsigned32) ; (*pcodepos)++ ;

 return ;
}

/*}}}*/
/*{{{  add_data_ref */

static void add_data_ref(s_aof *adesc,int32 symindex,unsigned32 offset,unsigned32 areanum,unsigned32 destreg,unsigned32 codepos)
{
 s_dataref *new = (s_dataref *)malloc(sizeof(s_dataref)) ;

 if (new == NULL)
  error("Failed to allocate data reference holder") ;

 trace("add_data_ref: symindex %d, offset 0x%08X, areanum %d, destreg %d, codepos 0x%08X",symindex,offset,areanum,destreg,codepos) ;

 new->symindex = symindex ;
 new->offset   = offset ;
 new->areanum  = areanum ;
 new->destreg  = destreg ;
 new->codepos  = codepos ;

 new->next     = adesc->drefs ;
 adesc->drefs  = new ;

 return ;
}

/*}}}*/
/*{{{  find_string */

/* FIXME : There is a macro FINDSTRING defined that does this job */
static char *findstring(s_aof *adesc,int offset)
{
 return((char *)(adesc->aofstrt + offset)) ;
}

/*}}}*/
/*{{{  checkexception */

static int checkexception(char *symname)
{
 int    matched = 0 ;
 char **cptr ;

 for (cptr = &(symbol_exceptions[0]); (*cptr != NULL); cptr++)
  if (strcmp(*cptr,symname) == 0)
   {
    matched = TRUE ;
    break ;
   }

 return(matched) ;
}

/*}}}*/
/*{{{  findsym */

static aof_symbol *findsym(s_aof *adesc,int *sloop,int aname,int index)
{
 aof_symbol *cptr = NULL ;

 /* This code relies on the fact that there is only one copy of each
  * string in the string table. If a string appears multiple times
  * this code will fail to match the string table offsets.
  */
 for (; (*sloop < READ(adesc->be,adesc->aofhdr->aof_nsyms));)
  {
   cptr = &(adesc->aofsymt[*sloop]) ;
   (*sloop)++ ; /* step the index onto the next symbol */
   if ((aname == READ(adesc->be,cptr->sym_areaname)) && (((int32)index << 2) == READ(adesc->be,cptr->sym_value)))
    break ; /* out of the for loop */
   cptr = NULL ; /* no match at this symbol index */
  }

 return(cptr) ;
}

/*}}}*/
/*{{{  find_exported */

static int32 find_exported(s_aof *adesc,int32 slimit,int32 sval,int32 saname)
{
 int32 symindex = -1 ;
 int   sloop ;

 trace("AREA relative: sval = 0x%08X : saname = 0x%08X \"%s\"",sval,saname,findstring(adesc,(int)saname)) ;

 /* scan the symbol table for an exported symbol that can be used */
 for (sloop = 0; (sloop < slimit); sloop++)
  {
   /* Check for exported symbol with matching definition */
#if 0
   trace("sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",sloop,READ(adesc->be,adesc->aofsymt[sloop].sym_areaname),READ(adesc->be,adesc->aofsymt[sloop].sym_value),(((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;
#endif

   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
    {
     symindex = sloop ;
     break ; /* out of the loop */
    }
  }

 return(symindex) ;
}

/*}}}*/
/*{{{  find_local */

static int32 find_local(s_aof *adesc,int32 slimit,int32 sval,int32 saname)
{
 int32 symindex = -1 ;
 int32 maxfound = 0 ;
 int   sloop ;

 trace("AREA relative: sval = 0x%08X : saname = 0x%08X \"%s\"",sval,saname,findstring(adesc,(int)saname)) ;

 /* scan the symbol table for a local symbol that can be used */
 for (sloop = 0; (sloop < slimit); sloop++)
  {
   /* Check for a local symbol closest to the required value */
   trace("sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",sloop,READ(adesc->be,adesc->aofsymt[sloop].sym_areaname),READ(adesc->be,adesc->aofsymt[sloop].sym_value),(((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;

   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_DEFAT))
    {
     int32 symval = READ(adesc->be,adesc->aofsymt[sloop].sym_value) ;
     /* Symbol is defined within the required area */
     if (symval <= sval) /* check for exact match or below */
      {
       /* Symbol is beneath the required offset */
       if (symval >= maxfound) /* use the last definition that gives exact or closest below */
        {
         maxfound = symval ;
         symindex = sloop ;
        }
      }
    }
  }

 /* The returned "symindex" will be -1 if no local symbol is found.
  * Otherwise it will reference the local symbol "containing" the required offset.
  */
 return(symindex) ;
}

/*}}}*/
/*{{{  referencedata */

static int referencedata(FILE *ofp,unsigned32 *pcodepos,char *firstdata,int tiny,int dolib)
{
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRdata,ofp) ;
   write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
  }
 (*pcodepos)++ ;

 /* We are interested in the base of the data defined by this object
  * when dealing with libraries.
  */
 if (dolib)
  {
   if (firstdata == NULL)
    {
     error("Missing pointer to first DATA directive for this library object") ;
     error("There should always be an exported symbol for the first datum in a library") ;
    }

   trace("referencedata: firstdata = \"%s\"",firstdata) ;

   /* LSB */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
    }
   (*pcodepos)++ ;

   if (!tiny)
    {
     /* MID */
     if (ofp != NULL)
      {
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
      }
     (*pcodepos)++ ;
    }

   /* REST */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
    }
   (*pcodepos)++ ;
  }

 return(FALSE) ;
}

/*}}}*/
/*{{{  referenceexternal */

static void referenceexternal(FILE *ofp,char *symname,int armreg,unsigned32 *pcodepos,int tiny)
{
/* TODO : If the linker made two passes we would know whether external
 * symbols were data or code during the object conversion. This would
 * allow the initialisation code to be optimised for loading the
 * address of code or data. At the moment using the AOF patch
 * directives means that 8bytes are wasted whenever the address of a
 * code symbol is required during the initialisation code.
 */

 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ;
   write_byte(PATCHARMDT,ofp) ;
   write_encoded(LDRfromdp(armreg),ofp) ;
   write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 /* LSB */
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFLSB,ofp) ; write_encoded(armreg,ofp) ;
   write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 if (!tiny) /* shorter access sequence */
  {
   /* MID */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFMID,ofp) ; write_encoded(armreg,ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
    }
   (*pcodepos)++ ;
  }

 /* REST */
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFREST,ofp) ; write_encoded(armreg,ofp) ;
   write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 return ;
}

/*}}}*/
/*{{{  loadcurrentvalue */

static int32 loadcurrentvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff,FILE *ofp)
{
 int32 remainder = 0 ;

/* FIXME : We can perform various optimisations:
 *
 * TODO : At the moment the same base "a1/r0" may get continually
 * reloaded. We should optimise the code so that if the last
 * "loadcurrentvalue" involved the same "a1/r0" setup we do not need
 * to generate the instructions.
 *
 * TODO : If current value is zero (in the initialised data) then
 * we do not need to load, we can just overwrite. In-fact we should be
 * able to optimise the relocation sequences to use the initialised
 * value directly, and add it in if non-zero using immediate
 * instructions, rather than loading through the module table.
 */

 /* Load the current value */
 if (roff < 4096)
  putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0xC) | roff),ofp) ;
 else
  {
   int base = (int)roff ;

   remainder = (roff & (4096 - 1)) ;
   base -= (int)remainder ;

   geninst(buffer,pboff,pcodepos,(unsigned32)base,initADDip,initADDa1) ;
   putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0x0) | remainder),ofp) ;
  }

 return(remainder) ;
}

/*}}}*/
/*{{{  storenewvalue */

static void storenewvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff,int32 remainder,FILE *ofp)
{
 /* write the value back into the module table */
 if (roff < 4096)
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0xC) | roff),ofp) ;
 else
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0x0) | remainder),ofp) ;
 return ;
}

/*}}}*/
/*{{{  CalculateMaxCodeP */

static void
CalculateMaxCodeP(
                  s_aof *       adesc,
                  int32         slimit,
                  int32         nareas)
{
  int loop;

  
  /* maxcodep = number of exported functions */
  
  for (loop = 0; loop < slimit; loop++)
    {
      unsigned32        sattr = READ( adesc->be, adesc->aofsymt[ loop ].sym_AT ) ;
      

      /* We are only interested in global symbols we define */
      
      if ((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
        {
          int32 aname = READ( adesc->be, adesc->aofsymt[ loop ].sym_areaname) ;
          int   aloop ;
          

          for (aloop = 0; (aloop < nareas); aloop++)
            {
             unsigned32 aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
              if ((READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname) && (aattr & AOF_CODEAT)) /* an exported code symbol */
                maxcodep += sizeof (unsigned32) ;
            }
        }
    }
  
  return;
  
} /* CalculateMaxCodeP */

/*}}}*/
/*{{{  CalculateMaxData */

static void
CalculateMaxData(
                 s_aof *        adesc,
                 int32          nareas )
{
  int   loop;
  
  /*
   * maxdata = size of exported data 
   *
  * This will be the total of all the (non-based and non-shared) data areas
  */
 
  for (loop = 0; loop < nareas; loop++)
    {
      unsigned32        attr = READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_attributes) ;

      
      if (!(attr & AOF_CODEAT) &&
          !(attr & AOF_BASEDAT) &&
          !(attr & AOF_SHLDATA))
        {
          maxdata += READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_size ) ;
        }
    }
 
 return;
 
} /* CalculateMaxData */

/*}}}*/
/*{{{  CreateObjectHeader */

static long
CreateObjectHeader(
                   s_aof *      adesc,
                   unsigned32 * buffer,
                   FILE *       ofp )
{ 
  int            tlen;
  int            loop;
  long		 swpos ; /* file offset of Size Word */
  unsigned32 vsn = READ(adesc->be,adesc->aofhdr->aof_vsn) ;
  
  /* Output the object header */
  
  write_byte( OBJMODULE, ofp );
  write_encoded( -1, ofp );     /* MODULE -1 */
  
  /* Output the magic identifier and "code size" value */
  
  swpos = (ftell(ofp) + sizeof(unsigned32) + 2) ; /* the "2" is to cover the CODE directive */
  /* NOTE: This can blow up badly if the module header format is ever changed */
  PWRITE( 0, buffer, T_Module );
  PWRITE( 0, buffer + 1, adesc->codesize );
  
  if ((tlen = strlen( adesc->fname )) > (HOF_title_len - 1))
    {
      loop = (tlen - HOF_title_len - 1) ;
      tlen = (HOF_title_len - 1) ;
    }
  else
    loop = 0 ;
  
  memcpy( (char *)(buffer + 2), (unsigned char *)&(adesc->fname[ loop ]), tlen );
  
  write_data( (unsigned char *)buffer, 2 * sizeof (unsigned32) + tlen, ofp );
  write_padding( HOF_title_len - tlen, ofp ) ;
  write_byte( OBJWORD,   ofp );
  write_byte( OBJMODNUM, ofp );
  
  PWRITE( 0, buffer, vsn);
  PWRITE( 0, (buffer + 1), maxdata );
  
  write_data( (unsigned char *)buffer, 2 * sizeof (unsigned32), ofp );
  
  write_byte( OBJINIT, ofp );

  if (smtopt)
    {
      PWRITE( 0, (unsigned32 *)buffer, maxcodep );
  
      write_data( (unsigned char *)buffer, sizeof (unsigned32), ofp ) ;
    }
  
  return(swpos);
  
} /* CreateObjectHeader */

/*}}}*/
/*{{{  defineDATA */

static void defineDATA(FILE *ofp,unsigned32 size,char *symname)
{
 if (ofp != NULL)
  {
   write_byte(OBJDATA,ofp) ;
   write_encoded((int)size,ofp) ;
   write_byte('_',ofp) ;
   write_string(symname,strlen(symname),ofp) ;
  }
 return ;
}

/*}}}*/
/*{{{  declareDATA */

static void declareDATA(s_aof *adesc,FILE *ofp,char *ldaname,int32 slimit,char **firstdata,int32 asize,int32 anoff)
{
 int         hidx ;
 int         last = (int)asize ; /* last possible data position in this area (for zero-length object) */
 int         sloop ;
 int         scount ;
 unsigned32 *ssize = (unsigned32 *)malloc((int)(slimit * 2) * sizeof(unsigned32)) ;
 unsigned32 *sorder = (ssize + slimit) ;

 if (ssize == NULL)
  error("Failed to allocate memory for symbol table size vector") ;

 /* We provide a unique symbol as the first "DATA" element for each of
  * the AOF data areas.
  */
 if ((strlen(ldaname) + 1 + strlen(UNIQAREA) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
  error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",ldaname,infile_duplicate) ;
 sprintf(tmpbuffer,"%s_%s_%s",ldaname,UNIQAREA,infile_duplicate) ;

 for (sloop = 0; (sloop < slimit); sloop++)
  {
   ssize[sloop] = -1 ; /* initialise the size vector */
   sorder[sloop] = -1 ; /* and the position vector */
  }

 /* Process the symbols within this data area */
 /* NOTE: Since the symbol table is not ordered, but we need to
  * order the DATA directives, we must perform multiple scans
  * over the table. We should really update the code to perform
  * a single pass generating a new ordered symbol table, and
  * then create the DATA directives from it.
  */

 /* This first loop scans for symbols in the desired area, and
  * calculates their lengths (relative to the other symbols).
  */

 scount = 0 ; /* no symbols yet found */
 do
  {
   int32 hval = 0 ; /* highest position seen within this area */

   hidx = -1 ;
   /* scan through the symbol table for un-processed symbols in this area */
   for (sloop = 0; (sloop < slimit); sloop++)
    {
     /* Check that the symbol references this data area */
     if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
      {
       /* If the size of this symbol has not been calculated,
        * and it is further into the file then we want to
        * process it.
        */
       if ((READ(adesc->be,adesc->aofsymt[sloop].sym_value) >= hval) && (ssize[sloop] == -1))
        {
         hidx = sloop ;
         hval = READ(adesc->be,adesc->aofsymt[sloop].sym_value) ;
        }
      }
    } /* symbol table scan loop */

   if (hidx != -1)
    {
     int32 sval  = READ(adesc->be,adesc->aofsymt[hidx].sym_value) ;
     ssize[hidx] = (last - sval) ;
     if ((int)(ssize[hidx]) < 0)
      error("Negative sized object \"%s\" (should never happen)",findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[hidx].sym_name))) ;
     sorder[scount++] = hidx ; /* remember where this symbol lived */
     last = (int)sval ;
    }
  } while (hidx != -1) ;

 /* We may have un-named (i.e. no symbols defined) datums at the start
  * of the area that still need to be catered for in the DATA
  * declarations.
  */
 if (*firstdata == NULL)
  {
   *firstdata = malloc(strlen(tmpbuffer) + 1) ;
   if (*firstdata == NULL)
    error("Failed to allocate string buffer") ;
   strcpy(*firstdata,tmpbuffer) ;
   trace("declareDATA: firstdata = \"%s\"",*firstdata) ;
  }
 trace("declareDATA: data area start symbol = \"%s\"",tmpbuffer) ;
 defineDATA(ofp,last,tmpbuffer) ; /* "last" offset in the area accounted for by a symbol */
 
 /* Deal with the symbols found, outputting them in the correct order */
 for (; (scount > 0); scount--)
  {
   char *symname ;
   unsigned32 sattr ;

   sloop = sorder[scount - 1] ; /* symbol index we are processing */

   if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) != anoff)
    error("Symbol index %d no longer matches areaname offset 0x%08X",sloop,anoff) ;

   if (ssize[sloop] == -1)
    error("Size not known for symbol %d",sloop) ;

   symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
   sattr = READ(adesc->be,adesc->aofsymt[sloop].sym_AT) ;

   /* Generate unique symbol names for local data symbols */ 
   if (((sattr & SYM_REFDEFMASK) != SYM_REFAT) && ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)) /* local symbol */
    {
     if ((strlen(symname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
      error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",symname,infile_duplicate) ;
     sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
     symname = tmpbuffer ;
    }

   trace("declareDATA: symname = \"%s\"",symname) ;
   defineDATA(ofp,ssize[sloop],symname) ;
  }

 /* Release the symbol size vector */
 free(ssize) ;

 return ;
}

/*}}}*/

/* Exported functions */
/*{{{  open_aof */

s_aof *open_aof(char *fname)
{
 s_aof *New ; /* AOF file descriptor */

 New = (s_aof *)malloc(sizeof(s_aof)) ;
 
 if (New != NULL)
  {
   FILE *fdesc ;

   New->fname = fname ; /* filename of object this is a descriptor for */
   New->cf = NULL ; /* no ChunkFile descriptor */
   New->cfhdr = NULL ; /* no ChunkFile header */
   New->aofhdr = NULL ; /* no cached areas */
   New->aofsymt = NULL ; /* no symbol table */
   New->aofstrt = NULL ; /* no string table */
   New->codesize = 0xFFFFFFFF ; /* code size not yet known */
   New->drefs = NULL ; /* no data references yet */

   if ((fdesc = fopen(fname,"r")) == NULL)
    warn("Failed to open object file \"%s\"",fname) ;
   else
    {
     if ((New->cf = (ChunkFile *)malloc(sizeof(ChunkFile))) == NULL)
      error("Unable to allocate 0x%08X bytes for ChunkFile \"%s\" descriptor",sizeof(ChunkFile),fname) ;
     else
      if (cf_open(fdesc,New->cf) == NULL)
       error("Failed to open \"%s\" as a ChunkFile",fname) ;
      else
       {
        int32 hdrsize = cf_headersize(New->cf) ;

        if (hdrsize == 0)
         error("ChunkFile \"%s\" did not open properly",fname) ;
        else
         if ((New->cfhdr = (cf_header *)malloc((int)hdrsize)) == NULL)
          error("Unable to allocate 0x%08X bytes for ChunkFile \"%s\" header",hdrsize,fname) ;
         else
          if (cf_readheader(New->cf,New->cfhdr,hdrsize) == NULL)
           error("Failed to read ChunkFile \"%s\" header (0x%08X bytes)",fname,hdrsize) ;
          else
           {
            New->be = LE ; /* default is little-endian */
            switch (cf_endianness(New->cfhdr->cf_magic))
             {
              case CF_BIG :
               New->be = BE ; /* big-endian file */
               /* and fall through to shared processing */
              case CF_LITTLE :
               /* if entered as CF_LITTLE then New->be has already been initialised */
               {
                if ((New->aofhdr = (aof_header *)cf_load(New,OBJ_HEAD)) == NULL)
                 error("Failed to load AOF header from \"%s\"",fname) ;
                else
                 if (READ(New->be,New->aofhdr->aof_type) != AOF_RELOC)
                  error("Invalid AOF ID 0x%08X in ChunkFile \"%s\"",READ(New->be,New->aofhdr->aof_type),fname) ;
                 else
                  if (READ(New->be,New->aofhdr->aof_vsn) > AOF_VERSION)
                   warn("ChunkFile \"%s\" contains New AOF version %d (<=%d expected)",fname,READ(New->be,New->aofhdr->aof_vsn),AOF_VERSION) ;
               }
               break ;

              default : /* unrecognised magic value */
               error("Unrecognised magic identifier 0x%08X in ChunkFile header",New->cfhdr->cf_magic) ;
             }

            if (New->aofhdr != NULL) /* we have an AOF header */
             {
              /* load the symbol table */
              if ((New->aofsymt = (aof_symbol *)cf_load(New,OBJ_SYMT)) == NULL)
               report("Warning: Symbol table not found (or zero length)") ;
              /* load the string table */
              if ((New->aofstrt = (char *)cf_load(New,OBJ_STRT)) == NULL)
               report("Warning: String table not found (or zero length)") ;
              /* load the code and data areas */
              if ((New->aofareas = (char *)cf_load(New,OBJ_AREA)) == NULL)
               report("Warning: Code/Data Areas not found (or zero length)") ;
             }
           }
       }

     fclose(fdesc) ;
    }
  }

 maxdata  = 0;
 maxcodep = 0;
 
 return(New) ;
}

/*}}}*/
/*{{{  convert_aof */

/* Internal symbol flags (above "real" attributes). These are used to
 * mark information within the symbol table of the original AOF file.
 */
#define LSYM_CODE    (SYM_LINKATTR << 1) /* imported as a code symbol */
#define LSYM_LCODE   (SYM_LINKATTR << 2) /* local code symbol */
#define LSYM_DATAREF (SYM_LINKATTR << 3) /* symbol referenced as data */

unsigned32 convert_aof(s_aof *adesc,char *outfile,int dolib,int tiny,int kernel)
{
 unsigned char *buffer = NULL ; /* temporary conversion buffer */
 FILE          *ofp = NULL ; /* file descriptor for 2nd pass GHOF output */
 unsigned32    *codebase = NULL ; /* vector used to hold GHOF offsets for converted areas */
 int            tlen ;
 int            loop ;
 unsigned32     boff ; /* buffer offset */
 unsigned32     base ;
 unsigned32     limit ;
 int32          slimit = READ(adesc->be,adesc->aofhdr->aof_nsyms) ;
 int32          nareas = READ(adesc->be,adesc->aofhdr->aof_nareas) ;
 unsigned32     codepos = 0 ;
 unsigned32     dataplace = 0 ;
 s_dataref     *dref ;
 char          *firstdata = NULL ;
 unsigned32     initdataamount = 0 ; /* amount of initialised data (not BSS) we have */
 long		    swpos = -1L ;

 if ((buffer = (unsigned char *)malloc(BUFFERSIZE)) == NULL)
  error("Failed to allocate temporary buffer") ;

 if ((tmpbuffer = (char *)malloc(TBUFFSIZE)) == NULL)
  error("Failed to allocate temporary symbol name buffer") ;

 if ((outfile != NULL) && ((ofp = fopen(outfile,"wb")) == NULL))
  error("Failed to open output file \"%s\"",outfile) ;
 /* NOTE: The remaining error cases rely on the host OS closing the
  * opened file during its exit handling.
  */

 if ((codebase = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32))) == NULL)
  error("Failed to allocate memory for code area base addresses") ;

 for (loop = 0; (loop < nareas); loop++)
  codebase[loop] = -1 ; /* initialise the vector */

 /* Release any data references that may be hanging around */
 if (adesc->drefs != NULL)
  {
   s_dataref *cptr = adesc->drefs ;

   for (; (cptr != NULL);)
    {
     s_dataref *This = cptr ;
     cptr = This->next ;
     free(This) ;
    }

   adesc->drefs = NULL ;
  }

 CalculateMaxCodeP(adesc,slimit,nareas) ;
 CalculateMaxData(adesc,nareas) ;
 trace("maxcodep = 0x%08X, maxdata = 0x%08X",maxcodep,maxdata) ;
 
/*{{{  generate GHOF module header */

 if (!dolib && !kernel)
  {
   /* Allow for header at start of object file */
   if (ofp == NULL) /* first pass */
    codepos += (sizeof(Module) / sizeof(unsigned32)) ;
   else
    {
     swpos = CreateObjectHeader(adesc,(unsigned32 *)buffer,ofp) ;
     codepos += (sizeof(Module) / sizeof(unsigned32)) ;
    }
  }

/*}}}*/
/*{{{  process (and output) the code areas */

 /* Process (and output) the code areas */
 boff  = 0 ;
 limit = 0 ;
 
 for (loop = 0; (loop < nareas); loop++)
  {
   unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
   int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
   int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
   int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
   aof_reloc *relocs = NULL ;

   base = limit ;
   limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

   if (attr & AOF_CODEAT)
    {
     if (!(attr & (AOF_32bitAT | AOF_REENTAT)))
      error("Object file Area %d is not APCS-3 re-entrant",loop) ;
     else
      {
       int         iloop ;  /* instruction loop */
       unsigned32  rcount ; /* relocation count */
       unsigned32 *code ;
       aof_reloc  *reloc ;

       codebase[loop] = (codepos << 2) ; /* remember the start of this code area */

       if ((asize % sizeof(unsigned32)) != 0)
        {
         if (ofp != NULL)
          fclose(ofp) ;
         error("Code area is not a word multiple in size") ;
        }

       code = (unsigned32 *)((int)(adesc->aofareas) + base) ;
       if (nrelocs != 0)
        relocs = (aof_reloc *)((int)code + asize) ;
       asize /= sizeof(unsigned32) ;
       rcount = 0 ; reloc = NULL ; /* no active relocations */

       /* Step through the code */
       for (iloop = 0; (iloop < asize); iloop++)
        {
         unsigned32  inst ;
         aof_symbol *symbol ;
         int         snum = 0 ;

         while ((symbol = findsym(adesc,&snum,(int)anoff,iloop)) != NULL)
          {
           char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
           unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

           if (!(sattr & SYM_DATAAT)) /* only output non-data symbols that appear in the code area */
            {
             sattr |= LSYM_LCODE ; WRITE(adesc->be,symbol->sym_AT,sattr) ; /* local function symbol */
             if (ofp == NULL)
              boff = 0 ; /* flush the code buffer */
             else
              {
               write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
               write_byte( OBJLABEL, ofp) ;
               write_byte('.',ofp) ;
               write_string(symname,strlen(symname),ofp) ;
              }
            }
          }

         if ((boff + sizeof(unsigned32)) > BUFFERSIZE)
          {
           if (ofp != NULL)
            write_data(buffer,(int)boff,ofp) ;
           boff = 0 ;
          }

         inst = READ(adesc->be,code[iloop]) ;

         trace( "code[0x%08X] = 0x%08X",(iloop << 2),inst) ;

         if ((rcount > 0) || (nrelocs > 0))
          {
           int        rloop ;
           aof_reloc *newreloc = NULL ;

           for (rloop = 0; (rloop < nrelocs); rloop++)
            if (READ(adesc->be,relocs[rloop].rel_offset) == ((int32)iloop << 2))
             {
              newreloc = &(relocs[rloop]) ;
              break ; /* match against the first only */
             }

           if (rcount > 0)
            {
             if (newreloc != NULL)
              error("Multi-instruction relocation for offset 0x%08X contains another relocation at offset 0x%08X",READ(adesc->be,reloc->rel_offset),(iloop << 2)) ;
             /* we use the previous reloc structure */
            }
           else
            reloc = newreloc ;

           /* "reloc" is non-NULL if this instruction has a relocation field */
           if (reloc != NULL)
            {
             unsigned32 relflags = READ(adesc->be,reloc->rel_flags) ;
             unsigned32 symindex ;
             unsigned32 ft ;
             unsigned32 newcount ;
             int        pcrel ;
             int        area ;
             int        based ;

             symbol = NULL ; /* relocation may be area relative */

             if (rel_type2(relflags))
              {
               symindex = rel2_sid(relflags) ;
               ft = rel2_FT(relflags) ;
               pcrel = (rel2_R(relflags) == REL_PCREL) ;
               area = (rel2_A(relflags) == 0) ;
               based = rel2_B(relflags) ;
               newcount = rel2_ins(relflags) ;
              }
             else
              {
               symindex = rel1_sid(relflags) ;
               ft = rel1_FT(relflags) ;
               pcrel = (rel1_R(relflags) == REL_PCREL) ;
               area = (rel1_A(relflags) == 0) ;
               based = 0 ;
               /* if type1 relocation, then rcount will always be zero at this point */
               newcount = 1 ;
              }

             /* rcount:
              *  0 : the linker may modify as many contiguous
              *      instructions as required
              *  1 : the linker will modify at most 1 instruction
              *  2 : the linker will modify at most 2 instructions
              *  3 : the linker will modify at most 3 instructions
              */
             if (rcount == 0)
              rcount = newcount ;

             if (rcount == 0)
              rcount = 1 ; /* only allow 1 instruction to be modified */

             trace("relocation %d : offset = 0x%08X : symindex = %d : rcount = %d",rloop,READ(adesc->be,reloc->rel_offset),symindex,rcount) ;

             if (!area) /* relocation is symbol relative (otherwise it is AREA relative) */
              symbol = &(adesc->aofsymt[symindex]) ;

             if (ft == 0x3) /* instruction */
              {
               if (pcrel)
                {
                 char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
                 unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

                 trace("PC-relative relocation") ;

                 if (ofp != NULL)
                  write_data(buffer,(int)boff,ofp) ; /* flush existing code */
                 boff = 0 ;

                 if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
                  {
                   /* imported code symbol */
                   sattr |= LSYM_CODE ; /* we will need a stub */
                   WRITE(adesc->be,symbol->sym_AT,sattr) ;
                  }
                 /* else warning "PC-relative instruction to a non-imported symbol" */

                 /* if (based) then it is a possible tailcall */
                 if (ofp != NULL)
                  {
                   write_byte(OBJWORD,ofp) ; /* WORD */
                   if ((inst & 0x0E000000) == 0x0A000000) /* branch instruction */ 
                    {
                     if (rcount != 1)
                      error("Multi-instruction branch relocations not supported") ;
                     write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
                     write_encoded((int)inst,ofp) ;
                    }
                   else
                    {
                     /* Check that the instruction is an ADD or a SUB */
                     if (((inst & 0x0C000000) != 0) || ((((inst >> 21) & 0xF) != 0x2) && (((inst >> 21) & 0xF) != 0x4)))
                      error("PC-relative relocation to instruction which is not a branch, ADD or SUB") ;

                     if (rcount == newcount) /* 1st instruction */
                      {
                       /* Check that the base instruction is indeed PC relative */
                       if (((inst >> 16) & 0xF) != 0xF)
                        error("1st instruction of PC-relative relocation does not have PC as Rn") ;

                       /* TODO: FIXME: We should remember the Rd of
                        * the first instruction, and check that
                        * subsequent instructions use the same for Rn
                        * and Rd.
                        */
                      }

                     /* Always convert instruction to ADD, and let
                      * linker replace with SUB as necessary. */
                     inst = ((inst & ~0x01E00000) | (0x4 << 21)) ;

                     /* The following assumes that rcount is in the
                      * range 1..3. It is coded that it will generate
                      * LSB and REST for two instruction sequences and
                      * LSB, MID and REST for three instruction
                      * sequences. */
                     if (rcount == newcount)
                      write_byte(PATCHARMDPLSB,ofp) ;
                     else
                      if (rcount > 1)
                       write_byte(PATCHARMDPMID,ofp) ;
                      else
                       write_byte(PATCHARMDPREST,ofp) ;
                     write_encoded((int)inst,ofp) ;
                    }
                   write_byte(OBJLABELREF,ofp) ; /* LABELREF */
                   write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ; /* .symbol */
                  }
                 codepos++ ;
                 rcount-- ;
                }
               else
                {
                 if (based)
                  {
                   int32       offset ;
                   int         aloop ;
                   unsigned32 *dbase = (unsigned32 *)(adesc->aofareas) ;

                   if (rcount > 1)
                    error("Multi-instruction sequences not yet supported for Based relocations") ;

                   /* Check that the instruction is "LDR <r>,[dp,#off]" */
                   if (((inst & 0x0C000000) != 0x04000000) && ((inst & (1 << 20)) != (1 << 20)))
                    error("Based relocation with non-LDR (0x%08X)",inst) ;
                   if (((inst >> 16) & 0xF) != 9)
                    error("Based relocation (LDR) not using r9 (0x%08X)",inst) ;
                   if ((inst & (1 << 25)) != 0)
                    error("Based relocation has non-immediate offset (0x%08X)",inst) ;

                   offset = ((inst & (1 << 23)) ? (inst & 0xFFF) : -(inst & 0xFFF)) ;

                   if (offset < 0)
                    error("Negative offsets are not supported for based loads (%d)",offset) ;

                   trace("Based relocation: offset %d (0x%08X)",offset,offset) ;

                   for (aloop = 0; (aloop < nareas); aloop++)
                    {
                     unsigned32 aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
                     int32 nrels = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_nrelocs) ;
                     
                     /* If AREA relative then we only need to match the area index */
                     if ((symbol == NULL) ? (aloop == symindex) : (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == READ(adesc->be,symbol->sym_areaname)))
                      {
                       aof_reloc  *relocs = (aof_reloc *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size)) ;

                       /* Check area is based using r9 */
                       if (aattr & AOF_BASEDAT)
                        {
                         int rloop ;

                         if (((aattr & AOF_BASEMASK) >> AOF_BASESHIFT) != 9)
                          error("Area is based on r%d, should be r9",((aattr & AOF_BASEMASK) >> AOF_BASESHIFT)) ;

                         /* Step through the relocations looking for matches */
                         for (rloop = 0; (rloop < nrels); rloop++)
                          {
                           /* Match against a relocation for the referenced offset */
                           if (READ(adesc->be,relocs[rloop].rel_offset) == offset)
                            {
                             aof_reloc  *reloc = &(relocs[rloop]) ; /* shorthand */
                             unsigned32  relflags ;
                             int32       symindex ;
                             char       *symname ;
                             unsigned32  sattr ;
                             int         arearel = 0 ;
                             int         areanum = -1 ;
                             unsigned32  lval ;

                             /* Load the base offset held in the indirection area */
                             lval = READ(adesc->be,((int *)dbase)[offset >> 2]) ;
                             trace(" Base offset (held in indirection area) = %d (0x%08X)",lval,lval) ;

                             relflags = READ(adesc->be,reloc->rel_flags) ;

                             if (rel_type2(relflags))
                              {
                               symindex = rel2_sid(relflags) ;
                               arearel = (rel2_A(relflags) == 0) ;
                              }
                             else
                              {
                               symindex = rel1_sid(relflags) ;
                               arearel = (rel1_A(relflags) == 0) ;
                              }

                             if (arearel)
                              {
                               unsigned32 areaname ;
                               areanum = symindex ;
                               areaname = READ(adesc->be,adesc->aofhdr->aof_areas[areanum].area_name) ;
                               if ((symindex = find_exported(adesc,slimit,lval,areaname)) == -1)
                                {
                                 if ((symindex = find_local(adesc,slimit,lval,areaname)) == -1)
                                  {
                                   unsigned32 rattr = READ(adesc->be,adesc->aofhdr->aof_areas[areanum].area_attributes) ; /* referenced area attributes */
                                   /* We do not have a global
                                    * (exported) or local symbol that
                                    * references this relocation
                                    * directly.
                                    */
#if 1 /* 940324 : temporary fix */
                                   symname = findstring(adesc,areaname) ;
                                   trace("Relocation into area \"%s\" offset 0x%08X : symbol = \"%s\"",findstring(adesc,areaname),lval,symname) ;
#else
                                   if (rattr & AOF_CODEAT) /* Relocation into code area */
                                    {
                                     trace("Relocation into code area %s offset 0x%08X\n",findstring(adesc,areaname),lval) ;
                                     symname = findstring(adesc,areaname) ;
                                     /* "lval" is the offset into the area */
                                    }
                                   else
                                    {
                                     error("No local data area symbol for relocation : area %s offset 0x%08X : rattr = 0x%08X",findstring(adesc,areaname),lval,rattr) ;
                                    }
#endif
                                  }
                                 else
                                  {
                                   /* We have a local symbol, but we
                                    * may not be referencing the start of it.
                                    */
                                   lval = (lval - READ(adesc->be,adesc->aofsymt[symindex].sym_value)) ; /* get offset from start of local symbol */
                                  }
                                }
                               else
                                lval = 0 ; /* we now have an exported symbol */
                              }
                             else
                              {
                               sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                               /* Check if an exported symbol exists for the same offset and area */
                               if ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)
                                {
                                 int32 newsi = find_exported(adesc,slimit,READ(adesc->be,adesc->aofsymt[symindex].sym_value),READ(adesc->be,adesc->aofsymt[symindex].sym_areaname)) ;
                                 /* If we cannot find a suitable
                                  * exported symbol, we make do with
                                  * the internal one.
                                  */
                                 if (newsi != -1)
                                  symindex = newsi ;
                                }

                               if (symindex == -1)
                                error("Exported symbol not found for relocation: instruction %d, offset 0x%08X, relflags 0x%08X",iloop,offset,relflags) ;
                              }

                             if (symindex != -1)
                              {
                               /* Mark the symbol as one requiring a data reference */
                               sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                               symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[symindex].sym_name)) ;
                               sattr |= LSYM_DATAREF ; WRITE(adesc->be,adesc->aofsymt[symindex].sym_AT,sattr) ; /* update symbol information */
                              }

                             if (ofp != NULL)
                              write_data(buffer,(int)boff,ofp) ;
                             boff = 0 ; /* flush existing code */

                             /* The branch uses the condition code of the original instruction */
                             if (ofp != NULL)
                              {
                               write_byte(OBJWORD,ofp) ;
                               write_byte(PATCHARMJP,ofp) ;
                               write_encoded( (int) BranchCC(0,0,(inst >> 28)),ofp) ;
                               write_byte(OBJLABELREF,ofp) ;
                               write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ;
                               write_number((unsigned int)((inst >> 12) & 0xF),ofp) ;
                               write_byte('_',ofp) ; write_text(symname,strlen(symname),ofp) ; write_byte('_',ofp) ;
                               codepos++ ;
                               write_number((unsigned int)(codepos << 2),ofp) ;
			       
                               if (dolib || kernel)
                                {
                                 /* XXX - NC - 20/1/94
                                  * If building for library/kernel there is a possibility that
                                  * this label will clash with one in a different file.  Hence
                                  * we must make it unique.
                                  */
                                 write_byte('_',ofp);
                                 write_text(outfile,strlen(outfile),ofp);
                                }
                               write_byte('\0',ofp) ;
                              }
                             else
                              codepos++ ;

                             add_data_ref(adesc,symindex,lval,areanum,((inst >> 12) & 0xF),(codepos << 2)) ;
                             break ; /* out of the relocation loop */
                            }
                          }

                         if (rloop == nrels)
                          error("Failed to find relocation for offset %d",offset) ;
                        }
                       else
                        error("Referenced area is not based") ;
                       
                       break ; /* since we have finished processing the referenced area */
                      }

                     /* Zero-initialised data (BSS) areas do not have
                      * any associated data. This code also assumes
                      * that they do not have any relocation
                      * directives either.
                      */
                     if (!(aattr & AOF_0INITAT))
                      dbase = (unsigned32 *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size) + (nrels * sizeof(aof_reloc))) ;
                     else
                      if (nrels > 0)
                       error("Zero-initialised data (BSS) with relocation directives");
                    }
                   rcount-- ;
                  }
                 else
                  error("Relocation: displaced : %d : 0x%08X : flags 0x%08X (not yet handled)",iloop,inst,relflags) ;
                }
              }
             else
              {
               error("No code to deal with byte, short or long relocations yet") ;
               error("Have you compiled the file with \"-li -apcs 3/reentrant\"?") ;
              }
            }
           else /* output the instruction (always little-endian) */
            putinbuffer(buffer,&boff,&codepos,inst,ofp) ;
          }
         else /* output the instruction (always little-endian) */
          putinbuffer(buffer,&boff,&codepos,inst,ofp) ;
        }
      }
    }
  }

 trace( "code areas processed" );

/*}}}*/
/*{{{  generate stubs to call external functions */

 if (!dolib && !kernel)
  {
   /* For all imported code symbols we generate stubs to indirect to the destination code */
   for (loop = 0; (loop < slimit); loop++)
    {
     if (READ(adesc->be,adesc->aofsymt[loop].sym_AT) & LSYM_CODE)
      {
       char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
       int   doex = checkexception(symname) ;

       if (ofp == NULL)
        boff = 0 ; /* flush the code buffer */
       else
        {
         write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
         write_byte(OBJLABEL,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       
       if (doex)
        putinbuffer(buffer,&boff,&codepos,stubPush,ofp) ;
 
       if (ofp != NULL)
        write_data(buffer,(int)boff,ofp) ;
       boff = 0 ; /* flush the code buffer */

       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded(LDRfromdp(12),ofp) ;
         write_byte(OBJDATAMODULE,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded(LDRfromoffset(12),ofp) ;
         write_byte(OBJCODESYMB,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (doex)
        {
         putinbuffer(buffer,&boff,&codepos,stubStore,ofp) ;
         putinbuffer(buffer,&boff,&codepos,stubPop,ofp) ;
        }
       else
        putinbuffer(buffer,&boff,&codepos,stubCall,ofp) ;
      }
    }
  }

/*}}}*/
/*{{{  generate stubs to reference external data */

 trace("Processing external data references") ;
 /* for all external data references */
 for (dref = adesc->drefs; (dref != NULL); dref = dref->next)
  {
   char       *symname ;
   unsigned32  sattr = 0 ;
   int32       aname ;
   int         aloop ;
   int         localarea = FALSE ;
   int         localcode = FALSE ;
   int         forceind = FALSE ;
   unsigned32  symbase = 0 ;

   if (dref->symindex == -1) /* area base reference */
    {
     unsigned32 laattr = READ(adesc->be,adesc->aofhdr->aof_areas[dref->areanum].area_attributes) ;

     /* We are relative to an internal area */
     aname = READ(adesc->be,adesc->aofhdr->aof_areas[dref->areanum].area_name) ;
     symname = findstring(adesc,(int)aname) ;
     if (laattr & AOF_CODEAT)
      {
#if 1
       /* We were adding the codebase value in twice. Since we know
        * that the "dref->offset" is from the start of the area,
        * codebase[dref->areanum] gives the base of that area. We do
        * not need to hold a "symbase" value.
        */
       if (codebase[dref->areanum] == -1)
        error("Invalid base for code area %s reference 0x%08X",symname,dref->offset) ;
       symbase = 0 ;
#else
       symbase = codebase[dref->areanum] ;
       if (symbase == -1)
        error("Invalid base for code area %s reference 0x%08X",symname,dref->offset) ;
#endif
      }
     else
      {
       /* Fake up some local data symbol attributes */
       localarea = TRUE ;
       sattr = (SYM_LOCALDEFAT | SYM_DATAAT) ;
       trace("Reference to local data area %s offset 0x%08X",symname,dref->offset) ;
      }
    }
   else /* symbolic reference */
    {
     symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[dref->symindex].sym_name)) ;
     sattr = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_AT) ;
     aname = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_areaname) ;
     symbase = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_value) ;
    }

   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJLABEL,ofp) ;
     write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ;
     write_number((unsigned int)(dref->destreg),ofp) ;
     write_byte('_',ofp) ;
     write_text(symname,strlen(symname),ofp) ;
     write_byte('_',ofp) ;
     write_number((unsigned int)(dref->codepos),ofp) ;
     
     if (dolib || kernel)
      {
       /* XXX - NC - 20/1/94
        * If building for library/kernel there is a possibility that
        * this label will clash with one in a different file.  Hence
        * we must make it unique.
        */
       write_byte('_',ofp);
       write_text(outfile,strlen(outfile),ofp);
      }
     
     write_byte('\0',ofp) ;
    }

   /* See if we can match the symbol area name against the areas in this object */
   for (aloop = 0; (aloop < nareas); aloop++)
    if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
     break ;

   /* The codebase value will only have been initialised for local
    * code areas. This saves having to check the attributes of the
    * areas as we scan through.
    */
   if ((aloop != nareas) && (codebase[aloop] != -1))
    {
#if 1
     if ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT) /* not exported via the module table */
      localcode = TRUE ;
     else
      {
       /* We could set "localcode" to be TRUE for all internal code
        * symbols. This would provide optimisations for referencing
        * code addresses. However, this would result in the internal
        * code not using the module table, and always referencing the
        * local version of the code (and possibly doing the wrong
        * thing if the module table pointer has been patched). If the
        * address is available in the module table then we ALWAYS
        * indirect.
        */
       forceind = TRUE ;
      }
#else
     /* Generate direct PC relative instructions for ALL references to
      * local code addresses. NOTE: This may cause problems if the
      * address/symbol is exported via the module table, and the
      * module table pointer is updated.
      */
     localcode = TRUE ;
#endif
    }

   if (localcode)
    {
     unsigned32 sval ;

     /* This is an optimisation. When the address of a local code
      * symbol is required, we generate the value directly using SUB
      * instructions from the pc. This saves using LABELREF
      * linker directives. */
     sval = (((codepos << 2) + 0x8) - (codebase[aloop] + symbase + dref->offset)) ;
     geninst(buffer,&boff,&codepos,sval,initSUBr(dref->destreg),initSUBr2(dref->destreg)) ;
    }
   else /* code cannot be accessed directly, we must use the symbol */
    {
     if (forceind || (sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
      {
       if (!forceind && (sattr & LSYM_LCODE)) /* local code symbol */
        {
         trace("local code symbol") ;
         /* LSB */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDPLSB,ofp) ;
           write_encoded((int)addrADDpc(dref->destreg),ofp) ;
           write_byte(OBJLABELREF,ofp) ;
           write_byte('.',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;

         if (!tiny) /* shorter access sequence */
          {
           /* MID */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPMID,ofp) ;
             write_encoded((int)addrADD(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }

         /* REST */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDPREST,ofp) ;
           write_encoded((int)addrADD(dref->destreg),ofp) ;
           write_byte(OBJLABELREF,ofp) ;
           write_byte('.',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;
        }
       else /* since we have another conditional above, we know that it is a code symbol */
        {
         /* We ignore "forceind" when building libraries or device drivers */
         if (dolib || kernel) /* (or device driver) treat as a local code access */
          {
           /* LSB */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPLSB,ofp) ;
             write_encoded((int)addrADDpc(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;

           if (!tiny) /* shorter access sequence */
            {
             /* MID */
             if (ofp != NULL)
              {
               write_byte(OBJWORD,ofp) ;
               write_byte(PATCHARMDPMID,ofp) ;
               write_encoded((int)addrADD(dref->destreg),ofp) ;
               write_byte(OBJLABELREF,ofp) ;
               write_byte('.',ofp) ;
               write_string(symname,strlen(symname),ofp) ;
              }
             codepos++ ;
            }

           /* REST */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPREST,ofp) ;
             write_encoded((int)addrADD(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }
         else /* indirect via the module table */
          {
           /* get address of code symbol (being treated as data) */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDT,ofp) ;
             write_encoded(LDRfromdp(dref->destreg),ofp) ;
             write_byte(OBJDATAMODULE,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;

           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDT,ofp) ;
             write_encoded(LDRfromoffset(dref->destreg),ofp) ;
             write_byte(OBJCODESYMB,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }
        }
      }
     else /* treat as access to a data symbol */
      {
       trace("treating as access to data symbol") ;
       if (((sattr & SYM_REFDEFMASK) != SYM_REFAT) && ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)) /* local symbol */
        {
         if ((strlen(symname) + 1 + strlen(UNIQAREA) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
          error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",symname,infile_duplicate) ;
         if (localarea)
          sprintf(tmpbuffer,"%s_%s_%s",symname,UNIQAREA,infile_duplicate) ;
         else
          sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
         symname = tmpbuffer ;
        }
       
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded((int)LDRfromdp(dref->destreg),ofp) ;

         if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
          {
           write_byte(OBJDATAMODULE,ofp) ;
           write_byte('_',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         else
          {
           write_byte(PATCHSHIFT,ofp) ;
           write_byte(0x3,ofp) ;
           write_byte(OBJMODNUM,ofp) ;
          }
        }
       codepos++ ;
  
       /* LSB */
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (!tiny) /* shorter access sequence */
        {
         /* MID */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
           write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;
        }

       /* REST */
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;
      }

     if (dref->offset != 0)
      geninst(buffer,&boff,&codepos,dref->offset,initADDr(dref->destreg),initADDr(dref->destreg)) ;
    }

   putinbuffer(buffer,&boff,&codepos,Branch(dref->codepos,(codepos << 2)),ofp) ;

 }

/*}}}*/
 
 if (ofp != NULL)
  write_data(buffer,(int)boff,ofp) ;
 boff = 0 ; /* flush the code buffer */

/*{{{  generate initialisation code */

 /* Kernel objects do not contain any initialisation code or module table declarations */
 if (!kernel)
  {
   unsigned32 *datapos = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32)) ;

   if (datapos == NULL)
    error("Failed to allocate memory for data area position vector") ;

   /* Initialise the vector with a suitable constant */
   for (loop = 0; (loop < nareas); loop++)
    datapos[loop] = (unsigned32)-1 ;
   
   trace("adding initialisation code");

   /* mark the start of the initialisation code */
   if (ofp != NULL)
    write_byte(OBJINIT,ofp) ;
   codepos++ ; /* INIT */

/*{{{  output CODETABLE directives */

   /* provide CODETABLE definitions for each exported function */
   if (!dolib) /* only when constructing normal objects */
    {
     for (loop = 0; (loop < slimit); loop++)
      {
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;

       /* The CODETABLE directives need to be provided in the same order
        * as the initialisation code below.
        */
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
        {
         char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         if (ofp != NULL)
          {
           write_byte(OBJCODETABLE,ofp) ;
           write_byte(CodePrefix_(),ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
        }
      }
    }

/*}}}*/
/*{{{  output DATA directives */

   /* provide DATA directives for every exported or referenced data symbol */
   /* first for initialised data */
   for (loop = 0; (loop < nareas); loop++)
    {
     unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;

     if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA) && !(attr & AOF_0INITAT))
      {
       int32  asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32  anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
       char  *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;

       declareDATA(adesc,ofp,ldaname,slimit,&firstdata,asize,anoff) ;
      }
    }

   /* and then for zero-initialised data (BSS) */
   for (loop = 0; (loop < nareas); loop++)
    {
     unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;

     if (attr & AOF_0INITAT)
      {
       int32  asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32  anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
       char  *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;

       declareDATA(adesc,ofp,ldaname,slimit,&firstdata,asize,anoff) ;
      }
    }

/*}}}*/

   /* provide the initialisation code */
   putinbuffer(buffer,&boff,&codepos,initCMP,ofp) ;
   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
/* TODO: If there is no function or data initialisation to be done,
 * then we can simply return from this code (saving a couple of
 * instructions).
 */
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJWORD,ofp) ; /* WORD */
     write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
     write_encoded(BranchCC(0,0,ccNE),ofp) ; /* BNE 0x???????? */
     write_byte(OBJLABELREF,ofp) ; /* LABELREF */
     if (dolib)
      {
       write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
       write_byte('_',ofp);
       write_string(outfile,strlen(outfile),ofp);
      }
     else
      write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
    }
   codepos++ ;

/*{{{  output function pointer (codetable) initialisation code */

   /* Function initialisation */
   if (!dolib) /* library objects have no function initialisation code */
    {
     if (ofp != NULL)
      {
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRfn,ofp) ;
       write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
      }
     codepos++ ;

     for (loop = 0; (loop < slimit); loop++)
      {
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
        {
         unsigned32 sval = READ(adesc->be,adesc->aofsymt[loop].sym_value) ;
         int32      aname ;
         int        aloop ;
         int        anum ;

         /* By this point we have dumped the code areas, so it is always a
          * negative offset to the required symbol.
          */
         if ((aname = READ(adesc->be,adesc->aofsymt[loop].sym_areaname)) == 0)
          error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
         for (aloop = 0; (aloop < nareas); aloop++)
          if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
           {
            anum = aloop ;
            break ;
           }
         if (anum == nareas)
          error("Area for referenced symbol offset 0x%08X not found",sval) ;
         if (codebase[anum] == -1)
          error("Address of area containing symbol offset 0x%08X not known",sval) ;
         sval = (((codepos << 2) + 0x8) - (sval + codebase[anum])) ;
         geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ;
         putinbuffer(buffer,&boff,&codepos,initSTRfn,ofp) ;
        }
      }
    }
   /* finish the function initialisation code */
   putinbuffer(buffer,&boff,&codepos,returnCall,ofp) ;

/*}}}*/
/*{{{  output initialised data */

/* TODO:
 * At the moment the storing of all the initialised data in a single
 * vector, and performing a copy is not always efficient. Sometimes it is
 * more efficient not to bother keeping a binary copy of the data, but to
 * generate explicit instructions for the non-zero values (Assuming that
 * the module table has been pre-zeroed).
 *
 * We could just keep a pool of non-zero values that cannot be
 * generated in a single ARM instruction. We can then build a conversion
 * structure that keeps a list of the original data area offset and the
 * new pool offset, or data value. We can then load the literals from the
 * pool or construct immediate load instructions.
 *
 * For continuous runs of data (where the addresses are consecutive) we can
 * generate loops to initialise the module table. Note: It will be worth
 * keeping small numbers of zeroes in such data blocks to make the
 * initialisation code shorter (and possibly quicker). The pool information
 * we construct can keep length information aswell for non-immediate loads.
 *
 * We can then be super efficient and roll the relocations into the actual
 * initialisation code. For immediate loads and single word copies we can
 * merge any offsets together.
 */

   {
    unsigned32 amount = 0 ; /* number of bytes placed into the module table data */
    int        pass ;

    if (ofp != NULL)
     write_data(buffer,(int)boff,ofp) ;
    boff = 0 ; /* flush the code buffer */
 
    dataplace = (codepos << 2) ; /* where the data is being written within the object file */

#ifndef ZERODATA
/* TODO: Since we know that the module table data area has already
 * been zeroed, we do not need to place zeroes into the initialised data
 * area.
 *
 * A simple optimisation (that has the minimum effect on the rest of
 * convertor) would be to check for a large block of zeroes at the start
 * or the end of a data area. We could then avoid writing the zeroes
 * into the image, and copying them in the data initialisation loop.
 */
#endif /* NOT ZERODATA */

    for (pass = 1; (pass < 3); pass++)
     {
      /* The first pass outputs the initialised data, and the second
       * pass ensures that the BSS space after that is accounted for.
       */
      limit = 0 ;
      for (loop = 0; (loop < nareas); loop++)
       {
        unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
        int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
        int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;

        switch (pass)
         {
          case 1 : /* initialised data */
           if (!(attr & AOF_0INITAT))
            {
             base = limit ;
             limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
      
             if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
              {
               unsigned char *data = (unsigned char *)((int)(adesc->aofareas) + base) ;
               if (ofp != NULL)
                write_data(data,(int)asize,ofp) ;
               codepos += (asize >> 2) ;
               datapos[loop] = amount ; /* where this area is within the module table data */
               amount += asize ;
              }
            }
           break ;
           
          case 2 : /* Zero-initialised data (BSS) */
           if (attr & AOF_0INITAT)
            {
             /* BSS (zero-initialised data) does not have any associated data */
             if (nrelocs > 0)
              error("Zero-initialised data (BSS) with relocation directives");
             datapos[loop] = amount ; /* where this area is within the module table data */
             amount += asize ; /* to keep the maxdata checks in step */
            }
           else
            {
             /* ensure we step over the areas containing information */
             base = limit ;
             limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
            }
           break ;

          default :
           error("Internal control error (pass = %d)",pass) ;   
         } /* switch */
       } /* areas */

      if (pass == 1) /* keep track of the amount of initialised data */
       initdataamount = amount ;
     } /* pass */

    if (amount != maxdata)
     error("Amount of data processed (0x%08X) does not match MaxData (0x%08X)",(int)amount,(int)maxdata) ;

    if ((amount % sizeof(int)) != 0)
     error("Amount of data written is NOT a word multiple") ; /* we will need to pad with NULs */
   }

/*}}}*/
/*{{{  output data initialisation code */

trace("generating data initialisation code") ;
   /* Data initialisation code */
   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJLABEL,ofp) ;
     if (dolib)
      {
       write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
       write_byte('_',ofp);
       write_string(outfile,strlen(outfile),ofp);
      }
     else
      write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
    }

   /* This is a fix to get around the problem of external
    * initialisation routines being called within the header code of
    * modules. Since the INIT chain is processed sequentially, the
    * external functions would be called before the initialisation
    * code for individual modules had occured. This results in the
    * module init. code overwriting values set/modified by the
    * external init. functions.
    */
   putinbuffer(buffer,&boff,&codepos,initCMP1,ofp) ;
   putinbuffer(buffer,&boff,&codepos,initReturn1,ofp) ;
   if (ofp != NULL)
    write_data(buffer,(int)boff,ofp) ;
   boff = 0 ; /* flush the code buffer */

   if (initdataamount != 0) /* data initialisation required */
    {
     int        looppos ;
     unsigned32 sval = dataplace ;
     int        first = TRUE ;

     (void)referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

     /* code to initialise the data vector */
     /* Copy "initdataamount" bytes from above into the module table */ 
     /* load "a2" with the address of the initialised data */
     sval = (((codepos << 2) + 0x8) - sval) ;
     geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ;

     /* load "a3" with the amount of data to be copied */
     if (initdataamount > 4)
      geninst(buffer,&boff,&codepos,initdataamount,initMOV,initADD) ;

     /* and then provide the copy loop instructions */
     looppos = ((int)codepos << 2) ; /* current code position */
     putinbuffer(buffer,&boff,&codepos,initLDRcopy,ofp) ;
     putinbuffer(buffer,&boff,&codepos,initSTRdata,ofp) ;
     if (initdataamount > 4)
      {
       putinbuffer(buffer,&boff,&codepos,initSUBS,ofp) ;
       putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE),ofp) ;
      }

#ifdef ZERODATA
     /* provide code to zero the BSS area */
     if (initdataamount < maxdata)
      {
       unsigned32 bsscount = (maxdata - initdataamount) ;

       if ((bsscount % sizeof(int)) != 0)
        error("Size of zero-initialised data (BSS) is not a word multiple") ;
       
       if (bsscount > 4)
        geninst(buffer,&boff,&codepos,bsscount,initMOV,initADD) ;
       putinbuffer(buffer,&boff,&codepos,zeroMOVa4,ofp) ;
       /* and then provide the zero loop instructions */
       looppos = ((int)codepos << 2) ; /* current code position */
       putinbuffer(buffer,&boff,&codepos,initSTRdata,ofp) ;
       if (bsscount > 4)
        {
         putinbuffer(buffer,&boff,&codepos,initSUBS,ofp) ;
         putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE),ofp) ;
        }
      }
#endif /* ZERODATA */

trace("checking for out-standing relocations") ;

     /* Check for out-standing initialised data relocations */
     if (ofp != NULL)
      write_data(buffer,(int)boff,ofp) ;
     boff = 0 ; /* flush the code buffer */
     limit = 0 ; /* upper-limit of module table data */
     first = TRUE ; /* to ensure only a single "ip" copy is re-loaded */
     for (loop = 0; (loop < nareas); loop++)
      {
       unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
       int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
       int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;

       /* Apply relocations to the module table data area we have just initialised */
       if (!(attr & AOF_0INITAT))
        {
         base = limit ;
         limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

         if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
          {
trace("data area %d: nrelocs %d",loop,nrelocs) ;
           if (nrelocs != 0)
            {
             aof_reloc *relocs = (aof_reloc *)((int)((int)(adesc->aofareas) + base) + asize) ;
             int        rloop ;

             /* Add instructions to apply the required relocation to the newly copied data */
             for (rloop = 0; (rloop < nrelocs); rloop++)
              {
               int32       roff = READ(adesc->be,relocs[rloop].rel_offset) ;
               unsigned32  rflags = READ(adesc->be,relocs[rloop].rel_flags) ;
               unsigned32  symindex ;
               unsigned32  ft ;
               int         pcrel ;
               int         area ;
               int         based ;
               aof_symbol *symbol = NULL ;
               char       *symname ;
               int32       symaname ;
               int         localdataarea = -1 ;
               unsigned32  sval ;
               
trace("datainit: reloc %d : rflags 0x%08X : roff 0x%08X",rloop,rflags,roff) ;

               if (rel_type2(rflags))
                {
                 symindex = rel2_sid(rflags) ;
                 ft = rel2_FT(rflags) ;
                 pcrel = (rel2_R(rflags) == REL_PCREL) ;
                 area = (rel2_A(rflags) == 0) ;
                 based = rel2_B(rflags) ;
                }
               else
                {
                 symindex = rel1_sid(rflags) ;
                 ft = rel1_FT(rflags) ;
                 pcrel = (rel1_R(rflags) == REL_PCREL) ;
                 area = (rel1_A(rflags) == 0) ;
                 based = 0 ;
                }

               if (ft == 0x3) /* instruction */
                error("Instruction relocation type on data area") ;

               if (pcrel)
                error("PC-relative relocation type on data area") ;

               if (based)
                error("Based relocation type on data area") ;

               /* Convert "ft" into the number of bytes to be dealt with */
               ft = ((ft == 0) ? 1 : (ft << 1)) ;
               if ((ft == 1) || (ft == 2))
                error("Byte and short AOF relocations are not supported at the moment") ;

               if (area) /* relocation relative to data area start */
                {
                 unsigned32 rattr = READ(adesc->be,adesc->aofhdr->aof_areas[symindex].area_attributes) ;

trace("relocation relative to data area start") ;

                 if (rattr & AOF_CODEAT)
                  {
                   error("Code needed to deal with area based relocation into code area %d",symindex) ;
                  }
                 else /* referencing data area */
                  {
                   localdataarea = symindex ; /* area being referenced */
                   sval = datapos[localdataarea] ;
                   /* The contents are currently loaded and added in below */
                  }
                 symindex = -1 ; /* stop following code treating as symbol access */
                }

               if (symindex != -1) /* relative to a symbol */
                {
trace("relocation relative to symbol %d",symindex) ;
                 symbol = &(adesc->aofsymt[symindex]) ;
                 symname = findstring(adesc,(int)READ(adesc->be,symbol->sym_name)) ;
                 symaname = READ(adesc->be,symbol->sym_areaname) ;
                }

               /* "datapos[loop]" is the offset of the base of this data area within the module table chunk */
               if ((localdataarea == -1) && (symaname == anoff))
                {
trace("relocation relative to local data area") ;
                 localdataarea = loop ; /* within this area */
                 sval = READ(adesc->be,symbol->sym_value) ; /* offset of symbol being used to relocate this data area field */
                 sval += datapos[loop] ; /* referenced offset within this data area within module table */
                }
               else
                {
                 if (symindex != -1)
                  {
                   if ((READ(adesc->be,symbol->sym_AT) & SYM_REFDEFMASK) == SYM_REFAT)
                    {
                     int32 remainder ;

                     if (first)
                      first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

                     roff += datapos[loop] ; /* offset within module table to be relocated */
                     remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;

                     if (ofp != NULL)
                      write_data(buffer,(int)boff,ofp) ;
                     boff = 0 ; /* flush the code buffer */

                     /* load the required data or code pointer */
                     referenceexternal(ofp,symname,0x1,&codepos,tiny) ;

                     putinbuffer(buffer,&boff,&codepos,initADDcode,ofp) ; /* add current value into address */
                     storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                    }
                   else /* internal symbol */
                    {
                     int iloop ; /* internal area loop */
                     unsigned32 localattr ;

                     for (iloop = 0; (iloop < nareas); iloop++)
                      if (symaname == READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name))
                       break ; /* out of the for loop */

                     if (iloop == nareas)
                      error("Local area not found for symbol \"%s\"",symname) ;

                     localattr = READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_attributes) ;
                     if (!(localattr & AOF_CODEAT) && !(localattr & AOF_BASEDAT) && !(localattr & AOF_SHLDATA))
                      {
                       localdataarea = iloop ; /* symbol references a local data area */
                       sval = READ(adesc->be,symbol->sym_value) ; /* offset of symbol being used to relocate this data area field */
                       sval += datapos[loop] ; /* referenced offset within this data area within module table */
                      }
                     else /* must be a local code symbol */
                      {
                       int32 remainder ;

                       sval = READ(adesc->be,symbol->sym_value) ;

                       /* We can generate a relocation using a PC-relative
                        * label reference.
                        */
                       for (iloop = 0; (iloop < nareas); iloop++)
                        if (READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name) == symaname)
                         break ;
                       if (iloop == nareas)
                        error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
                       if (codebase[iloop] == -1)
                        error("Address of area containing symbol offset 0x%08X not known",sval) ;

                       roff += datapos[loop] ; /* offset within module table to be relocated */
                       if (first)
                        first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ; /* load the required module table pointer */

                       remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;
                       sval = (((codepos << 2) + 0x8) - (codebase[iloop] + sval)) ;
                       geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ; /* address of symbol in "a2" */
                       putinbuffer(buffer,&boff,&codepos,initADDcode,ofp) ; /* add current value into address */
                       storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                      }
                    }
                  }
                }

trace("sval = %d (0x%08X)",sval,sval) ;

               /* We have already dealt with external symbols and
                * local code symbols by this point.
                */
               if (localdataarea != -1) /* are we referencing a local data area */
                {
                 int32 remainder = 0 ;

trace("referencing local data area %d",localdataarea) ;
trace("datapos[loop] = datapos[%d] = 0x%08X",loop,datapos[loop]) ;

                 roff += datapos[loop] ; /* offset within module table to be relocated */

trace("roff = %d (0x%08X)",roff,roff) ;

#if 1 /* 940331 : add in base of referenced data area to the symbol offset within that data area */
                 sval += datapos[localdataarea] ;
#endif

                 if (first)
                  first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

                 remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;

                 /* Update the value with the required relocation */
                 putinbuffer(buffer,&boff,&codepos,initADDinto,ofp) ;
                 if ((int32)sval > 0)
                  geninst(buffer,&boff,&codepos,(int32)sval,initADDmore,initADDmore) ;

                 /* and write the value back into the module table */
                 storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                }
              } /* relocation loop */
            } /* relocations */
          } /* data area */
        }
       else /* zero-initialised area */
        {
         if (nrelocs > 0)
          error("Zero-initialised data (BSS) with relocation directives");
        }
      } /* area loop */
    }

   putinbuffer(buffer,&boff,&codepos,returnCall,ofp) ;
   if (ofp != NULL)
    write_data(buffer,(int)boff,ofp) ;
   boff = 0 ; /* flush the code buffer */

/*}}}*/
/*{{{  output exported symbols */

   if (!dolib)
    {
     /* declare the symbols we export */
     for (loop = 0; (loop < slimit); loop++)
      {
       if ((READ(adesc->be,adesc->aofsymt[loop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
        {
         char * symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         if (ofp != NULL)
          {
           write_byte(OBJGLOBAL,ofp) ;
           write_byte(CodePrefix_(),ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
        }
      }
    }

/*}}}*/

   free(datapos) ;
  }

/*}}}*/
 
 if (swpos != -1L)
  {
   long endpos ;
   fflush(ofp) ;
   endpos = ftell(ofp) ;
   fseek(ofp,swpos,SEEK_SET) ;
   PWRITE(0,buffer,(codepos << 2)) ;
   write_text((char *)buffer,sizeof(unsigned32),ofp) ; /* since write_data adds a leading CODE directive */
   boff = 0 ;
   fflush(ofp) ;
   fseek(ofp,endpos,SEEK_SET) ;
  }

 if (ofp != NULL)
  fclose(ofp) ;

 if (tmpbuffer != NULL)
  free(tmpbuffer) ; /* release temporary symbol name buffer */
 if (buffer != NULL)
  free(buffer) ; /* release the temporary output buffer */

 return(codepos << 2) ; /* and return the size of the code/data generated */
}

/*}}}*/

/*}}}*/
