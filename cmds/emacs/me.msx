.I "set-fill-column."
Notice EMACS responds
"[Fill column is 1]." Now try typing some text.  You'll notice some very
strange things happening -- your text wraps at every word!! This effect
occurs because the set wrap margin command must be preceded by a
numeric argument or EMACS sets it to the first column.  Thus any text
you type that extends past the first column will wrap at the most
convenient line break. 
.PP
To reset the wrap column to 72 characters, press the
.B "<META>"
key and enter 72.  EMACS will respond "Arg: 72".  Now press
.B "^X-F."
EMACS will respond "[Fill column is 72]".  Your text will again wrap at the
margin you've been using up to this point.
.sb
.SH
Reformatting Paragraphs
.sf
.PP
After an intensive editing session, you may find that you have
paragraphs containing lines of differing lengths.  Although this
disparity will not affect the formatted text, aesthetic and technical
concerns may make it desirable to have consistent paragraph blocks on
the screen.  If you are in WRAP mode, you can reformat a paragraph with
the command
.B "M-Q"
.I "fill-paragraph."
This command 'fills' the current paragraph reformatting it so all the lines
are filled and wrap logically.  The process is complex, and (especially
with longer paragraphs) may take a little time. 
.sb
.SH
Changing Case
.sf
.PP
There may be occasions when you find it necessary to change the case of
the text you've entered.  EMACS allows you to change the case of even
large amounts of text with ease.  Let's try and convert a few of the
office traditionalists to the joy of word processing.  Type in the
following text:
.IP
.I
Throw away your typewriter and learn to use a word processor. 
Word processing is relatively easy to learn and will increase your
productivity enormously.  Enter the Computer Age and find out just how
much fun it can be!!
.LP
.R
Let's give it a little more impact by capitalizing the first four words. 
The first step is to define the region of text just as you would if you
were doing an extensive deletion.  Set the mark at the beginning of the
paragraph with
.B "M-<space>"
.I "set-mark"
and move the cursor to the space beyond "typewriter." Now enter
.B "^X-^U"
.I "case-region-upper."
Your text should now look like this:
.IP
.I
THROW AWAY YOUR TYPEWRITER and learn to use a word processor. 
Word processing is relatively easy to learn and will increase your
productivity enormously.  Enter the Computer Age and find out just how
much fun it can be!!
.LP
.R
If you want to change the text back to lower case, type
.B "^X-^L"
.I "case-region-lower."
You can also
capitalize individual words.  To capitalize the word "fun", position the
cursor in front of the word and type
.B "M-U"
.I "case-word-upper."
The word is now capitalized.  To change it
back to lower case, move the cursor back to the beginning of the word
and type
.B "M-L"
.I "case-word-lower."
.PP
You may also capitalize individual letters in EMACS.  The command
.B "M-C"
.I "case-word-capitalize"
capitalizes the first letter after the point.  This command would
normally be issued with the cursor positioned in front of the first
letter of the word you wish to capitalize.  If you issue it in the
middle of a word, you can end up with some strAnge looking text. 
.sb
.SH
Tabs
.sf
.PP
Unless your formatter is instructed to take screen text literally (as
MicroSCRIBE does in the 'verbatim' environment for example), tabs in
EMACS generally affect screen formatting only. 
.PP
When EMACS is first started, it sets the default tab to every eighth
column.  As long as you stay with default, every time you press the tab
key a tab character,
.B "^I"
is inserted.  This character, like other
control characters, is invisible -- but it makes a subtle and
significant difference to your file and editing. 
.PP
For example, in default mode, press the tab key and then type the word
.B "Test."
"Test" appears at the eighth column.  Move your cursor to the
beginning of the word and delete the backward character.  The word
doesn't move back just one character, but flushes to the left margin. 
The reason for this behavior is easily explained.  In tab default, EMACS
inserts a 'real' tab character when you press the tab key.  This
character is inserted at the default position, but NO SPACES are
inserted between the tab character and the margin (or previous tab
character).  As you will recall, EMACS only recognizes characters (such
as spaces or letters) and thus when the tab character is removed, the
text beyond the tab is flushed back to the margin or previous tab mark.
.PP
This situation changes if you alter the default configuration.  The
default value may be changed by entering a numeric argument before
pressing the tab key.  As we saw earlier, pressing the
.B "META"
key and entering a number allows you to specify how EMACS performs a given
action.  In this case, let's specify an argument of 10 and hit the tab
key. 
.PP
Now hit the tab key again and type
.B "Test."
Notice the word now
appears at the tenth column.  Now move to the beginning of the word and
delete the backward character.	"Test" moves back by one character. 
.PP
EMACS behaves differently in these circumstances because the
.B "^I"
.I "handle-tab"
function deals
with tabbing in two distinct ways.  In default conditions, or if the
numeric argument of zero is used,
.I "handle-tab"
inserts a true tab
character.  If, however, a non-zero numeric argument is specified,
.I "handle-tab"
inserts the correct number of spaces needed to position
the cursor at the next specified tab position.  It does NOT insert the
single tab character and hence any editing functions should take account
of the number of spaces between tabbed columns. 
.PP
Many times you would like to take a line which has been created using
the tab character and change it to use just spaces.  The command
.B "^X-^D"
.I "detab-line"
changes any tabs from the
point to the end of the current line into the right number of spaces so
the line does not change.  This is very useful for times when the file
must be printed or transferred to a machine which does not understand
tabs. 
.PP
Also, the inverse command,
.B "^X-^E"
.I "entab-lines"
changes multiple spaces to tabs where possible.  This is a good way to
shrink the size of large documents, especially with data tables.  Both
of these commands can take a numeric argument which will be interpreted
as the number of lines to en/detab. 
.sb
.SH
Summary
.sf
.PP
This chapter introduced some of the formatting features of
EMACS. Text-wrap, paragraph reformatting, and tabs were discussed in
some detail.  The commands in the following table were covered in the
chapter. 
.KS
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
Add-Mode/WRAP;^X-M [WRAP];Add wrap mode to current buffer
.sp .5
Delete-Mode/WRAP;^X-^M [WRAP];Remove wrap mode from current buffer
.sp .5
Set-Fill-Column;^X-F;Set fill column to given numeric argument  
.sp .5
Fill-Paragraph;M-Q;Logically reformats the current paragraph
.sp .5
Case-Word-Upper;M-U;T{
Text from point to end of the current word is changed to uppercase
T}
.sp .5
Case-Word-Lower;M-L;T{
Text from point to end of the  current word is changed to lowercase
T}
.sp .5
Case-Word-Capitalize;M-C;T{
First word (or letter) after the point is capitalized
T}
.sp .5
Case-Region-Upper;^X-^U;The current region is uppercased
.sp .5
Case-Region-Lower;^X-^L;The current region is lowercased
.sp .5
Handle-Tab;^I;T{
Tab interval is set to the given numeric argument
T}
.sp .5
Entab-Line;^X-^E;T{
Changes multiple spaces to tabs characters where possible
T}
.sp .5
Detab-Line;^X-^D;T{
Changes tab characters to the appropriate number of spaces
T}
.TE
.KE
.sb
.sb
.bp
.SH
Keyboard Macros
.sf
.PP
In many applications, it may be necessary to repeat a series of
characters or commands frequently.  For example, a paper may require the
frequent repetition of a complex formula or a long name.  You may also
have a series of EMACS commands that you invoke frequently.  Keyboard
macros offer a convenient method of recording and repeating these
commands. 
.PP
Imagine, for example, you are writing a scholarly paper on
.I "Asplenium platyneuron,"
the spleenwort fern.  Even the dedicated botanist would
probably find it a task bordering on the agonizing to type
.I "Asplenium platyneuron"
frequently throughout the paper.  An
alternative method is 'record' the name in a keyboard macro.  Try it
yourself.
.PP
The command
.B "^X-("
.I "begin-macro"
starts recording the all the keystrokes and commands you input.  After you've
typed it, enter
.I "Asplenium platyneuron."
To stop recording, type
.B "^X-)"
.I "end-macro."
EMACS has stored all the
keystrokes between the two commands.  To repeat the name you've stored,
just enter
.B "^X-E"
.I "execute-macro,"
and the name "Asplenium platyneuron" appears.  You can repeat this action as
often as you want, and of course as with any EMACS command, you may
precede it with a numerical argument. 
.PP
Because EMACS records keystrokes, you may freely intermix commands and
text.  Unfortunately, you can only store one macro at a time.  Thus, if
you begin to record another macro, the previously defined macro is
lost. Be careful to ensure that you've finished with one macro before
defining another.  If you have a series of commands that you would like
to 'record' for future use, use the macro or procedure facilities
detailed in chapter <X>.
.SH
Summary
.sf
.SH
This chapter covered keyboard macros.  You learned how to
record keystrokes and how to repeat the stored sequence. 
.KS
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
Start-Macro;^X-(;Starts recording all keyboard input
.sp .5
End-Macro;^X-);Stops recording keystrokes for macro
.sp .5
Execute-Macro;^X-E;T{
Entire sequence of recorded keystrokes is replayed
T}
.TE
.KE
.sb
.sb
.bp
.SH
MicroEMACS Macros
.sf
.PP
Macros are programs that are used to customize the editor and to
perform complicated editing tasks.  They may be stored in files or
buffers and may be executed using an appropriate command, or bound to a
particular keystroke.  Portions of the standard start-up file are
implement via macros, as well as the example menu system.  The
.I "execute-macro-<n>"
commands cause the
macro, numbered from 1 to 40, to be executed.  The
.I "execute-file"
command allows you to execute a macro stored in a
disk file, and the
.I "execute-buffer"
command allows you to execute a macro stored in a buffer.  Macros are stored for
easy execution by executing files that contain the store-macro command. 
.PP
There are many different aspects to the macro language within
MicroEMACS.  Editor commands are the various commands that manipulate
text, buffers, windows, etc, within the editor.  Directives are commands
which control what lines get executed within a macro.  Also there are
various types of variables.  Environmental variables both control and
report on different aspects of the editor.  User variables hold string
values which may be changed and inspected.  Buffer variables allow text
to be placed into variables.  Interactive variable allow the program to
prompt the user for information.  Functions can be used to manipulate
all these variables. 
.SH
Variables
.sf
.PP
Variables in MicroEMACS can be used to return values within
expressions, as repeat counts to editing commands, or as text to be
inserted into buffers and messages.  The value of these variables is set
using the set
.B "^X-A"
command.  For example, to set the current fill
column to 64 characters, the following macro line would be used:
.IP
set $fillcol 64
.LP
or to have the contents of
.B "%name"
inserted at the point in the current buffer, the command to use would be:
.IP
insert-string %name
.sb
.SH
Environmental Variables
.sf
.PP
"What good is a quote if you can't change it?"
.PP
These variables are used to change different aspects of the way
the editor works.  Also they will return the current settings if used as
part of an expression.  All environmental variable names begin with a
dollar sign ($) and are in lower case.
.TS
tab(;);
l lw(4i).
$fillcol;Current fill column
.sp .5
$pagelen;Number of screen lines used currently
.sp .5
$curwidth;Number of columns used currently
.sp .5
$curcol;Current column of point in current buffer
.sp .5
$curline;Current line of point in current buffer
.sp .5
$flicker;T{
Flicker Flag set to TRUE if IBM CGA set to FALSE for most others
T}
.sp .5
$cbufname;Name of the current buffer
.sp .5
$cfname;File name of the current buffer
.sp .5
$sres;T{
Current screen resolution (CGA, MONO or EGA on the IBM-PC driver.
LOW, MEDIUM, HIGH or DENSE on the Atari ST1040, NORMAL on all others)
T}
.sp .5
$debug;T{
Flag to trigger macro debugging (try it... you'll like it!)
T}
.sp .5
$status;T{
return status of the success of the last command
(TRUE or FALSE) usually used with !force
T}
.sp .5
$palette;T{
string used to control the palette register settings on graphics versions.
The usually form consists of groups of three octal digits
setting the red, green, and blue levels.
T}
.sp .5
$asave;T{
The number of inserted characters between automatic file-saves in ASAVE mode.
T}
.sp .5
$acount;T{
The countdown of inserted characters until the next save-file.
T}
.sp .5
$lastkey;Last keyboard character typed
.sp .5
$curchar;Character currently at the point
.sp .5
$discmd;T{
Flag to disable the echoing of messages on the command line
T}
.sp .5
$version;T{
Contains the current MicroEMACS version number
T}
.sp .5
$progname;T{
Always contains the string "MicroEMACS" for standard MicroEMACS.
Could be something else if used as part of someone else's program
T}
.sp .5
$seed;integer seed of the random number generator
.sp .5
$disinp;T{
Flag to disable the echoing of characters during command line input
T}
.TE
.PP
Obviously, many more of these variables will be available in
future releases of MicroEMACS. (Yes, send a vote for your favorite new
environmental variables today).
.sb
.SH
User variables
.sf
.PP
User variables allow you, the user, to store strings and
manipulate them.  These strings can be pieces of text, numbers (in text
form), or the logical values
.B "TRUE"
and
.B "FALSE."
These variables
can be combined, tested, inserted into buffers, and otherwise used to
control the way your macros execute.  At the moment, up to 100 user
variables may be in use in one editing session.  All users variable
names must begin with a percent sign (%) and may contain any printing
characters.  Only the first 10 characters are significant (i.e
differences beyond the tenth character are ignored).  Most operators
will truncate strings to a length of 128 characters. 
.sb
.SH
Buffer Variables
.sf
.PP
Buffer variables are special in that they can only be queried
and cannot be set.  What buffer variables are is a way to take text from
a buffer and place it in a variable. For example, if I have a buffer by
the name of RIGEL2, and it contains the text:
.KS
.TS
tab(;);
l l
l l
l l
l l
l l
l s.
;Richmond
;Lafayette
<*>;Bloomington
;Indianapolis
;Gary
 =* MicroEMACS 3.8i (WRAP) == rigel2 == File: /data/rigel2.txt =====
.TE
.KE
.FS
where <*> is the current point
.FE
and within a command I reference #rigel2, like:
.IP
insert-string #rigel2
.PP
MicroEMACS would start at the current point in the RIGEL2
buffer and grab all the text up to the end of that line and pass that
back.  Then it would advance the point to the beginning of the next line.
Thus, after our last command executes, the string "Bloomington" gets
inserted into the current buffer, and the buffer RIGEL2 now looks like
this:
.KS
.TS
tab(;);
l l
l l
l l
l l
l l
l s.
;Richmond
;Lafayette
;Bloomington
<*>;Indianapolis
;Gary
 =* MicroEMACS 3.8i (WRAP) == rigel2 == File: /data/rigel2.txt =====
.TE
.KE
as you have probably noticed, a buffer variable consists of the
buffer name, preceded by a pound sign (#).
.sb
.SH
Interactive variables
.sf
.PP
Interactive variables are actually a method to prompt the user
for a string.  This is done by using an at sign (@) followed either with
a quoted string, or a variable containing a string.  The string is the
placed on the bottom line, and the editor waits for the user to type in
a string.  Then the string typed in by the users is returned as the
value of the interactive variable.  For example:
.IP
set %quest "What file? "
.br
find-file @%quest
.LP
will ask the user for a file name, and then attempt to find it.
.sb
.sb
.SH
Functions
.sf
.PP
Functions can be used to manipulate variables in various ways. 
Functions can have one, two, or three arguments.  These arguments will
always be placed after the function on the current command line.  For
example, if we wanted to increase the current fill column by two, using
emacs's set
.B "^X-A"
command, we would write:
.KS
.TS
tab(;);
l l l l l l
c c c c c l.
set;$fillcol;&add;$fillcol;2;
;;;;\(ua;second operand
;;;\(ua;;first operand
;;\(ua;;;function to execute
;\(ua;;;;variable to set
\(ua;;;;;set (^X-A) command
.TE
.KE
.PP
Function names always begin with the ampersand (&) character,
and are only significant to the first three characters after the
ampersand.  Functions will normal expect one of three types of
arguments, and will automatically convert types when needed.
.KS
.TS
tab(;);
l lw(4i).
<num>;T{
an ascii string of digits which is interpreted as a numeric value. 
Any string which does not start with a digit or a minus sign (-) will be
considered zero. 
T}
.sp .5
<str>;T{
An arbitrary string of characters.  At the moment, strings are
limited to 128 characters in length. 
T}
.sp .5
<log>;T{
A logical value consisting of the string "TRUE" or "FALSE". 
Numeric strings will also evaluate to "FALSE" if they are equal to zero,
and "TRUE" if they are non-zero.  Arbitrary text strings will have the
value of "FALSE".
T}
.TE
.KE
A list of the currently available functions follows: (Once
again, send in those votes on what kind of functions you would like to
see added!) Functions are always used in lower case, the uppercase
letters in the function table are the short form of the function (i.e
&div for &divide).
.KS
.TS
tab(;);
l s l
l l lw(3i).
Numeric Functions:;(returns <num>)
_
&ADD;<num> <num>;Add two numbers
.sp .5
&SUB;<num> <num>;T{
Subtract the second number from the first
T}
.sp .5
&TIMes;<num> <num>;Multiply two numbers
.sp .5
&DIVide;<num> <num>;T{
Divide the first number by the second giving an integer result
T}
.sp .5
&MOD;<num> <num>;T{
Return the reminder of dividing the first number by the second
T}
.sp .5
&NEGate;<num>;Multiply the arg by -1
.sp .5
&LENgth;<str>;Returns length of string
.sp .5
&ASCii;<str>;T{
Return the ascii code of the first character in <str>
T}
.sp .5
&RND;<num>;T{
Returns a random integer between 1 and <num>
T}
.sp .5
&ABS;<num>;T{
Returns the absolute value of <num>
T}
.TE
.KE
.KS
.TS
tab(;);
l s l
l l lw(3i).
String manipulation functions:;(returns <str>)
_
&CAT;<str> <str>;Concatenate the two strings to form one
.sp .5
&LEFt;<str> <num>;T{
return the <num> leftmost characters from <str>
T}
.sp .5
&RIGht;<str> <num>;T{
return the <num> rightmost characters from <str>
T}
.sp .5
&MID;<str> <num1> <num2>;T{
Starting from <num1> position in <str>, return <num2> characters.
T}
.sp .5
&UPPer;<str>;Uppercase <str>
.sp .5
&LOWer;<str>;lowercase <str>
.sp .5
&CHR;<num>;T{
return a string with the character represented by ascii code <num>
T}
.sp .5
&GTK;;T{
return a string containing a single keystroke from the user
T}
.TE
.KE
.KS
.TS
tab(;);
l s l
l l lw(3i).
Logical Testing functions:;(returns <log>)
_
&NOT;<log>;Return the opposite logical value
.sp .5
&AND;<log1> <log2>;T{
Returns TRUE if BOTH logical arguments are TRUE
T}
.sp .5
&OR;<log1> <log2>;T{
Returns TRUE if either argument is TRUE
T}
.sp .5
&EQUal;<num> <num>;T{
If <num> and <num> are numerically equal, return TRUE
T}
.sp .5
&LESs;<num1> <num2>;T{
If <num1> is less than <num2>, return TRUE.
T}
.sp .5
&GREater;<num1> <num2>;T{
If <num1> is greater than, or equal to <num2>, return TRUE.
T}
.sp .5
&SEQual;<str1> <str2>;T{
If the two strings are the same, return TRUE.
T}
.sp .5
&SLEss;<str1> <str2>;T{
If <str1> is less alphabetically than <str2>, return TRUE.
T}
.sp .5
&SGReater;<str1> <str2>;T{
If <str1> is alphabetically greater than or equal to <str2>, return TRUE.
T}
.TE
.KE
.KS
.TS
tab(;);
l s l
l l lw(3i).
Special Functions:;;
_
&INDirect;<str>;Evaluate <str> as a variable.
.TE
.KE
.PP
This last function deserves more explanation. The &IND function
evaluates its argument, takes the resulting string, and then uses it as
a variable name.  For example, given the following code sequence:
.IP
; set up reference table
.sp
set %one	"elephant"
.br
set %two	"giraffe"
.br
set %thee	"donkey"
.sp
set %index "two"
.br
insert-string &ind %index
.LP
the string "giraffe" would have been inserted at the point in
the current buffer.  This indirection can be safely nested up to about
10 levels.
.sb
.SH
Directives
.sf
.PP
Directives are commands which only operate within an executing
macro, i.e they do not make sense as a single command. As such, they
cannot be called up singly or bound to keystroke. Used within macros,
they control what lines are executed and in what order.
.PP
Directives always start with the exclamation mark (!) character
and must be the first thing placed on a line. Directives executed singly
(via the execute-command-line command) interactively will be ignored.
.SH
!ENDM Directive
.sf
.PP
This directive is used to terminate a macro being stored. For
example, if a file is being executed contains the text:
.KS
.TS
tab(%);
l s
l l
l l
l l
l l
l s.
;  Read in a file in view mode, and make the window red
.sp
26%store-macro
%find-file @"File to view: "
%add-mode "view"
%add-mode "red"
!endm
.sp
write-message "[Consult macro has been loaded]"
.TE
.KE
only the lines between the store-macro command and the !ENDM
directive are stored in macro 26.
.sb
.SH
!FORCE Directive
.sf
.PP
When MicroEMACS executes a macro, if any command fails, the
macro is terminated at that point. If a line is preceded by a !FORCE
directive, execution continues weather the command succeeds or not. For
example:
.KS
.TS
tab(%);
l s
l l.
; Merge the top two windows
.sp
save-window%;remember what window we are at
1 next-window%;go to the top window
delete-window%;merge it with the second window
!force restore-window%;This will continue regardless
add-mode "red"%
.TE
.KE
.sb
.SH
!IF, !ELSE, and !ENDIF Directives
.sf
.PP
This directive allows statements only to be executed if a
condition specified in the directive is met.  Every line following the
!IF directive, until the first !ELSE or !ENDIF directive, is only
executed if the expression following the !IF directive evaluates to a
TRUE value.  For example, the following macro segment creates the
portion of a text file automatically.  (yes believe me, this will be
easier to understand then that last explanation....)
.KS
.IP
!if &sequal %curplace "timespace vortex"
.ti +4
insert-string "First, rematerialize~n"
.br
!endif
.br
!if &sequal %planet "earth"	;If we have landed on earth...
.ti +4
!if &sequal %time "late 20th century"  ;and we are then
.ti +8
write-message "Contact U.N.I.T."
.ti +4
!else
.ti +8
insert-string "Investigate the situation....~n"
.ti +8
insert-string "(SAY 'stay here Sara')~n"
.ti +4
!endif
.br
!else
.ti +4
set %conditions @"Atmosphere conditions outside? "
.ti +4
!if &sequal %conditions "safe"
.ti +8
insert-string &cat "Go outside......" "~n"
.ti +8
insert-string "lock the door~n"
.ti +4
!else
.ti +8
insert-string "Dematerialize..try somewhere else"
.ti +8
newline
.ti +4
!endif
.br
!endif
.KE
.sb
.SH
!GOTO Directive
.sf
.PP
Flow can be controlled within a MicroEMACS macro using the !GOTO
directive. It takes as an argument a label. A label consists of a line
starting with an asterisk (*) and then an alphanumeric label.  Only
labels in the currently executing macro can be jumped to, and trying to
jump to a non-existing label terminates execution of a macro.  For
example..
.KS
.IP
;Create a block of DATA statements for a BASIC program
.sp
.ti +4
insert-string "1000 DATA "
.ti +4
set %linenum 1000
.sp
*nxtin
.ti +4
update-screen		;make sure we see the changes
.ti +4
set %data @"Next number: "
.ti +4
!if &equal %data 0
.ti +8
!goto finish
.ti +4
!endif
.sp
.ti +4
!if &greater $curcol 60
.ti +8
2 delete-previous-character
.ti +8
newline
.ti +8
set %linenum &add %linenum 10
.ti +8
insert-string &cat %linenum " DATA "
.ti +4
!endif
.sp
.ti +4
insert-string &cat %data ", "
.ti +4
!goto nxtin
.sp
*finish
.sp
.ti +4
2 delete-previous-character
.ti +4
newline
.KE
.sb
.SH
!RETURN Directive
.sf
.PP
The !RETURN Directive causes the current macro to exit, either
returning to the caller (if any) or to interactive mode.  For example:
.KS
.IP
; Check the monitor type and set %mtyp
.sp
!if &sres "CGA"
.ti +4
set %mtyp 1
.ti +4
!return
.br
!else
.ti +4
set %mtyp 2
.br
!endif
.sp
insert-string "You are on a MONOCHROME machine!~n"
.KE
.sb
.sb
.sb
.bp
.SH
MicroEMACS commands
.sf
.PP
Below is a complete list of the commands in EMACS, the keys
normally used to do the command, and what the command does.  Remember,
on some computers there may also be additional ways of using a command
(cursor keys and special function keys for example). 
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
abort-command;^G;T{
This allows the user to abort out of any command that is waiting for input
T}
.sp .5
add-mode;^X-M;Add a mode to the current buffer
.sp .5
add-global-mode;M-M;Add a global mode for all new buffers
.sp .5
apropos;M-A;T{
List out commands whose name contains the string specified
T}
.sp .5
backward-character;^B;Move one character to the left
.sp .5
begin-macro;^X-(;Begin recording a keyboard macro
.sp .5
beginning-of-file;M-<;T{
Move to the beginning of the file in the current buffer
T}
.sp .5
beginning-of-line;^A;Move to the beginning of the current line
.sp .5
bind-to-key;M-K;Bind a key to a function
.sp .5
buffer-position;^X-=;T{
List the position of the cursor in the current window on the command line
T}
.sp .5
case-region-lower;^X-^L;Make a marked region all lower case
.sp .5
case-region-upper;^X-^U;Make a marked region all upper case
.sp .5
case-word-capitalize;M-C;Capitalize the following word
.sp .5
case-word-lower;M-L;Lower case the following word
.sp .5
case-word-upper;M-U;Upper case the following word
.sp .5
change-file-name;^X-N;T{
Change the name of the file in the current buffer
T}
.sp .5
change-screen-size;M-^S;T{
Change the number of lines of the screen currently being used
T}
.sp .5
change-screen-width;M-^T;T{
Change the number of columns of the screen currently being used
T}
.sp .5
clear-and-redraw;^L;Clear the physical screen and redraw it
.sp .5
clear-message-line;(none);Clear the command line
.sp .5
copy-region;M-W;T{
Copy the currently marked region into the kill buffer
T}
.sp .5
count-words;M-^C;T{
Count how many words, lines and characters are in the current marked region
T}
.sp .5
ctlx-prefix;^X;Change the key used as the ^X prefix
.sp .5
delete-blank-lines;^X-^O;Delete all blank lines around the cursor
.sp .5
delete-buffer;^X-K;T{
Delete a buffer which is not being currently displayed in a window
T}
.TE
.bp
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
delete-mode;^X-^M;Turn off a mode in the current buffer
.sp .5
delete-global-mode;M-^M;Turn off a global mode
.sp .5
delete-next-character;^D;Delete the character following the cursor
.sp .5
delete-next-word;M-D;Delete the word following the cursor
.sp .5
delete-other-windows;^X-1;T{
Make the current window cover the entire screen
T}
.sp .5
delete-previous-character;^H;T{
Delete the character to the left of the cursor
T}
.sp .5
delete-previous-word;M-^H;Delete the word to the left of the cursor
.sp .5
delete-window;^X-0;Remove the current window from the screen
.sp .5
describe-bindings;(none);Make a list of all legal commands
.sp .5
describe-key;^X-?;T{
Describe what command is bound to a keystroke sequence
T}
.sp .5
detab-line;^X-^D;T{
Change all tabs in a line to the equivalent spaces
T}
.sp .5
end-macro;^X-);stop recording a keyboard macro
.sp .5
end-of-file;M->;Move cursor to the end of the current buffer
.sp .5
end-of-line;^E;Move to the end of the current line
.sp .5
entab-line;^X-^E;T{
Change multiple spaces to tabs where possible
T}
.sp .5
exchange-point-and-mark;^X-^X;T{
Move cursor to the last marked spot, make the original position be marked
T}
.sp .5
execute-buffer;(none);Execute a buffer as a macro
.sp .5
execute-command-line;(none);T{
Execute a line typed on the command line as a macro command
T}
.sp .5
execute-file;FNB;Execute a file as a macro
.sp .5
execute-macro;^X-E;T{
Execute the keyboard macro (play back the recorded keystrokes)
T}
.sp .5
execute-macro-<n>;(none);T{
Execute numbered macro <N> where <N> is an integer from 1 to 40
T}
.sp .5
execute-named-command;M-X;Execute a command by name
.sp .5
execute-procedure;M-^E;Execute a procedure by name
.sp .5
exit-emacs;^X-^C;T{
Exit EMACS. If there are unwritten, changed buffers EMACS will ask to confirm
T}
.sp .5
fill-paragraph;M-Q;Fill the current paragraph
.sp .5
filter-buffer;^X-#;T{
Filter the current buffer through an external filter
T}
.sp .5
find-file;^X-^F;Find a file to edit in the current window
.sp .5
forward-character;^F;Move cursor one character to the right
.sp .5
goto-line;M-G;Goto a numbered line
.sp .5
goto-matching-fence;M-^F;Goto the matching fence
.TE
.bp
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
grow-window;^X-^;Make the current window larger
.sp .5
handle-tab;^I;Insert a tab or set tab stops
.sp .5
hunt-forward;FN=;T{
Hunt for the next match of the last search string
T}
.sp .5
hunt-backward;FN>;T{
Hunt for the last match of the last search string
T}
.sp .5
help;M-?;Read EMACS.HLP into a buffer and display it
.sp .5
i-shell;^X-C;Shell up to a new command processor
.sp .5
incremental-search;^X-S;Search for a string, incrementally
.sp .5
insert-file;^X-^I;T{
insert a file at the cursor in the current file
T}
.sp .5
insert-space;^C;Insert a space to the right of the cursor
.sp .5
insert-string;(none);Insert a string at the cursor
.sp .5
kill-paragraph;M-^W;Delete the current paragraph
.sp .5
kill-region;^W;T{
Delete the current marked region, moving it to the kill buffer
T}
.sp .5
kill-to-end-of-line;^K;Delete the rest of the current line
.sp .5
list-buffers;^X-^B;List all existing buffers
.sp .5
meta-prefix;<ESC>;Key used to precede all META commands
.sp .5
move-window-down;^X-^N;TMove all the lines in the current window down
.sp .5
move-window-up;^X-^P;Move all the lines in the current window up
.sp .5
name-buffer;M-^N;Change the name of the current buffer
.sp .5
newline;^M;Insert a <NL> at the cursor
.sp .5
newline-and-indent;^J;T{
Insert a <NL> at the cursor and indent
the new line the same as the preceding line
T}
.sp .5
next-buffer;^X-X;T{
Bring the next buffer in the list into the current window
T}
.sp .5
next-line;^N;Move the cursor down one line
.sp .5
next-page;^V;Move the cursor down one page
.sp .5
next-paragraph;M-N;Move cursor to the next paragraph
.sp .5
next-window;^X-O;Move cursor to the next window
.sp .5
next-word;M-F;T{
Move cursor to the beginning of the next word
T}
.sp .5
open-line;^O;Open a line at the cursor
.sp .5
pipe-command;^X-@;T{
Execute an external command and place its output in a buffer
T}
.sp .5
previous-line;^P;Move cursor up one line
.sp .5
previous-page;^Z;Move cursor up one page
.sp .5
previous-paragraph;M-P;Move back one paragraph
.sp .5
previous-window;^X-P;Move the cursor to the last window
.TE
.bp
.TS
tab(;);
l l l
lfI lfB lw(3i).
Key Binding;Keystroke;Effect
_
previous-word;M-B;T{
Move the cursor to the beginning of the word to the left of the cursor
T}
.sp .5
query-replace-string;M-^R;T{
Replace all of one string with another
string, interactively querying the user
T}
.sp .5
quick-exit;M-Z;Exit EMACS, writing out all changed buffers
.sp .5
quote-character;^Q;Insert the next character literally
.sp .5
read-file;^X-^R;Read a file into the current buffer
.sp .5
redraw-display;M-^L;T{
Redraw the display, centering the current line
T}
.sp .5
resize-window;^X-W;T{
Change the number of lines in the current window
T}
.sp .5
restore-window;(none);Move cursor to the last saved window
.sp .5
replace-string;M-R;T{
Replace all occurrences of one string
with another string from the cursor to the end of the buffer
T}
.sp .5
reverse-incremental-search;^X-R;Search backwards, incrementally
.sp .5
run;M-^E;Execute a named procedure
.sp .5
save-file;^X-^S;Save the current buffer if it is changed
.sp .5
save-window;(none);Remember current window (to restore later)
.sp .5
scroll-next-up;M-^Z;Scroll the next window up
.sp .5
scroll-next-down;M-^V;Scroll the next window down
.sp .5
search-forward;^S;Search for a string
.sp .5
search-reverse;^R;Search backwards for a string
.sp .5
select-buffer;^X-B;T{
Select a buffer to display in the current window
T}
.sp .5
set;^X-A;Set a variable to a value
.sp .5
set-encryption-key;M-E;Set the encryption key of the current buffer
.sp .5
set-fill-column;^X-F;Set the current fill column
.sp .5
set-mark;^X-.;Set the mark
.sp .5
shell-command;^X-!;Execute an external command
.sp .5
shrink-window;^X-^Z;Make the current window smaller
.sp .5
split-current-window;^X-2;Split the current window in two
.sp .5
store-macro;(none);T{
Store the following macro lines to a numbered macro
T}
.sp .5
store-procedure;(none);T{
Store the following macro lines to a named procedure
T}
.sp .5
transpose-characters;^T;T{
Transpose the character at the cursor with the character to the left
T}
.sp .5
trim-line;^X-^T;Trim any trailing whitespace from line
.sp .5
unbind-key;M-^K;Unbind a key from a function
.sp .5
universal-argument;^U;Execute the following command 4 times
.sp .5
unmark-buffer;M-~;T{
Unmark the current buffer (so it is no longer changed)
T}
.sp .5
update-screen;(none);Force a screen update during macro execution
.sp .5
view-file;^X-^V;Find a file,and put it in view mode
.sp .5
wrap-word;M-FNW;T{
Wrap the current word, this is an internal function
T}
.sp .5
write-file;^X-^W;T{
Write the current buffer under a new file name
T}
.sp .5
write-message;(none);Display a string on the command line
.sp .5
yank;^Y;T{
yank the kill buffer into the current buffer at the cursor
T}
.TE
.sb
.bp
.SH
MicroEMACS Bindings
.sf
.PP
Below is a complete list of the key bindings used in MicroEMACS.
This can be used as a wall chart reference for MicroEMACS commands.
.KS
.TS
tab(;);
c s s s
lfB l lfB l.
Default Key Bindings for MicroEmacs 3.8i
_
^A;Move to start of line;ESC A;Apropos (list some commands)
^B;Move backward by characters;ESC B;Backup by words
^C;Insert space;ESC C;Initial capitalize word
^D;Forward delete;ESC D;Delete forward word
^E;Goto end of line;ESC E;Reset Encryption Key
^F;Move forward by characters;ESC F;Advance by words
^G;Abort out of things;ESC G;Go to a line
^H;Backward delete		      
^I;Insert tab/Set tab stops
^J;Insert CR-LF, then indent 		    
^K;Kill forward;ESC K;Bind Key to function
^L;Refresh the screen;ESC L;Lower case word
^M;Insert CR-LF;ESC M;Add global mode
^N;Move forward by lines;ESC N;Goto End paragraph
^O;Open up a blank line	      
^P;Move backward by lines;ESC P;Goto Beginning of paragraph
^Q;Insert literal;ESC Q;Fill current paragraph
^R;Search backwards;ESC R;Search and replace
^S;Search forward
^T;Transpose characters		       
^U;Repeat command four times;ESC U;Upper case word
^V;Move forward by pages;ESC V;Move backward by pages
^W;Kill region;ESC W;Copy region to kill buffer
^Y;Yank back from killbuffer;ESC X;Execute named command
^Z;Move backward by pages;ESC Z;Save all buffers and exit
.sp
ESC ^C;Count words in region;ESC ~;Unmark current buffer
ESC ^F;Goto matching fence;ESC !;Reposition window
ESC ^H;Delete backward word;ESC <;Move to start of buffer
ESC ^K;Unbind Key from function;ESC >;Move to end of buffer
ESC ^L;Reposition window;ESC .;Set mark
ESC ^M;Delete global mode;ESC space;Set mark
ESC ^N;Rename current buffer;ESC rubout;Delete backward word
ESC ^R;Search & replace w/query;rubout;Backward delete
ESC ^S;Change screen rows
ESC ^T;Change screen columns
ESC ^V;Scroll next window down
ESC ^W;Delete Paragraph
ESC ^Z;Scroll next window up
.TE
.KE
.KS
.TS
tab(;);
c s s s
lfB l lfB l.
Default Key Bindings for MicroEmacs 3.8i
_
.sp
^X ?;Describe a key;^X !;Run 1 command in a subjob
^X =;Show the cursor position;^X @;Pipe DOS command to buffer
^X ^;Enlarge display window;^X #;Filter buffer thru DOS filter
^X 0;Delete current window;^X (;Begin macro
^X 1;Delete other windows;^X );End macro
^X 2;Split current window
;;^X A;Set variable value
^X ^B;Display buffer list;^X B;Switch a window to a buffer
^X ^C;Exit MicroEMACS;^X C;Start a new command processor
;;^X D;Suspend MicroEMACS (BSD4.2 only)
;;^X E;Execute macro
^X ^F;Find file;^X F;Set fill column
^X ^I;Insert file
;;^X K;Delete buffer
^X ^L;Lower case region
^X ^M;Delete Mode;^X M;Add a mode
^X ^N;Move window down;^X N;Rename current filename
^X ^O;Delete blank lines;^X O;Move to the next window
^X ^P;Move window up;^X P;Move to the previous window
^X ^R;Get a file from disk;^X R;Incremental reverse search
^X ^S;Save current file;^X S;Incremental forward search
^X ^U;Upper case region
^X ^V;View file
^X ^W;Write a file to disk;^X W;resize Window
^X ^X;Swap "." and mark;^X X;Use next buffer
^X ^Z;Shrink window;^X Z;Enlarge display window
.TE
.KE
.KS
.TS
tab (;);
l l.
Only under PCDOS:
.sp .5
<ALT>-S Hunt forward;SHIFT <F1> - <F10>
<ALT>-R Hunt backward;Execute macros 1 - 10
.TE
.KE
.KS
.TS
tab(;);
l s
l l.
Usable Modes
_
WRAP;Lines going past right margin "wrap" to a new line
VIEW;Read-Only mode where no modifications are allowed
CMODE;Change behavior of some commands to work with C better
EXACT;Exact case matching on search strings
OVER;Overwrite typed characters instead of inserting them
CRYPT;Current buffer will be encrypted on write, decrypted on read
MAGIC;Use regular expression matching in searches
ASAVE;Save the file every 256 inserted characters
.TE
.sp .5
.TS
tab(;);
l l.
WHITE/CYAN/MAGENTA/YELLOW/BLUE/RED/GREEN/BLACK;Sets foreground color
white/cyan/magenta/yellow/blue/red/green/black;Sets background color
.TE
.KE
.sb
.bp
.SH
Supported machines
.sf
.PP
The following table lists all the hardware/compilers for which I
currently support MicroEMACS.  This is not exclusive of all machines
which MicroEMACS will run on, but I have either run it myself, or had a
first hand report of it running.
.KS
.TS
tab(;);
l l l l.
Hardware;OS;Compiler;Comments
_
VAX 780;UNIX V5;native
;UNIX V7;native
;BSD 4.2;native;job control supported
;*VMS;native;only some terminals supported
.sp
NCR Tower;UNIX V5;native
.sp
Fortune 32:16;UNIX V7;native
.sp
IBM-PC;MSDOS 2/3.2;Lattice 2.15;Large CODE/Large DATA
;;AZTEC 3.4e;Small CODE/Large DATA
;;*MSC 4.0
;;*MWC 86
.sp
HP150;MSDOS;Lattice 2.15;T{
Function key labels for the touch screen
T}
.sp
HP110;MSDOS;Lattice 2.15
;;Aztec 3.4e
.sp
T{
*Data General 10
T};MSDOS;Lattice 2.15
.sp
T{
*Texas Instruments Professional
T};MSDOS;Lattice 2.15
.sp
Amiga;Intuition;Lattice 3.03;no mouse or menus yet
;;*Aztec 3
.sp
ST520;TOS;Lattice 3.10;T{
no menus yet, no shell commands
T}
+Macintosh;Finder 5.0;Aztec
.TE
.KE
.FS
* means that I do not own or have access to the listed compiler and/or
machine and must rely upon others to help support it.
.FE
.FS
+ Systems to be supported (i.e some code is already written:)
.FE
.sb
.bp
.SH
Machine Dependent Notes
.sf
.PP
This appendix lists some notes specific to individual
implementations of MicroEMACS. Every attempt has been made to allow
EMACS to be identical on all machines, but we have also tried to take
advantage of function keys, cursor keys, mice, and special screen modes
where possible.
.SH
IBM-PC/XT/AT and its clones
.sf
.PP
The IBM-PC family of computers is supported with a variety of
different display adapters.  EMACS will attempt to discover what adapter
is connected and use the proper driver for it.	Below is a list of the
currently supported video adapters:
.KS
.TS
tab(;);
l l l.
;Adapter;$sres;Original mode used
_
Monochrome Graphics Adapter;MONO;MONO
Color Graphics Adapter;CGA;CGA
Enhanced graphics Adapter;EGA;CGA
.TE
.KE
.PP
EMACS also takes advantage of various function keys and the keys
on the keypad on an IBM-PC.  The function keys are initially not bound
to any particular functions (except by the emacs.rc startup file), but
the keypad keys do default to the following:
.KS
.TS
tab(;);
l l.
Keypad key;Function
_
Home;beginning-of-file
CSRS UP;previous-line
Pg Up;previous-page
CSRS LEFT;backward-character
CSRS RIGHT;forward-character
End;end-of-file
CSRS DOWN;next-line
Pg Dn;Next-page
.TE
.KE
.PP
All these special keys are indicated in EMACS macros by use of the
.B "FN"
prefix.  Below is a list of many of the keys and the codes
used to specify them.  Also the codes may be gotten by using the
describe-key (^X ?) command on the suspect key.
.KS
.TS
tab(%);
l s s s s
l l l l l.
IBM PC function keys in MicroEmacs
.sp .5
%function%Function%^function%Alt-function
f1)%FN;%FNT%FN^%FNh
f2)%FN<%FNU%FN_%FNi
f3)%FN=%FNV%FN`%FNj
f4)%FN>%FNW%FNa%FNk
f5)%FN?%FNX%FNb%FNl
f6)%FN@%FNY%FNc%FNm
f7)%FNA%FNZ%FNd%FNn
f8)%FNB%FN[%FNe%FNo
f9)%FNC%FN\%FNf%FNp
f10)%FND%FN]%FNg%FNq
.sp
home)%FNG%%FNw
CuUp)%FNH
PgUp)%FNI%%FN {Alt 132}
CuLf)%FNK%%FNs
 5  )
CuRt)%FNM%%FNt
 End)%FNO%%FNu
CuDn)%FNP
PgDn)%FNQ%%FNv
 Ins)%FNR
 Del)%FNS
.TE
.KE
.sb
.bp
.SH
Atari 520/1040ST
.sf
.PP
The ATARI ST family of computers have a dual personality.  They
may use either a monochrome or a color screen.	EMACS supports two
screen resolutions on each monitor. 
.KS
.TS
tab(;);
l l l l l.
Monitor;$sres;size;#color;$palette format
_
Color;LOW;40x25;16;000111222333444555666777
;MEDIUM;80x25;4;000111222333
Mono;HIGH;80x25;2;000
;DENSE*;80x40;2;000
.TE
.KE
.FS
* DENSE mode is not yet supported in 3.8i.  It will be soon
.FE
.PP
The $palette environment variable can be used to change what
color is associated with each color name.  With a color monitor, each
group of three digits indicates an octal number specifying the RED,
GREEN and BLUE levels of that color.  Each color digit can vary from 0
to 7.  For example, the initial setting of $palette in LOW resolution is:
.IP
000700070770007707077777
.LP
which broken up is:
.IP
000 700 070 770 007 707 077 777
.LP
which means:
.KS
.TS
tab(;);
l l.
000;Black
700;Red
070;Green
770;Yellow
007;Blue
707;Magenta
077;Cyan
777;White
.TE
.KE
.PP
Also the mouse generates FN prefix codes when moved, or when one
of the two buttons is pressed.	Initially the movement of the mouse is
bound to movement of the cursor, and the left mouse button generates a
set-mark (M-space) command.  The cursor keys and the function keys are
bound similarly to IBM-PC.
.sb
.SH
Amiga 1000
.sf
.PP
The Commodore AMIGA 1000 version of MicroEMACS does not have
extensive support of the mouse or of pull down menus as of yet.  It does
however come up in a window, and it is possible to re-size it to run in
different sized windows.  The
.B "M-^S"
.I "change-screen-size"
takes its numeric argument as the new number
of lines for EMACS to use.  The
.B "M-^T"
.I "change-screen-width"
command allows you to change the number of
columns EMACS will use.  The defaults for these are 23 lines and 77
characters across for a full screen window.
.DS C
Note about Compiling MicroEMACS
.DE
.IP
.I
If you are compiling the sources on the AMIGA to produce an
executable image, and you are using the Lattice compiler, be sure to
give the CLI command 'STACK 40000' before compiling to make sure the
compiler has sufficient stack space to successfully complete
compilation.
.sb
.bp
.SH
UNIX V5, V7, and BSD4.[23]
.sf
.PP
MicroEMACS under UNIX utilizes the
.B "TERMCAP"
library to provide machine independent screen functions.  Make sure that
termcap is available and properly set on your account before attempting
to use MicroEMACS. 
.PP
Under systems which support job control, you can use the
.B "^X-D"
.I "suspend-emacs"
command to place EMACS
into the background.  This carries a much smaller overhead than bringing
up a new shell under EMACS.  EMACS will properly redraw the screen when
you bring it back to the foreground.
.PP
With the addition of some very machine/operating system specific
code, EMACS can prevent two or more people from modifying the same file
at the same time. The upper level of a set of
functions to provide file locking exist in the source file
.B "LOCK.C."
It requires two machine specific functions written and linked into EMACS
for it to operate properly. 
.IP
char *dolock(fname)
.sp
char *fname;
.sp
dolock() locks a file, preventing others from modifying it. If
it succeeds, it returns NULL, otherwise it returns a pointer to
a string in the form "LOCK ERROR: explanation".
.sp
char *undolock(fname)
.sp
char *fname;
.sp
undolock() unlocks a file, allowing others to modifying it. If
it succeeds, it returns NULL, otherwise it returns a pointer to
a string in the form "LOCK ERROR: explanation".
