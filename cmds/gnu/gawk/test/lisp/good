walk (LISP in awk)	Copyright (c) 1988, 1990 Roger Rohrbach

-> (lambda (exp) (cond ((isconst exp) (list (mksend 1 exp))) (t (compapply (func exp) (complis (arglist exp)) (length (arglist exp))))))
(lambda (u) (cond ((null u) (quote ())) ((null (rest u)) (compexp (first u))) (t (append-3 (compexp (first u)) (list (mkalloc 1)) (complis (rest u))))))
(lambda (fn vals n) (append-3 vals (mklink n) (list (mkcall fn))))
(lambda (x) (or (numberp x) (eq x t) (eq x ()) (and (not (atom x)) (eq (first x) (quote quote)))))
(lambda (x) (first x))
(lambda (x) (rest x))
(lambda (dest val) (list (quote MOVEI) dest val))
(lambda (dest) (list (quote PUSH) (quote sp) dest))
(lambda (fn) (list (quote CALL) fn))
(lambda (n) (cond ((eqn n 1) (quote ())) (t (concat (mkmove n 1) (mklink1 (sub1 n))))))
(lambda (n) (cond ((zerop n) (quote ())) (t (concat (mkpop n) (mklink1 (sub1 n))))))
(lambda (n) (list (quote POP) (quote sp) n))
(lambda (dest val) (list (quote MOVE) dest val))
(lambda (x) (car x))
(lambda (x) (cdr x))
(lambda (element sequence) (cond ((listp sequence) (cons element sequence)) (t (quote ()))))
(lambda (l1 l2 l3) (append l1 (append l2 l3)))
(lambda (x) (cond ((consp x) t) ((null x) t) (t ())))
(lambda (e) (not (atom e)))
(lambda (x y) (eq x y))
addition undefined for given arguments
subtraction undefined for given arguments
(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)
(lambda (n) (or (succ n _integers_) (error NOADD)))
(lambda (n) (or (pred n _integers_) (error NOSUB)))
(lambda (x) (eq x 0))
(lambda (x) (member x _integers_))
(lambda (x y) (member x (after _integers_ y)))
(lambda (x y) (member y (after _integers_ x)))
(lambda (x y) (cond ((zerop y) x) (t (difference (sub1 x) (sub1 y)))))
(lambda (s) (cond ((atom s) 0) ((null (cdr s)) 1) (t (add1 (length (cdr s))))))
(lambda (x y) (length (append (before _integers_ x) (before _integers_ y))))
(lambda (x y) (cond ((null x) y) ((member (car x) y) (union (cdr x) y)) (t (cons (car x) (union (cdr x) y)))))
(lambda (x y) (cond ((null x) ()) ((member (car x) y) (cons (car x) (intersection (cdr x) y))) (t (intersection (cdr x) y))))
(lambda (in out) (cond ((null in) ()) ((member (car in) out) (ldifference (cdr in) out)) (t (cons (car in) (ldifference (cdr in) out)))))
(lambda (a b) (cond ((null a) t) ((member (car a) b) (subsetp (cdr a) b)) (t ())))
(lambda (a b) (and (subsetp a b) (subsetp b a)))
(lambda (e) (car (cdr e)))
(lambda (e) (cdr (cdr e)))
(lambda (e) (car (car e)))
(lambda (e) (cdr (car e)))
(lambda (e) (car (cdr (car e))))
(lambda (e) (car (cdr (cdr e))))
(lambda (e) (cdr (cdr (car e))))
(lambda (e) (cdr (car (cdr e))))
(lambda (e) (eq e ()))
(lambda (e) (eq e ()))
(lambda (s) (cond ((atom s) s) (t (ff (car s)))))
(lambda (x y z) (cond ((atom z) (cond ((eq z y) x) (t z))) (t (cons (subst x y (car z)) (subst x y (cdr z))))))
(lambda (x y) (or (and (atom x) (atom y) (eq x y)) (and (not (atom x)) (not (atom y)) (equal (car x) (car y)) (equal (cdr x) (cdr y)))))
(lambda (x y) (cond ((null x) y) (t (cons (car x) (append (cdr x) y)))))
(lambda (x y) (and (not (null y)) (or (equal x (car y)) (member x (cdr y)))))
(lambda (x y) (cond ((and (null x) (null y)) ()) ((and (not (atom x)) (not (atom y))) (cons (list (car x) (car y)) (pair (cdr x) (cdr y))))))
(lambda (x y) (cond ((null y) ()) ((eq caar y x) (car y)) (t (assoc x (cdr y)))))
(lambda (x y) (cond ((atom y) (_sublis x y)) (t (cons (sublis x (car y)) (sublis x (cdr y))))))
(lambda (x z) (cond ((null x) z) ((eq (caar x) z) (cadar x)) (t (_sublis (cdr x) z))))
(lambda (e) (cond ((atom e) ()) ((null (cdr e)) (car e)) (t (last (cdr e)))))
(lambda (x) (_reverse x ()))
(lambda (x y) (cond ((null x) y) (t (_reverse (cdr x) (cons (car x) y)))))
(lambda (e l) (cond ((null l) ()) ((equal e (car l)) (remove e (cdr l))) (t (cons (car l) (remove e (cdr l))))))
(lambda (x y) (cond ((or (null y) (null (cdr y))) ()) ((eq (car y) x) (cadr y)) (t (succ x (cdr y)))))
(lambda (x y) (cond ((or (null y) (null (cdr y))) ()) ((eq (cadr y) x) (car y)) (t (pred x (cdr y)))))
(lambda (x y) (cond ((atom x) ()) ((null (cdr x)) ()) ((equal (car x) y) ()) ((equal (cadr x) y) (cons (car x) ())) (t (cons (car x) (before (cdr x) y)))))
(lambda (x y) (cond ((atom x) ()) ((equal (car x) y) (cdr x)) (t (after (cdr x) y))))
(lambda (x) (succ x Properties))
(lambda (x i) ((lambda (pr) (cond ((null pr) ()) (t (cadr pr)))) (assoc i (plist x))))
(lambda (x v i) (and (or (plist x) (set (quote Properties) (cons x (cons () Properties)))) (and (set (quote Properties) (append (before Properties x) (append (list x (cons (list i v) ((lambda (l) (remove (assoc i l) l)) (plist x)))) (cdr (after Properties x))))) v)))
(lambda (x i) (and (get x i) (set (quote Properties) (append (before Properties x) (append (list x ((lambda (l) (remove (assoc i l) l)) (plist x))) (cdr (after Properties x))))) i))
(lambda (f l) (cond ((null l) ()) (t (cons (eval (list f (list (quote quote) (car l)))) (mapcar f (cdr l))))))
(lambda (f args) (cond ((null args) ()) (t (eval (cons f (mapcar (quote (lambda (a) (list (quote quote) a))) args))))))
