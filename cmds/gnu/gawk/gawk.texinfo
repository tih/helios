\input texinfo   @c -*-texinfo-*-
@c %**start of header (This is for running Texinfo on a region.)
@setfilename gawk-info
@settitle The GAWK Manual
@c %**end of header (This is for running Texinfo on a region.)

@ifinfo
@synindex fn cp
@synindex vr cp
@end ifinfo
@iftex
@syncodeindex fn cp
@syncodeindex vr cp
@end iftex

@iftex
@finalout
@end iftex

@ifinfo
This file documents @code{awk}, a program that you can use to select
particular records in a file and perform operations upon them.

Copyright (C) 1989 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@c @smallbook
@c For printing as a small manual, uncomment the above line.  Then change
@c every `@example' to `@smallexample' and every `@end example' to
@c `@end smallexample'.  That's all.

@setchapternewpage odd
@titlepage
@sp 11
@center @titlefont{The GAWK Manual}
@sp 4
@center by
@center Diane Barlow Close
@center Arnold D. Robbins
@center Paul H. Rubin
@center Richard Stallman
@sp 2
@center Edition 0.12 Beta
@sp 2
@center October 1989

@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1989 Free Software Foundation, Inc.
@sp 2

This is Edition 0.12 Beta of @cite{The GAWK Manual}, @*
for the 2.11.1 version of the GNU implementation @*
of AWK.

@sp 2
Published by the Free Software Foundation @*
675 Massachusetts Avenue, @*
Cambridge, MA 02139 USA @*
Printed copies are available for $10 each.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@node Top, Preface, (dir), (dir)
@comment  node-name,  next,  previous,  up
@c Preface or Licensing nodes should come right after the Top
@c node, in `unnumbered' sections, then the chapter, `What is gawk'.

@ifinfo
This file documents @code{awk}, a program that you can use to select
particular records in a file and perform operations upon them; it
contains the following chapters:
@end ifinfo

@menu
* Preface::            What you can do with @code{awk}; brief history
                       and acknowledgements.

* Copying::            Your right to copy and distribute @code{gawk}.

* This Manual::        Using this manual. 
                       Includes sample input files that you can use.
* Getting Started::    A basic introduction to using @code{awk}.
                       How to run an @code{awk} program.  Command line syntax.

* Reading Files::      How to read files and manipulate fields.

* Printing::           How to print using @code{awk}.  Describes the
                       @code{print} and @code{printf} statements.  
                       Also describes redirection of output.

* One-liners::         Short, sample @code{awk} programs.

* Patterns::           The various types of patterns explained in detail.

* Actions::            The various types of actions are introduced here.
                       Describes expressions and the various operators in
                       detail.  Also describes comparison expressions.

* Expressions::        Expressions are the basic building blocks of statements.

* Statements::         The various control statements are described in
                       detail.

* Arrays::             The description and use of arrays.  Also includes
                       array-oriented control statements.

* Built-in::           The built-in functions are summarized here.

* User-defined::       User-defined functions are described in detail.

* Var: Built-in Variables.  The built-in variables are summarized here.

* Command Line::       How to run @code{gawk}.

* Language History::   The evolution of the @code{awk} language.

* Gawk Summary::       @code{gawk} Options and Language Summary.

* Sample Program::     A sample @code{awk} program with a complete explanation.

* Notes::              Something about the implementation of @code{gawk}.

* Glossary::           An explanation of some unfamiliar terms.

* Index::
@end menu

@node Preface, Copying, Top , Top
@comment  node-name,  next,  previous,  up
@unnumbered Preface

@c @cindex what is @code{awk}
If you are like many computer users, you frequently would like to make
changes in various text files wherever certain patterns appear, or
extract data from parts of certain lines while discarding the rest.  To
write a program to do this in a language such as C or Pascal is a
time-consuming inconvenience that may take many lines of code.  The job
may be easier with @code{awk}.

The @code{awk} utility interprets a special-purpose programming language
that makes it possible to handle simple data-reformatting jobs easily
with just a few lines of code.

The GNU implementation of @code{awk} is called @code{gawk}; it is fully
upward compatible with the System V Release 3.1 and later
version of @code{awk}.  All properly written
@code{awk} programs should work with @code{gawk}.  So we usually don't
distinguish between @code{gawk} and other @code{awk} implementations in
this manual.@refill

@cindex uses of @code{awk}
This manual teaches you what @code{awk} does and how you can use
@code{awk} effectively.  You should already be familiar with basic
system commands such as @code{ls}.  Using @code{awk} you can: @refill

@itemize @bullet
@item
manage small, personal databases,

@item
generate reports,

@item
validate data,
@item
produce indexes, and perform other document preparation tasks,

@item
even experiment with algorithms that can be adapted later to other computer
languages!
@end itemize

@menu
* History::  The history of @code{gawk} and @code{awk}.  Acknowledgements.
@end menu

@node History, , Preface, Preface
@comment  node-name,  next,  previous,  up
@unnumberedsec History of @code{awk} and @code{gawk}

@cindex acronym
@cindex history of @code{awk}
The name @code{awk} comes from the initials of its designers: Alfred V.
Aho, Peter J. Weinberger, and Brian W. Kernighan.  The original version of
@code{awk} was written in 1977.  In 1985 a new version made the programming
language more powerful, introducing user-defined functions, multiple input
streams, and computed regular expressions.
This new version became generally available with System V Release 3.1.
The version in System V Release 4 added some new features and also cleaned
up the behaviour in some of the ``dark corners'' of the language.@refill
@comment We don't refer people to non-free information
@comment  In 1988, the original authors
@comment published @cite{The AWK Programming Language} (Addison-Wesley, ISBN
@comment 0-201-07981-X), as a definitive description of the @code{awk} language.

The GNU implementation, @code{gawk}, was written in 1986 by Paul Rubin
and Jay Fenlason, with advice from Richard Stallman.  John Woods
contributed parts of the code as well.  In 1988 and 1989, David Trueman, with
help from Arnold Robbins, thoroughly reworked @code{gawk} for compatibility
with the newer @code{awk}.

Many people need to be thanked for their assistance in producing this
manual.  Jay Fenlason contributed many ideas and sample programs.  Richard
Mlynarik and Robert Chassell gave helpful comments on drafts of this
manual.  The paper @cite{A Supplemental Document for @code{awk}} by John W.
Pierce of the Chemistry Department at UC San Diego, pinpointed several
issues relevant both to @code{awk} implementation and to this manual, that
would otherwise have escaped us.

Finally, we would like to thank Brian Kernighan of Bell Labs for invaluable
assistance during the testing and debugging of @code{gawk}, and for
help in clarifying several points about the language.@refill

@node Copying, This Manual, Preface, Top
@unnumbered GNU General Public License
@center Version 1, February 1989

@display
Copyright @copyright{} 1989 Free Software Foundation, Inc.
675 Mass Ave, Cambridge, MA 02139, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

@c fakenode - this is for prepinfo.
@unnumberedsec Preamble

  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change free
software---to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.
You can use it for your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  The precise terms and conditions for copying, distribution and
modification follow.

@iftex
@c fakenode -- this is for prepinfo.
@unnumberedsec TERMS AND CONDITIONS
@end iftex
@ifinfo
@center TERMS AND CONDITIONS
@end ifinfo

@enumerate
@item
This License Agreement applies to any program or other work which
contains a notice placed by the copyright holder saying it may be
distributed under the terms of this General Public License.  The
``Program'', below, refers to any such program or work, and a ``work based
on the Program'' means either the Program or any work containing the
Program or a portion of it, either verbatim or with modifications.  Each
licensee is addressed as ``you''.

@item
You may copy and distribute verbatim copies of the Program's source
code as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
General Public License and to the absence of any warranty; and give any
other recipients of the Program a copy of this General Public License
along with the Program.  You may charge a fee for the physical act of
transferring a copy.

@item
You may modify your copy or copies of the Program or any portion of
it, and copy and distribute such modifications under the terms of Paragraph
1 above, provided that you also do the following:

@itemize @bullet
@item
cause the modified files to carry prominent notices stating that
you changed the files and the date of any change; and

@item
cause the whole of any work that you distribute or publish, that
in whole or in part contains the Program or any part thereof, either
with or without modifications, to be licensed at no charge to all
third parties under the terms of this General Public License (except
that you may choose to grant warranty protection to some or all
third parties, at your option).

@item
If the modified program normally reads commands interactively when
run, you must cause it, when started running for such interactive use
in the simplest and most usual way, to print or display an
announcement including an appropriate copyright notice and a notice
that there is no warranty (or else, saying that you provide a
warranty) and that users may redistribute the program under these
conditions, and telling the user how to view a copy of this General
Public License.

@item
You may charge a fee for the physical act of transferring a
copy, and you may at your option offer warranty protection in
exchange for a fee.
@end itemize

Mere aggregation of another independent work with the Program (or its
derivative) on a volume of a storage or distribution medium does not bring
the other work under the scope of these terms.

@item
You may copy and distribute the Program (or a portion or derivative of
it, under Paragraph 2) in object code or executable form under the terms of
Paragraphs 1 and 2 above provided that you also do one of the following:

@itemize @bullet
@item
accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of
Paragraphs 1 and 2 above; or,

@item
accompany it with a written offer, valid for at least three
years, to give any third party free (except for a nominal charge
for the cost of distribution) a complete machine-readable copy of the
corresponding source code, to be distributed under the terms of
Paragraphs 1 and 2 above; or,

@item
accompany it with the information you received as to where the
corresponding source code may be obtained.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form alone.)
@end itemize

Source code for a work means the preferred form of the work for making
modifications to it.  For an executable file, complete source code means
all the source code for all modules it contains; but, as a special
exception, it need not include source code for modules which are standard
libraries that accompany the operating system on which the executable
file runs, or for standard header files or definitions files that
accompany that operating system.

@item
You may not copy, modify, sublicense, distribute or transfer the
Program except as expressly provided under this General Public License.
Any attempt otherwise to copy, modify, sublicense, distribute or transfer
the Program is void, and will automatically terminate your rights to use
the Program under this License.  However, parties who have received
copies, or rights to use copies, from you under this General Public
License will not have their licenses terminated so long as such parties
remain in full compliance.

@item
By copying, distributing or modifying the Program (or any work based
on the Program) you indicate your acceptance of this license to do so,
and all its terms and conditions.

@item
Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the original
licensor to copy, distribute or modify the Program subject to these
terms and conditions.  You may not impose any further restrictions on the
recipients' exercise of the rights granted herein.

@item
The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of the license which applies to it and ``any
later version'', you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
the license, you may choose any version ever published by the Free Software
Foundation.

@item
If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

@iftex
@c fakenode -- this is for prepinfo.
@heading NO WARRANTY
@end iftex
@ifinfo
@center NO WARRANTY
@end ifinfo

@item
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

@item
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT
LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE
WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
@end enumerate

@iftex
@c fakenode -- this is for prepinfo.
@heading END OF TERMS AND CONDITIONS
@end iftex
@ifinfo
@center END OF TERMS AND CONDITIONS
@end ifinfo

@page
@c fakenode -- this is for prepinfo.
@unnumberedsec Appendix: Using These Terms in New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

  To do so, attach the following notices to the program.  It is safest to
attach them to the start of each source file to most effectively convey
the exclusion of warranty; and each file should have at least the
``copyright'' line and a pointer to where the full notice is found.

@smallexample
@var{one line to give the program's name and a brief idea of what it does.}
Copyright (C) 19@var{yy}  @var{name of author}

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@end smallexample

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

@smallexample
Gnomovision version 69, Copyright (C) 19@var{yy} @var{name of author}
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
@end smallexample

The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items---whatever suits your
program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  Here a sample; alter the names:

@example
Yoyodyne, Inc., hereby disclaims all copyright interest in the
program `Gnomovision' (a program to direct compilers to make passes
at assemblers) written by James Hacker.

@var{signature of Ty Coon}, 1 April 1989
Ty Coon, President of Vice
@end example

That's all there is to it!

@node This Manual, Getting Started, Copying, Top
@chapter Using This Manual
@cindex manual, using this
@cindex using this manual
@cindex language, @code{awk}
@cindex program, @code{awk}
@cindex @code{awk} language
@cindex @code{awk} program

The term @code{gawk} refers to a particular program (a version of
@code{awk}, developed as part the GNU project), and to the language you
use to tell this program what to do.  When we need to be careful, we
call the program ``the @code{awk} utility'' and the language ``the
@code{awk} language''.  The purpose of this manual is to explain the
@code{awk} language and how to run the @code{awk} utility.

The term @dfn{@code{awk} program} refers to a program written by you in
the @code{awk} programming language.@refill

@xref{Getting Started}, for the bare essentials you need to know to
start using @code{awk}.  

Some useful ``one-liners'' are included to give you a feel for the
@code{awk} language (@pxref{One-liners}).

@ignore
@strong{I deleted four paragraphs here because they would confuse the
beginner more than help him.  They mention terms such as ``field'',
``pattern'', ``action'', ``built-in function'' which the beginner
doesn't know.}

@strong{If you can find a way to introduce several of these concepts here,
enough to give the reader a map of what is to follow, that might
be useful.  I'm not sure that can be done without taking up more
space than ought to be used here.  There may be no way to win.}

@strong{ADR: I'd like to tackle this in phase 2 of my editing.}
@end ignore

A sizable sample @code{awk} program has been provided for you (@pxref{Sample
Program}).@refill

If you find terms that you aren't familiar with, try looking them
up in the glossary (@pxref{Glossary}).@refill

Most of the time complete @code{awk} programs are used as examples, but in
some of the more advanced sections, only the part of the @code{awk} program
that illustrates the concept being described is shown.@refill

@menu
This chapter contains the following sections:

* Sample Data Files::  Sample data files for use in the @code{awk} programs
                       illustrated in this manual.
@end menu

@node Sample Data Files, , This Manual, This Manual
@section Data Files for the Examples

@cindex input file, sample
@cindex sample input file
@cindex @file{BBS-list} file
Many of the examples in this manual take their input from two sample
data files.  The first, called @file{BBS-list}, represents a list of
computer bulletin board systems and information about those systems.
The second data file, called @file{inventory-shipped}, contains
information about shipments on a monthly basis.  Each line of these
files is one @dfn{record}.

In the file @file{BBS-list}, each record contains the name of a computer
bulletin board, its phone number, the board's baud rate, and a code for
the number of hours it is operational.  An @samp{A} in the last column
means the board operates 24 hours all week.  A @samp{B} in the last
column means the board operates evening and weekend hours, only.  A
@samp{C} means the board operates only on weekends.

@group
@example
aardvark     555-5553     1200/300          B
alpo-net     555-3412     2400/1200/300     A
barfly       555-7685     1200/300          A
bites        555-1675     2400/1200/300     A
camelot      555-0542     300               C
core         555-2912     1200/300          C
fooey        555-1234     2400/1200/300     B
foot         555-6699     1200/300          B
macfoo       555-6480     1200/300          A
sdace        555-3430     2400/1200/300     A
sabafoo      555-2127     1200/300          C
@end example
@end group

@cindex @file{inventory-shipped} file
The second data file, called @file{inventory-shipped}, represents
information about shipments during the year.  Each line of this file is
also one record.  Each record contains the month of the year, the number
of green crates shipped, the number of red boxes shipped, the number of
orange bags shipped, and the number of blue packages shipped,
respectively.  There are 16 entries, covering the 12 months of one year
and 4 months of the next year.

@group
@example
Jan  13  25  15 115
Feb  15  32  24 226
Mar  15  24  34 228
Apr  31  52  63 420
May  16  34  29 208
Jun  31  42  75 492
Jul  24  34  67 436
Aug  15  34  47 316
Sep  13  55  37 277
Oct  29  54  68 525
Nov  20  87  82 577
Dec  17  35  61 401

Jan  21  36  64 620
Feb  26  58  80 652
Mar  24  75  70 495
Apr  21  70  74 514
@end example
@end group

@ifinfo
If you are reading this in GNU Emacs using Info, you can copy the regions
of text showing these sample files into your own test files.  This way you
can try out the examples shown in the remainder of this document.  You do
this by using the command @kbd{M-x write-region} to copy text from the Info
file into a file for use with @code{awk} (see your @cite{GNU Emacs Manual}
for more information).  Using this information, create your own
@file{BBS-list} and @file{inventory-shipped} files, and practice what you
learn in this manual.
@end ifinfo

@node Getting Started, Reading Files, This Manual, Top
@chapter Getting Started With @code{awk}
@cindex script, definition of
@cindex rule, definition of
@cindex program, definition of
@cindex basic function of @code{gawk}

The basic function of @code{awk} is to search files for lines (or other
units of text) that contain certain patterns.  When a line matches one
of the patterns, @code{awk} performs specified actions on that line.
@code{awk} keeps processing input lines in this way until the end of the
input file is reached.@refill

When you run @code{awk}, you specify an @code{awk} @dfn{program} which
tells @code{awk} what to do.  The program consists of a series of
@dfn{rules}.  (It may also contain @dfn{function definitions}, but that
is an advanced feature, so let's ignore it for now.
@xref{User-defined}.)  Each rule specifies one pattern to search for,
and one action to perform when that pattern is found.

Syntactically, a rule consists of a pattern followed by an action.  The
action is enclosed in curly braces to separate it from the pattern.
Rules are usually separated by newlines.  Therefore, an @code{awk}
program looks like this:

@example
@var{pattern} @{ @var{action} @}
@var{pattern} @{ @var{action} @}
@dots{}
@end example

@menu
* Very Simple::      A very simple example.
* Two Rules::        A less simple one-line example with two rules.
* More Complex::     A more complex example.
* Running gawk::     How to run @code{gawk} programs; includes command line syntax.
* Comments::         Adding documentation to @code{gawk} programs.
* Statements/Lines:: Subdividing or combining statements into lines.
* When::             When to use @code{gawk} and when to use other things.
@end menu

@node Very Simple, Two Rules, Getting Started, Getting Started
@section A Very Simple Example

@cindex @samp{print $0}
The following command runs a simple @code{awk} program that searches the
input file @file{BBS-list} for the string of characters: @samp{foo}.  (A
string of characters is usually called, quite simply, a @dfn{string}.
The term @dfn{string} is perhaps based on similar usage in English, such
as ``a string of pearls,'' or, ``a string of cars in a train.'')

@example
awk '/foo/ @{ print $0 @}' BBS-list
@end example

@noindent
When lines containing @samp{foo} are found, they are printed, because
@w{@samp{print $0}} means print the current line.  (Just @samp{print} by
itself also means the same thing, so we could have written that
instead.)

You will notice that slashes, @samp{/}, surround the string @samp{foo}
in the actual @code{awk} program.  The slashes indicate that @samp{foo}
is a pattern to search for.  This type of pattern is called a
@dfn{regular expression}, and is covered in more detail later
(@pxref{Regexp}).  There are single-quotes around the @code{awk} program
so that the shell won't interpret any of it as special shell
characters.@refill

Here is what this program prints:

@example
fooey        555-1234     2400/1200/300     B
foot         555-6699     1200/300          B
macfoo       555-6480     1200/300          A
sabafoo      555-2127     1200/300          C
@end example

@cindex action, default
@cindex pattern, default
@cindex default action
@cindex default pattern
In an @code{awk} rule, either the pattern or the action can be omitted,
but not both.  If the pattern is omitted, then the action is performed
for @emph{every} input line.  If the action is omitted, the default
action is to print all lines that match the pattern.

Thus, we could leave out the action (the @code{print} statement and the curly
braces) in the above example, and the result would be the same: all
lines matching the pattern @samp{foo} would be printed.  By comparison,
omitting the @code{print} statement but retaining the curly braces makes an
empty action that does nothing; then no lines would be printed.

@node Two Rules, More Complex, Very Simple, Getting Started
@section An Example with Two Rules
@cindex how @code{awk} works

The @code{awk} utility reads the input files one line at a
time.  For each line, @code{awk} tries the patterns of all the rules.
If several patterns match then several actions are run, in the order in
which they appear in the @code{awk} program.  If no patterns match, then
no actions are run.

After processing all the rules (perhaps none) that match the line,
@code{awk} reads the next line (however, @pxref{Next Statement}).
This continues until the end of the file is reached.@refill

For example, the @code{awk} program:

@example
/12/  @{ print $0 @}
/21/  @{ print $0 @}
@end example

@noindent
contains two rules.  The first rule has the string @samp{12} as the
pattern and @samp{print $0} as the action.  The second rule has the
string @samp{21} as the pattern and also has @samp{print $0} as the
action.  Each rule's action is enclosed in its own pair of braces.

This @code{awk} program prints every line that contains the string
@samp{12} @emph{or} the string @samp{21}.  If a line contains both
strings, it is printed twice, once by each rule.

If we run this program on our two sample data files, @file{BBS-list} and
@file{inventory-shipped}, as shown here:

@example
awk '/12/ @{ print $0 @}
     /21/ @{ print $0 @}' BBS-list inventory-shipped
@end example

@noindent
we get the following output:

@example
aardvark     555-5553     1200/300          B
alpo-net     555-3412     2400/1200/300     A
barfly       555-7685     1200/300          A
bites        555-1675     2400/1200/300     A
core         555-2912     1200/300          C
fooey        555-1234     2400/1200/300     B
foot         555-6699     1200/300          B
macfoo       555-6480     1200/300          A
sdace        555-3430     2400/1200/300     A
sabafoo      555-2127     1200/300          C
sabafoo      555-2127     1200/300          C
Jan  21  36  64 620
Apr  21  70  74 514
@end example

@noindent
Note how the line in @file{BBS-list} beginning with @samp{sabafoo}
was printed twice, once for each rule.

@node More Complex, Running gawk, Two Rules, Getting Started
@comment  node-name,  next,  previous,  up
@section A More Complex Example

Here is an example to give you an idea of what typical @code{awk}
programs do.  This example shows how @code{awk} can be used to
summarize, select, and rearrange the output of another utility.  It uses
features that haven't been covered yet, so don't worry if you don't
understand all the details.

@example
ls -l | awk '$5 == "Nov" @{ sum += $4 @}
             END @{ print sum @}'
@end example

This command prints the total number of bytes in all the files in the
current directory that were last modified in November (of any year).
(In the C shell you would need to type a semicolon and then a backslash
at the end of the first line; in the Bourne shell or the Bourne-Again
shell, you can type the example as shown.)

The @w{@samp{ls -l}} part of this example is a command that gives you a full
listing of all the files in a directory, including file size and date.
Its output looks like this:

@example
-rw-r--r--  1 close        1933 Nov  7 13:05 Makefile
-rw-r--r--  1 close       10809 Nov  7 13:03 gawk.h
-rw-r--r--  1 close         983 Apr 13 12:14 gawk.tab.h
-rw-r--r--  1 close       31869 Jun 15 12:20 gawk.y
-rw-r--r--  1 close       22414 Nov  7 13:03 gawk1.c
-rw-r--r--  1 close       37455 Nov  7 13:03 gawk2.c
-rw-r--r--  1 close       27511 Dec  9 13:07 gawk3.c
-rw-r--r--  1 close        7989 Nov  7 13:03 gawk4.c
@end example

@noindent
The first field contains read-write permissions, the second field contains
the number of links to the file, and the third field identifies the owner of
the file.  The fourth field contains the size of the file in bytes.  The
fifth, sixth, and seventh fields contain the month, day, and time,
respectively, that the file was last modified.  Finally, the eighth field
contains the name of the file.

The @code{$5 == "Nov"} in our @code{awk} program is an expression that
tests whether the fifth field of the output from @w{@samp{ls -l}}
matches the string @samp{Nov}.  Each time a line has the string
@samp{Nov} in its fifth field, the action @samp{@{ sum += $4 @}} is
performed.  This adds the fourth field (the file size) to the variable
@code{sum}.  As a result, when @code{awk} has finished reading all the
input lines, @code{sum} is the sum of the sizes of files whose
lines matched the pattern.@refill

After the last line of output from @code{ls} has been processed, the
@code{END} rule is executed, and the value of @code{sum} is
printed.  In this example, the value of @code{sum} would be 80600.@refill

These more advanced @code{awk} techniques are covered in later sections
(@pxref{Actions}).  Before you can move on to more advanced @code{awk}
programming, you have to know how @code{awk} interprets your input and
displays your output.  By manipulating fields and using @code{print}
statements, you can produce some very useful and spectacular looking
reports.@refill


@node Running gawk, Comments, More Complex, Getting Started
@section How to Run @code{awk} Programs

@cindex command line formats
@cindex running @code{awk} programs
There are several ways to run an @code{awk} program.  If the program is
short, it is easiest to include it in the command that runs @code{awk},
like this:

@example
awk '@var{program}' @var{input-file1} @var{input-file2} @dots{}
@end example

@noindent
where @var{program} consists of a series of patterns and actions, as
described earlier.

When the program is long, you would probably prefer to put it in a file
and run it with a command like this:

@example
awk -f @var{program-file} @var{input-file1} @var{input-file2} @dots{}
@end example

@menu
* One-shot::            Running a short throw-away @code{awk} program.
* Read Terminal::       Using no input files (input from terminal instead).
* Long::                Putting permanent @code{awk} programs in files.
* Executable Scripts::  Making self-contained @code{awk} programs.
@end menu

@node One-shot, Read Terminal, Running gawk, Running gawk
@subsection One-shot Throw-away @code{awk} Programs

Once you are familiar with @code{awk}, you will often type simple
programs at the moment you want to use them.  Then you can write the
program as the first argument of the @code{awk} command, like this:

@example
awk '@var{program}' @var{input-file1} @var{input-file2} @dots{}
@end example

@noindent
where @var{program} consists of a series of @var{patterns} and
@var{actions}, as described earlier.

@cindex single quotes, why needed
This command format tells the shell to start @code{awk} and use the
@var{program} to process records in the input file(s).  There are single
quotes around the @var{program} so that the shell doesn't interpret any
@code{awk} characters as special shell characters.  They cause the
shell to treat all of @var{program} as a single argument for
@code{awk}.  They also allow @var{program} to be more than one line
long.@refill

This format is also useful for running short or medium-sized @code{awk}
programs from shell scripts, because it avoids the need for a separate
file for the @code{awk} program.  A self-contained shell script is more
reliable since there are no other files to misplace.

@node Read Terminal, Long, One-shot, Running gawk
@subsection Running @code{awk} without Input Files

@cindex standard input
@cindex input, standard
You can also use @code{awk} without any input files.  If you type the
command line:@refill

@example
awk '@var{program}'
@end example

@noindent
then @code{awk} applies the @var{program} to the @dfn{standard input},
which usually means whatever you type on the terminal.  This continues
until you indicate end-of-file by typing @kbd{Control-d}.

For example, if you execute this command:

@example
awk '/th/'
@end example

@noindent
whatever you type next is taken as data for that @code{awk}
program.  If you go on to type the following data:

@example
Kathy
Ben
Tom
Beth
Seth
Karen
Thomas
@kbd{Control-d}
@end example

@noindent
then @code{awk} prints this output:

@example
Kathy
Beth
Seth
@end example

@noindent
@cindex case sensitivity
@cindex pattern, case sensitive
as matching the pattern @samp{th}.  Notice that it did not recognize
@samp{Thomas} as matching the pattern.  The @code{awk} language is
@dfn{case sensitive}, and matches patterns exactly.  (However, you can
override this with the variable @code{IGNORECASE}.
@xref{Case-sensitivity}.)

@node Long, Executable Scripts, Read Terminal, Running gawk
@subsection Running Long Programs

@cindex running long programs
@cindex @samp{-f} option
@cindex program file
@cindex file, @code{awk} program
Sometimes your @code{awk} programs can be very long.  In this case it is
more convenient to put the program into a separate file.  To tell
@code{awk} to use that file for its program, you type:@refill

@example
awk -f @var{source-file} @var{input-file1} @var{input-file2} @dots{}
@end example

The @samp{-f} tells the @code{awk} utility to get the @code{awk} program
from the file @var{source-file}.  Any file name can be used for
@var{source-file}.  For example, you could put the program:@refill

@example
/th/
@end example

@noindent
into the file @file{th-prog}.  Then this command:

@example
awk -f th-prog
@end example

@noindent
does the same thing as this one:

@example
awk '/th/'
@end example

@noindent
which was explained earlier (@pxref{Read Terminal}).  Note that you
don't usually need single quotes around the file name that you specify
with @samp{-f}, because most file names don't contain any of the shell's
special characters.

If you want to identify your @code{awk} program files clearly as such,
you can add the extension @file{.awk} to the file name.  This doesn't
affect the execution of the @code{awk} program, but it does make
``housekeeping'' easier.

@node Executable Scripts,  , Long, Running gawk
@c node-name, next, previous, up
@subsection Executable @code{awk} Programs
@cindex executable scripts
@cindex scripts, executable
@cindex self contained programs
@cindex program, self contained
@cindex @samp{#!}

Once you have learned @code{awk}, you may want to write self-contained
@code{awk} scripts, using the @samp{#!} script mechanism.  You can do
this on BSD Unix systems and (someday) on GNU.

For example, you could create a text file named @file{hello}, containing
the following (where @samp{BEGIN} is a feature we have not yet
discussed):

@example
#! /bin/awk -f

# a sample awk program
BEGIN    @{ print "hello, world" @}
@end example

@noindent
After making this file executable (with the @code{chmod} command), you
can simply type:

@example
hello
@end example

@noindent
at the shell, and the system will arrange to run @code{awk} as if you
had typed:

@example
awk -f hello
@end example

@noindent
Self-contained @code{awk} scripts are useful when you want to write a
program which users can invoke without knowing that the program is
written in @code{awk}.

@cindex shell scripts
@cindex scripts, shell
If your system does not support the @samp{#!} mechanism, you can get a
similar effect using a regular shell script.  It would look something
like this:

@example
: The colon makes sure this script is executed by the Bourne shell.
awk '@var{program}' "$@@"
@end example

Using this technique, it is @emph{vital} to enclose the @var{program} in
single quotes to protect it from interpretation by the shell.  If you
omit the quotes, only a shell wizard can predict the result.

The @samp{"$@@"} causes the shell to forward all the command line
arguments to the @code{awk} program, without interpretation.  The first
line, which starts with a colon, is used so that this shell script will
work even if invoked by a user who uses the C shell.
@c Someday: (See @cite{The Bourne Again Shell}, by ??.)

@c We don't refer to hoarded information.
@c  (See
@c @cite{The UNIX Programming Environment} by Brian Kernighan and Rob Pike,
@c Prentice-Hall, 1984, for more information on writing shell programs that
@c use the Unix utilities.  The most powerful version of the shell is the
@c Korn shell.  A detailed description of the Korn shell can be found in
@c @cite{The KornShell Command and Programming Language} by Morris Bolsky
@c and David Korn, Prentice-Hall, 1989.)

@node Comments, Statements/Lines, Running gawk, Getting Started
@section Comments in @code{awk} Programs
@cindex comments
@cindex use of comments
@cindex documenting @code{awk} programs
@cindex programs, documenting

A @dfn{comment} is some text that is included in a program for the sake
of human readers, and that is not really part of the program.  Comments
can explain what the program does, and how it works.  Nearly all
programming languages have provisions for comments, because programs are
hard to understand without their extra help.

In the @code{awk} language, a comment starts with the sharp sign
character, @samp{#}, and continues to the end of the line.  The
@code{awk} language ignores the rest of a line following a sharp sign.
For example, we could have put the following into @file{th-prog}:@refill

@example
# This program finds records containing the pattern @samp{th}.  This is how
# you continue comments on additional lines.
/th/
@end example

You can put comment lines into keyboard-composed throw-away @code{awk}
programs also, but this usually isn't very useful; the purpose of a
comment is to help you or another person understand the program at
another time.

@node Statements/Lines, When, Comments, Getting Started
@section @code{awk} Statements versus Lines

Most often, each line in an @code{awk} program is a separate statement or
separate rule, like this:

@example
awk '/12/  @{ print $0 @}
     /21/  @{ print $0 @}' BBS-list inventory-shipped
@end example

But sometimes statements can be more than one line, and lines can
contain several statements.  You can split a statement into multiple
lines by inserting a newline after any of the following:

@example
,    @{    ?    :    ||    &&    do    else
@end example

@noindent
A newline at any other point is considered the end of the statement.

@cindex backslash continuation
@cindex continuation of lines
If you would like to split a single statement into two lines at a point
where a newline would terminate it, you can @dfn{continue} it by ending the
first line with a backslash character, @samp{\}.  This is allowed
absolutely anywhere in the statement, even in the middle of a string or
regular expression.  For example:

@example
awk '/This program is too long, so continue it\
 on the next line/ @{ print $1 @}'
@end example

@noindent
We have generally not used backslash continuation in the sample programs in
this manual.  Since there is no limit on the length of a line, it is never
strictly necessary; it just makes programs prettier.  We have preferred to
make them even more pretty by keeping the statements short.  Backslash
continuation is most useful when your @code{awk} program is in a separate
source file, instead of typed in on the command line.

@strong{Warning: backslash continuation does not work as described above
with the C shell.}  Continuation with backslash works for @code{awk}
programs in files, and also for one-shot programs @emph{provided} you
are using the Bourne shell or the Bourne-again shell.  But the C shell
used on Berkeley Unix behaves differently!  There, you must use two
backslashes in a row, followed by a newline.@refill

@cindex multiple statements on one line
When @code{awk} statements within one rule are short, you might want to put
more than one of them on a line.  You do this by separating the statements
with semicolons, @samp{;}.
This also applies to the rules themselves.
Thus, the above example program could have been written:@refill

@example
/12/ @{ print $0 @} ; /21/ @{ print $0 @}
@end example

@noindent
@strong{Note:} the requirement that rules on the same line must be
separated with a semicolon is a recent change in the @code{awk}
language; it was done for consistency with the treatment of statements
within an action.

@node When, , Statements/Lines, Getting Started
@section When to Use @code{awk}

@cindex when to use @code{awk}
@cindex applications of @code{awk}
What use is all of this to me, you might ask?  Using additional utility
programs, more advanced patterns, field separators, arithmetic
statements, and other selection criteria, you can produce much more
complex output.  The @code{awk} language is very useful for producing
reports from large amounts of raw data, such as summarizing information
from the output of other utility programs such as @code{ls}.
(@xref{More Complex, , A More Complex Example}.)

Programs written with @code{awk} are usually much smaller than they would
be in other languages.  This makes @code{awk} programs easy to compose and
use.  Often @code{awk} programs can be quickly composed at your terminal,
used once, and thrown away.  Since @code{awk} programs are interpreted, you
can avoid the usually lengthy edit-compile-test-debug cycle of software
development.

Complex programs have been written in @code{awk}, including a complete
retargetable assembler for 8-bit microprocessors (@pxref{Glossary}, for
more information) and a microcode assembler for a special purpose Prolog
computer.  However, @code{awk}'s capabilities are strained by tasks of
such complexity.

If you find yourself writing @code{awk} scripts of more than, say, a few
hundred lines, you might consider using a different programming
language.  Emacs Lisp is a good choice if you need sophisticated string
or pattern matching capabilities.  The shell is also good at string and
pattern matching; in addition, it allows powerful use of the system
utilities.  More conventional languages, such as C, C++, and Lisp, offer
better facilities for system programming and for managing the complexity
of large programs.  Programs in these languages may require more lines
of source code than the equivalent @code{awk} programs, but they are
easier to maintain and usually run more efficiently.@refill

@node Reading Files, Printing, Getting Started, Top
@chapter Reading Input Files

@cindex reading files
@cindex input
@cindex standard input
@vindex FILENAME
In the typical @code{awk} program, all input is read either from the
standard input (usually the keyboard) or from files whose names you
specify on the @code{awk} command line.  If you specify input files,
@code{awk} reads data from the first one until it reaches the end; then
it reads the second file until it reaches the end, and so on.  The name
of the current input file can be found in the built-in variable
@code{FILENAME} (@pxref{Built-in Variables}).@refill

The input is read in units called @dfn{records}, and processed by the
rules one record at a time.  By default, each record is one line.  Each
record read is split automatically into @dfn{fields}, to make it more
convenient for a rule to work on parts of the record under
consideration.

On rare occasions you will need to use the @code{getline} command,
which can do explicit input from any number of files (@pxref{Getline}).

@menu
* Records::             Controlling how data is split into records.
* Fields::              An introduction to fields.
* Non-Constant Fields:: Non-constant Field Numbers.
* Changing Fields::     Changing the Contents of a Field.
* Field Separators::    The field separator and how to change it.
* Multiple Line::       Reading multi-line records.

* Getline::             Reading files under explicit program control
                        using the @code{getline} function.

* Close Input::         Closing an input file (so you can read from
                        the beginning once more).
@end menu

@node Records, Fields, Reading Files, Reading Files
@section How Input is Split into Records

@cindex record separator
The @code{awk} language divides its input into records and fields.
Records are separated by a character called the @dfn{record separator}.
By default, the record separator is the newline character.  Therefore,
normally, a record is a line of text.@refill

@c @cindex changing the record separator
@vindex RS
Sometimes you may want to use a different character to separate your
records.  You can use different characters by changing the built-in
variable @code{RS}.  

The value of @code{RS} is a string that says how to separate records;
the default value is @code{"\n"}, the string of just a newline
character.  This is why records are, by default, single lines.

@code{RS} can have any string as its value, but only the first character
of the string is used as the record separator.  The other characters are
ignored.  @code{RS} is exceptional in this regard; @code{awk} uses the
full value of all its other built-in variables.@refill

@ignore
Someday this should be true!

The value of @code{RS} is not limited to a one-character string.  It can
be any regular expression (@pxref{Regexp}).  In general, each record
ends at the next string that matches the regular expression; the next
record starts at the end of the matching string.  This general rule is
actually at work in the usual case, where @code{RS} contains just a
newline: a record ends at the beginning of the next matching string (the
next newline in the input) and the following record starts just after
the end of this string (at the first character of the following line).
The newline, since it matches @code{RS}, is not part of either record.
@end ignore

You can change the value of @code{RS} in the @code{awk} program with the
assignment operator, @samp{=} (@pxref{Assignment Ops}).  The new
record-separator character should be enclosed in quotation marks to make
a string constant.  Often the right time to do this is at the beginning
of execution, before any input has been processed, so that the very
first record will be read with the proper separator.  To do this, use
the special @code{BEGIN} pattern (@pxref{BEGIN/END}).  For
example:@refill

@example
awk 'BEGIN @{ RS = "/" @} ; @{ print $0 @}' BBS-list
@end example

@noindent
changes the value of @code{RS} to @code{"/"}, before reading any input.
This is a string whose first character is a slash; as a result, records
are separated by slashes.  Then the input file is read, and the second
rule in the @code{awk} program (the action with no pattern) prints each
record.  Since each @code{print} statement adds a newline at the end of
its output, the effect of this @code{awk} program is to copy the input
with each slash changed to a newline.

Another way to change the record separator is on the command line,
using the variable-assignment feature (@pxref{Command Line}).

@example
awk '@dots{}' RS="/" @var{source-file}
@end example

@noindent
This sets @code{RS} to @samp{/} before processing @var{source-file}.

The empty string (a string of no characters) has a special meaning
as the value of @code{RS}: it means that records are separated only
by blank lines.  @xref{Multiple Line}, for more details.

@cindex number of records, @code{NR} or @code{FNR}
@vindex NR
@vindex FNR
The @code{awk} utility keeps track of the number of records that have
been read so far from the current input file.  This value is stored in a
built-in variable called @code{FNR}.  It is reset to zero when a new
file is started.  Another built-in variable, @code{NR}, is the total
number of input records read so far from all files.  It starts at zero
but is never automatically reset to zero.

If you change the value of @code{RS} in the middle of an @code{awk} run,
the new value is used to delimit subsequent records, but the record
currently being processed (and records already finished) are not
affected.

@node Fields, Non-Constant Fields, Records, Reading Files
@section Examining Fields

@cindex examining fields
@cindex fields
@cindex accessing fields
When @code{awk} reads an input record, the record is
automatically separated or @dfn{parsed} by the interpreter into pieces
called @dfn{fields}.  By default, fields are separated by whitespace,
like words in a line.
Whitespace in @code{awk} means any string of one or more spaces and/or
tabs; other characters such as newline, formfeed, and so on, that are
considered whitespace by other languages are @emph{not} considered
whitespace by @code{awk}.

The purpose of fields is to make it more convenient for you to refer to
these pieces of the record.  You don't have to use them---you can
operate on the whole record if you wish---but fields are what make
simple @code{awk} programs so powerful.

@cindex @code{$} (field operator)
@cindex operators, @code{$}
To refer to a field in an @code{awk} program, you use a dollar-sign,
@samp{$}, followed by the number of the field you want.  Thus, @code{$1}
refers to the first field, @code{$2} to the second, and so on.  For
example, suppose the following is a line of input:@refill

@example
This seems like a pretty nice example.
@end example

@noindent
Here the first field, or @code{$1}, is @samp{This}; the second field, or
@code{$2}, is @samp{seems}; and so on.  Note that the last field,
@code{$7}, is @samp{example.}.  Because there is no space between the
@samp{e} and the @samp{.}, the period is considered part of the seventh
field.@refill

No matter how many fields there are, the last field in a record can be
represented by @code{$NF}.  So, in the example above, @code{$NF} would
be the same as @code{$7}, which is @samp{example.}.  Why this works is
explained below (@pxref{Non-Constant Fields}).  If you try to refer to a
field beyond the last one, such as @code{$8} when the record has only 7
fields, you get the empty string.

@vindex NF
@cindex number of fields, @code{NF}
Plain @code{NF}, with no @samp{$}, is a built-in variable whose value
is the number of fields in the current record.

@code{$0}, which looks like an attempt to refer to the zeroth field, is
a special case: it represents the whole input record.  This is what you
would use when you aren't interested in fields.

Here are some more examples:

@example
awk '$1 ~ /foo/ @{ print $0 @}' BBS-list
@end example

@noindent
This example prints each record in the file @file{BBS-list} whose first
field contains the string @samp{foo}.  The operator @samp{~} is called a
@dfn{matching operator} (@pxref{Comparison Ops}); it tests whether a
string (here, the field @code{$1}) contains a match for a given regular
expression.@refill

By contrast, the following example:

@example
awk '/foo/ @{ print $1, $NF @}' BBS-list
@end example

@noindent
looks for @samp{foo} in @emph{the entire record} and prints the first
field and the last field for each input record containing a
match.@refill

@node Non-Constant Fields, Changing Fields, Fields, Reading Files
@section Non-constant Field Numbers

The number of a field does not need to be a constant.  Any expression in
the @code{awk} language can be used after a @samp{$} to refer to a
field.  The value of the expression specifies the field number.  If the
value is a string, rather than a number, it is converted to a number.
Consider this example:@refill

@example
awk '@{ print $NR @}'
@end example

@noindent
Recall that @code{NR} is the number of records read so far: 1 in the
first record, 2 in the second, etc.  So this example prints the first
field of the first record, the second field of the second record, and so
on.  For the twentieth record, field number 20 is printed; most likely,
the record has fewer than 20 fields, so this prints a blank line.

Here is another example of using expressions as field numbers:

@example
awk '@{ print $(2*2) @}' BBS-list
@end example

The @code{awk} language must evaluate the expression @code{(2*2)} and use
its value as the number of the field to print.  The @samp{*} sign
represents multiplication, so the expression @code{2*2} evaluates to 4.
The parentheses are used so that the multiplication is done before the
@samp{$} operation; they are necessary whenever there is a binary
operator in the field-number expression.  This example, then, prints the
hours of operation (the fourth field) for every line of the file
@file{BBS-list}.@refill

If the field number you compute is zero, you get the entire record.
Thus, @code{$(2-2)} has the same value as @code{$0}.  Negative field
numbers are not allowed.

The number of fields in the current record is stored in the built-in
variable @code{NF} (@pxref{Built-in Variables}).  The expression
@code{$NF} is not a special feature: it is the direct consequence of
evaluating @code{NF} and using its value as a field number.

@node Changing Fields, Field Separators, Non-Constant Fields, Reading Files
@section Changing the Contents of a Field

@cindex field, changing contents of
@cindex changing contents of a field
@cindex assignment to fields
You can change the contents of a field as seen by @code{awk} within an
@code{awk} program; this changes what @code{awk} perceives as the
current input record.  (The actual input is untouched: @code{awk} never
modifies the input file.)

Look at this example:

@example
awk '@{ $3 = $2 - 10; print $2, $3 @}' inventory-shipped
@end example

@noindent
The @samp{-} sign represents subtraction, so this program reassigns
field three, @code{$3}, to be the value of field two minus ten,
@code{$2 - 10}.  (@xref{Arithmetic Ops}.)  Then field two, and the
new value for field three, are printed.  

In order for this to work, the text in field @code{$2} must make sense
as a number; the string of characters must be converted to a number in
order for the computer to do arithmetic on it.  The number resulting
from the subtraction is converted back to a string of characters which
then becomes field three.  @xref{Conversion}.

When you change the value of a field (as perceived by @code{awk}), the
text of the input record is recalculated to contain the new field where
the old one was.  Therefore, @code{$0} changes to reflect the altered
field.  Thus,

@example
awk '@{ $2 = $2 - 10; print $0 @}' inventory-shipped
@end example

@noindent
prints a copy of the input file, with 10 subtracted from the second
field of each line.

You can also assign contents to fields that are out of range.  For
example:

@example
awk '@{ $6 = ($5 + $4 + $3 + $2) ; print $6 @}' inventory-shipped
@end example

@noindent
We've just created @code{$6}, whose value is the sum of fields
@code{$2}, @code{$3}, @code{$4}, and @code{$5}.  The @samp{+} sign
represents addition.  For the file @file{inventory-shipped}, @code{$6}
represents the total number of parcels shipped for a particular month.

Creating a new field changes the internal @code{awk} copy of the current
input record---the value of @code{$0}.  Thus, if you do @samp{print $0}
after adding a field, the record printed includes the new field, with
the appropriate number of field separators between it and the previously
existing fields.

This recomputation affects and is affected by several features not yet
discussed, in particular, the @dfn{output field separator}, @code{OFS},
which is used to separate the fields (@pxref{Output Separators}), and
@code{NF} (the number of fields; @pxref{Fields}).  For example, the
value of @code{NF} is set to the number of the highest field you
create.@refill

Note, however, that merely @emph{referencing} an out-of-range field
does @emph{not} change the value of either @code{$0} or @code{NF}.
Referencing an out-of-range field merely produces a null string.  For
example:@refill

@example
if ($(NF+1) != "")
    print "can't happen"
else
    print "everything is normal"
@end example

@noindent
should print @samp{everything is normal}, because @code{NF+1} is certain
to be out of range.  (@xref{If Statement}, for more information about
@code{awk}'s @code{if-else} statements.)

@node Field Separators, Multiple Line, Changing Fields, Reading Files
@section Specifying How Fields Are Separated
@vindex FS
@cindex fields, separating
@cindex field separator, @code{FS}
@cindex @samp{-F} option

The way @code{awk} splits an input record into fields is controlled by
the @dfn{field separator}, which is a single character or a regular
expression.  @code{awk} scans the input record for matches for the
separator; the fields themselves are the text between the matches.  For
example, if the field separator is @samp{oo}, then the following line:

@example
moo goo gai pan
@end example

@noindent
would be split into three fields: @samp{m}, @samp{@ g} and @samp{@ gai@ 
pan}.

The field separator is represented by the built-in variable @code{FS}.
Shell programmers take note!  @code{awk} does not use the name
@code{IFS} which is used by the shell.@refill

You can change the value of @code{FS} in the @code{awk} program with the
assignment operator, @samp{=} (@pxref{Assignment Ops}).  Often the right
time to do this is at the beginning of execution, before any input has
been processed, so that the very first record will be read with the
proper separator.  To do this, use the special @code{BEGIN} pattern
(@pxref{BEGIN/END}).  For example, here we set the value of @code{FS} to
the string @code{","}:

@example
awk 'BEGIN @{ FS = "," @} ; @{ print $2 @}'
@end example

@noindent
Given the input line,

@example
John Q. Smith, 29 Oak St., Walamazoo, MI 42139
@end example

@noindent
this @code{awk} program extracts the string @samp{29 Oak St.}.

@cindex field separator, choice of
@cindex regular expressions as field separators
Sometimes your input data will contain separator characters that don't
separate fields the way you thought they would.  For instance, the
person's name in the example we've been using might have a title or
suffix attached, such as @samp{John Q. Smith, LXIX}.  From input
containing such a name:

@example
John Q. Smith, LXIX, 29 Oak St., Walamazoo, MI 42139
@end example

@noindent
the previous sample program would extract @samp{LXIX}, instead of
@samp{29 Oak St.}.  If you were expecting the program to print the
address, you would be surprised.  So choose your data layout and
separator characters carefully to prevent such problems.

As you know, by default, fields are separated by whitespace sequences
(spaces and tabs), not by single spaces: two spaces in a row do not
delimit an empty field.  The default value of the field separator is a
string @w{@code{" "}} containing a single space.  If this value were
interpreted in the usual way, each space character would separate
fields, so two spaces in a row would make an empty field between them.
The reason this does not happen is that a single space as the value of
@code{FS} is a special case: it is taken to specify the default manner
of delimiting fields.

If @code{FS} is any other single character, such as @code{","}, then
each occurrence of that character separates two fields.  Two consecutive
occurrences delimit an empty field.  If the character occurs at the
beginning or the end of the line, that too delimits an empty field.  The
space character is the only single character which does not follow these
rules.

More generally, the value of @code{FS} may be a string containing any
regular expression.  Then each match in the record for the regular
expression separates fields.  For example, the assignment:@refill

@example
FS = ", \t"
@end example

@noindent
makes every area of an input line that consists of a comma followed by a
space and a tab, into a field separator.  (@samp{\t} stands for a
tab.)@refill

For a less trivial example of a regular expression, suppose you want
single spaces to separate fields the way single commas were used above.
You can set @code{FS} to @w{@code{"[@ ]"}}.  This regular expression
matches a single space and nothing else.

@cindex field separator, setting on command line
@cindex command line, setting @code{FS} on
@code{FS} can be set on the command line.  You use the @samp{-F} argument to
do so.  For example:

@example
awk -F, '@var{program}' @var{input-files}
@end example

@noindent
sets @code{FS} to be the @samp{,} character.  Notice that the argument uses
a capital @samp{F}.  Contrast this with @samp{-f}, which specifies a file
containing an @code{awk} program.  Case is significant in command options:
the @samp{-F} and @samp{-f} options have nothing to do with each other.
You can use both options at the same time to set the @code{FS} argument
@emph{and} get an @code{awk} program from a file.

As a special case, in compatibility mode (@pxref{Command Line}), if the
argument to @samp{-F} is @samp{t}, then @code{FS} is set to the tab
character.  (This is because if you type @samp{-F\t}, without the quotes,
at the shell, the @samp{\} gets deleted, so @code{awk} figures that you
really want your fields to be separated with tabs, and not @samp{t}s.
Use @samp{FS="t"} on the command line if you really do want to separate
your fields with @samp{t}s.)

For example, let's use an @code{awk} program file called @file{baud.awk}
that contains the pattern @code{/300/}, and the action @samp{print $1}.
Here is the program:

@example
/300/   @{ print $1 @}
@end example

Let's also set @code{FS} to be the @samp{-} character, and run the
program on the file @file{BBS-list}.  The following command prints a
list of the names of the bulletin boards that operate at 300 baud and
the first three digits of their phone numbers:@refill

@example
awk -F- -f baud.awk BBS-list
@end example

@noindent
It produces this output:

@example
aardvark     555
alpo
barfly       555
bites        555
camelot      555
core         555
fooey        555
foot         555
macfoo       555
sdace        555
sabafoo      555
@end example

@noindent
Note the second line of output.  If you check the original file, you will
see that the second line looked like this:

@example
alpo-net     555-3412     2400/1200/300     A
@end example

The @samp{-} as part of the system's name was used as the field
separator, instead of the @samp{-} in the phone number that was
originally intended.  This demonstrates why you have to be careful in
choosing your field and record separators.

The following program searches the system password file, and prints
the entries for users who have no password:

@example
awk -F: '$2 == ""' /etc/passwd
@end example

@noindent
Here we use the @samp{-F} option on the command line to set the field
separator.  Note that fields in @file{/etc/passwd} are separated by
colons.  The second field represents a user's encrypted password, but if
the field is empty, that user has no password.

@node Multiple Line, Getline, Field Separators, Reading Files
@section Multiple-Line Records

@cindex multiple line records
@cindex input, multiple line records
@cindex reading files, multiple line records
@cindex records, multiple line
In some data bases, a single line cannot conveniently hold all the
information in one entry.  In such cases, you can use multi-line
records.

The first step in doing this is to choose your data format: when records
are not defined as single lines, how do you want to define them?
What should separate records?

One technique is to use an unusual character or string to separate
records.  For example, you could use the formfeed character (written
@samp{\f} in @code{awk}, as in C) to separate them, making each record
a page of the file.  To do this, just set the variable @code{RS} to
@code{"\f"} (a string containing the formfeed character).  Any
other character could equally well be used, as long as it won't be part
of the data in a record.

@ignore
Another technique is to have blank lines separate records.  The string
@code{"^\n+"} is a regular expression that matches any sequence of
newlines starting at the beginning of a line---in other words, it
matches a sequence of blank lines.  If you set @code{RS} to this string,
a record always ends at the first blank line encountered.  In
addition, a regular expression always matches the longest possible
sequence when there is a choice.  So the next record doesn't start until
the first nonblank line that follows---no matter how many blank lines
appear in a row, they are considered one record-separator.
@end ignore

Another technique is to have blank lines separate records.  By a special
dispensation, a null string as the value of @code{RS} indicates that
records are separated by one or more blank lines.  If you set @code{RS}
to the null string, a record always ends at the first blank line
encountered.  And the next record doesn't start until the first nonblank
line that follows---no matter how many blank lines appear in a row, they
are considered one record-separator.

The second step is to separate the fields in the record.  One way to do
this is to put each field on a separate line: to do this, just set the
variable @code{FS} to the string @code{"\n"}.  (This simple regular
expression matches a single newline.)

Another idea is to divide each of the lines into fields in the normal
manner.  This happens by default as a result of a special feature: when
@code{RS} is set to the null string, the newline character @emph{always}
acts as a field separator.  This is in addition to whatever field
separations result from @code{FS}.

The original motivation for this special exception was probably so that
you get useful behavior in the default case (i.e., @w{@code{FS == "
"}}).  This feature can be a problem if you really don't want the
newline character to separate fields, since there is no way to
prevent it.  However, you can work around this by using the @code{split}
function to break up the record manually (@pxref{String Functions}).

@ignore
Here are two ways to use records separated by blank lines and break each
line into fields normally:

@example
awk 'BEGIN @{ RS = ""; FS = "[ \t\n]+" @} @{ print $1 @}' BBS-list

@exdent @r{or}

awk 'BEGIN @{ RS = "^\n+"; FS = "[ \t\n]+" @} @{ print $1 @}' BBS-list
@end example
@end ignore

@ignore
Here is how to use records separated by blank lines and break each
line into fields normally:

@example
awk 'BEGIN @{ RS = ""; FS = "[ \t\n]+" @} ; @{ print $1 @}' BBS-list
@end example
@end ignore

@node Getline, Close Input, Multiple Line, Reading Files
@section Explicit Input with @code{getline}

@findex getline
@cindex input, explicit
@cindex explicit input
@cindex input, @code{getline} command
@cindex reading files, @code{getline} command
So far we have been getting our input files from @code{awk}'s main
input stream---either the standard input (usually your terminal) or the
files specified on the command line.  The @code{awk} language has a
special built-in command called @code{getline} that
can be used to read input under your explicit control.

This command is quite complex and should @emph{not} be used by
beginners.  It is covered here because this is the chapter on input.
The examples that follow the explanation of the @code{getline} command
include material that has not been covered yet.  Therefore, come back
and study the @code{getline} command @emph{after} you have reviewed the
rest of this manual and have a good knowledge of how @code{awk} works.

@code{getline} returns 1 if it finds a record, and 0 if the end of the
file is encountered.  If there is some error in getting a record, such
as a file that cannot be opened, then @code{getline} returns @minus{}1.

In the following examples, @var{command} stands for a string value that
represents a shell command.

@table @code
@item getline
The @code{getline} command can be used without arguments to read input
from the current input file.  All it does in this case is read the next
input record and split it up into fields.  This is useful if you've
finished processing the current record, but you want to do some special
processing @emph{right now} on the next record.  Here's an
example:@refill

@example
awk '@{
     if (t = index($0, "/*")) @{
          if(t > 1)
               tmp = substr($0, 1, t - 1)
          else
               tmp = ""
          u = index(substr($0, t + 2), "*/")
          while (! u) @{
               getline
               t = -1
               u = index($0, "*/")
          @}
          if(u <= length($0) - 2)
               $0 = tmp substr($0, t + u + 3)
          else
               $0 = tmp
     @}
     print $0
@}'
@end example

This @code{awk} program deletes all comments, @samp{/* @dots{}
*/}, from the input.  By replacing the @samp{print $0} with other
statements, you could perform more complicated processing on the
decommented input, such as searching it for matches for a regular
expression.

This form of the @code{getline} command sets @code{NF} (the number of
fields; @pxref{Fields}), @code{NR} (the number of records read so far;
@pxref{Records}), @code{FNR} (the number of records read from this input
file), and the value of @code{$0}.

@strong{Note:} the new value of @code{$0} is used in testing
the patterns of any subsequent rules.  The original value
of @code{$0} that triggered the rule which executed @code{getline}
is lost.  By contrast, the @code{next} statement reads a new record
but immediately begins processing it normally, starting with the first
rule in the program.  @xref{Next Statement}.

@item getline @var{var}
This form of @code{getline} reads a record into the variable @var{var}.
This is useful when you want your program to read the next record from
the current input file, but you don't want to subject the record to the
normal input processing.

For example, suppose the next line is a comment, or a special string,
and you want to read it, but you must make certain that it won't trigger
any rules.  This version of @code{getline} allows you to read that line
and store it in a variable so that the main
read-a-line-and-check-each-rule loop of @code{awk} never sees it.

The following example swaps every two lines of input.  For example, given:

@example
wan
tew
free
phore
@end example

@noindent
it outputs:

@example
tew
wan
phore
free
@end example

@noindent
Here's the program:

@example
awk '@{
     if ((getline tmp) > 0) @{
          print tmp
          print $0
     @} else
          print $0
@}'
@end example

The @code{getline} function used in this way sets only the variables
@code{NR} and @code{FNR} (and of course, @var{var}).  The record is not
split into fields, so the values of the fields (including @code{$0}) and
the value of @code{NF} do not change.@refill

@item getline < @var{file}
@cindex input redirection
@cindex redirection of input
This form of the @code{getline} function takes its input from the file
@var{file}.  Here @var{file} is a string-valued expression that
specifies the file name.  @samp{< @var{file}} is called a @dfn{redirection}
since it directs input to come from a different place.

This form is useful if you want to read your input from a particular
file, instead of from the main input stream.  For example, the following
program reads its input record from the file @file{foo.input} when it
encounters a first field with a value equal to 10 in the current input
file.@refill

@example
awk '@{
if ($1 == 10) @{
     getline < "foo.input"
     print
@} else
     print
@}'
@end example

Since the main input stream is not used, the values of @code{NR} and
@code{FNR} are not changed.  But the record read is split into fields in
the normal manner, so the values of @code{$0} and other fields are
changed.  So is the value of @code{NF}.

This does not cause the record to be tested against all the patterns
in the @code{awk} program, in the way that would happen if the record
were read normally by the main processing loop of @code{awk}.  However
the new record is tested against any subsequent rules, just as when
@code{getline} is used without a redirection.

@item getline @var{var} < @var{file}
This form of the @code{getline} function takes its input from the file
@var{file} and puts it in the variable @var{var}.  As above, @var{file}
is a string-valued expression that specifies the file to read from.

In this version of @code{getline}, none of the built-in variables are
changed, and the record is not split into fields.  The only variable
changed is @var{var}.

For example, the following program copies all the input files to the
output, except for records that say @w{@samp{@@include @var{filename}}}.
Such a record is replaced by the contents of the file
@var{filename}.@refill

@example
awk '@{
     if (NF == 2 && $1 == "@@include") @{
          while ((getline line < $2) > 0)
               print line
          close($2)
     @} else
          print
@}'
@end example

Note here how the name of the extra input file is not built into
the program; it is taken from the data, from the second field on
the @samp{@@include} line.

The @code{close} function is called to ensure that if two identical
@samp{@@include} lines appear in the input, the entire specified file is
included twice.  @xref{Close Input}.

One deficiency of this program is that it does not process nested
@samp{@@include} statements the way a true macro preprocessor would.

@item @var{command} | getline
You can @dfn{pipe} the output of a command into @code{getline}.  A pipe is
simply a way to link the output of one program to the input of another.  In
this case, the string @var{command} is run as a shell command and its output
is piped into @code{awk} to be used as input.  This form of @code{getline}
reads one record from the pipe.

For example, the following program copies input to output, except for lines
that begin with @samp{@@execute}, which are replaced by the output produced by
running the rest of the line as a shell command:

@example
awk '@{
     if ($1 == "@@execute") @{
          tmp = substr($0, 10)
          while ((tmp | getline) > 0)
               print
          close(tmp)
     @} else
          print
@}'
@end example

@noindent
The @code{close} function is called to ensure that if two identical
@samp{@@execute} lines appear in the input, the command is run again for
each one.  @xref{Close Input}.

Given the input:

@example
foo
bar
baz
@@execute who
bletch
@end example

@noindent
the program might produce:

@example
foo
bar
baz
hack     ttyv0   Jul 13 14:22
hack     ttyp0   Jul 13 14:23     (gnu:0)
hack     ttyp1   Jul 13 14:23     (gnu:0)
hack     ttyp2   Jul 13 14:23     (gnu:0)
hack     ttyp3   Jul 13 14:23     (gnu:0)
bletch
@end example

@noindent
Notice that this program ran the command @code{who} and printed the result.
(If you try this program yourself, you will get different results, showing
you logged in.)

This variation of @code{getline} splits the record into fields, sets the
value of @code{NF} and recomputes the value of @code{$0}.  The values of
@code{NR} and @code{FNR} are not changed.

@item @var{command} | getline @var{var}
The output of the command @var{command} is sent through a pipe to
@code{getline} and into the variable @var{var}.  For example, the
following program reads the current date and time into the variable
@code{current_time}, using the utility called @code{date}, and then
prints it.@refill

@group
@example
awk 'BEGIN @{
     "date" | getline current_time
     close("date")
     print "Report printed on " current_time
@}'
@end example
@end group

In this version of @code{getline}, none of the built-in variables are
changed, and the record is not split into fields.
@end table

@node Close Input,, Getline, Reading Files
@section Closing Input Files and Pipes
@cindex closing input files and pipes
@findex close

If the same file name or the same shell command is used with
@code{getline} more than once during the execution of an @code{awk}
program, the file is opened (or the command is executed) only the first time.
At that time, the first record of input is read from that file or command.
The next time the same file or command is used in @code{getline}, another
record is read from it, and so on.

This implies that if you want to start reading the same file again from
the beginning, or if you want to rerun a shell command (rather that
reading more output from the command), you must take special steps.
What you can do is use the @code{close} function, as follows:

@example
close(@var{filename})
@end example

@noindent
or

@example
close(@var{command})
@end example

The argument @var{filename} or @var{command} can be any expression.  Its
value must exactly equal the string that was used to open the file or
start the command---for example, if you open a pipe with this:

@example
"sort -r names" | getline foo
@end example

@noindent
then you must close it with this:

@example
close("sort -r names")
@end example

Once this function call is executed, the next @code{getline} from that
file or command will reopen the file or rerun the command.

@node Printing, One-liners, Reading Files, Top
@chapter Printing Output

@cindex printing
@cindex output
One of the most common things that actions do is to output or @dfn{print}
some or all of the input.  For simple output, use the @code{print}
statement.  For fancier formatting use the @code{printf} statement.
Both are described in this chapter.

@menu
* Print::              The @code{print} statement.
* Print Examples::     Simple examples of @code{print} statements.
* Output Separators::  The output separators and how to change them.
* Printf::             The @code{printf} statement.
* Redirection::        How to redirect output to multiple files and pipes.
* Special Files::      File name interpretation in @code{gawk}.  @code{gawk}
                       allows access to inherited file descriptors.
@end menu

@node Print, Print Examples, Printing, Printing
@section The @code{print} Statement
@cindex @code{print} statement

The @code{print} statement does output with simple, standardized
formatting.  You specify only the strings or numbers to be printed, in a
list separated by commas.  They are output, separated by single spaces,
followed by a newline.  The statement looks like this:

@example
print @var{item1}, @var{item2}, @dots{}
@end example

@noindent
The entire list of items may optionally be enclosed in parentheses.  The
parentheses are necessary if any of the item expressions uses a
relational operator; otherwise it could be confused with a redirection
(@pxref{Redirection}).  The relational operators are @samp{==},
@samp{!=}, @samp{<}, @samp{>}, @samp{>=}, @samp{<=}, @samp{~} and
@samp{!~} (@pxref{Comparison Ops}).@refill

The items printed can be constant strings or numbers, fields of the
current record (such as @code{$1}), variables, or any @code{awk}
expressions.  The @code{print} statement is completely general for
computing @emph{what} values to print.  With one exception
(@pxref{Output Separators}), what you can't do is specify @emph{how} to
print them---how many columns to use, whether to use exponential
notation or not, and so on.  For that, you need the @code{printf}
statement (@pxref{Printf}).

The simple statement @samp{print} with no items is equivalent to
@samp{print $0}: it prints the entire current record.  To print a blank
line, use @samp{print ""}, where @code{""} is the null, or empty,
string.

To print a fixed piece of text, use a string constant such as
@w{@code{"Hello there"}} as one item.  If you forget to use the
double-quote characters, your text will be taken as an @code{awk}
expression, and you will probably get an error.  Keep in mind that a
space is printed between any two items.

Most often, each @code{print} statement makes one line of output.  But it
isn't limited to one line.  If an item value is a string that contains a
newline, the newline is output along with the rest of the string.  A
single @code{print} can make any number of lines this way.

@node Print Examples, Output Separators, Print, Printing
@section Examples of @code{print} Statements

Here is an example of printing a string that contains embedded newlines:

@example
awk 'BEGIN @{ print "line one\nline two\nline three" @}'
@end example

@noindent
produces output like this:

@example
line one
line two
line three
@end example

Here is an example that prints the first two fields of each input record,
with a space between them:

@example
awk '@{ print $1, $2 @}' inventory-shipped
@end example

@noindent
Its output looks like this:

@example
Jan 13
Feb 15
Mar 15
@dots{}
@end example

A common mistake in using the @code{print} statement is to omit the comma
between two items.  This often has the effect of making the items run
together in the output, with no space.  The reason for this is that
juxtaposing two string expressions in @code{awk} means to concatenate
them.  For example, without the comma:

@example
awk '@{ print $1 $2 @}' inventory-shipped
@end example

@noindent
prints:

@example
Jan13
Feb15
Mar15
@dots{}
@end example

Neither example's output makes much sense to someone unfamiliar with the
file @file{inventory-shipped}.  A heading line at the beginning would make
it clearer.  Let's add some headings to our table of months (@code{$1}) and
green crates shipped (@code{$2}).  We do this using the @code{BEGIN} pattern
(@pxref{BEGIN/END}) to cause the headings to be printed only once:

@c the formatting is strange here because the @{ becomes just a brace.
@example
awk 'BEGIN @{  print "Month Crates"
              print "----- ------" @}
           @{  print $1, $2 @}' inventory-shipped
@end example

@noindent
Did you already guess what happens?  This program prints the following:

@group
@example
Month Crates
----- ------
Jan 13
Feb 15
Mar 15
@dots{}
@end example
@end group

@noindent
The headings and the table data don't line up!  We can fix this by printing
some spaces between the two fields:

@example
awk 'BEGIN @{ print "Month Crates"
             print "----- ------" @}
           @{ print $1, "     ", $2 @}' inventory-shipped
@end example

You can imagine that this way of lining up columns can get pretty
complicated when you have many columns to fix.  Counting spaces for two
or three columns can be simple, but more than this and you can get
``lost'' quite easily.  This is why the @code{printf} statement was
created (@pxref{Printf}); one of its specialties is lining up columns of
data.

@node Output Separators, Printf, Print Examples, Printing
@section Output Separators

@cindex output field separator, @code{OFS}
@vindex OFS
@vindex ORS
@cindex output record separator, @code{ORS}
As mentioned previously, a @code{print} statement contains a list
of items, separated by commas.  In the output, the items are normally
separated by single spaces.  But they do not have to be spaces; a
single space is only the default.  You can specify any string of
characters to use as the @dfn{output field separator} by setting the
built-in variable @code{OFS}.  The initial value of this variable
is the string @w{@code{" "}}.

The output from an entire @code{print} statement is called an
@dfn{output record}.  Each @code{print} statement outputs one output
record and then outputs a string called the @dfn{output record separator}.
The built-in variable @code{ORS} specifies this string.  The initial
value of the variable is the string @code{"\n"} containing a newline
character; thus, normally each @code{print} statement makes a separate line.

You can change how output fields and records are separated by assigning
new values to the variables @code{OFS} and/or @code{ORS}.  The usual
place to do this is in the @code{BEGIN} rule (@pxref{BEGIN/END}), so
that it happens before any input is processed.  You may also do this
with assignments on the command line, before the names of your input
files.

The following example prints the first and second fields of each input
record separated by a semicolon, with a blank line added after each
line:@refill

@example
awk 'BEGIN @{ OFS = ";"; ORS = "\n\n" @}
           @{ print $1, $2 @}'  BBS-list
@end example

If the value of @code{ORS} does not contain a newline, all your output
will be run together on a single line, unless you output newlines some
other way.

@node Printf, Redirection, Output Separators, Printing
@section Using @code{printf} Statements For Fancier Printing
@cindex formatted output
@cindex output, formatted

If you want more precise control over the output format than
@code{print} gives you, use @code{printf}.  With @code{printf} you can
specify the width to use for each item, and you can specify various
stylistic choices for numbers (such as what radix to use, whether to
print an exponent, whether to print a sign, and how many digits to print
after the decimal point).  You do this by specifying a string, called
the @dfn{format string}, which controls how and where to print the other
arguments.

@menu
* Basic Printf::       Syntax of the @code{printf} statement.
* Control Letters::    Format-control letters.
* Format Modifiers::   Format-specification modifiers.
* Printf Examples::    Several examples.
@end menu

@node Basic Printf, Control Letters, Printf, Printf
@subsection Introduction to the @code{printf} Statement

@cindex @code{printf} statement, syntax of
The @code{printf} statement looks like this:@refill

@example
printf @var{format}, @var{item1}, @var{item2}, @dots{}
@end example

@noindent
The entire list of items may optionally be enclosed in parentheses.  The
parentheses are necessary if any of the item expressions uses a
relational operator; otherwise it could be confused with a redirection
(@pxref{Redirection}).  The relational operators are @samp{==},
@samp{!=}, @samp{<}, @samp{>}, @samp{>=}, @samp{<=}, @samp{~} and
@samp{!~} (@pxref{Comparison Ops}).@refill

@cindex format string
The difference between @code{printf} and @code{print} is the argument
@var{format}.  This is an expression whose value is taken as a string; its
job is to say how to output each of the other arguments.  It is called
the @dfn{format string}.

The format string is essentially the same as in the C library function
@code{printf}.  Most of @var{format} is text to be output verbatim.
Scattered among this text are @dfn{format specifiers}, one per item.
Each format specifier says to output the next item at that place in the
format.@refill

The @code{printf} statement does not automatically append a newline to its
output.  It outputs nothing but what the format specifies.  So if you want
a newline, you must include one in the format.  The output separator
variables @code{OFS} and @code{ORS} have no effect on @code{printf}
statements.

@node Control Letters, Format Modifiers, Basic Printf, Printf
@subsection Format-Control Letters
@cindex @code{printf}, format-control characters
@cindex format specifier

A format specifier starts with the character @samp{%} and ends with a
@dfn{format-control letter}; it tells the @code{printf} statement how
to output one item.  (If you actually want to output a @samp{%}, write
@samp{%%}.)  The format-control letter specifies what kind of value to
print.  The rest of the format specifier is made up of optional
@dfn{modifiers} which are parameters such as the field width to use.

Here is a list of the format-control letters:

@table @samp
@item c
This prints a number as an ASCII character.  Thus, @samp{printf "%c",
65} outputs the letter @samp{A}.  The output for a string value is
the first character of the string.

@item d
This prints a decimal integer.

@item i
This also prints a decimal integer.

@item e
This prints a number in scientific (exponential) notation.
For example,

@example
printf "%4.3e", 1950
@end example

@noindent
prints @samp{1.950e+03}, with a total of 4 significant figures of
which 3 follow the decimal point.  The @samp{4.3} are @dfn{modifiers},
discussed below.

@item f
This prints a number in floating point notation.

@item g
This prints either scientific notation or floating point notation, whichever
is shorter.

@item o
This prints an unsigned octal integer.

@item s
This prints a string.

@item x
This prints an unsigned hexadecimal integer.

@item X
This prints an unsigned hexadecimal integer.  However, for the values 10
through 15, it uses the letters @samp{A} through @samp{F} instead of
@samp{a} through @samp{f}.

@item %
This isn't really a format-control letter, but it does have a meaning
when used after a @samp{%}: the sequence @samp{%%} outputs one
@samp{%}.  It does not consume an argument.
@end table

@node Format Modifiers, Printf Examples, Control Letters, Printf
@subsection Modifiers for @code{printf} Formats

@cindex @code{printf}, modifiers
@cindex modifiers (in format specifiers)
A format specification can also include @dfn{modifiers} that can control
how much of the item's value is printed and how much space it gets.  The
modifiers come between the @samp{%} and the format-control letter.  Here
are the possible modifiers, in the order in which they may appear:

@table @samp
@item -
The minus sign, used before the width modifier, says to left-justify
the argument within its specified width.  Normally the argument
is printed right-justified in the specified width.  Thus,

@example
printf "%-4s", "foo"
@end example

@noindent
prints @samp{foo }.

@item @var{width}
This is a number representing the desired width of a field.  Inserting any
number between the @samp{%} sign and the format control character forces the
field to be expanded to this width.  The default way to do this is to
pad with spaces on the left.  For example,

@example
printf "%4s", "foo"
@end example

@noindent
prints @samp{ foo}.

The value of @var{width} is a minimum width, not a maximum.  If the item
value requires more than @var{width} characters, it can be as wide as
necessary.  Thus,

@example
printf "%4s", "foobar"
@end example

@noindent
prints @samp{foobar}.  Preceding the @var{width} with a minus sign causes
the output to be padded with spaces on the right, instead of on the left.

@item .@var{prec}
This is a number that specifies the precision to use when printing.
This specifies the number of digits you want printed to the right of the
decimal point.  For a string, it specifies the maximum number of
characters from the string that should be printed.
@end table

The C library @code{printf}'s dynamic @var{width} and @var{prec}
capability (for example, @code{"%*.*s"}) is not yet supported.  However, it can
easily be simulated using concatenation to dynamically build the
format string.@refill

@node Printf Examples, , Format Modifiers, Printf
@subsection Examples of Using @code{printf}

Here is how to use @code{printf} to make an aligned table:

@example
awk '@{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end example

@noindent
prints the names of bulletin boards (@code{$1}) of the file
@file{BBS-list} as a string of 10 characters, left justified.  It also
prints the phone numbers (@code{$2}) afterward on the line.  This
produces an aligned two-column table of names and phone numbers:

@example
aardvark   555-5553
alpo-net   555-3412
barfly     555-7685
bites      555-1675
camelot    555-0542
core       555-2912
fooey      555-1234
foot       555-6699
macfoo     555-6480
sdace      555-3430
sabafoo    555-2127
@end example

Did you notice that we did not specify that the phone numbers be printed
as numbers?  They had to be printed as strings because the numbers are
separated by a dash.  This dash would be interpreted as a minus sign if
we had tried to print the phone numbers as numbers.  This would have led
to some pretty confusing results.

We did not specify a width for the phone numbers because they are the
last things on their lines.  We don't need to put spaces after them.

We could make our table look even nicer by adding headings to the tops
of the columns.  To do this, use the @code{BEGIN} pattern
(@pxref{BEGIN/END}) to cause the header to be printed only once, at the
beginning of the @code{awk} program:

@example
awk 'BEGIN @{ print "Name      Number"
             print "----      ------" @}
     @{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end example

Did you notice that we mixed @code{print} and @code{printf} statements in
the above example?  We could have used just @code{printf} statements to get
the same results:

@example
awk 'BEGIN @{ printf "%-10s %s\n", "Name", "Number"
             printf "%-10s %s\n", "----", "------" @}
     @{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end example

@noindent
By outputting each column heading with the same format specification
used for the elements of the column, we have made sure that the headings
are aligned just like the columns.

The fact that the same format specification is used three times can be
emphasized by storing it in a variable, like this:

@example
awk 'BEGIN @{ format = "%-10s %s\n"
             printf format, "Name", "Number"
             printf format, "----", "------" @}
     @{ printf format, $1, $2 @}' BBS-list
@end example

See if you can use the @code{printf} statement to line up the headings and
table data for our @file{inventory-shipped} example covered earlier in the
section on the @code{print} statement (@pxref{Print}).

@node Redirection, Special Files, Printf, Printing
@section Redirecting Output of @code{print} and @code{printf}

@cindex output redirection
@cindex redirection of output
So far we have been dealing only with output that prints to the standard
output, usually your terminal.  Both @code{print} and @code{printf} can be
told to send their output to other places.  This is called
@dfn{redirection}.@refill

A redirection appears after the @code{print} or @code{printf} statement.
Redirections in @code{awk} are written just like redirections in shell
commands, except that they are written inside the @code{awk} program.

@menu
* File/Pipe Redirection::       Redirecting Output to Files and Pipes.
* Close Output::                How to close output files and pipes.
@end menu

@node File/Pipe Redirection, Close Output, Redirection, Redirection
@subsection Redirecting Output to Files and Pipes

Here are the three forms of output redirection.  They are all shown for
the @code{print} statement, but they work identically for @code{printf}
also.

@table @code
@item print @var{items} > @var{output-file}
This type of redirection prints the items onto the output file
@var{output-file}.  The file name @var{output-file} can be any
expression.  Its value is changed to a string and then used as a
file name (@pxref{Expressions}).@refill

When this type of redirection is used, the @var{output-file} is erased
before the first output is written to it.  Subsequent writes do not
erase @var{output-file}, but append to it.  If @var{output-file} does
not exist, then it is created.@refill

For example, here is how one @code{awk} program can write a list of
BBS names to a file @file{name-list} and a list of phone numbers to a
file @file{phone-list}.  Each output file contains one name or number
per line.

@example
awk '@{ print $2 > "phone-list"
       print $1 > "name-list" @}' BBS-list
@end example

@item print @var{items} >> @var{output-file}
This type of redirection prints the items onto the output file
@var{output-file}.  The difference between this and the
single-@samp{>} redirection is that the old contents (if any) of
@var{output-file} are not erased.  Instead, the @code{awk} output is
appended to the file.

@cindex pipes for output
@cindex output, piping
@item print @var{items} | @var{command}
It is also possible to send output through a @dfn{pipe} instead of into a
file.   This type of redirection opens a pipe to @var{command} and writes
the values of @var{items} through this pipe, to another process created
to execute @var{command}.@refill

The redirection argument @var{command} is actually an @code{awk}
expression.  Its value is converted to a string, whose contents give the
shell command to be run.

For example, this produces two files, one unsorted list of BBS names
and one list sorted in reverse alphabetical order:

@example
awk '@{ print $1 > "names.unsorted"
       print $1 | "sort -r > names.sorted" @}' BBS-list
@end example

Here the unsorted list is written with an ordinary redirection while
the sorted list is written by piping through the @code{sort} utility.

Here is an example that uses redirection to mail a message to a mailing
list @samp{bug-system}.  This might be useful when trouble is encountered
in an @code{awk} script run periodically for system maintenance.

@example
print "Awk script failed:", $0 | "mail bug-system"
print "at record number", FNR, "of", FILENAME  | "mail bug-system"
close("mail bug-system")
@end example

We call the @code{close} function here because it's a good idea to close
the pipe as soon as all the intended output has been sent to it.
@xref{Close Output}, for more information on this.
@end table

Redirecting output using @samp{>}, @samp{>>}, or @samp{|} asks the system
to open a file or pipe only if the particular @var{file} or @var{command}
you've specified has not already been written to by your program.@refill

@node Close Output, , File/Pipe Redirection, Redirection
@subsection Closing Output Files and Pipes
@cindex closing output files and pipes
@findex close

When a file or pipe is opened, the file name or command associated with
it is remembered by @code{awk} and subsequent writes to the same file or
command are appended to the previous writes.  The file or pipe stays
open until @code{awk} exits.  This is usually convenient.

Sometimes there is a reason to close an output file or pipe earlier
than that.  To do this, use the @code{close} function, as follows:

@example
close(@var{filename})
@end example

@noindent
or

@example
close(@var{command})
@end example

The argument @var{filename} or @var{command} can be any expression.
Its value must exactly equal the string used to open the file or pipe
to begin with---for example, if you open a pipe with this:

@example
print $1 | "sort -r > names.sorted"
@end example

@noindent
then you must close it with this:

@example
close("sort -r > names.sorted")
@end example

Here are some reasons why you might need to close an output file:

@itemize @bullet
@item
To write a file and read it back later on in the same @code{awk}
program.  Close the file when you are finished writing it; then
you can start reading it with @code{getline} (@pxref{Getline}).

@item
To write numerous files, successively, in the same @code{awk}
program.  If you don't close the files, eventually you will exceed the
system limit on the number of open files in one process.  So close
each one when you are finished writing it.

@item
To make a command finish.  When you redirect output through a pipe,
the command reading the pipe normally continues to try to read input
as long as the pipe is open.  Often this means the command cannot
really do its work until the pipe is closed.  For example, if you
redirect output to the @code{mail} program, the message is not
actually sent until the pipe is closed.

@item
To run the same program a second time, with the same arguments.
This is not the same thing as giving more input to the first run!

For example, suppose you pipe output to the @code{mail} program.  If you
output several lines redirected to this pipe without closing it, they make
a single message of several lines.  By contrast, if you close the pipe
after each line of output, then each line makes a separate message.
@end itemize

@node Special Files, , Redirection, Printing
@section Standard I/O Streams
@cindex standard input
@cindex standard output
@cindex standard error output
@cindex file descriptors

Running programs conventionally have three input and output streams
already available to them for reading and writing.  These are known as
the @dfn{standard input}, @dfn{standard output}, and @dfn{standard error
output}.  These streams are, by default, terminal input and output, but
they are often redirected with the shell, via the @samp{<}, @samp{<<},
@samp{>}, @samp{>>}, @samp{>&} and @samp{|} operators.  Standard error
is used only for writing error messages; the reason we have two separate
streams, standard output and standard error, is so that they can be
redirected separately.

@c @cindex differences between @code{gawk} and @code{awk}
In other implementations of @code{awk}, the only way to write an error
message to standard error in an @code{awk} program is as follows:

@example
print "Serious error detected!\n" | "cat 1>&2"
@end example

@noindent
This works by opening a pipeline to a shell command which can access the
standard error stream which it inherits from the @code{awk} process.
This is far from elegant, and is also inefficient, since it requires a
separate process.  So people writing @code{awk} programs have often
neglected to do this.  Instead, they have sent the error messages to the
terminal, like this:

@example
NF != 4 @{
   printf("line %d skipped: doesn't have 4 fields\n", FNR) > "/dev/tty"
@}
@end example

@noindent
This has the same effect most of the time, but not always: although the
standard error stream is usually the terminal, it can be redirected, and
when that happens, writing to the terminal is not correct.  In fact, if
@code{awk} is run from a background job, it may not have a terminal at all.
Then opening @file{/dev/tty} will fail.

@code{gawk} provides special file names for accessing the three standard
streams.  When you redirect input or output in @code{gawk}, if the file name
matches one of these special names, then @code{gawk} directly uses the
stream it stands for.

@cindex @file{/dev/stdin}
@cindex @file{/dev/stdout}
@cindex @file{/dev/stderr}
@cindex @file{/dev/fd/}
@table @file
@item /dev/stdin
The standard input (file descriptor 0).

@item /dev/stdout
The standard output (file descriptor 1).

@item /dev/stderr
The standard error output (file descriptor 2).

@item /dev/fd/@var{n}
The file associated with file descriptor @var{n}.  Such a file must have
been opened by the program initiating the @code{awk} execution (typically
the shell).  Unless you take special pains, only descriptors 0, 1 and 2
are available.
@end table

The file names @file{/dev/stdin}, @file{/dev/stdout}, and @file{/dev/stderr}
are aliases for @file{/dev/fd/0}, @file{/dev/fd/1}, and @file{/dev/fd/2},
respectively, but they are more self-explanatory.

The proper way to write an error message in a @code{gawk} program
is to use @file{/dev/stderr}, like this:

@example
NF != 4 @{
  printf("line %d skipped: doesn't have 4 fields\n", FNR) > "/dev/stderr"
@}
@end example

Recognition of these special file names is disabled if @code{gawk} is in
compatibility mode (@pxref{Command Line}).

@node One-liners, Patterns, Printing, Top
@chapter Useful ``One-liners''

@cindex one-liners
Useful @code{awk} programs are often short, just a line or two.  Here is a
collection of useful, short programs to get you started.  Some of these
programs contain constructs that haven't been covered yet.  The description
of the program will give you a good idea of what is going on, but please
read the rest of the manual to become an @code{awk} expert!

@table @code
@item awk '@{ num_fields = num_fields + NF @}
@itemx @ @ @ @ @ END @{ print num_fields @}'
This program prints the total number of fields in all input lines.

@item awk 'length($0) > 80'
This program prints every line longer than 80 characters.  The sole
rule has a relational expression as its pattern, and has no action (so the
default action, printing the record, is used).

@item awk 'NF > 0'
This program prints every line that has at least one field.  This is an
easy way to delete blank lines from a file (or rather, to create a new
file similar to the old file but from which the blank lines have been
deleted).

@item awk '@{ if (NF > 0) print @}'
This program also prints every line that has at least one field.  Here we
allow the rule to match every line, then decide in the action whether
to print.

@item awk@ 'BEGIN@ @{@ for (i = 1; i <= 7; i++)
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ print int(101 * rand()) @}'
This program prints 7 random numbers from 0 to 100, inclusive.

@item ls -l @var{files} | awk '@{ x += $4 @} ; END @{ print "total bytes: " x @}'
This program prints the total number of bytes used by @var{files}.

@item expand@ @var{file}@ |@ awk@ '@{ if (x < length()) x = length() @}
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ END @{ print "maximum line length is " x @}'
This program prints the maximum line length of @var{file}.  The input
is piped through the @code{expand} program to change tabs into spaces,
so the widths compared are actually the right-margin columns.
@end table

@node Patterns, Actions, One-liners, Top
@chapter Patterns
@cindex pattern, definition of

Patterns in @code{awk} control the execution of rules: a rule is
executed when its pattern matches the current input record.  This
chapter tells all about how to write patterns.

@menu
* Kinds of Patterns::    A list of all kinds of patterns.
                         The following subsections describe them in detail.

* Empty::                The empty pattern, which matches every record.

* Regexp::               Regular expressions such as @samp{/foo/}.

* Comparison Patterns::  Comparison expressions such as @code{$1 > 10}.

* Boolean Patterns::     Combining comparison expressions.

* Expression Patterns::  Any expression can be used as a pattern.

* Ranges::               Using pairs of patterns to specify record ranges.

* BEGIN/END::            Specifying initialization and cleanup rules.
@end menu

@node Kinds of Patterns, Empty, Patterns, Patterns
@section Kinds of Patterns
@cindex patterns, types of

Here is a summary of the types of patterns supported in @code{awk}.

@table @code
@item /@var{regular expression}/
A regular expression as a pattern.  It matches when the text of the
input record fits the regular expression.  (@xref{Regexp, , Regular
Expressions as Patterns}.)

@item @var{expression}
A single expression.  It matches when its value, converted to a number,
is nonzero (if a number) or nonnull (if a string).  (@xref{Expression
Patterns}.)

@item @var{pat1}, @var{pat2}
A pair of patterns separated by a comma, specifying a range of records.
(@xref{Ranges, , Specifying Record Ranges With Patterns}.)

@item BEGIN
@itemx END
Special patterns to supply start-up or clean-up information to
@code{awk}.  (@xref{BEGIN/END}.)

@item @var{null}
The empty pattern matches every input record.  (@xref{Empty, , The Empty
Pattern}.)
@end table

@node Empty, Regexp, Kinds of Patterns, Patterns
@section The Empty Pattern

@cindex empty pattern
@cindex pattern, empty
An empty pattern is considered to match @emph{every} input record.  For
example, the program:@refill

@example
awk '@{ print $1 @}' BBS-list
@end example

@noindent
prints just the first field of every record.

@node Regexp, Comparison Patterns, Empty, Patterns
@section Regular Expressions as Patterns
@cindex pattern, regular expressions
@cindex regexp
@cindex regular expressions as patterns

A @dfn{regular expression}, or @dfn{regexp}, is a way of describing a
class of strings.  A regular expression enclosed in slashes (@samp{/})
is an @code{awk} pattern that matches every input record whose text
belongs to that class.

The simplest regular expression is a sequence of letters, numbers, or
both.  Such a regexp matches any string that contains that sequence.
Thus, the regexp @samp{foo} matches any string containing @samp{foo}.
Therefore, the pattern @code{/foo/} matches any input record containing
@samp{foo}.  Other kinds of regexps let you specify more complicated
classes of strings.

@menu
* Usage: Regexp Usage.          How regexps are used in patterns.
* Operators: Regexp Operators.  How to write a regexp.
* Case-sensitivity::            How to do case-insensitive matching.
@end menu

@node Regexp Usage, Regexp Operators, Regexp, Regexp
@subsection How to Use Regular Expressions

A regular expression can be used as a pattern by enclosing it in
slashes.  Then the regular expression is matched against the entire text
of each record.  (Normally, it only needs to match some part of the text
in order to succeed.)  For example, this prints the second field of each
record that contains @samp{foo} anywhere:

@example
awk '/foo/ @{ print $2 @}' BBS-list
@end example

@cindex regular expression matching operators
@cindex string-matching operators
@cindex operators, string-matching
@cindex operators, regular expression matching
@cindex regexp search operators
Regular expressions can also be used in comparison expressions.  Then
you can specify the string to match against; it need not be the entire
current input record.  These comparison expressions can be used as
patterns or in @code{if} and @code{while} statements.

@table @code
@item @var{exp} ~ /@var{regexp}/
This is true if the expression @var{exp} (taken as a character string)
is matched by @var{regexp}.  The following example matches, or selects,
all input records with the upper-case letter @samp{J} somewhere in the
first field:@refill

@example
awk '$1 ~ /J/' inventory-shipped
@end example

So does this:

@example
awk '@{ if ($1 ~ /J/) print @}' inventory-shipped
@end example

@item @var{exp} !~ /@var{regexp}/
This is true if the expression @var{exp} (taken as a character string)
is @emph{not} matched by @var{regexp}.  The following example matches,
or selects, all input records whose first field @emph{does not} contain
the upper-case letter @samp{J}:@refill

@example
awk '$1 !~ /J/' inventory-shipped
@end example
@end table

@cindex computed regular expressions
@cindex regular expressions, computed
@cindex dynamic regular expressions
The right hand side of a @samp{~} or @samp{!~} operator need not be a
constant regexp (i.e., a string of characters between slashes).  It may
be any expression.  The expression is evaluated, and converted if
necessary to a string; the contents of the string are used as the
regexp.  A regexp that is computed in this way is called a @dfn{dynamic
regexp}.  For example:

@example
identifier_regexp = "[A-Za-z_][A-Za-z_0-9]+"
$0 ~ identifier_regexp
@end example

@noindent
sets @code{identifier_regexp} to a regexp that describes @code{awk}
variable names, and tests if the input record matches this regexp.

@node Regexp Operators, Case-sensitivity, Regexp Usage, Regexp
@subsection Regular Expression Operators
@cindex metacharacters
@cindex regular expression metacharacters

You can combine regular expressions with the following characters,
called @dfn{regular expression operators}, or @dfn{metacharacters}, to
increase the power and versatility of regular expressions.

Here is a table of metacharacters.  All characters not listed in the
table stand for themselves.

@table @code
@item ^
This matches the beginning of the string or the beginning of a line
within the string.  For example:

@example
^@@chapter
@end example

@noindent
matches the @samp{@@chapter} at the beginning of a string, and can be used
to identify chapter beginnings in Texinfo source files.

@item $
This is similar to @samp{^}, but it matches only at the end of a string
or the end of a line within the string.  For example:

@example
p$
@end example

@noindent
matches a record that ends with a @samp{p}.

@item .
This matches any single character except a newline.  For example:

@example
.P
@end example

@noindent
matches any single character followed by a @samp{P} in a string.  Using
concatenation we can make regular expressions like @samp{U.A}, which
matches any three-character sequence that begins with @samp{U} and ends
with @samp{A}.

@item [@dots{}]
This is called a @dfn{character set}.  It matches any one of the
characters that are enclosed in the square brackets.  For example:

@example
[MVX]
@end example

@noindent
matches any of the characters @samp{M}, @samp{V}, or @samp{X} in a
string.@refill

Ranges of characters are indicated by using a hyphen between the beginning
and ending characters, and enclosing the whole thing in brackets.  For
example:@refill

@example
[0-9]
@end example

@noindent
matches any digit.

To include the character @samp{\}, @samp{]}, @samp{-} or @samp{^} in a
character set, put a @samp{\} in front of it.  For example:

@example
[d\]]
@end example

@noindent
matches either @samp{]}, or @samp{d}.@refill

This treatment of @samp{\} is compatible with other @code{awk}
implementations but incompatible with the proposed POSIX specification
for @code{awk}.  The current draft specifies the use of the same syntax
used in @code{egrep}.

We may change @code{gawk} to fit the standard, once we are sure it will
no longer change.  For the meanwhile, the @samp{-a} option specifies the
traditional @code{awk} syntax described above (which is also the
default), while the @samp{-e} option specifies @code{egrep} syntax.
@xref{Options}.

In @code{egrep} syntax, backslash is not syntactically special within
square brackets.  This means that special tricks have to be used to
represent the characters @samp{]}, @samp{-} and @samp{^} as members of a
character set.

To match @samp{-}, write it as @samp{---}, which is a range containing
only @samp{-}.  You may also give @samp{-} as the first or last
character in the set.  To match @samp{^}, put it anywhere except as the
first character of a set.  To match a @samp{]}, make it the first
character in the set.  For example:

@example
[]d^]
@end example

@noindent
matches either @samp{]}, @samp{d} or @samp{^}.@refill

@item [^ @dots{}]
This is a @dfn{complemented character set}.  The first character after
the @samp{[} @emph{must} be a @samp{^}.  It matches any characters
@emph{except} those in the square brackets.  For example:

@example
[^0-9]
@end example

@noindent
matches any character that is not a digit.

@item |
This is the @dfn{alternation operator} and it is used to specify
alternatives.  For example:

@example
^P|[0-9]
@end example

@noindent
matches any string that matches either @samp{^P} or @samp{[0-9]}.  This
means it matches any string that contains a digit or starts with @samp{P}.

The alternation applies to the largest possible regexps on either side.
@item (@dots{})
Parentheses are used for grouping in regular expressions as in
arithmetic.  They can be used to concatenate regular expressions
containing the alternation operator, @samp{|}.

@item *
This symbol means that the preceding regular expression is to be
repeated as many times as possible to find a match.  For example:

@example
ph*
@end example

@noindent
applies the @samp{*} symbol to the preceding @samp{h} and looks for matches
to one @samp{p} followed by any number of @samp{h}s.  This will also match
just @samp{p} if no @samp{h}s are present.

The @samp{*} repeats the @emph{smallest} possible preceding expression.
(Use parentheses if you wish to repeat a larger expression.)  It finds
as many repetitions as possible.  For example:

@example
awk '/\(c[ad][ad]*r x\)/ @{ print @}' sample
@end example

@noindent
prints every record in the input containing a string of the form
@samp{(car x)}, @samp{(cdr x)}, @samp{(cadr x)}, and so on.@refill

@item +
This symbol is similar to @samp{*}, but the preceding expression must be
matched at least once.  This means that:

@example
wh+y
@end example

@noindent
would match @samp{why} and @samp{whhy} but not @samp{wy}, whereas
@samp{wh*y} would match all three of these strings.  This is a simpler
way of writing the last @samp{*} example:

@example
awk '/\(c[ad]+r x\)/ @{ print @}' sample
@end example

@item ?
This symbol is similar to @samp{*}, but the preceding expression can be
matched once or not at all.  For example:

@example
fe?d
@end example

@noindent
will match @samp{fed} or @samp{fd}, but nothing else.@refill

@item \
This is used to suppress the special meaning of a character when
matching.  For example:

@example
\$
@end example

@noindent
matches the character @samp{$}.

The escape sequences used for string constants (@pxref{Constants}) are
valid in regular expressions as well; they are also introduced by a
@samp{\}.
@end table

In regular expressions, the @samp{*}, @samp{+}, and @samp{?} operators have
the highest precedence, followed by concatenation, and finally by @samp{|}.
As in arithmetic, parentheses can change how operators are grouped.@refill

@node Case-sensitivity,, Regexp Operators, Regexp
@subsection Case-sensitivity in Matching

Case is normally significant in regular expressions, both when matching
ordinary characters (i.e., not metacharacters), and inside character
sets.  Thus a @samp{w} in a regular expression matches only a lower case
@samp{w} and not an upper case @samp{W}.

The simplest way to do a case-independent match is to use a character
set: @samp{[Ww]}.  However, this can be cumbersome if you need to use it
often; and it can make the regular expressions harder for humans to
read.  There are two other alternatives that you might prefer.

One way to do a case-insensitive match at a particular point in the
program is to convert the data to a single case, using the
@code{tolower} or @code{toupper} built-in string functions (which we
haven't discussed yet; @pxref{String Functions}).  For example:

@example
tolower($1) ~ /foo/  @{ @dots{} @}
@end example

@noindent
converts the first field to lower case before matching against it.

Another method is to set the variable @code{IGNORECASE} to a nonzero
value (@pxref{Built-in Variables}).  When @code{IGNORECASE} is not zero,
@emph{all} regexp operations ignore case.  Changing the value of
@code{IGNORECASE} dynamically controls the case sensitivity of your
program as it runs.  Case is significant by default because
@code{IGNORECASE} (like most variables) is initialized to zero.

@example
x = "aB"
if (x ~ /ab/) @dots{}   # this test will fail

IGNORECASE = 1
if (x ~ /ab/) @dots{}   # now it will succeed
@end example

You cannot generally use @code{IGNORECASE} to make certain rules
case-insensitive and other rules case-sensitive, because there is no way
to set @code{IGNORECASE} just for the pattern of a particular rule.  To
do this, you must use character sets or @code{tolower}.  However, one
thing you can do only with @code{IGNORECASE} is turn case-sensitivity on
or off dynamically for all the rules at once.

@code{IGNORECASE} can be set on the command line, or in a @code{BEGIN}
rule.  Setting @code{IGNORECASE} from the command line is a way to make
a program case-insensitive without having to edit it.

The value of @code{IGNORECASE} has no effect if @code{gawk} is in
compatibility mode (@pxref{Command Line}).  Case is always significant
in compatibility mode.

@node Comparison Patterns, Boolean Patterns, Regexp, Patterns
@section Comparison Expressions as Patterns
@cindex comparison expressions as patterns
@cindex pattern, comparison expressions
@cindex relational operators
@cindex operators, relational

@dfn{Comparison patterns} test relationships such as equality between
two strings or numbers.  They are a special case of expression patterns
(@pxref{Expression Patterns}).  They are written with @dfn{relational
operators}, which are a superset of those in C.  Here is a table of
them:

@table @code
@item @var{x} < @var{y}
True if @var{x} is less than @var{y}.

@item @var{x} <= @var{y}
True if @var{x} is less than or equal to @var{y}.

@item @var{x} > @var{y}
True if @var{x} is greater than @var{y}.

@item @var{x} >= @var{y}
True if @var{x} is greater than or equal to @var{y}.

@item @var{x} == @var{y}
True if @var{x} is equal to @var{y}.

@item @var{x} != @var{y}
True if @var{x} is not equal to @var{y}.

@item @var{x} ~ @var{y}
True if @var{x} matches the regular expression described by @var{y}.

@item @var{x} !~ @var{y}
True if @var{x} does not match the regular expression described by @var{y}.
@end table

The operands of a relational operator are compared as numbers if they
are both numbers.  Otherwise they are converted to, and compared as,
strings (@pxref{Conversion}).  Strings are compared by comparing the
first character of each, then the second character of each, and so on,
until there is a difference.  If the two strings are equal until the
shorter one runs out, the shorter one is considered to be less than the
longer one.  Thus, @code{"10"} is less than @code{"9"}.

The left operand of the @samp{~} and @samp{!~} operators is a string.
The right operand is either a constant regular expression enclosed in
slashes (@code{/@var{regexp}/}), or any expression, whose string value
is used as a dynamic regular expression (@pxref{Regexp Usage}).

The following example prints the second field of each input record
whose first field is precisely @samp{foo}.

@example
awk '$1 == "foo" @{ print $2 @}' BBS-list
@end example

@noindent
Contrast this with the following regular expression match, which would
accept any record with a first field that contains @samp{foo}:

@example
awk '$1 ~ "foo" @{ print $2 @}' BBS-list
@end example

@noindent
or, equivalently, this one:

@example
awk '$1 ~ /foo/ @{ print $2 @}' BBS-list
@end example

@node Boolean Patterns, Expression Patterns, Comparison Patterns, Patterns
@section Boolean Operators and Patterns
@cindex patterns, boolean
@cindex boolean patterns

A @dfn{boolean pattern} is an expression which combines other patterns
using the @dfn{boolean operators} ``or'' (@samp{||}), ``and''
(@samp{&&}), and ``not'' (@samp{!}).  Whether the boolean pattern
matches an input record depends on whether its subpatterns match.

For example, the following command prints all records in the input file
@file{BBS-list} that contain both @samp{2400} and @samp{foo}.@refill

@example
awk '/2400/ && /foo/' BBS-list
@end example

The following command prints all records in the input file
@file{BBS-list} that contain @emph{either} @samp{2400} or @samp{foo}, or
both.@refill

@example
awk '/2400/ || /foo/' BBS-list
@end example

The following command prints all records in the input file
@file{BBS-list} that do @emph{not} contain the string @samp{foo}.

@example
awk '! /foo/' BBS-list
@end example

Note that boolean patterns are a special case of expression patterns
(@pxref{Expression Patterns}); they are expressions that use the
boolean operators.  @xref{Boolean Ops}, for complete information on
the boolean operators.

The subpatterns of a boolean pattern can be constant regular
expressions, comparisons, or any other @code{gawk} expressions.  Range
patterns are not expressions, so they cannot appear inside boolean
patterns.  Likewise, the special patterns @code{BEGIN} and @code{END},
which never match any input record, are not expressions and cannot
appear inside boolean patterns.

@node Expression Patterns, Ranges, Boolean Patterns, Patterns
@section Expressions as Patterns

Any @code{awk} expression is valid also as a pattern in @code{gawk}.
Then the pattern ``matches'' if the expression's value is nonzero (if a
number) or nonnull (if a string).

The expression is reevaluated each time the rule is tested against a new
input record.  If the expression uses fields such as @code{$1}, the
value depends directly on the new input record's text; otherwise, it
depends only on what has happened so far in the execution of the
@code{awk} program, but that may still be useful.

Comparison patterns are actually a special case of this.  For
example, the expression @code{$5 == "foo"} has the value 1 when the
value of @code{$5} equals @code{"foo"}, and 0 otherwise; therefore, this
expression as a pattern matches when the two values are equal.

Boolean patterns are also special cases of expression patterns.

A constant regexp as a pattern is also a special case of an expression
pattern.  @code{/foo/} as an expression has the value 1 if @samp{foo}
appears in the current input record; thus, as a pattern, @code{/foo/}
matches any record containing @samp{foo}.

Other implementations of @code{awk} are less general than @code{gawk}:
they allow comparison expressions, and boolean combinations thereof
(optionally with parentheses), but not necessarily other kinds of
expressions.

@node Ranges, BEGIN/END, Expression Patterns, Patterns
@section Specifying Record Ranges With Patterns

@cindex range pattern
@cindex patterns, range
A @dfn{range pattern} is made of two patterns separated by a comma, of
the form @code{@var{begpat}, @var{endpat}}.  It matches ranges of
consecutive input records.  The first pattern @var{begpat} controls
where the range begins, and the second one @var{endpat} controls where
it ends.  For example,@refill

@example
awk '$1 == "on", $1 == "off"'
@end example

@noindent
prints every record between @samp{on}/@samp{off} pairs, inclusive.

In more detail, a range pattern starts out by matching @var{begpat}
against every input record; when a record matches @var{begpat}, the
range pattern becomes @dfn{turned on}.  The range pattern matches this
record.  As long as it stays turned on, it automatically matches every
input record read.  But meanwhile, it also matches @var{endpat} against
every input record, and when that succeeds, the range pattern is turned
off again for the following record.  Now it goes back to checking
@var{begpat} against each record.

The record that turns on the range pattern and the one that turns it
off both match the range pattern.  If you don't want to operate on
these records, you can write @code{if} statements in the rule's action
to distinguish them.

It is possible for a pattern to be turned both on and off by the same
record, if both conditions are satisfied by that record.  Then the action is
executed for just that record.

@node BEGIN/END,, Ranges, Patterns
@section @code{BEGIN} and @code{END} Special Patterns

@cindex @code{BEGIN} special pattern
@cindex patterns, @code{BEGIN}
@cindex @code{END} special pattern
@cindex patterns, @code{END}
@code{BEGIN} and @code{END} are special patterns.  They are not used to
match input records.  Rather, they are used for supplying start-up or
clean-up information to your @code{awk} script.  A @code{BEGIN} rule is
executed, once, before the first input record has been read.  An @code{END}
rule is executed, once, after all the input has been read.  For
example:@refill

@group
@example
awk 'BEGIN @{ print "Analysis of `foo'" @}
     /foo/ @{ ++foobar @}
     END   @{ print "`foo' appears " foobar " times." @}' BBS-list
@end example
@end group

This program finds out how many times the string @samp{foo} appears in
the input file @file{BBS-list}.  The @code{BEGIN} rule prints a title
for the report.  There is no need to use the @code{BEGIN} rule to
initialize the counter @code{foobar} to zero, as @code{awk} does this
for us automatically (@pxref{Variables}).

The second rule increments the variable @code{foobar} every time a
record containing the pattern @samp{foo} is read.  The @code{END} rule
prints the value of @code{foobar} at the end of the run.@refill

The special patterns @code{BEGIN} and @code{END} cannot be used in ranges
or with boolean operators.

An @code{awk} program may have multiple @code{BEGIN} and/or @code{END}
rules.  They are executed in the order they appear, all the @code{BEGIN}
rules at start-up and all the @code{END} rules at termination.

Multiple @code{BEGIN} and @code{END} sections are useful for writing
library functions, since each library can have its own @code{BEGIN} or
@code{END} rule to do its own initialization and/or cleanup.  Note that
the order in which library functions are named on the command line
controls the order in which their @code{BEGIN} and @code{END} rules are
executed.  Therefore you have to be careful to write such rules in
library files so that it doesn't matter what order they are executed in.
@xref{Command Line}, for more information on using library functions.

If an @code{awk} program only has a @code{BEGIN} rule, and no other
rules, then the program exits after the @code{BEGIN} rule has been run.
(Older versions of @code{awk} used to keep reading and ignoring input
until end of file was seen.)  However, if an @code{END} rule exists as
well, then the input will be read, even if there are no other rules in
the program.  This is necessary in case the @code{END} rule checks the
@code{NR} variable.

@code{BEGIN} and @code{END} rules must have actions; there is no default
action for these rules since there is no current record when they run.

@node Actions, Expressions, Patterns, Top
@chapter Actions: Overview
@cindex action, definition of
@cindex curly braces
@cindex action, curly braces
@cindex action, separating statements

An @code{awk} @dfn{program} or @dfn{script} consists of a series of
@dfn{rules} and function definitions, interspersed.  (Functions are
described later.  @xref{User-defined}.)

A rule contains a pattern and an @dfn{action}, either of which may be
omitted.  The purpose of the action is to tell @code{awk} what to do
once a match for the pattern is found.  Thus, the entire program
looks somewhat like this:

@example
@r{[}@var{pattern}@r{]} @r{[}@{ @var{action} @}@r{]}
@r{[}@var{pattern}@r{]} @r{[}@{ @var{action} @}@r{]}
@dots{}
function @var{name} (@var{args}) @{ @dots{} @}
@dots{}
@end example

An action consists of one or more @code{awk} @dfn{statements}, enclosed
in curly braces (@samp{@{} and @samp{@}}).  Each statement specifies one
thing to be done.  The statements are separated by newlines or
semicolons.

The curly braces around an action must be used even if the action
contains only one statement, or even if it contains no statements at
all.  However, if you omit the action entirely, omit the curly braces as
well.  (An omitted action is equivalent to @samp{@{ print $0 @}}.)

Here are the kinds of statement supported in @code{awk}:

@itemize @bullet
@item
Expressions, which can call functions or assign values to variables
(@pxref{Expressions}).  Executing this kind of statement simply computes
the value of the expression and then ignores it.  This is useful when
the expression has side effects (@pxref{Assignment Ops}).

@item
Control statements, which specify the control flow of @code{awk}
programs.  The @code{awk} language gives you C-like constructs
(@code{if}, @code{for}, @code{while}, and so on) as well as a few
special ones (@pxref{Statements}).@refill

@item
Compound statements, which consist of one or more statements enclosed in
curly braces.  A compound statement is used in order to put several
statements together in the body of an @code{if}, @code{while}, @code{do}
or @code{for} statement.

@item
Input control, using the @code{getline} function (@pxref{Getline}),
and the @code{next} statement (@pxref{Next Statement}).

@item
Output statements, @code{print} and @code{printf}.  @xref{Printing}.

@item
Deletion statements, for deleting array elements.  @xref{Delete}.
@end itemize

@iftex
The next two chapters cover in detail expressions and control
statements, respectively.  We go on to treat arrays, and built-in
functions, both of which are used in expressions.  Then we proceed
to discuss how to define your own functions.
@end iftex

@node Expressions, Statements, Actions, Top
@chapter Actions: Expressions
@cindex expression

Expressions are the basic building block of @code{awk} actions.  An
expression evaluates to a value, which you can print, test, store in a
variable or pass to a function.

But, beyond that, an expression can assign a new value to a variable
or a field, with an assignment operator.

An expression can serve as a statement on its own.  Most other kinds of
statement contain one or more expressions which specify data to be
operated on.  As in other languages, expressions in @code{awk} include
variables, array references, constants, and function calls, as well as
combinations of these with various operators.

@menu
* Constants::       String, numeric, and regexp constants.
* Variables::       Variables give names to values for later use.
* Arithmetic Ops::  Arithmetic operations (@samp{+}, @samp{-}, etc.)
* Concatenation::   Concatenating strings.
* Comparison Ops::  Comparison of numbers and strings with @samp{<}, etc.
* Boolean Ops::     Combining comparison expressions using boolean operators
                    @samp{||} (``or''), @samp{&&} (``and'') and @samp{!} (``not'').

* Assignment Ops::  Changing the value of a variable or a field.
* Increment Ops::   Incrementing the numeric value of a variable.

* Conversion::      The conversion of strings to numbers and vice versa.
* Conditional Exp:: Conditional expressions select between two subexpressions
                    under control of a third subexpression.
* Function Calls::  A function call is an expression.
* Precedence::      How various operators nest.
@end menu

@node Constants, Variables, Expressions, Expressions
@section Constant Expressions
@cindex constants, types of
@cindex string constants

The simplest type of expression is the @dfn{constant}, which always has
the same value.  There are three types of constant: numeric constants,
string constants, and regular expression constants.

@cindex numeric constant
@cindex numeric value
A @dfn{numeric constant} stands for a number.  This number can be an
integer, a decimal fraction, or a number in scientific (exponential)
notation.  Note that all numeric values are represented within
@code{awk} in double-precision floating point.  Here are some examples
of numeric constants, which all have the same value:

@example
105
1.05e+2
1050e-1
@end example

A string constant consists of a sequence of characters enclosed in
double-quote marks.  For example:

@example
"parrot"
@end example

@noindent
@c @cindex differences between @code{gawk} and @code{awk}
represents the string whose contents are @samp{parrot}.  Strings in
@code{gawk} can be of any length and they can contain all the possible
8-bit ASCII characters including ASCII NUL.  Other @code{awk}
implementations may have difficulty with some character codes.@refill

@cindex escape sequence notation
Some characters cannot be included literally in a string constant.  You
represent them instead with @dfn{escape sequences}, which are character
sequences beginning with a backslash (@samp{\}).

One use of an escape sequence is to include a double-quote character in
a string constant.  Since a plain double-quote would end the string, you
must use @samp{\"} to represent a single double-quote character as a
part of the string.  Backslash itself is another character that can't be
included normally; you write @samp{\\} to put one backslash in the
string.  Thus, the string whose contents are the two characters
@samp{"\} must be written @code{"\"\\"}.

Another use of backslash is to represent unprintable characters
such as newline.  While there is nothing to stop you from writing most
of these characters directly in a string constant, they may look ugly.

Here is a table of all the escape sequences used in @code{awk}:

@table @code
@item \\
Represents a literal backslash, @samp{\}.

@item \a
Represents the ``alert'' character, control-g, ASCII code 7.

@item \b
Represents a backspace, control-h, ASCII code 8.

@item \f
Represents a formfeed, control-l, ASCII code 12.

@item \n
Represents a newline, control-j, ASCII code 10.

@item \r
Represents a carriage return, control-m, ASCII code 13.

@item \t
Represents a horizontal tab, control-i, ASCII code 9.

@item \v
Represents a vertical tab, control-k, ASCII code 11.

@item \@var{nnn}
Represents the octal value @var{nnn}, where @var{nnn} are one to three
digits between 0 and 7.  For example, the code for the ASCII ESC
(escape) character is @samp{\033}.@refill

@item \x@var{hh@dots{}}
Represents the hexadecimal value @var{hh}, where @var{hh} are hexadecimal
digits (@samp{0} through @samp{9} and either @samp{A} through @samp{F} or
@samp{a} through @samp{f}).  Like the same construct in ANSI C, the escape
sequence continues until the first non-hexadecimal digit is seen.  However,
using more than two hexadecimal digits produces undefined results.@refill
@end table

A constant regexp is a regular expression description enclosed in
slashes, such as @code{/^beginning and end$/}.  Most regexps used in
@code{awk} programs are constant, but the @samp{~} and @samp{!~}
operators can also match computed or ``dynamic'' regexps (@pxref{Regexp
Usage}).

Constant regexps are useful only with the @samp{~} and @samp{!~} operators;
you cannot assign them to variables or print them.  They are not truly
expressions in the usual sense.

@node Variables, Arithmetic Ops, Constants, Expressions
@section Variables
@cindex variables, user-defined
@cindex user-defined variables

Variables let you give names to values and refer to them later.  You have
already seen variables in many of the examples.  The name of a variable
must be a sequence of letters, digits and underscores, but it may not begin
with a digit.  Case is significant in variable names; @code{a} and @code{A}
are distinct variables.

A variable name is a valid expression by itself; it represents the
variable's current value.  Variables are given new values with
@dfn{assignment operators} and @dfn{increment operators}.
@xref{Assignment Ops}.

A few variables have special built-in meanings, such as @code{FS}, the
field separator, and @code{NF}, the number of fields in the current
input record.  @xref{Built-in Variables}, for a list of them.  These
built-in variables can be used and assigned just like all other
variables, but their values are also used or changed automatically by
@code{awk}.  Each built-in variable's name is made entirely of upper case
letters.

Variables in @code{awk} can be assigned either numeric values or string
values.  By default, variables are initialized to the null string, which
is effectively zero if converted to a number.  So there is no need to
``initialize'' each variable explicitly in @code{awk}, the way you would
need to do in C or most other traditional programming languages.

@menu
* Assignment Options::  Setting variables on the command line and a summary
                        of command line syntax.  This is an advanced method
                        of input.
@end menu

@node Assignment Options,, Variables, Variables
@subsection Assigning Variables on the Command Line

You can set any @code{awk} variable by including a @dfn{variable assignment}
among the arguments on the command line when you invoke @code{awk}
(@pxref{Command Line}).  Such an assignment has this form:

@example
@var{variable}=@var{text}
@end example

@noindent
With it, you can set a variable either at the beginning of the
@code{awk} run or in between input files.

If you precede the assignment with the @samp{-v} option, like this:

@example
-v @var{variable}=@var{text}
@end example

@noindent
then the variable is set at the very beginning, before even the
@code{BEGIN} rules are run.  The @samp{-v} option and its assignment
must precede all the file name arguments.

Otherwise, the variable assignment is performed at a time determined by
its position among the input file arguments: after the processing of the
preceding input file argument.  For example:

@example
awk '@{ print $n @}' n=4 inventory-shipped n=2 BBS-list
@end example

@noindent
prints the value of field number @code{n} for all input records.  Before
the first file is read, the command line sets the variable @code{n}
equal to 4.  This causes the fourth field to be printed in lines from
the file @file{inventory-shipped}.  After the first file has finished,
but before the second file is started, @code{n} is set to 2, so that the
second field is printed in lines from @file{BBS-list}.

Command line arguments are made available for explicit examination by
the @code{awk} program in an array named @code{ARGV} (@pxref{Built-in
Variables}).

@node Arithmetic Ops, Concatenation, Variables, Expressions
@section Arithmetic Operators
@cindex arithmetic operators
@cindex operators, arithmetic
@cindex addition
@cindex subtraction
@cindex multiplication
@cindex division
@cindex remainder
@cindex quotient
@cindex exponentiation

The @code{awk} language uses the common arithmetic operators when
evaluating expressions.  All of these arithmetic operators follow normal
precedence rules, and work as you would expect them to.  This example
divides field three by field four, adds field two, stores the result
into field one, and prints the resulting altered input record:

@example
awk '@{ $1 = $2 + $3 / $4; print @}' inventory-shipped
@end example

The arithmetic operators in @code{awk} are:

@table @code
@item @var{x} + @var{y}
Addition.

@item @var{x} - @var{y}
Subtraction.

@item - @var{x}
Negation.

@item @var{x} * @var{y}
Multiplication.

@item @var{x} / @var{y}
Division.  Since all numbers in @code{awk} are double-precision
floating point, the result is not rounded to an integer: @code{3 / 4}
has the value 0.75.

@item @var{x} % @var{y}
@c @cindex differences between @code{gawk} and @code{awk}
Remainder.  The quotient is rounded toward zero to an integer,
multiplied by @var{y} and this result is subtracted from @var{x}.
This operation is sometimes known as ``trunc-mod''.  The following
relation always holds:

@example
b * int(a / b) + (a % b) == a
@end example

One undesirable effect of this definition of remainder is that
@code{@var{x} % @var{y}} is negative if @var{x} is negative.  Thus,

@example
-17 % 8 = -1
@end example

In other @code{awk} implementations, the signedness of the remainder
may be machine dependent.

@item @var{x} ^ @var{y}
@itemx @var{x} ** @var{y}
Exponentiation: @var{x} raised to the @var{y} power.  @code{2 ^ 3} has
the value 8.  The character sequence @samp{**} is equivalent to
@samp{^}.
@end table

@node Concatenation, Comparison Ops, Arithmetic Ops, Expressions
@section String Concatenation

@cindex string operators
@cindex operators, string
@cindex concatenation
There is only one string operation: concatenation.  It does not have a
specific operator to represent it.  Instead, concatenation is performed by
writing expressions next to one another, with no operator.  For example:

@example
awk '@{ print "Field number one: " $1 @}' BBS-list
@end example

@noindent
produces, for the first record in @file{BBS-list}:

@example
Field number one: aardvark
@end example

Without the space in the string constant after the @samp{:}, the line
would run together.  For example:

@example
awk '@{ print "Field number one:" $1 @}' BBS-list
@end example

@noindent
produces, for the first record in @file{BBS-list}:

@example
Field number one:aardvark
@end example

Since string concatenation does not have an explicit operator, it is
often necessary to insure that it happens where you want it to by
enclosing the items to be concatenated in parentheses.  For example, the
following code fragment does not concatenate @code{file} and @code{name}
as you might expect:

@example
file = "file"
name = "name"
print "something meaningful" > file name
@end example

@noindent
It is necessary to use the following:

@example
print "something meaningful" > (file name)
@end example

We recommend you use parentheses around concatenation in all but the
most common contexts (such as in the right-hand operand of @samp{=}).

@ignore
@code{gawk} actually now allows a concatenation on the right hand
side of a @code{>} redirection, but other @code{awk}s don't.  So for
now we won't mention that fact.
@end ignore

@node Comparison Ops, Boolean Ops, Concatenation, Expressions
@section Comparison Expressions
@cindex comparison expressions
@cindex expressions, comparison
@cindex relational operators
@cindex operators, relational
@cindex regexp operators

@dfn{Comparison expressions} compare strings or numbers for
relationships such as equality.  They are written using @dfn{relational
operators}, which are a superset of those in C.  Here is a table of
them:

@table @code
@item @var{x} < @var{y}
True if @var{x} is less than @var{y}.

@item @var{x} <= @var{y}
True if @var{x} is less than or equal to @var{y}.

@item @var{x} > @var{y}
True if @var{x} is greater than @var{y}.

@item @var{x} >= @var{y}
True if @var{x} is greater than or equal to @var{y}.

@item @var{x} == @var{y}
True if @var{x} is equal to @var{y}.

@item @var{x} != @var{y}
True if @var{x} is not equal to @var{y}.

@item @var{x} ~ @var{y}
True if the string @var{x} matches the regexp denoted by @var{y}.

@item @var{x} !~ @var{y}
True if the string @var{x} does not match the regexp denoted by @var{y}.

@item @var{subscript} in @var{array}
True if array @var{array} has an element with the subscript @var{subscript}.
@end table

Comparison expressions have the value 1 if true and 0 if false.

The operands of a relational operator are compared as numbers if they
are both numbers.  Otherwise they are converted to, and compared as,
strings (@pxref{Conversion}).  Strings are compared by comparing the
first character of each, then the second character of each, and so on.
Thus, @code{"10"} is less than @code{"9"}.

For example,

@example
$1 == "foo"
@end example

@noindent
has the value of 1, or is true, if the first field of the current input
record is precisely @samp{foo}.  By contrast, 

@example
$1 ~ /foo/
@end example

@noindent
has the value 1 if the first field contains @samp{foo}.

The right hand operand of the @samp{~} and @samp{!~} operators may be
either a constant regexp (@code{/@dots{}/}), or it may be an ordinary
expression, in which case the value of the expression as a string is a
dynamic regexp (@pxref{Regexp Usage}).

@cindex regexp as expression
In very recent implementations of @code{awk}, a constant regular
expression in slashes by itself is also an expression.  The regexp
@code{/@var{regexp}/} is an abbreviation for this comparison expression:

@example
$0 ~ /@var{regexp}/
@end example

In some contexts it may be necessary to write parentheses around the
regexp to avoid confusing the @code{gawk} parser.  For example,
@code{(/x/ - /y/) > threshold} is not allowed, but @code{((/x/) - (/y/))
> threshold} parses properly.

One special place where @code{/foo/} is @emph{not} an abbreviation for
@code{$0 ~ /foo/} is when it is the right-hand operand of @samp{~} or
@samp{!~}!

@node Boolean Ops, Assignment Ops, Comparison Ops, Expressions
@section Boolean Expressions
@cindex expressions, boolean
@cindex boolean expressions
@cindex operators, boolean
@cindex boolean operators
@cindex logical operations
@cindex and operator
@cindex or operator
@cindex not operator

A @dfn{boolean expression} is combination of comparison expressions or
matching expressions, using the @dfn{boolean operators} ``or''
(@samp{||}), ``and'' (@samp{&&}), and ``not'' (@samp{!}), along with
parentheses to control nesting.  The truth of the boolean expression is
computed by combining the truth values of the component expressions.

Boolean expressions can be used wherever comparison and matching
expressions can be used.  They can be used in @code{if} and @code{while}
statements.  They have numeric values (1 if true, 0 if false), which
come into place if the result of the boolean expression is stored in a
variable, or used in arithmetic.

In addition, every boolean expression is also a valid boolean pattern, so
you can use it as a pattern to control the execution of rules.

Here are descriptions of the three boolean operators, with an example of
each.  It may be instructive to compare these examples with the
analogous examples of boolean patterns (@pxref{Boolean Patterns}), which
use the same boolean operators in patterns instead of expressions.

@table @code
@item @var{boolean1} && @var{boolean2}
True if both @var{boolean1} and @var{boolean2} are true.  For example,
the following statement prints the current input record if it contains
both @samp{2400} and @samp{foo}.@refill

@example
if ($0 ~ /2400/ && $0 ~ /foo/) print
@end example

The subexpression @var{boolean2} is evaluated only if @var{boolean1}
is true.  This can make a difference when @var{boolean2} contains
expressions that have side effects: in the case of @code{$0 ~ /foo/ &&
($2 == bar++)}, the variable @code{bar} is not incremented if there is
no @samp{foo} in the record.

@item @var{boolean1} || @var{boolean2}
True if at least one of @var{boolean1} and @var{boolean2} is true.
For example, the following command prints all records in the input
file @file{BBS-list} that contain @emph{either} @samp{2400} or
@samp{foo}, or both.@refill

@example
awk '@{ if ($0 ~ /2400/ || $0 ~ /foo/) print @}' BBS-list
@end example

The subexpression @var{boolean2} is evaluated only if @var{boolean1}
is false.  This can make a difference when @var{boolean2} contains
expressions that have side effects.

@item !@var{boolean}
True if @var{boolean} is false.  For example, the following program prints
all records in the input file @file{BBS-list} that do @emph{not} contain the
string @samp{foo}.

@example
awk '@{ if (! ($0 ~ /foo/)) print @}' BBS-list
@end example
@end table

@node Assignment Ops, Increment Ops, Boolean Ops, Expressions
@section Assignment Expressions
@cindex assignment operators
@cindex operators, assignment
@cindex expressions, assignment

An @dfn{assignment} is an expression that stores a new value into a
variable.  For example, let's assign the value 1 to the variable
@code{z}:@refill

@example
z = 1
@end example

After this expression is executed, the variable @code{z} has the value 1.
Whatever old value @code{z} had before the assignment is forgotten.

Assignments can store string values also.  For example, this would store
the value @code{"this food is good"} in the variable @code{message}:

@example
thing = "food"
predicate = "good"
message = "this " thing " is " predicate
@end example

@noindent
(This also illustrates concatenation of strings.)

The @samp{=} sign is called an @dfn{assignment operator}.  It is the
simplest assignment operator because the value of the right-hand
operand is stored unchanged.

@cindex side effect
Most operators (addition, concatenation, and so on) have no effect
except to compute a value.  If you ignore the value, you might as well
not use the operator.  An assignment operator is different; it does
produce a value, but even if you ignore the value, the assignment still
makes itself felt through the alteration of the variable.  We call this
a @dfn{side effect}.

@cindex lvalue
The left-hand operand of an assignment need not be a variable
(@pxref{Variables}); it can also be a field (@pxref{Changing Fields}) or
an array element (@pxref{Arrays}).  These are all called @dfn{lvalues},
which means they can appear on the left-hand side of an assignment operator.
The right-hand operand may be any expression; it produces the new value
which the assignment stores in the specified variable, field or array
element.

It is important to note that variables do @emph{not} have permanent types.
The type of a variable is simply the type of whatever value it happens
to hold at the moment.  In the following program fragment, the variable
@code{foo} has a numeric value at first, and a string value later on:

@example
foo = 1
print foo
foo = "bar"
print foo
@end example

@noindent
When the second assignment gives @code{foo} a string value, the fact that
it previously had a numeric value is forgotten.

An assignment is an expression, so it has a value: the same value that
is assigned.  Thus, @code{z = 1} as an expression has the value 1.
One consequence of this is that you can write multiple assignments together:

@example
x = y = z = 0
@end example

@noindent
stores the value 0 in all three variables.  It does this because the
value of @code{z = 0}, which is 0, is stored into @code{y}, and then
the value of @code{y = z = 0}, which is 0, is stored into @code{x}.

You can use an assignment anywhere an expression is called for.  For
example, it is valid to write @code{x != (y = 1)} to set @code{y} to 1
and then test whether @code{x} equals 1.  But this style tends to make
programs hard to read; except in a one-shot program, you should
rewrite it to get rid of such nesting of assignments.  This is never very
hard.

Aside from @samp{=}, there are several other assignment operators that
do arithmetic with the old value of the variable.  For example, the
operator @samp{+=} computes a new value by adding the right-hand value
to the old value of the variable.  Thus, the following assignment adds
5 to the value of @code{foo}:

@example
foo += 5
@end example

@noindent
This is precisely equivalent to the following:

@example
foo = foo + 5
@end example

@noindent
Use whichever one makes the meaning of your program clearer.

Here is a table of the arithmetic assignment operators.  In each
case, the right-hand operand is an expression whose value is converted
to a number.

@table @code
@item @var{lvalue} += @var{increment}
Adds @var{increment} to the value of @var{lvalue} to make the new value
of @var{lvalue}.

@item @var{lvalue} -= @var{decrement}
Subtracts @var{decrement} from the value of @var{lvalue}.

@item @var{lvalue} *= @var{coefficient}
Multiplies the value of @var{lvalue} by @var{coefficient}.

@item @var{lvalue} /= @var{quotient}
Divides the value of @var{lvalue} by @var{quotient}.

@item @var{lvalue} %= @var{modulus}
Sets @var{lvalue} to its remainder by @var{modulus}.

@item @var{lvalue} ^= @var{power}
@itemx @var{lvalue} **= @var{power}
Raises @var{lvalue} to the power @var{power}.
@end table

@node Increment Ops, Conversion, Assignment Ops, Expressions
@section Increment Operators

@cindex increment operators
@cindex operators, increment
@dfn{Increment operators} increase or decrease the value of a variable
by 1.  You could do the same thing with an assignment operator, so
the increment operators add no power to the @code{awk} language; but they
are convenient abbreviations for something very common.

The operator to add 1 is written @samp{++}.  It can be used to increment
a variable either before or after taking its value.

To pre-increment a variable @var{v}, write @code{++@var{v}}.  This adds
1 to the value of @var{v} and that new value is also the value of this
expression.  The assignment expression @code{@var{v} += 1} is completely
equivalent.

Writing the @samp{++} after the variable specifies post-increment.  This
increments the variable value just the same; the difference is that the
value of the increment expression itself is the variable's @emph{old}
value.  Thus, if @code{foo} has value 4, then the expression @code{foo++}
has the value 4, but it changes the value of @code{foo} to 5.

The post-increment @code{foo++} is nearly equivalent to writing @code{(foo
+= 1) - 1}.  It is not perfectly equivalent because all numbers in
@code{awk} are floating point: in floating point, @code{foo + 1 - 1} does
not necessarily equal @code{foo}.  But the difference is minute as
long as you stick to numbers that are fairly small (less than a trillion).

Any lvalue can be incremented.  Fields and array elements are incremented
just like variables.

The decrement operator @samp{--} works just like @samp{++} except that
it subtracts 1 instead of adding.  Like @samp{++}, it can be used before
the lvalue to pre-decrement or after it to post-decrement.

Here is a summary of increment and decrement expressions.

@table @code
@item ++@var{lvalue}
This expression increments @var{lvalue} and the new value becomes the
value of this expression.

@item @var{lvalue}++
This expression causes the contents of @var{lvalue} to be incremented.
The value of the expression is the @emph{old} value of @var{lvalue}.

@item --@var{lvalue}
Like @code{++@var{lvalue}}, but instead of adding, it subtracts.  It
decrements @var{lvalue} and delivers the value that results.

@item @var{lvalue}--
Like @code{@var{lvalue}++}, but instead of adding, it subtracts.  It
decrements @var{lvalue}.  The value of the expression is the @emph{old}
value of @var{lvalue}.
@end table

@node Conversion, Conditional Exp, Increment Ops, Expressions
@section Conversion of Strings and Numbers

@cindex conversion of strings and numbers
Strings are converted to numbers, and numbers to strings, if the context
of the @code{awk} program demands it.  For example, if the value of
either @code{foo} or @code{bar} in the expression @code{foo + bar}
happens to be a string, it is converted to a number before the addition
is performed.  If numeric values appear in string concatenation, they
are converted to strings.  Consider this:@refill

@example
two = 2; three = 3
print (two three) + 4
@end example

@noindent
This eventually prints the (numeric) value 27.  The numeric values of
the variables @code{two} and @code{three} are converted to strings and
concatenated together, and the resulting string is converted back to the
number 23, to which 4 is then added.

If, for some reason, you need to force a number to be converted to a
string, concatenate the null string with that number.  To force a string
to be converted to a number, add zero to that string.

Strings are converted to numbers by interpreting them as numerals:
@code{"2.5"} converts to 2.5, and @code{"1e3"} converts to 1000.
Strings that can't be interpreted as valid numbers are converted to
zero.

@vindex OFMT
The exact manner in which numbers are converted into strings is controlled
by the @code{awk} built-in variable @code{OFMT} (@pxref{Built-in Variables}).
Numbers are converted using a special
version of the @code{sprintf} function (@pxref{Built-in}) with @code{OFMT}
as the format specifier.@refill

@code{OFMT}'s default value is @code{"%.6g"}, which prints a value with
at least six significant digits.  For some applications you will want to
change it to specify more precision.  Double precision on most modern
machines gives you 16 or 17 decimal digits of precision.

Strange results can happen if you set @code{OFMT} to a string that doesn't
tell @code{sprintf} how to format floating point numbers in a useful way.
For example, if you forget the @samp{%} in the format, all numbers will be
converted to the same constant string.@refill

@node Conditional Exp, Function Calls, Conversion, Expressions
@section Conditional Expressions
@cindex conditional expression
@cindex expression, conditional

A @dfn{conditional expression} is a special kind of expression with
three operands.  It allows you to use one expression's value to select
one of two other expressions.

The conditional expression looks the same as in the C language:

@example
@var{selector} ? @var{if-true-exp} : @var{if-false-exp}
@end example

@noindent
There are three subexpressions.  The first, @var{selector}, is always
computed first.  If it is ``true'' (not zero) then @var{if-true-exp} is
computed next and its value becomes the value of the whole expression.
Otherwise, @var{if-false-exp} is computed next and its value becomes the
value of the whole expression.

For example, this expression produces the absolute value of @code{x}:

@example
x > 0 ? x : -x
@end example

Each time the conditional expression is computed, exactly one of
@var{if-true-exp} and @var{if-false-exp} is computed; the other is ignored.
This is important when the expressions contain side effects.  For example,
this conditional expression examines element @code{i} of either array
@code{a} or array @code{b}, and increments @code{i}.

@example
x == y ? a[i++] : b[i++]
@end example

@noindent
This is guaranteed to increment @code{i} exactly once, because each time
one or the other of the two increment expressions is executed,
and the other is not.

@node Function Calls, Precedence, Conditional Exp, Expressions
@section Function Calls
@cindex function call
@cindex calling a function

A @dfn{function} is a name for a particular calculation.  Because it has
a name, you can ask for it by name at any point in the program.  For
example, the function @code{sqrt} computes the square root of a number.

A fixed set of functions are @dfn{built in}, which means they are
available in every @code{awk} program.  The @code{sqrt} function is one
of these.  @xref{Built-in}, for a list of built-in functions and their
descriptions.  In addition, you can define your own functions in the
program for use elsewhere in the same program.  @xref{User-defined},
for how to do this.

@cindex arguments in function call
The way to use a function is with a @dfn{function call} expression,
which consists of the function name followed by a list of
@dfn{arguments} in parentheses.  The arguments are expressions which
give the raw materials for the calculation that the function will do.
When there is more than one argument, they are separated by commas.  If
there are no arguments, write just @samp{()} after the function name.
Here are some examples:

@example
sqrt(x**2 + y**2)    # @r{One argument}
atan2(y, x)          # @r{Two arguments}
rand()               # @r{No arguments}
@end example

@strong{Do not put any space between the function name and the
open-parenthesis!}  A user-defined function name looks just like the name of
a variable, and space would make the expression look like concatenation
of a variable with an expression inside parentheses.  Space before the
parenthesis is harmless with built-in functions, but it is best not to get
into the habit of using space, lest you do likewise for a user-defined
function one day by mistake.

Each function expects a particular number of arguments.  For example, the
@code{sqrt} function must be called with a single argument, the number
to take the square root of:

@example
sqrt(@var{argument})
@end example

Some of the built-in functions allow you to omit the final argument.
If you do so, they use a reasonable default.  @xref{Built-in},
for full details.  If arguments are omitted in calls to user-defined
functions, then those arguments are treated as local variables,
initialized to the null string (@pxref{User-defined}).

Like every other expression, the function call has a value, which is
computed by the function based on the arguments you give it.  In this
example, the value of @code{sqrt(@var{argument})} is the square root of the
argument.  A function can also have side effects, such as assigning the
values of certain variables or doing I/O.

Here is a command to read numbers, one number per line, and print the
square root of each one:

@example
awk '@{ print "The square root of", $1, "is", sqrt($1) @}'
@end example

@node Precedence,, Function Calls, Expressions
@section Operator Precedence: How Operators Nest
@cindex precedence
@cindex operator precedence

@dfn{Operator precedence} determines how operators are grouped, when
different operators appear close by in one expression.  For example,
@samp{*} has higher precedence than @samp{+}; thus, @code{a + b * c}
means to multiply @code{b} and @code{c}, and then add @code{a} to the
product.

You can overrule the precedence of the operators by writing parentheses
yourself.  You can think of the precedence rules as saying where the
parentheses are assumed if you do not write parentheses yourself.  In
fact, it is wise always to use parentheses whenever you have an unusual
combination of operators, because other people who read the program may
not remember what the precedence is in this case.  You might forget,
too; then you could make a mistake.  Explicit parentheses will prevent
any such mistake.

When operators of equal precedence are used together, the leftmost
operator groups first, except for the assignment, conditional and
and exponentiation operators, which group in the opposite order.
Thus, @code{a - b + c} groups as @code{(a - b) + c};
@code{a = b = c} groups as @code{a = (b = c)}.

The precedence of prefix unary operators does not matter as long as only
unary operators are involved, because there is only one way to parse
them---innermost first.  Thus, @code{$++i} means @code{$(++i)} and
@code{++$x} means @code{++($x)}.  However, when another operator follows
the operand, then the precedence of the unary operators can matter.
Thus, @code{$x**2} means @code{($x)**2}, but @code{-x**2} means
@code{-(x**2)}, because @samp{-} has lower precedence than @samp{**}
while @samp{$} has higher precedence.

Here is a table of the operators of @code{awk}, in order of increasing
precedence:

@table @asis
@item assignment
@samp{=}, @samp{+=}, @samp{-=}, @samp{*=}, @samp{/=}, @samp{%=},
@samp{^=}, @samp{**=}.  These operators group right-to-left.

@item conditional
@samp{?:}.  These operators group right-to-left.

@item logical ``or''.
@samp{||}.

@item logical ``and''.
@samp{&&}.

@item array membership
@code{in}.

@item matching
@samp{~}, @samp{!~}.

@item relational, and redirection
The relational operators and the redirections have the same precedence
level.  Characters such as @samp{>} serve both as relationals and as
redirections; the context distinguishes between the two meanings.

The relational operators are @samp{<}, @samp{<=}, @samp{==}, @samp{!=},
@samp{>=} and @samp{>}.

The I/O redirection operators are @samp{<}, @samp{>}, @samp{>>} and
@samp{|}.

Note that I/O redirection operators in @code{print} and @code{printf}
statements belong to the statement level, not to expressions.  The
redirection does not produce an expression which could be the operand of
another operator.  As a result, it does not make sense to use a
redirection operator near another operator of lower precedence, without
parentheses.  Such combinations, for example @samp{print foo > a ? b :
c}, result in syntax errors.

@item concatentation
No special token is used to indicate concatenation.
The operands are simply written side by side.
@c This is supposedly being fixed
@ignore
Concatenation has the same precedence as relational and redirection
operators.  These operators nest left to right.  Thus, @code{4 5 > 6}
concatenates first, yielding 1, while @code{6 < 4 5} compares first, and
yields @code{"05"}.
@end ignore

@item add, subtract
@samp{+}, @samp{-}.

@item multiply, divide, mod
@samp{*}, @samp{/}, @samp{%}.

@item unary plus, minus, ``not''
@samp{+}, @samp{-}, @samp{!}.

@item exponentiation
@samp{^}, @samp{**}.  These operators group right-to-left.

@item increment, decrement
@samp{++}, @samp{--}.

@item field
@samp{$}.
@end table

@node Statements, Arrays, Expressions, Top
@chapter Actions: Control Statements
@cindex control statement

@dfn{Control statements} such as @code{if}, @code{while}, and so on
control the flow of execution in @code{awk} programs.  Most of the
control statements in @code{awk} are patterned on similar statements in
C.

All the control statements start with special keywords such as @code{if}
and @code{while}, to distinguish them from simple expressions.

Many control statements contain other statements; for example, the
@code{if} statement contains another statement which may or may not be
executed.  The contained statement is called the @dfn{body}.  If you
want to include more than one statement in the body, group them into a
single compound statement with curly braces, separating them with
newlines or semicolons.

@menu
* If Statement::            Conditionally execute some @code{awk} statements.

* While Statement::         Loop until some condition is satisfied.

* Do Statement::            Do specified action while looping until some
                            condition is satisfied.

* For Statement::           Another looping statement, that provides
                            initialization and increment clauses.

* Break Statement::         Immediately exit the innermost enclosing loop.

* Continue Statement::      Skip to the end of the innermost enclosing loop.

* Next Statement::          Stop processing the current input record.

* Exit Statement::          Stop execution of @code{awk}.
@end menu

@node If Statement, While Statement, Statements, Statements
@section The @code{if} Statement

@cindex @code{if} statement
The @code{if}-@code{else} statement is @code{awk}'s decision-making
statement.  It looks like this:@refill

@example
if (@var{condition}) @var{then-body} @r{[}else @var{else-body}@r{]}
@end example

@noindent
Here @var{condition} is an expression that controls what the rest of the
statement will do.  If @var{condition} is true, @var{then-body} is
executed; otherwise, @var{else-body} is executed (assuming that the
@code{else} clause is present).  The @code{else} part of the statement is
optional.  The condition is considered false if its value is zero or
the null string, true otherwise.@refill

Here is an example:

@example
if (x % 2 == 0)
    print "x is even"
else
    print "x is odd"
@end example

In this example, if the expression @code{x % 2 == 0} is true (that is,
the value of @code{x} is divisible by 2), then the first @code{print}
statement is executed, otherwise the second @code{print} statement is
performed.@refill

If the @code{else} appears on the same line as @var{then-body}, and
@var{then-body} is not a compound statement (i.e., not surrounded by
curly braces), then a semicolon must separate @var{then-body} from
@code{else}.  To illustrate this, let's rewrite the previous example:

@group
@example
awk '@{ if (x % 2 == 0) print "x is even"; else
        print "x is odd" @}'
@end example
@end group

@noindent
If you forget the @samp{;}, @code{awk} won't be able to parse the
statement, and you will get a syntax error.

We would not actually write this example this way, because a human
reader might fail to see the @code{else} if it were not the first thing
on its line.

@node While Statement, Do Statement, If Statement, Statements
@section The @code{while} Statement
@cindex @code{while} statement
@cindex loop
@cindex body of a loop

In programming, a @dfn{loop} means a part of a program that is (or at least can
be) executed two or more times in succession.

The @code{while} statement is the simplest looping statement in
@code{awk}.  It repeatedly executes a statement as long as a condition is
true.  It looks like this:

@example
while (@var{condition})
  @var{body}
@end example

@noindent
Here @var{body} is a statement that we call the @dfn{body} of the loop,
and @var{condition} is an expression that controls how long the loop
keeps running.

The first thing the @code{while} statement does is test @var{condition}.
If @var{condition} is true, it executes the statement @var{body}.
(Truth, as usual in @code{awk}, means that the value of @var{condition}
is not zero and not a null string.)  After @var{body} has been executed,
@var{condition} is tested again, and if it is still true, @var{body} is
executed again.  This process repeats until @var{condition} is no longer
true.  If @var{condition} is initially false, the body of the loop is
never executed.@refill

This example prints the first three fields of each record, one per line.

@example
awk '@{ i = 1
       while (i <= 3) @{
           print $i
           i++
       @}
@}'
@end example

@noindent
Here the body of the loop is a compound statement enclosed in braces,
containing two statements.

The loop works like this: first, the value of @code{i} is set to 1.
Then, the @code{while} tests whether @code{i} is less than or equal to
three.  This is the case when @code{i} equals one, so the @code{i}-th
field is printed.  Then the @code{i++} increments the value of @code{i}
and the loop repeats.  The loop terminates when @code{i} reaches 4.

As you can see, a newline is not required between the condition and the
body; but using one makes the program clearer unless the body is a
compound statement or is very simple.  The newline after the open-brace
that begins the compound statement is not required either, but the
program would be hard to read without it.

@node Do Statement, For Statement, While Statement, Statements
@section The @code{do}-@code{while} Statement

The @code{do} loop is a variation of the @code{while} looping statement.
The @code{do} loop executes the @var{body} once, then repeats @var{body}
as long as @var{condition} is true.  It looks like this:

@group
@example
do
  @var{body}
while (@var{condition})
@end example
@end group

Even if @var{condition} is false at the start, @var{body} is executed at
least once (and only once, unless executing @var{body} makes
@var{condition} true).  Contrast this with the corresponding
@code{while} statement:

@example
while (@var{condition})
  @var{body}
@end example

@noindent
This statement does not execute @var{body} even once if @var{condition}
is false to begin with.

Here is an example of a @code{do} statement:

@example
awk '@{ i = 1
       do @{
          print $0
          i++
       @} while (i <= 10)
@}'
@end example

@noindent
prints each input record ten times.  It isn't a very realistic example,
since in this case an ordinary @code{while} would do just as well.  But
this reflects actual experience; there is only occasionally a real use
for a @code{do} statement.@refill

@node For Statement, Break Statement, Do Statement, Statements
@section The @code{for} Statement
@cindex @code{for} statement

The @code{for} statement makes it more convenient to count iterations of a
loop.  The general form of the @code{for} statement looks like this:@refill

@example
for (@var{initialization}; @var{condition}; @var{increment})
  @var{body}
@end example

@noindent
This statement starts by executing @var{initialization}.  Then, as long
as @var{condition} is true, it repeatedly executes @var{body} and then
@var{increment}.  Typically @var{initialization} sets a variable to
either zero or one, @var{increment} adds 1 to it, and @var{condition}
compares it against the desired number of iterations.

Here is an example of a @code{for} statement:

@example
awk '@{ for (i = 1; i <= 3; i++)
          print $i
@}'
@end example

@noindent
This prints the first three fields of each input record, one field per
line.

In the @code{for} statement, @var{body} stands for any statement, but
@var{initialization}, @var{condition} and @var{increment} are just
expressions.  You cannot set more than one variable in the
@var{initialization} part unless you use a multiple assignment statement
such as @code{x = y = 0}, which is possible only if all the initial values
are equal.  (But you can initialize additional variables by writing
their assignments as separate statements preceding the @code{for} loop.)

The same is true of the @var{increment} part; to increment additional
variables, you must write separate statements at the end of the loop.
The C compound expression, using C's comma operator, would be useful in
this context, but it is not supported in @code{awk}.

Most often, @var{increment} is an increment expression, as in the
example above.  But this is not required; it can be any expression
whatever.  For example, this statement prints all the powers of 2
between 1 and 100:

@example
for (i = 1; i <= 100; i *= 2)
  print i
@end example

Any of the three expressions in the parentheses following @code{for} may
be omitted if there is nothing to be done there.  Thus, @w{@samp{for (;x
> 0;)}} is equivalent to @w{@samp{while (x > 0)}}.  If the
@var{condition} is omitted, it is treated as @var{true}, effectively
yielding an infinite loop.@refill

In most cases, a @code{for} loop is an abbreviation for a @code{while}
loop, as shown here:

@example
@var{initialization}
while (@var{condition}) @{
  @var{body}
  @var{increment}
@}
@end example

@noindent
The only exception is when the @code{continue} statement
(@pxref{Continue Statement}) is used inside the loop; changing a
@code{for} statement to a @code{while} statement in this way can change
the effect of the @code{continue} statement inside the loop.

There is an alternate version of the @code{for} loop, for iterating over
all the indices of an array:

@example
for (i in array)
    @var{do something with} array[i]
@end example

@noindent
@xref{Arrays}, for more information on this version of the @code{for} loop.

The @code{awk} language has a @code{for} statement in addition to a
@code{while} statement because often a @code{for} loop is both less work to
type and more natural to think of.  Counting the number of iterations is
very common in loops.  It can be easier to think of this counting as part
of looping rather than as something to do inside the loop.

The next section has more complicated examples of @code{for} loops.

@node Break Statement, Continue Statement, For Statement, Statements
@section The @code{break} Statement
@cindex @code{break} statement
@cindex loops, exiting

The @code{break} statement jumps out of the innermost @code{for},
@code{while}, or @code{do}-@code{while} loop that encloses it.  The
following example finds the smallest divisor of any integer, and also
identifies prime numbers:@refill

@example
awk '# find smallest divisor of num
     @{ num = $1
       for (div = 2; div*div <= num; div++)
         if (num % div == 0)
           break
       if (num % div == 0)
         printf "Smallest divisor of %d is %d\n", num, div
       else
         printf "%d is prime\n", num  @}'
@end example

When the remainder is zero in the first @code{if} statement, @code{awk}
immediately @dfn{breaks out} of the containing @code{for} loop.  This means
that @code{awk} proceeds immediately to the statement following the loop
and continues processing.  (This is very different from the @code{exit}
statement (@pxref{Exit Statement}) which stops the entire @code{awk}
program.)@refill

Here is another program equivalent to the previous one.  It illustrates how
the @var{condition} of a @code{for} or @code{while} could just as well be
replaced with a @code{break} inside an @code{if}:

@example
awk '# find smallest divisor of num
     @{ num = $1
       for (div = 2; ; div++) @{
         if (num % div == 0) @{
           printf "Smallest divisor of %d is %d\n", num, div
           break
         @}
         if (div*div > num) @{
           printf "%d is prime\n", num
           break
         @}
       @}
@}'
@end example

@node Continue Statement, Next Statement, Break Statement, Statements
@section The @code{continue} Statement

@cindex @code{continue} statement
The @code{continue} statement, like @code{break}, is used only inside
@code{for}, @code{while}, and @code{do}-@code{while} loops.  It skips
over the rest of the loop body, causing the next cycle around the loop
to begin immediately.  Contrast this with @code{break}, which jumps out
of the loop altogether.  Here is an example:@refill

@example
# print names that don't contain the string "ignore"

# first, save the text of each line
@{ names[NR] = $0 @}

# print what we're interested in
END @{
   for (x in names) @{
       if (names[x] ~ /ignore/)
           continue
       print names[x]
   @}
@}
@end example

If one of the input records contains the string @samp{ignore}, this
example skips the print statement for that record, and continues back to
the first statement in the loop.

This isn't a practical example of @code{continue}, since it would be
just as easy to write the loop like this:

@example
for (x in names)
  if (names[x] !~ /ignore/)
    print names[x]
@end example

The @code{continue} statement in a @code{for} loop directs @code{awk} to
skip the rest of the body of the loop, and resume execution with the
increment-expression of the @code{for} statement.  The following program
illustrates this fact:@refill

@example
awk 'BEGIN @{
     for (x = 0; x <= 20; x++) @{
         if (x == 5)
             continue
         printf ("%d ", x)
     @}
     print ""
@}'
@end example

@noindent
This program prints all the numbers from 0 to 20, except for 5, for
which the @code{printf} is skipped.  Since the increment @code{x++}
is not skipped, @code{x} does not remain stuck at 5.  Contrast the
@code{for} loop above with the @code{while} loop:

@example
awk 'BEGIN @{
     x = 0
     while (x <= 20) @{
         if (x == 5)
             continue
         printf ("%d ", x)
         x++
     @}
     print ""
@}'
@end example

@noindent
This program loops forever once @code{x} gets to 5.

@node Next Statement, Exit Statement, Continue Statement, Statements
@section The @code{next} Statement
@cindex @code{next} statement

The @code{next} statement forces @code{awk} to immediately stop processing
the current record and go on to the next record.  This means that no
further rules are executed for the current record.  The rest of the
current rule's action is not executed either.

Contrast this with the effect of the @code{getline} function
(@pxref{Getline}).  That too causes @code{awk} to read the next record
immediately, but it does not alter the flow of control in any way.  So
the rest of the current action executes with a new input record.

At the grossest level, @code{awk} program execution is a loop that reads
an input record and then tests each rule's pattern against it.  If you
think of this loop as a @code{for} statement whose body contains the
rules, then the @code{next} statement is analogous to a @code{continue}
statement: it skips to the end of the body of this implicit loop, and
executes the increment (which reads another record).

For example, if your @code{awk} program works only on records with four
fields, and you don't want it to fail when given bad input, you might
use this rule near the beginning of the program:

@example
NF != 4 @{
  printf("line %d skipped: doesn't have 4 fields", FNR) > "/dev/stderr"
  next
@}
@end example

@noindent
so that the following rules will not see the bad record.  The error
message is redirected to the standard error output stream, as error
messages should be.  @xref{Special Files}.

The @code{next} statement is not allowed in a @code{BEGIN} or @code{END}
rule.

@node Exit Statement, , Next Statement, Statements
@section The @code{exit} Statement

@cindex @code{exit} statement
The @code{exit} statement causes @code{awk} to immediately stop
executing the current rule and to stop processing input; any remaining input
is ignored.@refill

If an @code{exit} statement is executed from a @code{BEGIN} rule the
program stops processing everything immediately.  No input records are
read.  However, if an @code{END} rule is present, it is executed
(@pxref{BEGIN/END}).

If @code{exit} is used as part of an @code{END} rule, it causes
the program to stop immediately.

An @code{exit} statement that is part an ordinary rule (that is, not part
of a @code{BEGIN} or @code{END} rule) stops the execution of any further
automatic rules, but the @code{END} rule is executed if there is one.
If you don't want the @code{END} rule to do its job in this case, you
can set a variable to nonzero before the @code{exit} statement, and check
that variable in the @code{END} rule.

If an argument is supplied to @code{exit}, its value is used as the exit
status code for the @code{awk} process.  If no argument is supplied,
@code{exit} returns status zero (success).@refill

For example, let's say you've discovered an error condition you really
don't know how to handle.  Conventionally, programs report this by
exiting with a nonzero status.  Your @code{awk} program can do this
using an @code{exit} statement with a nonzero argument.  Here's an
example of this:@refill

@example
BEGIN @{
       if (("date" | getline date_now) < 0) @{
         print "Can't get system date" > "/dev/stderr"
         exit 4
       @}
@}
@end example

@node Arrays, Built-in, Statements, Top
@chapter Arrays in @code{awk}

An @dfn{array} is a table of various values, called @dfn{elements}.  The
elements of an array are distinguished by their @dfn{indices}.  Indices
may be either numbers or strings.  Each array has a name, which looks
like a variable name, but must not be in use as a variable name in the
same @code{awk} program.

@menu
* Intro: Array Intro.      Basic facts about arrays in @code{awk}.
* Reference to Elements::  How to examine one element of an array.
* Assigning Elements::     How to change an element of an array.
* Example: Array Example.  Sample program explained.

* Scanning an Array::      A variation of the @code{for} statement.  It loops
                           through the indices of an array's existing elements.

* Delete::                 The @code{delete} statement removes an element from an array.

* Multi-dimensional::      Emulating multi-dimensional arrays in @code{awk}.
* Multi-scanning::         Scanning multi-dimensional arrays.
@end menu

@node Array Intro, Reference to Elements, Arrays, Arrays
@section Introduction to Arrays

@cindex arrays
The @code{awk} language has one-dimensional @dfn{arrays} for storing groups
of related strings or numbers.

Every @code{awk} array must have a name.  Array names have the same
syntax as variable names; any valid variable name would also be a valid
array name.  But you cannot use one name in both ways (as an array and
as a variable) in one @code{awk} program.

Arrays in @code{awk} superficially resemble arrays in other programming
languages; but there are fundamental differences.  In @code{awk}, you
don't need to specify the size of an array before you start to use it.
What's more, in @code{awk} any number or even a string may be used as an
array index.

In most other languages, you have to @dfn{declare} an array and specify
how many elements or components it has.  In such languages, the
declaration causes a contiguous block of memory to be allocated for that
many elements.  An index in the array must be a positive integer; for
example, the index 0 specifies the first element in the array, which is
actually stored at the beginning of the block of memory.  Index 1
specifies the second element, which is stored in memory right after the
first element, and so on.  It is impossible to add more elements to the
array, because it has room for only as many elements as you declared.

A contiguous array of four elements might look like this, conceptually,
if the element values are 8, @code{"foo"}, @code{""} and 30:@refill

@example
+---------+---------+--------+---------+
|    8    |  "foo"  |   ""   |    30   |    @r{value}
+---------+---------+--------+---------+
     0         1         2         3        @r{index}
@end example

@noindent
Only the values are stored; the indices are implicit from the order of
the values.  8 is the value at index 0, because 8 appears in the
position with 0 elements before it.

@cindex arrays, definition of
@cindex associative arrays
Arrays in @code{awk} are different: they are @dfn{associative}.  This means
that each array is a collection of pairs: an index, and its corresponding
array element value:

@example
@r{Element} 4     @r{Value} 30
@r{Element} 2     @r{Value} "foo"
@r{Element} 1     @r{Value} 8
@r{Element} 3     @r{Value} ""
@end example

@noindent
We have shown the pairs in jumbled order because their order doesn't
mean anything.

One advantage of an associative array is that new pairs can be added
at any time.  For example, suppose we add to that array a tenth element
whose value is @w{@code{"number ten"}}.  The result is this:

@example
@r{Element} 10    @r{Value} "number ten"
@r{Element} 4     @r{Value} 30
@r{Element} 2     @r{Value} "foo"
@r{Element} 1     @r{Value} 8
@r{Element} 3     @r{Value} ""
@end example

@noindent
Now the array is @dfn{sparse} (i.e., some indices are missing): it has
elements 4 and 10, but doesn't have elements 5, 6, 7, 8, or 9.@refill

Another consequence of associative arrays is that the indices don't
have to be positive integers.  Any number, or even a string, can be
an index.  For example, here is an array which translates words from
English into French:

@example
@r{Element} "dog" @r{Value} "chien"
@r{Element} "cat" @r{Value} "chat"
@r{Element} "one" @r{Value} "un"
@r{Element} 1     @r{Value} "un"
@end example

@noindent
Here we decided to translate the number 1 in both spelled-out and
numeric form---thus illustrating that a single array can have both
numbers and strings as indices.

When @code{awk} creates an array for you, e.g., with the @code{split}
built-in function (@pxref{String Functions}), that array's indices
are consecutive integers starting at 1.

@node Reference to Elements, Assigning Elements, Array Intro, Arrays
@section Referring to an Array Element
@cindex array reference
@cindex element of array
@cindex reference to array

The principal way of using an array is to refer to one of its elements.
An array reference is an expression which looks like this:

@example
@var{array}[@var{index}]
@end example

@noindent
Here @var{array} is the name of an array.  The expression @var{index} is
the index of the element of the array that you want.

The value of the array reference is the current value of that array
element.  For example, @code{foo[4.3]} is an expression for the element
of array @code{foo} at index 4.3.

If you refer to an array element that has no recorded value, the value
of the reference is @code{""}, the null string.  This includes elements
to which you have not assigned any value, and elements that have been
deleted (@pxref{Delete}).  Such a reference automatically creates that
array element, with the null string as its value.  (In some cases,
this is unfortunate, because it might waste memory inside @code{awk}).

@cindex arrays, determining presence of elements
You can find out if an element exists in an array at a certain index with
the expression:

@example
@var{index} in @var{array}
@end example

@noindent
This expression tests whether or not the particular index exists,
without the side effect of creating that element if it is not present.
The expression has the value 1 (true) if @code{@var{array}[@var{index}]}
exists, and 0 (false) if it does not exist.@refill

For example, to test whether the array @code{frequencies} contains the
index @code{"2"}, you could write this statement:@refill

@example
if ("2" in frequencies) print "Subscript \"2\" is present."
@end example

Note that this is @emph{not} a test of whether or not the array
@code{frequencies} contains an element whose @emph{value} is @code{"2"}.
(There is no way to do that except to scan all the elements.)  Also, this
@emph{does not} create @code{frequencies["2"]}, while the following
(incorrect) alternative would do so:@refill

@example
if (frequencies["2"] != "") print "Subscript \"2\" is present."
@end example

@node Assigning Elements, Array Example, Reference to Elements, Arrays
@section Assigning Array Elements
@cindex array assignment
@cindex element assignment

Array elements are lvalues: they can be assigned values just like
@code{awk} variables:

@example
@var{array}[@var{subscript}] = @var{value}
@end example

@noindent
Here @var{array} is the name of your array.  The expression
@var{subscript} is the index of the element of the array that you want
to assign a value.  The expression @var{value} is the value you are
assigning to that element of the array.@refill

@node Array Example, Scanning an Array, Assigning Elements, Arrays
@section Basic Example of an Array

The following program takes a list of lines, each beginning with a line
number, and prints them out in order of line number.  The line numbers are
not in order, however, when they are first read:  they are scrambled.  This
program sorts the lines by making an array using the line numbers as
subscripts.  It then prints out the lines in sorted order of their numbers.
It is a very simple program, and gets confused if it encounters repeated
numbers, gaps, or lines that don't begin with a number.@refill

@example
@{
  if ($1 > max)
    max = $1
  arr[$1] = $0
@}

END @{
  for (x = 1; x <= max; x++)
    print arr[x]
@}
@end example

@ignore
The first rule just initializes the variable @code{max}.  (This is not
strictly necessary, since an uninitialized variable has the null string
as its value, and the null string is effectively zero when used in
a context where a number is required.)
@end ignore

The first rule keeps track of the largest line number seen so far;
it also stores each line into the array @code{arr}, at an index that
is the line's number.

The second rule runs after all the input has been read, to print out
all the lines.

When this program is run with the following input:

@example
5  I am the Five man
2  Who are you?  The new number two!
4  . . . And four on the floor
1  Who is number one?
3  I three you.
@end example

@noindent
its output is this:

@example
1  Who is number one?
2  Who are you?  The new number two!
3  I three you.
4  . . . And four on the floor
5  I am the Five man
@end example

If a line number is repeated, the last line with a given number overrides
the others.

Gaps in the line numbers can be handled with an easy improvement to the
program's @code{END} rule:

@example
END @{
  for (x = 1; x <= max; x++)
    if (x in arr)
      print arr[x]
@}
@end example

@node Scanning an Array, Delete, Array Example, Arrays
@section Scanning All Elements of an Array
@cindex @code{for (x in @dots{})}
@cindex arrays, special @code{for} statement
@cindex scanning an array

In programs that use arrays, often you need a loop that executes
once for each element of an array.  In other languages, where arrays are
contiguous and indices are limited to positive integers, this is
easy: the largest index is one less than the length of the array, and you can
find all the valid indices by counting from zero up to that value.  This
technique won't do the job in @code{awk}, since any number or string
may be an array index.  So @code{awk} has a special kind of @code{for}
statement for scanning an array:

@example
for (@var{var} in @var{array})
  @var{body}
@end example

@noindent
This loop executes @var{body} once for each different value that your
program has previously used as an index in @var{array}, with the
variable @var{var} set to that index.@refill

Here is a program that uses this form of the @code{for} statement.  The
first rule scans the input records and notes which words appear (at
least once) in the input, by storing a 1 into the array @code{used} with
the word as index.  The second rule scans the elements of @code{used} to
find all the distinct words that appear in the input.  It prints each
word that is more than 10 characters long, and also prints the number of
such words.  @xref{Built-in}, for more information on the built-in
function @code{length}.

@example
# Record a 1 for each word that is used at least once.
@{
  for (i = 1; i <= NF; i++)
    used[$i] = 1
@}

# Find number of distinct words more than 10 characters long.
END @{
  num_long_words = 0
  for (x in used)
    if (length(x) > 10) @{
      ++num_long_words
      print x
  @}
  print num_long_words, "words longer than 10 characters"
@}
@end example

@noindent
@xref{Sample Program}, for a more detailed example of this type.

The order in which elements of the array are accessed by this statement
is determined by the internal arrangement of the array elements within
@code{awk} and cannot be controlled or changed.  This can lead to
problems if new elements are added to @var{array} by statements in
@var{body}; you cannot predict whether or not the @code{for} loop will
reach them.  Similarly, changing @var{var} inside the loop can produce
strange results.  It is best to avoid such things.@refill

@node Delete, Multi-dimensional, Scanning an Array, Arrays
@section The @code{delete} Statement
@cindex @code{delete} statement
@cindex deleting elements of arrays
@cindex removing elements of arrays
@cindex arrays, deleting an element

You can remove an individual element of an array using the @code{delete}
statement:

@example
delete @var{array}[@var{index}]
@end example

When an array element is deleted, it is as if you had never referred to it
and had never given it any value.  Any value the element formerly had
can no longer be obtained.

Here is an example of deleting elements in an array:

@example
for (i in frequencies)
  delete frequencies[i]
@end example

@noindent
This example removes all the elements from the array @code{frequencies}.

If you delete an element, a subsequent @code{for} statement to scan the array
will not report that element, and the @code{in} operator to check for
the presence of that element will return 0:

@example
delete foo[4]
if (4 in foo)
  print "This will never be printed"
@end example

@node Multi-dimensional, Multi-scanning, Delete, Arrays
@section Multi-dimensional Arrays

@cindex subscripts, multi-dimensional in arrays
@cindex arrays, multi-dimensional subscripts
@cindex multi-dimensional subscripts
A multi-dimensional array is an array in which an element is identified
by a sequence of indices, not a single index.  For example, a
two-dimensional array requires two indices.  The usual way (in most
languages, including @code{awk}) to refer to an element of a
two-dimensional array named @code{grid} is with
@code{grid[@var{x},@var{y}]}.

@vindex SUBSEP
Multi-dimensional arrays are supported in @code{awk} through
concatenation of indices into one string.  What happens is that
@code{awk} converts the indices into strings (@pxref{Conversion}) and
concatenates them together, with a separator between them.  This creates
a single string that describes the values of the separate indices.  The
combined string is used as a single index into an ordinary,
one-dimensional array.  The separator used is the value of the built-in
variable @code{SUBSEP}.

For example, suppose we evaluate the expression @code{foo[5,12]="value"}
when the value of @code{SUBSEP} is @code{"@@"}.  The numbers 5 and 12 are
concatenated with a comma between them, yielding @code{"5@@12"}; thus,
the array element @code{foo["5@@12"]} is set to @code{"value"}.

Once the element's value is stored, @code{awk} has no record of whether
it was stored with a single index or a sequence of indices.  The two
expressions @code{foo[5,12]} and @w{@code{foo[5 SUBSEP 12]}} always have
the same value.

The default value of @code{SUBSEP} is actually the string @code{"\034"},
which contains a nonprinting character that is unlikely to appear in an
@code{awk} program or in the input data.

The usefulness of choosing an unlikely character comes from the fact
that index values that contain a string matching @code{SUBSEP} lead to
combined strings that are ambiguous.  Suppose that @code{SUBSEP} were
@code{"@@"}; then @w{@code{foo["a@@b", "c"]}} and @w{@code{foo["a",
"b@@c"]}} would be indistinguishable because both would actually be
stored as @code{foo["a@@b@@c"]}.  Because @code{SUBSEP} is
@code{"\034"}, such confusion can actually happen only when an index
contains the character with ASCII code 034, which is a rare
event.@refill

You can test whether a particular index-sequence exists in a
``multi-dimensional'' array with the same operator @code{in} used for single
dimensional arrays.  Instead of a single index as the left-hand operand,
write the whole sequence of indices, separated by commas, in
parentheses:@refill

@example
(@var{subscript1}, @var{subscript2}, @dots{}) in @var{array}
@end example

The following example treats its input as a two-dimensional array of
fields; it rotates this array 90 degrees clockwise and prints the
result.  It assumes that all lines have the same number of
elements.

@example
awk '@{
     if (max_nf < NF)
          max_nf = NF
     max_nr = NR
     for (x = 1; x <= NF; x++)
          vector[x, NR] = $x
@}

END @{
     for (x = 1; x <= max_nf; x++) @{
          for (y = max_nr; y >= 1; --y)
               printf("%s ", vector[x, y])
          printf("\n")
     @}
@}'
@end example

@noindent
When given the input:

@example
1 2 3 4 5 6
2 3 4 5 6 1
3 4 5 6 1 2
4 5 6 1 2 3
@end example

@noindent
it produces:

@example
4 3 2 1
5 4 3 2
6 5 4 3
1 6 5 4
2 1 6 5
3 2 1 6
@end example

@node Multi-scanning, , Multi-dimensional, Arrays
@section Scanning Multi-dimensional Arrays

There is no special @code{for} statement for scanning a
``multi-dimensional'' array; there cannot be one, because in truth there
are no multi-dimensional arrays or elements; there is only a
multi-dimensional @emph{way of accessing} an array.

However, if your program has an array that is always accessed as
multi-dimensional, you can get the effect of scanning it by combining
the scanning @code{for} statement (@pxref{Scanning an Array}) with the
@code{split} built-in function (@pxref{String Functions}).  It works
like this:

@example
for (combined in @var{array}) @{
  split(combined, separate, SUBSEP)
  @dots{}
@}
@end example

@noindent
This finds each concatenated, combined index in the array, and splits it
into the individual indices by breaking it apart where the value of
@code{SUBSEP} appears.  The split-out indices become the elements of
the array @code{separate}.

Thus, suppose you have previously stored in @code{@var{array}[1,
"foo"]}; then an element with index @code{"1\034foo"} exists in
@var{array}.  (Recall that the default value of @code{SUBSEP} contains
the character with code 034.)  Sooner or later the @code{for} statement
will find that index and do an iteration with @code{combined} set to
@code{"1\034foo"}.  Then the @code{split} function is called as
follows:

@example
split("1\034foo", separate, "\034")
@end example

@noindent
The result of this is to set @code{separate[1]} to 1 and @code{separate[2]}
to @code{"foo"}.  Presto, the original sequence of separate indices has
been recovered.

@node Built-in, User-defined, Arrays, Top
@chapter Built-in Functions

@cindex built-in functions
@dfn{Built-in} functions are functions that are always available for
your @code{awk} program to call.  This chapter defines all the built-in
functions in @code{awk}; some of them are mentioned in other sections,
but they are summarized here for your convenience.  (You can also define
new functions yourself.  @xref{User-defined}.)

@menu
* Calling Built-in::   How to call built-in functions.

* Numeric Functions::  Functions that work with numbers,
                       including @code{int}, @code{sin} and @code{rand}.

* String Functions::   Functions for string manipulation,
                       such as @code{split}, @code{match}, and @code{sprintf}.

* I/O Functions::      Functions for files and shell commands
@end menu

@node Calling Built-in, Numeric Functions, Built-in, Built-in
@section Calling Built-in Functions

To call a built-in function, write the name of the function followed
by arguments in parentheses.  For example, @code{atan2(y + z, 1)}
is a call to the function @code{atan2}, with two arguments.

Whitespace is ignored between the built-in function name and the
open-parenthesis, but we recommend that you avoid using whitespace
there.  User-defined functions do not permit whitespace in this way, and
you will find it easier to avoid mistakes by following a simple
convention which always works: no whitespace after a function name.

Each built-in function accepts a certain number of arguments.  In most
cases, any extra arguments given to built-in functions are ignored.  The
defaults for omitted arguments vary from function to function and are
described under the individual functions.

When a function is called, expressions that create the function's actual
parameters are evaluated completely before the function call is performed.
For example, in the code fragment:

@example
i = 4
j = sqrt(i++)
@end example

@noindent
the variable @code{i} is set to 5 before @code{sqrt} is called
with a value of 4 for its actual parameter.

@node Numeric Functions, String Functions, Calling Built-in, Built-in
@section Numeric Built-in Functions

Here is a full list of built-in functions that work with numbers:

@table @code
@item int(@var{x})
This gives you the integer part of @var{x}, truncated toward 0.  This
produces the nearest integer to @var{x}, located between @var{x} and 0.

For example, @code{int(3)} is 3, @code{int(3.9)} is 3, @code{int(-3.9)}
is @minus{}3, and @code{int(-3)} is @minus{}3 as well.@refill

@item sqrt(@var{x})
This gives you the positive square root of @var{x}.  It reports an error
if @var{x} is negative.  Thus, @code{sqrt(4)} is 2.@refill

@item exp(@var{x})
This gives you the exponential of @var{x}, or reports an error if
@var{x} is out of range.  The range of values @var{x} can have depends
on your machine's floating point representation.@refill

@item log(@var{x})
This gives you the natural logarithm of @var{x}, if @var{x} is positive;
otherwise, it reports an error.@refill

@item sin(@var{x})
This gives you the sine of @var{x}, with @var{x} in radians.

@item cos(@var{x})
This gives you the cosine of @var{x}, with @var{x} in radians.

@item atan2(@var{y}, @var{x})
This gives you the arctangent of @code{@var{y} / @var{x}}, with the
quotient understood in radians.

@item rand()
This gives you a random number.  The values of @code{rand} are
uniformly-distributed between 0 and 1.  The value is never 0 and never
1.

Often you want random integers instead.  Here is a user-defined function
you can use to obtain a random nonnegative integer less than @var{n}:

@example
function randint(n) @{
     return int(n * rand())
@}
@end example

@noindent
The multiplication produces a random real number greater than 0 and less
than @var{n}.  We then make it an integer (using @code{int}) between 0
and @code{@var{n} @minus{} 1}.

Here is an example where a similar function is used to produce
random integers between 1 and @var{n}:

@example
awk '
# Function to roll a simulated die.
function roll(n) @{ return 1 + int(rand() * n) @}

# Roll 3 six-sided dice and print total number of points.
@{
      printf("%d points\n", roll(6)+roll(6)+roll(6))
@}'
@end example

@strong{Note:} @code{rand} starts generating numbers from the same
point, or @dfn{seed}, each time you run @code{awk}.  This means that
a program will produce the same results each time you run it.
The numbers are random within one @code{awk} run, but predictable
from run to run.  This is convenient for debugging, but if you want
a program to do different things each time it is used, you must change
the seed to a value that will be different in each run.  To do this,
use @code{srand}.

@item srand(@var{x})
The function @code{srand} sets the starting point, or @dfn{seed},
for generating random numbers to the value @var{x}.

Each seed value leads to a particular sequence of ``random'' numbers.
Thus, if you set the seed to the same value a second time, you will get
the same sequence of ``random'' numbers again.

If you omit the argument @var{x}, as in @code{srand()}, then the current
date and time of day are used for a seed.  This is the way to get random
numbers that are truly unpredictable.

The return value of @code{srand} is the previous seed.  This makes it
easy to keep track of the seeds for use in consistently reproducing
sequences of random numbers.

@item time()
The function @code{time} (not in all versions of @code{awk}) returns the
current time in seconds since January 1, 1970.

@item ctime(@var{then})
The function @code{ctime} (not in all versions of @code{awk}) takes an numeric
argument in seconds and returns a string representing the corresponding date,
suitable for printing or further processing.
@end table

@node String Functions, I/O Functions, Numeric Functions, Built-in
@section Built-in Functions for String Manipulation

  The functions in this section look at the text of one or more
strings.

@table @code
@item index(@var{in}, @var{find})
@findex match
This searches the string @var{in} for the first occurrence of the string
@var{find}, and returns the position where that occurrence begins in the
string @var{in}.  For example:@refill

@example
awk 'BEGIN @{ print index("peanut", "an") @}'
@end example

@noindent
prints @samp{3}.  If @var{find} is not found, @code{index} returns 0.

@item length(@var{string})
@findex length
This gives you the number of characters in @var{string}.  If
@var{string} is a number, the length of the digit string representing
that number is returned.  For example, @code{length("abcde")} is 5.  By
contrast, @code{length(15 * 35)} works out to 3.  How?  Well, 15 * 35 =
525, and 525 is then converted to the string @samp{"525"}, which has
three characters.

If no argument is supplied, @code{length} returns the length of @code{$0}.

@item match(@var{string}, @var{regexp})
@findex match
The @code{match} function searches the string, @var{string}, for the
longest, leftmost substring matched by the regular expression,
@var{regexp}.  It returns the character position, or @dfn{index}, of
where that substring begins (1, if it starts at the beginning of
@var{string}).  If no match if found, it returns 0.

@vindex RSTART
@vindex RLENGTH
The @code{match} function sets the built-in variable @code{RSTART} to
the index.  It also sets the built-in variable @code{RLENGTH} to the
length of the matched substring.  If no match is found, @code{RSTART}
is set to 0, and @code{RLENGTH} to @minus{}1.

For example:

@example
awk '@{
       if ($1 == "FIND")
         regex = $2
       else @{
         where = match($0, regex)
         if (where)
           print "Match of", regex, "found at", where, "in", $0
       @}
@}'
@end example

@noindent
This program looks for lines that match the regular expression stored in
the variable @code{regex}.  This regular expression can be changed.  If the
first word on a line is @samp{FIND}, @code{regex} is changed to be the
second word on that line.  Therefore, given:

@example
FIND fo*bar
My program was a foobar
But none of it would doobar
FIND Melvin
JF+KM
This line is property of The Reality Engineering Co.
This file created by Melvin.
@end example

@noindent
@code{awk} prints:

@example
Match of fo*bar found at 18 in My program was a foobar
Match of Melvin found at 26 in This file created by Melvin.
@end example

@item split(@var{string}, @var{array}, @var{fieldsep})
@findex split
This divides @var{string} up into pieces separated by @var{fieldsep},
and stores the pieces in @var{array}.  The first piece is stored in
@code{@var{array}[1]}, the second piece in @code{@var{array}[2]}, and so
forth.  The string value of the third argument, @var{fieldsep}, is used
as a regexp to search for to find the places to split @var{string}.  If
the @var{fieldsep} is omitted, the value of @code{FS} is used.
@code{split} returns the number of elements created.@refill

The @code{split} function, then, splits strings into pieces in a
manner similar to the way input lines are split into fields.  For example:

@example
split("auto-da-fe", a, "-")
@end example

@noindent
splits the string @samp{auto-da-fe} into three fields using @samp{-} as the
separator.  It sets the contents of the array @code{a} as follows:

@example
a[1] = "auto"
a[2] = "da"
a[3] = "fe"
@end example

@noindent
The value returned by this call to @code{split} is 3.

@item sprintf(@var{format}, @var{expression1},@dots{})
@findex sprintf
This returns (without printing) the string that @code{printf} would
have printed out with the same arguments (@pxref{Printf}).  For
example:

@example
sprintf("pi = %.2f (approx.)", 22/7)
@end example

@noindent
returns the string @w{@code{"pi = 3.14 (approx.)"}}.

@item sub(@var{regexp}, @var{replacement}, @var{target})
@findex sub
The @code{sub} function alters the value of @var{target}.
It searches this value, which should be a string, for the
leftmost substring matched by the regular expression, @var{regexp},
extending this match as far as possible.  Then the entire string is
changed by replacing the matched text with @var{replacement}.
The modified string becomes the new value of @var{target}.

This function is peculiar because @var{target} is not simply
used to compute a value, and not just any expression will do: it
must be a variable, field or array reference, so that @code{sub} can
store a modified value there.  If this argument is omitted, then the
default is to use and alter @code{$0}.

For example:@refill

@example
str = "water, water, everywhere"
sub(/at/, "ith", str)
@end example

@noindent
sets @code{str} to @w{@code{"wither, water, everywhere"}}, by replacing the
leftmost, longest occurrence of @samp{at} with @samp{ith}.

The @code{sub} function returns the number of substitutions made (either
one or zero).

If the special character @samp{&} appears in @var{replacement}, it
stands for the precise substring that was matched by @var{regexp}.  (If
the regexp can match more than one string, then this precise substring
may vary.)  For example:@refill

@example
awk '@{ sub(/candidate/, "& and his wife"); print @}'
@end example

@noindent
changes the first occurrence of @samp{candidate} to @samp{candidate
and his wife} on each input line.

The effect of this special character can be turned off by putting a
backslash before it in the string.  As usual, to insert one backslash in
the string, you must write two backslashes.  Therefore, write @samp{\\&}
in a string constant to include a literal @samp{&} in the replacement.
For example, here is how to replace the first @samp{|} on each line with
an @samp{&}:@refill

@example
awk '@{ sub(/\|/, "\\&"); print @}'
@end example

@strong{Note:} as mentioned above, the third argument to @code{sub} must
be an lvalue.  Some versions of @code{awk} allow the third argument to
be an expression which is not an lvalue.  In such a case, @code{sub}
would still search for the pattern and return 0 or 1, but the result of
the substitution (if any) would be thrown away because there is no place
to put it.  Such versions of @code{awk} accept expressions like
this:@refill

@example
sub(/USA/, "United States", "the USA and Canada")
@end example

@noindent
But that is considered erroneous in @code{gawk}.

@item gsub(@var{regexp}, @var{replacement}, @var{target})
@findex gsub
This is similar to the @code{sub} function, except @code{gsub} replaces
@emph{all} of the longest, leftmost, @emph{nonoverlapping} matching
substrings it can find.  The @samp{g} in @code{gsub} stands for
``global'', which means replace everywhere.  For example:@refill

@example
awk '@{ gsub(/Britain/, "United Kingdom"); print @}'
@end example

@noindent
replaces all occurrences of the string @samp{Britain} with @samp{United
Kingdom} for all input records.@refill

The @code{gsub} function returns the number of substitutions made.  If
the variable to be searched and altered, @var{target}, is
omitted, then the entire input record, @code{$0}, is used.@refill

As in @code{sub}, the characters @samp{&} and @samp{\} are special, and
the third argument must be an lvalue.

@item substr(@var{string}, @var{start}, @var{length})
@findex substr
This returns a @var{length}-character-long substring of @var{string},
starting at character number @var{start}.  The first character of a
string is character number one.  For example,
@code{substr("washington", 5, 3)} returns @code{"ing"}.@refill

If @var{length} is not present, this function returns the whole suffix of
@var{string} that begins at character number @var{start}.  For example,
@code{substr("washington", 5)} returns @code{"ington"}.

@item tolower(@var{string})
@findex tolower
This returns a copy of @var{string}, with each upper-case character
in the string replaced with its corresponding lower-case character.
Nonalphabetic characters are left unchanged.  For example,
@code{tolower("MiXeD cAsE 123")} returns @code{"mixed case 123"}.

@item toupper(@var{string})
@findex toupper
This returns a copy of @var{string}, with each lower-case character
in the string replaced with its corresponding upper-case character.
Nonalphabetic characters are left unchanged.  For example,
@code{toupper("MiXeD cAsE 123")} returns @code{"MIXED CASE 123"}.
@end table

@node I/O Functions, , String Functions, Built-in
@section Built-in Functions For Input/Output

@table @code
@item close(@var{filename})
Close the file @var{filename}, for input or output.  The argument may
alternatively be a shell command that was used for redirecting to or
from a pipe; then the pipe is closed.

@xref{Close Input}, regarding closing input files and pipes.
@xref{Close Output}, regarding closing output files and pipes.

@item system(@var{command})
@findex system
@cindex interaction of @code{awk} with other programs
The system function allows the user to execute operating system commands
and then return to the @code{awk} program.  The @code{system} function
executes the command given by the string @var{command}.  It returns, as
its value, the status returned by the command that was executed.

For example, if the following fragment of code is put in your @code{awk}
program:

@example
END @{
     system("mail -s 'awk run done' operator < /dev/null")
@}
@end example

@noindent
the system operator will be sent mail when the @code{awk} program
finishes processing input and begins its end-of-input processing.

Note that much the same result can be obtained by redirecting
@code{print} or @code{printf} into a pipe.  However, if your @code{awk}
program is interactive, @code{system} is useful for cranking up large
self-contained programs, such as a shell or an editor.@refill

Some operating systems cannot implement the @code{system} function.
@code{system} causes a fatal error if it is not supported.
@end table

@node User-defined, Built-in Variables, Built-in, Top
@chapter User-defined Functions

@cindex user-defined functions
@cindex functions, user-defined
Complicated @code{awk} programs can often be simplified by defining
your own functions.  User-defined functions can be called just like
built-in ones (@pxref{Function Calls}), but it is up to you to define
them---to tell @code{awk} what they should do.

@menu
* Definition Syntax::   How to write definitions and what they mean.
* Function Example::    An example function definition and what it does.
* Function Caveats::    Things to watch out for.
* Return Statement::    Specifying the value a function returns.
@end menu

@node Definition Syntax, Function Example, User-defined, User-defined
@section Syntax of Function Definitions
@cindex defining functions
@cindex function definition

Definitions of functions can appear anywhere between the rules of the
@code{awk} program.  Thus, the general form of an @code{awk} program is
extended to include sequences of rules @emph{and} user-defined function
definitions.

The definition of a function named @var{name} looks like this:

@example
function @var{name} (@var{parameter-list}) @{
     @var{body-of-function}
@}
@end example

@noindent
The keyword @code{function} may be abbreviated @code{func}.

@var{name} is the name of the function to be defined.  A valid function
name is like a valid variable name: a sequence of letters, digits and
underscores, not starting with a digit.

@var{parameter-list} is a list of the function's arguments and local
variable names, separated by commas.  When the function is called,
the argument names are used to hold the argument values given in
the call.  The local variables are initialized to the null string.

The @var{body-of-function} consists of @code{awk} statements.  It is the
most important part of the definition, because it says what the function
should actually @emph{do}.  The argument names exist to give the body a
way to talk about the arguments; local variables, to give the body
places to keep temporary values.

Argument names are not distinguished syntactically from local variable
names; instead, the number of arguments supplied when the function is
called determines how many argument variables there are.  Thus, if three
argument values are given, the first three names in @var{parameter-list}
are arguments, and the rest are local variables.

It follows that if the number of arguments is not the same in all calls
to the function, some of the names in @var{parameter-list} may be
arguments on some occasions and local variables on others.  Another
way to think of this is that omitted arguments default to the
null string.

Usually when you write a function you know how many names you intend to
use for arguments and how many you intend to use as locals.  By
convention, you should write an extra space between the arguments and
the locals, so that other people can follow how your function is
supposed to be used.

During execution of the function body, the arguments and local variable
values hide or @dfn{shadow} any variables of the same names used in the
rest of the program.  The shadowed variables are not accessible in the
function definition, because there is no way to name them while their
names have been taken away for the local variables.  All other variables
used in the @code{awk} program can be referenced or set normally in the
function definition.

The arguments and local variables last only as long as the function body
is executing.  Once the body finishes, the shadowed variables come back.

The function body can contain expressions which call functions.  They
can even call this function, either directly or by way of another
function.  When this happens, we say the function is @dfn{recursive}.

There is no need in @code{awk} to put the definition of a function
before all uses of the function.  This is because @code{awk} reads the
entire program before starting to execute any of it.

@node Function Example, Function Caveats, Definition Syntax, User-defined
@section Function Definition Example

Here is an example of a user-defined function, called @code{myprint}, that
takes a number and prints it in a specific format.

@example
function myprint(num)
@{
     printf "%6.3g\n", num
@}
@end example

@noindent
To illustrate, here is an @code{awk} rule which uses our @code{myprint}
function:

@example
$3 > 0     @{ myprint($3) @}
@end example

@noindent
This program prints, in our special format, all the third fields that
contain a positive number in our input.  Therefore, when given:

@example
 1.2   3.4   5.6   7.8
 9.10 11.12 13.14 15.16
17.18 19.20 21.22 23.24
@end example

@noindent
this program, using our function to format the results, prints:

@example
   5.6
  13.1
  21.2
@end example

Here is a rather contrived example of a recursive function.  It prints a
string backwards:

@example
function rev (str, len) @{
    if (len == 0) @{
        printf "\n"
        return
    @}
    printf "%c", substr(str, len, 1)
    rev(str, len - 1)
@}
@end example

@node Function Caveats, Return Statement, Function Example, User-defined
@section Calling User-defined Functions

@dfn{Calling a function} means causing the function to run and do its job.
A function call is an expression, and its value is the value returned by
the function.

A function call consists of the function name followed by the arguments
in parentheses.  What you write in the call for the arguments are
@code{awk} expressions; each time the call is executed, these
expressions are evaluated, and the values are the actual arguments.  For
example, here is a call to @code{foo} with three arguments:

@example
foo(x y, "lose", 4 * z)
@end example

@strong{Note:} whitespace characters (spaces and tabs) are not allowed
between the function name and the open-parenthesis of the argument list.
If you write whitespace by mistake, @code{awk} might think that you mean
to concatenate a variable with an expression in parentheses.  However, it
notices that you used a function name and not a variable name, and reports
an error.

@cindex call by value
When a function is called, it is given a @emph{copy} of the values of
its arguments.  This is called @dfn{call by value}.  The caller may use
a variable as the expression for the argument, but the called function
does not know this: all it knows is what value the argument had.  For
example, if you write this code:

@example
foo = "bar"
z = myfunc(foo)
@end example

@noindent
then you should not think of the argument to @code{myfunc} as being
``the variable @code{foo}''.  Instead, think of the argument as the
string value, @code{"bar"}.

If the function @code{myfunc} alters the values of its local variables,
this has no effect on any other variables.  In particular, if @code{myfunc}
does this:

@example
function myfunc (win) @{
  print win
  win = "zzz"
  print win
@}
@end example

@noindent
to change its first argument variable @code{win}, this @emph{does not}
change the value of @code{foo} in the caller.  The role of @code{foo} in
calling @code{myfunc} ended when its value, @code{"bar"}, was computed.
If @code{win} also exists outside of @code{myfunc}, the function body
cannot alter this outer value, because it is shadowed during the
execution of @code{myfunc} and cannot be seen or changed from there.

@cindex call by reference
However, when arrays are the parameters to functions, they are @emph{not}
copied.  Instead, the array itself is made available for direct manipulation
by the function.  This is usually called @dfn{call by reference}.
Changes made to an array parameter inside the body of a function @emph{are}
visible outside that function.  @emph{This can be very dangerous if you don't
watch what you are doing.}  For example:@refill

@example
function changeit (array, ind, nvalue) @{
     array[ind] = nvalue
@}

BEGIN @{
           a[1] = 1 ; a[2] = 2 ; a[3] = 3
           changeit(a, 2, "two")
           printf "a[1] = %s, a[2] = %s, a[3] = %s\n", a[1], a[2], a[3]
      @}
@end example

@noindent
prints @samp{a[1] = 1, a[2] = two, a[3] = 3}, because calling
@code{changeit} stores @code{"two"} in the second element of @code{a}.

@node Return Statement, , Function Caveats, User-defined
@section The @code{return} Statement
@cindex @code{return} statement

The body of a user-defined function can contain a @code{return} statement.
This statement returns control to the rest of the @code{awk} program.  It
can also be used to return a value for use in the rest of the @code{awk}
program.  It looks like this:@refill

@example
return @var{expression}
@end example

The @var{expression} part is optional.  If it is omitted, then the returned
value is undefined and, therefore, unpredictable.

A @code{return} statement with no value expression is assumed at the end of
every function definition.  So if control reaches the end of the function
definition, then the function returns an unpredictable value.

Here is an example of a user-defined function that returns a value
for the largest number among the elements of an array:@refill

@example
function maxelt (vec,   i, ret) @{
     for (i in vec) @{
          if (ret == "" || vec[i] > ret)
               ret = vec[i]
     @}
     return ret
@}
@end example

@noindent
You call @code{maxelt} with one argument, an array name.  The local
variables @code{i} and @code{ret} are not intended to be arguments;
while there is nothing to stop you from passing two or three arguments
to @code{maxelt}, the results would be strange.  The extra space before
@code{i} in the function parameter list is to indicate that @code{i} and
@code{ret} are not supposed to be arguments.  This is a convention which
you should follow when you define functions.

Here is a program that uses our @code{maxelt} function.  It loads an
array, calls @code{maxelt}, and then reports the maximum number in that
array:@refill

@example
awk '
function maxelt (vec,   i, ret) @{
     for (i in vec) @{
          if (ret == "" || vec[i] > ret)
               ret = vec[i]
     @}
     return ret
@}

# Load all fields of each record into nums.
@{
          for(i = 1; i <= NF; i++)
               nums[NR, i] = $i
@}

END @{
     print maxelt(nums)
@}'
@end example

Given the following input:

@example
 1 5 23 8 16
44 3 5 2 8 26
256 291 1396 2962 100
-6 467 998 1101
99385 11 0 225
@end example

@noindent
our program tells us (predictably) that:

@example
99385
@end example

@noindent
is the largest number in our array.

@node Built-in Variables, Command Line, User-defined, Top
@chapter Built-in Variables
@cindex built-in variables

Most @code{awk} variables are available for you to use for your own
purposes; they never change except when your program assigns them, and
never affect anything except when your program examines them.

A few variables have special built-in meanings.  Some of them @code{awk}
examines automatically, so that they enable you to tell @code{awk} how
to do certain things.  Others are set automatically by @code{awk}, so
that they carry information from the internal workings of @code{awk} to
your program.

This chapter documents all the built-in variables of @code{gawk}.  Most
of them are also documented in the chapters where their areas of
activity are described.

@menu
* User-modified::  Built-in variables that you change to control @code{awk}.

* Auto-set::       Built-in variables where @code{awk} gives you information.
@end menu

@node User-modified, Auto-set, Built-in Variables, Built-in Variables
@section Built-in Variables That Control @code{awk}
@cindex built-in variables, user modifiable

This is a list of the variables which you can change to control how
@code{awk} does certain things.

@table @code
@c it's unadvisable to have multiple index entries for the same name
@c since in Info there is no way to distinguish the two.
@c @vindex FS
@item FS
@code{FS} is the input field separator (@pxref{Field Separators}).
The value is a single-character string or a multi-character regular
expression that matches the separations between fields in an input
record.

The default value is @w{@code{" "}}, a string consisting of a single
space.  As a special exception, this value actually means that any
sequence of spaces and tabs is a single separator.  It also causes
spaces and tabs at the beginning or end of a line to be ignored.

You can set the value of @code{FS} on the command line using the
@samp{-F} option:

@example
awk -F, '@var{program}' @var{input-files}
@end example

@item IGNORECASE
@c @vindex IGNORECASE
If @code{IGNORECASE} is nonzero, then @emph{all} regular expression
matching is done in a case-independent fashion.  In particular, regexp
matching with @samp{~} and @samp{!~}, and the @code{gsub} @code{index},
@code{match}, @code{split} and @code{sub} functions all ignore case when
doing their particular regexp operations.  @strong{Note:} since field
splitting with the value of the @code{FS} variable is also a regular
expression operation, that too is done with case ignored.
@xref{Case-sensitivity}.

If @code{gawk} is in compatibility mode (@pxref{Command Line}), then
@code{IGNORECASE} has no special meaning, and regexp operations are
always case-sensitive.@refill

@item OFMT
@c @vindex OFMT
This string is used by @code{awk} to control conversion of numbers to
strings (@pxref{Conversion}).  It works by being passed, in effect, as
the first argument to the @code{sprintf} function.  Its default value
is @code{"%.6g"}.@refill

@item OFS
@c @vindex OFS
This is the output field separator (@pxref{Output Separators}).  It is
output between the fields output by a @code{print} statement.  Its
default value is @w{@code{" "}}, a string consisting of a single space.

@item ORS
@c @vindex ORS
This is the output record separator.  It is output at the end of every
@code{print} statement.  Its default value is a string containing a
single newline character, which could be written as @code{"\n"}.
(@xref{Output Separators}).@refill

@item RS
@c @vindex RS
This is @code{awk}'s record separator.  Its default value is a string
containing a single newline character, which means that an input record
consists of a single line of text.  (@xref{Records}.)@refill

@item SUBSEP
@c @vindex SUBSEP
@code{SUBSEP} is a subscript separator.  It has the default value of
@code{"\034"}, and is used to separate the parts of the name of a
multi-dimensional array.  Thus, if you access @code{foo[12,3]}, it
really accesses @code{foo["12\0343"]}.  (@xref{Multi-dimensional}).@refill
@end table

@node Auto-set, , User-modified, Built-in Variables
@section Built-in Variables That Convey Information to You

This is a list of the variables that are set automatically by @code{awk}
on certain occasions so as to provide information for your program.

@table @code
@item ARGC
@itemx ARGV
@c @vindex ARGC
@c @vindex ARGV
The command-line arguments available to @code{awk} are stored in an
array called @code{ARGV}.  @code{ARGC} is the number of command-line
arguments present.  @code{ARGV} is indexed from zero to @w{@code{ARGC - 1}}.
@xref{Command Line}.  For example:

@example
awk '@{ print ARGV[$1] @}' inventory-shipped BBS-list
@end example

@noindent
In this example, @code{ARGV[0]} contains @code{"awk"}, @code{ARGV[1]}
contains @code{"inventory-shipped"}, and @code{ARGV[2]} contains
@code{"BBS-list"}.  The value of @code{ARGC} is 3, one more than the
index of the last element in @code{ARGV} since the elements are numbered
from zero.@refill

Notice that the @code{awk} program is not entered in @code{ARGV}.  The
other special command line options, with their arguments, are also not
entered.  But variable assignments on the command line @emph{are}
treated as arguments, and do show up in the @code{ARGV} array.

Your program can alter @code{ARGC} and the elements of @code{ARGV}.
Each time @code{awk} reaches the end of an input file, it uses the next
element of @code{ARGV} as the name of the next input file.  By storing a
different string there, your program can change which files are read.
You can use @code{"-"} to represent the standard input.  By storing
additional elements and incrementing @code{ARGC} you can cause
additional files to be read.

If you decrease the value of @code{ARGC}, that eliminates input files
from the end of the list.  By recording the old value of @code{ARGC}
elsewhere, your program can treat the eliminated arguments as
something other than file names.

To eliminate a file from the middle of the list, store the null string
(@code{""}) into @code{ARGV} in place of the file's name.  As a
special feature, @code{awk} ignores file names that have been
replaced with the null string.

@item ENVIRON
@vindex ENVIRON
This is an array that contains the values of the environment.  The array
indices are the environment variable names; the values are the values of
the particular environment variables.  For example,
@code{ENVIRON["HOME"]} might be @file{/u/close}.  Changing this array
does not affect the environment passed on to any programs that
@code{awk} may spawn via redirection or the @code{system} function.
(In a future version of @code{gawk}, it may do so.)

Some operating systems may not have environment variables.
On such systems, the array @code{ENVIRON} is empty.

@item FILENAME
@c @vindex FILENAME
This is the name of the file that @code{awk} is currently reading.
If @code{awk} is reading from the standard input (in other words,
there are no files listed on the command line),
@code{FILENAME} is set to @code{"-"}.
@code{FILENAME} is changed each time a new file is read (@pxref{Reading
Files}).@refill

@item FNR
@c @vindex FNR
@code{FNR} is the current record number in the current file.  @code{FNR} is
incremented each time a new record is read (@pxref{Getline}).
It is reinitialized to 0 each time a new input file is started.

@item NF
@c @vindex NF
@code{NF} is the number of fields in the current input record.
@code{NF} is set each time a new record is read, when a new field is
created, or when @code{$0} changes (@pxref{Fields}).@refill

@item NR
@c @vindex NR
This is the number of input records @code{awk} has processed since
the beginning of the program's execution.  (@pxref{Records}).
@code{NR} is set each time a new record is read.@refill

@item RLENGTH
@c @vindex RLENGTH
@code{RLENGTH} is the length of the substring matched by the
@code{match} function (@pxref{String Functions}).  @code{RLENGTH} is set
by invoking the @code{match} function.  Its value is the length of the
matched string, or @minus{}1 if no match was found.@refill

@item RSTART
@c @vindex RSTART
@code{RSTART} is the start-index of the substring matched by the
@code{match} function (@pxref{String Functions}).  @code{RSTART} is set
by invoking the @code{match} function.  Its value is the position of the
string where the matched substring starts, or 0 if no match was
found.@refill
@end table

@node Command Line, Language History, Built-in Variables, Top
@c node-name, next, previous, up
@chapter Invocation of @code{awk}
@cindex command line
@cindex invocation of @code{gawk}
@cindex arguments, command line
@cindex options, command line

There are two ways to run @code{awk}: with an explicit program, or with
one or more program files.  Here are templates for both of them; items
enclosed in @samp{@r{[}@dots{}@r{]}} in these templates are optional.

@example
awk @r{[@code{-F@var{fs}}] [@code{-v @var{var}=@var{val}}] [@code{-V}] [@code{-C}] [@code{-c}] [@code{-a}] [@code{-e}] [@code{--}]} '@var{program}' @var{file} @dots{}
awk @r{[@code{-F@var{fs}}] @code{-f @var{source-file}} [@code{-f @var{source-file} @dots{}}] [@code{-v @var{var}=@var{val}}] [@code{-V}] [@code{-C}] [@code{-c}] [@code{-a}] [@code{-e}] [@code{--}]} @var{file} @dots{}
@end example

@menu
* Options::             Command line options and their meanings.
* Other Arguments::     Input file names and variable assignments.
* AWKPATH Variable::    Searching directories for @code{awk} programs.
@end menu

@node Options, Other Arguments, Command Line, Command Line
@section Command Line Options

Options begin with a minus sign, and consist of a single character.
The options and their meanings are as follows:

@table @code
@item -F@var{fs}
Sets the @code{FS} variable to @var{fs} (@pxref{Field Separators}).

@item -f @var{source-file}
Indicates that the @code{awk} program is to be found in @var{source-file}
instead of in the first non-option argument.

@item -v @var{var}=@var{val}
@cindex @samp{-v} option
Sets the variable @var{var} to the value @var{val} @emph{before}
execution of the program begins.  Such variable values are available
inside the @code{BEGIN} rule (see below for a fuller explanation).

The @samp{-v} option only has room to set one variable, but you can use
it more than once, setting another variable each time, like this:
@samp{@w{-v foo=1} @w{-v bar=2}}.

@item -a
Specifies use of traditional @code{awk} syntax for regular expressions.
This means that @samp{\} can be used to quote any regular expression
operators inside of square brackets, just as it can be outside of them.
This mode is currently the default; the @samp{-a} option is useful in
shell scripts so that they will not break if the default is changed.
@xref{Regexp Operators}.

@item -e
Specifies use of @code{egrep} syntax for regular expressions.  This
means that @samp{\} does not serve as a quoting character inside of
square brackets; ideosyncratic techniques are needed to include various
special characters within them.  This mode may become the default at
some time in the future.  @xref{Regexp Operators}.

@item -c
@cindex @samp{-c} option
Specifies @dfn{compatibility mode}, in which the GNU extensions in
@code{gawk} are disabled, so that @code{gawk} behaves just like Unix
@code{awk}.  These extensions are noted below, where their usage is
explained.  @xref{Compatibility Mode}.

@item -V
@cindex @samp{-V} option
Prints version information for this particular copy of @code{gawk}.
This is so you can determine if your copy of @code{gawk} is up to date
with respect to whatever the Free Software Foundation is currently
distributing.  This option may disappear in a future version of @code{gawk}.

@item -C
@cindex @samp{-C} option
Prints the short version of the General Public License.
This option may disappear in a future version of @code{gawk}.

@item --
Signals the end of the command line options.  The following arguments
are not treated as options even if they begin with @samp{-}.  This
interpretation of @samp{--} follows the POSIX argument parsing
conventions.

This is useful if you have file names that start with @samp{-},
or in shell scripts, if you have file names that will be specified
by the user and that might start with @samp{-}.
@end table

Any other options are flagged as invalid with a warning message, but
are otherwise ignored.

In compatibility mode, as a special case, if the value of @var{fs} supplied
to the @samp{-F} option is @samp{t}, then @code{FS} is set to the tab
character (@code{"\t"}).  Also, the @samp{-C} and @samp{-V} options
are not recognized.@refill

If the @samp{-f} option is @emph{not} used, then the first non-option
command line argument is expected to be the program text.

The @samp{-f} option may be used more than once on the command line.
Then @code{awk} reads its program source from all of the named files, as
if they had been concatenated together into one big file.  This is
useful for creating libraries of @code{awk} functions.  Useful functions
can be written once, and then retrieved from a standard place, instead
of having to be included into each individual program.  You can still
type in a program at the terminal and use library functions, by specifying
@samp{-f /dev/tty}.  @code{awk} will read a file from the terminal
to use as part of the @code{awk} program.  After typing your program,
type @kbd{Control-d} (the end-of-file character) to terminate it.

@node Other Arguments, AWKPATH Variable, Options, Command Line
@section Other Command Line Arguments

Any additional arguments on the command line are normally treated as
input files to be processed in the order specified.  However, an
argument that has the form @code{@var{var}=@var{value}}, means to assign
the value @var{value} to the variable @var{var}---it does not specify a
file at all.

@vindex ARGV
All these arguments are made available to your @code{awk} program in the
@code{ARGV} array (@pxref{Built-in Variables}).  Command line options
and the program text (if present) are omitted from the @code{ARGV}
array.  All other arguments, including variable assignments, are
included.

The distinction between file name arguments and variable-assignment
arguments is made when @code{awk} is about to open the next input file.
At that point in execution, it checks the ``file name'' to see whether
it is really a variable assignment; if so, @code{awk} sets the variable
instead of reading a file.

Therefore, the variables actually receive the specified values after all
previously specified files have been read.  In particular, the values of
variables assigned in this fashion are @emph{not} available inside a
@code{BEGIN} rule (@pxref{BEGIN/END}), since such rules are run before
@code{awk} begins scanning the argument list.@refill

In some earlier implementations of @code{awk}, when a variable assignment
occurred before any file names, the assignment would happen @emph{before}
the @code{BEGIN} rule was executed.  Some applications came to depend
upon this ``feature''.  When @code{awk} was changed to be more consistent,
the @samp{-v} option was added to accomodate applications that depended
upon this old behaviour.

The variable assignment feature is most useful for assigning to variables
such as @code{RS}, @code{OFS}, and @code{ORS}, which control input and
output formats, before scanning the data files.  It is also useful for
controlling state if multiple passes are needed over a data file.  For
example:@refill

@cindex multiple passes over data
@cindex passes, multiple
@example
awk 'pass == 1  @{ @var{pass 1 stuff} @}
     pass == 2  @{ @var{pass 2 stuff} @}' pass=1 datafile pass=2 datafile
@end example

@node AWKPATH Variable,, Other Arguments, Command Line
@section The @code{AWKPATH} Environment Variable
@cindex @code{AWKPATH} environment variable
@cindex search path
@cindex directory search
@cindex path, search
@c @cindex differences between @code{gawk} and @code{awk}

The previous section described how @code{awk} program files can be named
on the command line with the @samp{-f} option.  In some @code{awk}
implementations, you must supply a precise path name for each program
file, unless the file is in the current directory.

But in @code{gawk}, if the file name supplied in the @samp{-f} option
does not contain a @samp{/}, then @code{gawk} searches a list of
directories (called the @dfn{search path}), one by one, looking for a
file with the specified name.

The search path is actually a string containing directory names
separated by colons.  @code{gawk} gets its search path from the
@code{AWKPATH} environment variable.  If that variable does not exist,
@code{gawk} uses the default path, which is
@samp{.:/usr/lib/awk:/usr/local/lib/awk}.@refill

The search path feature is particularly useful for building up libraries
of useful @code{awk} functions.  The library files can be placed in a
standard directory that is in the default path, and then specified on
the command line with a short file name.  Otherwise, the full file name
would have to be typed for each file.

Path searching is not done if @code{gawk} is in compatibility mode.
@xref{Command Line}.

@strong{Note:} if you want files in the current directory to be found,
you must include the current directory in the path, either by writing
@file{.} as an entry in the path, or by writing a null entry in the
path.  (A null entry is indicated by starting or ending the path with a
colon, or by placing two colons next to each other (@samp{::}).)  If the
current directory is not included in the path, then files cannot be
found in the current directory.  This path search mechanism is identical
to the shell's.
@c someday, @cite{The Bourne Again Shell}....

@node Language History, Gawk Summary, Command Line, Top
@chapter The Evolution of the @code{awk} Language

This manual describes the GNU implementation of @code{awk}, which is patterned
after the System V Release 4 version.  Many @code{awk} users are only familiar
with the original @code{awk} implementation in Version 7 Unix, which is also
the basis for the version in Berkeley Unix.  This chapter briefly describes
the evolution of the @code{awk} language.

@menu
* V7/S5R3.1::   The major changes between V7 and System V Release 3.1.

* S5R4::        The minor changes between System V Releases 3.1 and 4.

* S5R4/GNU::    The extensions in @code{gawk} not in System V Release 4.
@end menu

@node V7/S5R3.1, S5R4, Language History, Language History
@section Major Changes Between V7 and S5R3.1

The @code{awk} language evolved considerably between the release of
Version 7 Unix (1978) and the new version first made widely available in
System V Release 3.1 (1987).  This section summarizes the changes, with
cross-references to further details.

@itemize @bullet
@item
The requirement for @samp{;} to separate rules on a line
(@pxref{Statements/Lines}).

@item
User-defined functions, and the @code{return} statement
(@pxref{User-defined}).

@item
The @code{delete} statement (@pxref{Delete}).

@item
The @code{do}-@code{while} statement (@pxref{Do Statement}).

@item
The built-in functions @code{atan2}, @code{cos}, @code{sin}, @code{rand} and
@code{srand} (@pxref{Numeric Functions}).

@item
The built-in functions @code{gsub}, @code{sub}, and @code{match}
(@pxref{String Functions}).

@item
The built-in functions @code{close} and @code{system} (@pxref{I/O
Functions}).

@item
The @code{ARGC}, @code{ARGV}, @code{FNR}, @code{RLENGTH}, @code{RSTART},
and @code{SUBSEP} built-in variables (@pxref{Built-in Variables}).

@item
The conditional expression using the operators @samp{?} and @samp{:}
(@pxref{Conditional Exp}).

@item
The exponentiation operator @samp{^} (@pxref{Arithmetic Ops}) and its
assignment operator form @samp{^=} (@pxref{Assignment Ops}).@refill

@item
C-compatible operator precedence, which breaks some old @code{awk}
programs (@pxref{Precedence}).

@item
Regexps as the value of @code{FS} (@pxref{Field Separators}), or as the
third argument to the @code{split} function (@pxref{String
Functions}).@refill

@item
Dynamic regexps as operands of the @samp{~} and @samp{!~} operators
(@pxref{Regexp Usage}).

@item
Escape sequences (@pxref{Constants}) in regexps.@refill

@item
The escape sequences @samp{\b}, @samp{\f}, and @samp{\r}
(@pxref{Constants}).

@item
Redirection of input for the @code{getline} function (@pxref{Getline}).

@item
Multiple @code{BEGIN} and @code{END} rules (@pxref{BEGIN/END}).

@item
Simulation of multidimensional arrays (@pxref{Multi-dimensional}).
@end itemize

@node S5R4, S5R4/GNU, V7/S5R3.1, Language History
@section Minor Changes between S5R3.1 and S5R4

The System V Release 4 version of Unix @code{awk} added these features:

@itemize @bullet
@item
The @code{ENVIRON} variable (@pxref{Built-in Variables}).

@item
Multiple @samp{-f} options on the command line (@pxref{Command Line}).

@item
The @samp{-v} option for assigning variables before program execution begins
(@pxref{Command Line}).

@item
The @samp{--} option for terminating command line options.

@item
The @samp{\a}, @samp{\v}, and @samp{\x} escape sequences (@pxref{Constants}).

@item
A defined return value for the @code{srand} built-in function
(@pxref{Numeric Functions}).

@item
The @code{toupper} and @code{tolower} built-in string functions
for case translation (@pxref{String Functions}).

@item
A cleaner specification for the @samp{%c} format-control letter in the
@code{printf} function (@pxref{Printf}).

@item
The use of constant regexps such as @code{/foo/} as expressions, where
they are equivalent to use of the matching operator, as in @code{$0 ~
/foo/}.
@end itemize

@node S5R4/GNU, , S5R4, Language History
@section Extensions In @code{gawk} Not In S5R4

The GNU implementation, @code{gawk}, adds these features:

@itemize @bullet
@item
The @code{AWKPATH} environment variable for specifying a path search for
the @samp{-f} command line option (@pxref{Command Line}).

@item
The @samp{-C} and @samp{-V} command line options (@pxref{Command Line}).

@item
The @code{IGNORECASE} variable and its effects (@pxref{Case-sensitivity}).

@item
The @file{/dev/stdin}, @file{/dev/stdout}, @file{/dev/stderr}, and
@file{/dev/fd/@var{n}} file name interpretation (@pxref{Special Files}).

@item
The @samp{-c} option to turn off these extensions (@pxref{Command Line}).

@item
The @samp{-a} and @samp{-e} options to specify the syntax of regular
expressions that @code{gawk} will accept (@pxref{Command Line}).
@end itemize

@node Gawk Summary, Sample Program, Language History, Top
@appendix @code{gawk} Summary

@ignore
See, man pages are good for something.  This chapter started life as the
gawk.1 man page for 2.11.
@end ignore

This appendix provides a brief summary of the @code{gawk} command line and the
@code{awk} language.  It is designed to serve as ``quick reference.''  It is
therefore terse, but complete.

@menu
* Command Line Summary::  Recapitulation of the command line.
* Language Summary::      A terse review of the language.
* Variables/Fields::      Variables, fields, and arrays.
* Rules Summary::         Patterns and Actions, and their component parts.
* Functions Summary::     Defining and calling functions.
@end menu

@node Command Line Summary, Language Summary, Gawk Summary, Gawk Summary
@appendixsec Command Line Options Summary

The command line consists of options to @code{gawk} itself, the
@code{awk} program text (if not supplied via the @samp{-f} option), and
values to be made available in the @code{ARGC} and @code{ARGV}
predefined @code{awk} variables:

@example
awk @r{[@code{-F@var{fs}}] [@code{-v @var{var}=@var{val}}] [@code{-V}] [@code{-C}] [@code{-c}] [@code{-a}] [@code{-e}] [@code{--}]} '@var{program}' @var{file} @dots{}
awk @r{[@code{-F@var{fs}}] @code{-f @var{source-file}} [@code{-f @var{source-file} @dots{}}] [@code{-v @var{var}=@var{val}}] [@code{-V}] [@code{-C}] [@code{-c}] [@code{-a}] [@code{-e}] [@code{--}]} @var{file} @dots{}
@end example

The options that @code{gawk} accepts are:

@table @code
@item -F@var{fs}
Use @var{fs} for the input field separator (the value of the @code{FS}
predefined variable).

@item -f @var{program-file}
Read the @code{awk} program source from the file @var{program-file}, instead
of from the first command line argument.

@item -v @var{var}=@var{val}
Assign the variable @var{var} the value @var{val} before program execution
begins.

@item -a
Specifies use of traditional @code{awk} syntax for regular expressions.
This means that @samp{\} can be used to quote regular expression
operators inside of square brackets, just as it can be outside of them.

@item -e
Specifies use of @code{egrep} syntax for regular expressions.  This
means that @samp{\} does not serve as a quoting character inside of
square brackets.

@item -c
Specifies compatibility mode, in which @code{gawk} extensions are turned
off.

@item -V
Print version information for this particular copy of @code{gawk} on the error
output.  This option may disappear in a future version of @code{gawk}.

@item -C
Print the short version of the General Public License on the error
output.  This option may disappear in a future version of @code{gawk}.

@item --
Signal the end of options.  This is useful to allow further arguments to the
@code{awk} program itself to start with a @samp{-}.  This is mainly for
consistency with the argument parsing conventions of POSIX.
@end table

Any other options are flagged as invalid, but are otherwise ignored.
@xref{Command Line}, for more details.

@node Language Summary, Variables/Fields, Command Line Summary, Gawk Summary
@appendixsec Language Summary

An @code{awk} program consists of a sequence of pattern-action statements
and optional function definitions.

@example
@var{pattern}    @{ @var{action statements} @}

function @var{name}(@var{parameter list})     @{ @var{action statements} @}
@end example

@code{gawk} first reads the program source from the
@var{program-file}(s) if specified, or from the first non-option
argument on the command line.  The @samp{-f} option may be used multiple
times on the command line.  @code{gawk} reads the program text from all
the @var{program-file} files, effectively concatenating them in the
order they are specified.  This is useful for building libraries of
@code{awk} functions, without having to include them in each new
@code{awk} program that uses them.  To use a library function in a file
from a program typed in on the command line, specify @samp{-f /dev/tty};
then type your program, and end it with a @kbd{C-d}.  @xref{Command
Line}.

The environment variable @code{AWKPATH} specifies a search path to use
when finding source files named with the @samp{-f} option.  If the
variable @code{AWKPATH} is not set, @code{gawk} uses the default path,
@samp{.:/usr/lib/awk:/usr/local/lib/awk}.  If a file name given to the
@samp{-f} option contains a @samp{/} character, no path search is
performed.  @xref{AWKPATH Variable}, for a full description of the
@code{AWKPATH} environment variable.@refill

@code{gawk} compiles the program into an internal form, and then proceeds to
read each file named in the @code{ARGV} array.  If there are no files named
on the command line, @code{gawk} reads the standard input.

If a ``file'' named on the command line has the form
@samp{@var{var}=@var{val}}, it is treated as a variable assignment: the
variable @var{var} is assigned the value @var{val}.

For each line in the input, @code{gawk} tests to see if it matches any
@var{pattern} in the @code{awk} program.  For each pattern that the line
matches, the associated @var{action} is executed.

@node Variables/Fields, Rules Summary, Language Summary, Gawk Summary
@appendixsec Variables and Fields

@code{awk} variables are dynamic; they come into existence when they are
first used.  Their values are either floating-point numbers or strings.
@code{awk} also has one-dimension arrays; multiple-dimensional arrays
may be simulated.  There are several predefined variables that
@code{awk} sets as a program runs; these are summarized below.

@menu
* Fields Summary::      Input field splitting.
* Built-in Summary::    @code{awk}'s built-in variables.
* Arrays Summary::      Using arrays.
* Data Type Summary::   Values in @code{awk} are numbers or strings.
@end menu

@node Fields Summary, Built-in Summary, Variables/Fields, Variables/Fields
@appendixsubsec Fields

As each input line is read, @code{gawk} splits the line into
@var{fields}, using the value of the @code{FS} variable as the field
separator.  If @code{FS} is a single character, fields are separated by
that character.  Otherwise, @code{FS} is expected to be a full regular
expression.  In the special case that @code{FS} is a single blank,
fields are separated by runs of blanks and/or tabs.  Note that the value
of @code{IGNORECASE} (@pxref{Case-sensitivity}) also affects how fields
are split when @code{FS} is a regular expression.

Each field in the input line may be referenced by its position, @code{$1},
@code{$2}, and so on.  @code{$0} is the whole line.  The value of a field may
be assigned to as well.  Field numbers need not be constants:

@example
n = 5
print $n
@end example

@noindent
prints the fifth field in the input line.  The variable @code{NF} is set to
the total number of fields in the input line.

References to nonexistent fields (i.e., fields after @code{$NF}) return
the null-string.  However, assigning to a nonexistent field (e.g.,
@code{$(NF+2) = 5}) increases the value of @code{NF}, creates any
intervening fields with the null string as their value, and causes the
value of @code{$0} to be recomputed, with the fields being separated by
the value of @code{OFS}.@refill

@xref{Reading Files}, for a full description of the way @code{awk} defines
and uses fields.

@node Built-in Summary, Arrays Summary, Fields Summary, Variables/Fields
@appendixsubsec Built-in Variables

@code{awk}'s built-in variables are:

@table @code
@item ARGC
The number of command line arguments (not including options or the
@code{awk} program itself).

@item ARGV
The array of command line arguments.  The array is indexed from 0 to
@code{ARGC} - 1.  Dynamically changing the contents of @code{ARGV} can control
the files used for data.@refill

@item ENVIRON
An array containing the values of the environment variables.  The array
is indexed by variable name, each element being the value of that
variable.  Thus, the environment variable @code{HOME} would be in
@code{ENVIRON["HOME"]}.  Its value might be @file{/u/close}.

Changing this array does not affect the environment seen by programs
which @code{gawk} spawns via redirection or the @code{system} function.
(This may change in a future version of @code{gawk}.)

Some operating systems do not have environment variables.
The array @code{ENVIRON} is empty when running on these systems.

@item FILENAME
The name of the current input file.  If no files are specified on the command
line, the value of @code{FILENAME} is @samp{-}.

@item FNR
The input record number in the current input file.

@item FS
The input field separator, a blank by default.

@item IGNORECASE
The case-sensitivity flag for regular expression operations.  If
@code{IGNORECASE} has a nonzero value, then pattern matching in rules,
field splitting with @code{FS}, regular expression matching with
@samp{~} and @samp{!~}, and the @code{gsub}, @code{index}, @code{match},
@code{split} and @code{sub} predefined functions all ignore case
when doing regular expression operations.@refill

@item NF
The number of fields in the current input record.

@item NR
The total number of input records seen so far.

@item OFMT
The output format for numbers, @code{"%.6g"} by default.

@item OFS
The output field separator, a blank by default.

@item ORS
The output record separator, by default a newline.

@item RS
The input record separator, by default a newline.  @code{RS} is exceptional
in that only the first character of its string value is used for separating
records.  If @code{RS} is set to the null string, then records are separated by
blank lines.  When @code{RS} is set to the null string, then the newline
character always acts as a field separator, in addition to whatever value
@code{FS} may have.@refill

@item RSTART
The index of the first character matched by @code{match}; 0 if no match.

@item RLENGTH
The length of the string matched by @code{match}; @minus{}1 if no match.

@item SUBSEP
The string used to separate multiple subscripts in array elements, by
default @code{"\034"}.
@end table

@xref{Built-in Variables}.

@node Arrays Summary, Data Type Summary, Built-in Summary, Variables/Fields
@appendixsubsec Arrays

Arrays are subscripted with an expression between square brackets
(@samp{[} and @samp{]}).  The expression may be either a number or
a string.  Since arrays are associative, string indices are meaningful
and are not converted to numbers.

If you use multiple expressions separated by commas inside the square
brackets, then the array subscript is a string consisting of the
concatenation of the individual subscript values, converted to strings,
separated by the subscript separator (the value of @code{SUBSEP}).

The special operator @code{in} may be used in an @code{if} or
@code{while} statement to see if an array has an index consisting of a
particular value.

@group
@example
if (val in array)
        print array[val]
@end example
@end group

If the array has multiple subscripts, use @code{(i, j, @dots{}) in array}
to test for existence of an element.

The @code{in} construct may also be used in a @code{for} loop to iterate
over all the elements of an array.  @xref{Scanning an Array}.

An element may be deleted from an array using the @code{delete} statement.

@xref{Arrays}, for more detailed information.

@node Data Type Summary, , Arrays Summary, Variables/Fields
@appendixsubsec Data Types

The value of an @code{awk} expression is always either a number
or a string.

Certain contexts (such as arithmetic operators) require numeric
values.  They convert strings to numbers by interpreting the text
of the string as a numeral.  If the string does not look like a
numeral, it converts to 0.

Certain contexts (such as concatenation) require string values.
They convert numbers to strings by effectively printing them.

To force conversion of a string value to a number, simply add 0
to it.  If the value you start with is already a number, this
does not change it.

To force conversion of a numeric value to a string, concatenate it with
the null string.

The @code{awk} language defines comparisons as being done numerically if
possible, otherwise one or both operands are converted to strings and
a string comparison is performed.

Uninitialized variables have the string value @code{""} (the null, or
empty, string).  In contexts where a number is required, this is
equivalent to 0.

@xref{Variables}, for more information on variable naming and initialization;
@pxref{Conversion}, for more information on how variable values are
interpreted.@refill

@node Rules Summary, Functions Summary, Variables/Fields, Gawk Summary
@appendixsec Patterns and Actions

@menu
* Pattern Summary::     Quick overview of patterns.
* Regexp Summary::      Quick overview of regular expressions.
* Actions Summary::     Quick overview of actions.
@end menu

An @code{awk} program is mostly composed of rules, each consisting of a
pattern followed by an action.  The action is enclosed in @samp{@{} and
@samp{@}}.  Either the pattern may be missing, or the action may be
missing, but, of course, not both.  If the pattern is missing, the
action is executed for every single line of input.  A missing action is
equivalent to this action,

@example
@{ print @}
@end example

@noindent
which prints the entire line.

Comments begin with the @samp{#} character, and continue until the end of the
line.  Blank lines may be used to separate statements.  Normally, a statement
ends with a newline, however, this is not the case for lines ending in a
@samp{,}, @samp{@{}, @samp{?}, @samp{:}, @samp{&&}, or @samp{||}.  Lines
ending in @code{do} or @code{else} also have their statements automatically
continued on the following line.  In other cases, a line can be continued by
ending it with a @samp{\}, in which case the newline is ignored.@refill

Multiple statements may be put on one line by separating them with a @samp{;}.
This applies to both the statements within the action part of a rule (the
usual case), and to the rule statements themselves.

@xref{Comments}, for information on @code{awk}'s commenting convention;
@pxref{Statements/Lines}, for a description of the line continuation
mechanism in @code{awk}.

@node Pattern Summary, Regexp Summary, Rules Summary, Rules Summary
@appendixsubsec Patterns

@code{awk} patterns may be one of the following:

@example
/@var{regular expression}/
@var{relational expression}
@var{pattern} && @var{pattern}
@var{pattern} || @var{pattern}
@var{pattern} ? @var{pattern} : @var{pattern}
(@var{pattern})
! @var{pattern}
@var{pattern1}, @var{pattern2}
BEGIN
END
@end example

@code{BEGIN} and @code{END} are two special kinds of patterns that are not
tested against the input.  The action parts of all @code{BEGIN} rules are
merged as if all the statements had been written in a single @code{BEGIN}
rule.  They are executed before any of the input is read.  Similarly, all the
@code{END} rules are merged, and executed when all the input is exhausted (or
when an @code{exit} statement is executed).  @code{BEGIN} and @code{END}
patterns cannot be combined with other patterns in pattern expressions.
@code{BEGIN} and @code{END} rules cannot have missing action parts.@refill

For @samp{/@var{regular-expression}/} patterns, the associated statement is
executed for each input line that matches the regular expression.  Regular
expressions are the same as those in @code{egrep}, and are summarized below.

A @var{relational expression} may use any of the operators defined below in
the section on actions.  These generally test whether certain fields match
certain regular expressions.

The @samp{&&}, @samp{||}, and @samp{!} operators are logical ``and'',
logical ``or'', and logical ``not'', respectively, as in C.  They do
short-circuit evaluation, also as in C, and are used for combining more
primitive pattern expressions.  As in most languages, parentheses may be
used to change the order of evaluation.

The @samp{?:} operator is like the same operator in C.  If the first
pattern matches, then the second pattern is matched against the input
record; otherwise, the third is matched.  Only one of the second and
third patterns is matched.

The @samp{@var{pattern1}, @var{pattern2}} form of a pattern is called a
range pattern.  It matches all input lines starting with a line that
matches @var{pattern1}, and continuing until a line that matches
@var{pattern2}, inclusive.  A range pattern cannot be used as an operand
to any of the pattern operators.

@xref{Patterns}, for a full description of the pattern part of @code{awk}
rules.

@node Regexp Summary, Actions Summary, Pattern Summary, Rules Summary
@appendixsubsec Regular Expressions

Regular expressions are the extended kind found in @code{egrep}.
They are composed of characters as follows:

@table @code
@item @var{c}
matches the character @var{c} (assuming @var{c} is a character with no
special meaning in regexps).

@item \@var{c}
matches the literal character @var{c}.

@item .
matches any character except newline.

@item ^
matches the beginning of a line or a string.

@item $
matches the end of a line or a string.

@item [@var{abc}@dots{}]
matches any of the characters @var{abc}@dots{} (character class).

@item [^@var{abc}@dots{}]
matches any character except @var{abc}@dots{} and newline (negated
character class).

@item @var{r1}|@var{r2}
matches either @var{r1} or @var{r2} (alternation).

@item @var{r1r2}
matches @var{r1}, and then @var{r2} (concatenation).

@item @var{r}+
matches one or more @var{r}'s.

@item @var{r}*
matches zero or more @var{r}'s. 

@item @var{r}?
matches zero or one @var{r}'s. 

@item (@var{r})
matches @var{r} (grouping).
@end table

@xref{Regexp}, for a more detailed explanation of regular expressions.

The escape sequences allowed in string constants are also valid in
regular expressions (@pxref{Constants}).

@node Actions Summary, , Regexp Summary, Rules Summary
@appendixsubsec Actions

Action statements are enclosed in braces, @samp{@{} and @samp{@}}.
Action statements consist of the usual assignment, conditional, and looping
statements found in most languages.  The operators, control statements,
and input/output statements available are patterned after those in C.

@menu
* Operator Summary::            @code{awk} operators.
* Control Flow Summary::        The control statements.
* I/O Summary::                 The I/O statements.
* Printf Summary::              A summary of @code{printf}.
* Special File Summary::        Special file names interpreted internally.
* Numeric Functions Summary::   Built-in numeric functions.
* String Functions Summary::    Built-in string functions.
* String Constants Summary::    Escape sequences in strings.
@end menu

@node Operator Summary, Control Flow Summary, Actions Summary, Actions Summary
@appendixsubsubsec Operators

The operators in @code{awk}, in order of increasing precedence, are

@table @code
@item = += -= *= /= %= ^=
Assignment.  Both absolute assignment (@code{@var{var}=@var{value}})
and operator assignment (the other forms) are supported.

@item ?:
A conditional expression, as in C.  This has the form @code{@var{expr1} ?
@var{expr2} : @var{expr3}}.  If @var{expr1} is true, the value of the
expression is @var{expr2}; otherwise it is @var{expr3}.  Only one of
@var{expr2} and @var{expr3} is evaluated.@refill

@item ||
Logical ``or''.

@item &&
Logical ``and''.

@item ~ !~
Regular expression match, negated match.

@item < <= > >= != ==
The usual relational operators.

@item @var{blank}
String concatenation.

@item + -
Addition and subtraction.

@item * / %
Multiplication, division, and modulus.

@item + - !
Unary plus, unary minus, and logical negation.

@item ^
Exponentiation (@samp{**} may also be used, and @samp{**=} for the assignment
operator).

@item ++ --
Increment and decrement, both prefix and postfix.

@item $
Field reference.
@end table

@xref{Expressions}, for a full description of all the operators listed
above.  @xref{Fields}, for a description of the field reference operator.

@node Control Flow Summary, I/O Summary, Operator Summary, Actions Summary
@appendixsubsubsec Control Statements

The control statements are as follows:

@example
if (@var{condition}) @var{statement} @r{[} else @var{statement} @r{]}
while (@var{condition}) @var{statement}
do @var{statement} while (@var{condition})
for (@var{expr1}; @var{expr2}; @var{expr3}) @var{statement}
for (@var{var} in @var{array}) @var{statement}
break
continue
delete @var{array}[@var{index}]
exit @r{[} @var{expression} @r{]}
@{ @var{statements} @}
@end example

@xref{Statements}, for a full description of all the control statements
listed above.

@node I/O Summary, Printf Summary, Control Flow Summary, Actions Summary
@appendixsubsubsec I/O Statements

The input/output statements are as follows:

@table @code
@item getline
Set @code{$0} from next input record; set @code{NF}, @code{NR}, @code{FNR}.

@item getline <@var{file}
Set @code{$0} from next record of @var{file}; set @code{NF}.

@item getline @var{var}
Set @var{var} from next input record; set @code{NF}, @code{FNR}.

@item getline @var{var} <@var{file}
Set @var{var} from next record of @var{file}.

@item next
Stop processing the current input record.  The next input record is read and
processing starts over with the first pattern in the @code{awk} program.
If the end of the input data is reached, the @code{END} rule(s), if any,
are executed.

@item print
Prints the current record.

@item print @var{expr-list}
Prints expressions.

@item print @var{expr-list} > @var{file}
Prints expressions on @var{file}.

@item printf @var{fmt, expr-list}
Format and print.

@item printf @var{fmt, expr-list} > file
Format and print on @var{file}.
@end table

Other input/output redirections are also allowed.  For @code{print} and
@code{printf}, @samp{>> @var{file}} appends output to the @var{file},
while @samp{| @var{command}} writes on a pipe.  In a similar fashion,
@samp{@var{command} | getline} pipes input into @code{getline}.
@code{getline} returns 0 on end of file, and @minus{}1 on an error.@refill

@xref{Getline}, for a full description of the @code{getline} statement.
@xref{Printing}, for a full description of @code{print} and
@code{printf}.  Finally, @pxref{Next Statement}, for a description of
how the @code{next} statement works.@refill

@node Printf Summary, Special File Summary, I/O Summary, Actions Summary
@appendixsubsubsec @code{printf} Summary

The @code{awk} @code{printf} statement and @code{sprintf} function
accept the following conversion specification formats:

@table @code
@item %c
An ASCII character.  If the argument used for @samp{%c} is numeric, it is
treated as a character and printed.  Otherwise, the argument is assumed to
be a string, and the only first character of that string is printed.

@item %d
A decimal number (the integer part).

@item %i
Also a decimal integer.

@item %e
A floating point number of the form
@samp{@r{[}-@r{]}d.ddddddE@r{[}+-@r{]}dd}.@refill

@item %f
A floating point number of the form
@r{[}@code{-}@r{]}@code{ddd.dddddd}.

@item %g
Use @samp{%e} or @samp{%f} conversion, whichever is shorter, with
nonsignificant zeros suppressed.

@item %o
An unsigned octal number (again, an integer).

@item %s
A character string.

@item %x
An unsigned hexadecimal number (an integer).

@item %X
Like @samp{%x}, except use @samp{A} through @samp{F} instead of @samp{a}
through @samp{f} for decimal 10 through 15.@refill

@item %%
A single @samp{%} character; no argument is converted.
@end table

There are optional, additional parameters that may lie between the @samp{%}
and the control letter:

@table @code
@item -
The expression should be left-justified within its field.

@item @var{width}
The field should be padded to this width.  If @var{width} has a leading zero,
then the field is padded with zeros.  Otherwise it is padded with blanks.

@item .@var{prec}
A number indicating the maximum width of strings or digits to the right
of the decimal point.
@end table

@xref{Printf}, for examples and for a more detailed description.

@node Special File Summary, Numeric Functions Summary, Printf Summary, Actions Summary
@appendixsubsubsec Special File Names

When doing I/O redirection from either @code{print} or @code{printf} into a
file, or via @code{getline} from a file, @code{gawk} recognizes certain special
file names internally.  These file names allow access to open file descriptors
inherited from @code{gawk}'s parent process (usually the shell).  The
file names are:

@table @file
@item /dev/stdin
The standard input.

@item /dev/stdout
The standard output.

@item /dev/stderr
The standard error output.

@item /dev/fd/@var{n}
The file denoted by the open file descriptor @var{n}.
@end table

@noindent
These file names may also be used on the command line to name data files.

@xref{Special Files}, for a longer description that provides the motivation
for this feature.

@node Numeric Functions Summary, String Functions Summary, Special File Summary, Actions Summary
@appendixsubsubsec Numeric Functions

@code{awk} has the following predefined arithmetic functions:

@table @code
@item atan2(@var{y}, @var{x})
returns the arctangent of @var{y/x} in radians.

@item cos(@var{expr})
returns the cosine in radians.

@item exp(@var{expr})
the exponential function.

@item int(@var{expr})
truncates to integer.

@item log(@var{expr})
the natural logarithm function.

@item rand()
returns a random number between 0 and 1.

@item sin(@var{expr})
returns the sine in radians.

@item sqrt(@var{expr})
the square root function.

@item srand(@var{expr})
use @var{expr} as a new seed for the random number generator.  If no @var{expr}
is provided, the time of day is used.  The return value is the previous
seed for the random number generator.
@end table

@node String Functions Summary, String Constants Summary, Numeric Functions Summary, Actions Summary
@appendixsubsubsec String Functions

@code{awk} has the following predefined string functions:

@table @code
@item gsub(@var{r}, @var{s}, @var{t})
for each substring matching the regular expression @var{r} in the string
@var{t}, substitute the string @var{s}, and return the number of substitutions.
If @var{t} is not supplied, use @code{$0}.

@item index(@var{s}, @var{t})
returns the index of the string @var{t} in the string @var{s}, or 0 if
@var{t} is not present.

@item length(@var{s})
returns the length of the string @var{s}.

@item match(@var{s}, @var{r})
returns the position in @var{s} where the regular expression @var{r}
occurs, or 0 if @var{r} is not present, and sets the values of @code{RSTART}
and @code{RLENGTH}.

@item split(@var{s}, @var{a}, @var{r})
splits the string @var{s} into the array @var{a} on the regular expression
@var{r}, and returns the number of fields.  If @var{r} is omitted, @code{FS}
is used instead.

@item sprintf(@var{fmt}, @var{expr-list})
prints @var{expr-list} according to @var{fmt}, and returns the resulting string.

@item sub(@var{r}, @var{s}, @var{t})
this is just like @code{gsub}, but only the first matching substring is
replaced.

@item substr(@var{s}, @var{i}, @var{n})
returns the @var{n}-character substring of @var{s} starting at @var{i}.
If @var{n} is omitted, the rest of @var{s} is used.

@item tolower(@var{str})
returns a copy of the string @var{str}, with all the upper-case characters in
@var{str} translated to their corresponding lower-case counterparts.
Nonalphabetic characters are left unchanged.

@item toupper(@var{str})
returns a copy of the string @var{str}, with all the lower-case characters in
@var{str} translated to their corresponding upper-case counterparts.
Nonalphabetic characters are left unchanged.

@item system(@var{cmd-line})
Execute the command @var{cmd-line}, and return the exit status.
@end table

@xref{Built-in}, for a description of all of @code{awk}'s built-in functions.

@node String Constants Summary, , String Functions Summary, Actions Summary
@appendixsubsubsec String Constants

String constants in @code{awk} are sequences of characters enclosed
between double quotes (@code{"}).  Within strings, certain @dfn{escape sequences}
are recognized, as in C.  These are:

@table @code
@item \\
A literal backslash.

@item \a
The ``alert'' character; usually the ASCII BEL character.

@item \b
Backspace.

@item \f
Formfeed.

@item \n
Newline.

@item \r
Carriage return.

@item \t
Horizontal tab.

@item \v
Vertical tab.

@item \x@var{hex digits}
The character represented by the string of hexadecimal digits following
the @samp{\x}.  As in ANSI C, all following hexadecimal digits are
considered part of the escape sequence.  (This feature should tell us
something about language design by committee.)  E.g., @code{"\x1B"} is a
string containing the ASCII ESC (escape) character.

@item \@var{ddd}
The character represented by the 1-, 2-, or 3-digit sequence of octal
digits.  Thus, @code{"\033"} is also a string containing the ASCII ESC
(escape) character.

@item \@var{c}
The literal character @var{c}.
@end table

The escape sequences may also be used inside constant regular expressions
(e.g., the regexp @code{@w{/[@ \t\f\n\r\v]/}} matches whitespace
characters).@refill

@xref{Constants}.

@node Functions Summary, , Rules Summary, Gawk Summary
@appendixsec Functions

Functions in @code{awk} are defined as follows:

@example
function @var{name}(@var{parameter list}) @{ @var{statements} @}
@end example

Actual parameters supplied in the function call are used to instantiate
the formal parameters declared in the function.  Arrays are passed by
reference, other variables are passed by value.

If there are fewer arguments passed than there are names in @var{parameter-list},
the extra names are given the null string as value.  Extra names have the
effect of local variables.

The open-parenthesis in a function call must immediately follow the
function name, without any intervening white space.  This is to avoid a
syntactic ambiguity with the concatenation operator.

The word @code{func} may be used in place of @code{function}.

@xref{User-defined}, for a more complete description.

@node Sample Program, Notes, Gawk Summary, Top
@appendix Sample Program

The following example is a complete @code{awk} program, which prints
the number of occurrences of each word in its input.  It illustrates the
associative nature of @code{awk} arrays by using strings as subscripts.  It
also demonstrates the @samp{for @var{x} in @var{array}} construction.
Finally, it shows how @code{awk} can be used in conjunction with other
utility programs to do a useful task of some complexity with a minimum of
effort.  Some explanations follow the program listing.@refill

@example
awk '
# Print list of word frequencies
@{
    for (i = 1; i <= NF; i++)
        freq[$i]++
@}

END @{
    for (word in freq)
        printf "%s\t%d\n", word, freq[word]
@}'
@end example

The first thing to notice about this program is that it has two rules.  The
first rule, because it has an empty pattern, is executed on every line of
the input.  It uses @code{awk}'s field-accessing mechanism (@pxref{Fields})
to pick out the individual words from the line, and the built-in variable
@code{NF} (@pxref{Built-in Variables}) to know how many fields are available.

For each input word, an element of the array @code{freq} is incremented to
reflect that the word has been seen an additional time.@refill

The second rule, because it has the pattern @code{END}, is not executed
until the input has been exhausted.  It prints out the contents of the
@code{freq} table that has been built up inside the first action.@refill

Note that this program has several problems that would prevent it from being
useful by itself on real text files:@refill

@itemize @bullet
@item
Words are detected using the @code{awk} convention that fields are
separated by whitespace and that other characters in the input (except
newlines) don't have any special meaning to @code{awk}.  This means that
punctuation characters count as part of words.@refill

@item
The @code{awk} language considers upper and lower case characters to be
distinct.  Therefore, @samp{foo} and @samp{Foo} are not treated by this
program as the same word.  This is undesirable since in normal text, words
are capitalized if they begin sentences, and a frequency analyzer should not
be sensitive to that.@refill

@item
The output does not come out in any useful order.  You're more likely to be
interested in which words occur most frequently, or having an alphabetized
table of how frequently each word occurs.@refill
@end itemize

The way to solve these problems is to use other system utilities to
process the input and output of the @code{awk} script.  Suppose the
script shown above is saved in the file @file{frequency.awk}.  Then the
shell command:@refill

@example
tr A-Z a-z < file1 | tr -cd 'a-z\012' \
  | awk -f frequency.awk \
  | sort +1 -nr
@end example

@noindent
produces a table of the words appearing in @file{file1} in order of
decreasing frequency.

The first @code{tr} command in this pipeline translates all the upper case
characters in @file{file1} to lower case.  The second @code{tr} command
deletes all the characters in the input except lower case characters and
newlines.  The second argument to the second @code{tr} is quoted to protect
the backslash in it from being interpreted by the shell.  The @code{awk}
program reads this suitably massaged data and produces a word frequency
table, which is not ordered.

The @code{awk} script's output is now sorted by the @code{sort} command and
printed on the terminal.  The options given to @code{sort} in this example
specify to sort by the second field of each input line (skipping one field),
that the sort keys should be treated as numeric quantities (otherwise
@samp{15} would come before @samp{5}), and that the sorting should be done
in descending (reverse) order.@refill

See the general operating system documentation for more information on how
to use the @code{tr} and @code{sort} commands.@refill

@ignore
@strong{ADR: I have some more substantial programs courtesy of Rick Adams
at UUNET.  I am planning on incorporating those either in addition to or
instead of this program.}

@strong{I would also like to incorporate the general @code{translate}
function that I have written.}
@end ignore

@node Notes, Glossary, Sample Program, Top
@appendix Implementation Notes

This appendix contains information mainly of interest to implementors and
maintainers of @code{gawk}.  Everything in it applies specifically to
@code{gawk}, and not to other implementations.

@menu
* Compatibility Mode::   How to disable certain @code{gawk} extensions.

* Future Extensions::    New features we may implement soon.

* Improvements::         Suggestions for improvements by volunteers.
@end menu

@node Compatibility Mode, Future Extensions, Notes, Notes
@appendixsec Downwards Compatibility and Debugging

@xref{S5R4/GNU}, for a summary of the GNU extensions to the @code{awk}
language and program.  All of these features can be turned off either by
compiling @code{gawk} with @samp{-DSTRICT} (not recommended), or by
invoking @code{gawk} with the @samp{-c} option.@refill

If @code{gawk} is compiled for debugging with @samp{-DDEBUG}, then there
are two more options available on the command line.

@table @samp
@item -d
Print out debugging information during execution.

@item -D
Print out the parse stack information as the program is being parsed.
@end table

Both of these options are intended only for serious @code{gawk} developers,
and not for the casual user.  They probably have not even been compiled into
your version of @code{gawk}, since they slow down execution.

The code for recognizing special file names such as @file{/dev/stdin}
can be disabled at compile time with @samp{-DNO_DEV_FD}, or with
@samp{-DSTRICT}.@refill

@node Future Extensions, Improvements, Compatibility Mode, Notes
@appendixsec Probable Future Extensions

This section briefly lists extensions that indicate the directions we are
currently considering for @code{gawk}.

@table @asis
@item ANSI C compatible @code{printf}
The @code{printf} and @code{sprintf} functions may be enhanced to be
fully compatible with the specification for the @code{printf} family
of functions in ANSI C.@refill

@item @code{RS} as a regexp
The meaning of @code{RS} may be generalized along the lines of @code{FS}.

@item Control of subprocess environment
Changes made in @code{gawk} to the array @code{ENVIRON} may be
propagated to subprocesses run by @code{gawk}.

@item Data bases
It may be possible to map an NDBM/GDBM file into an @code{awk} array.

@item Single-character fields
The null string, @code{""}, as a field separator, will cause field
splitting and the split function to separate individual characters.
Thus, @code{split(a, "abcd", "")} would yield @code{a[1] == "a"},
@code{a[2] == "b"}, and so on.

@item Fixed-length fields and records
A mechanism may be provided to allow the specification of fixed length
fields and records.

@item Regexp syntax
The @code{egrep} syntax for regular expressions, now specified
with the @samp{-e} option, may become the default, since the
POSIX standard may specify this.

@c this is @emph{very} long term --- not worth including right now.
@ignore
@item The C Comma Operator
We may add the C comma operator, which takes the form
@code{@var{expr1},@var{expr2}}.  The first expression is evaluated, and the
result is thrown away.  The value of the full expression is the value of
@var{expr2}.@refill
@end ignore
@end table

@node Improvements,, Future Extensions, Notes
@appendixsec Suggestions for Improvements

Here are some projects that would-be @code{gawk} hackers might like to take
on.  They vary in size from a few days to a few weeks of programming,
depending on which one you choose and how fast a programmer you are.  Please
send any improvements you write to the maintainers at the GNU
project.@refill

@enumerate
@item
State machine regexp matcher: At present, @code{gawk} uses the
backtracking regular expression matcher from the GNU subroutine library.
If a regexp is really going to be used a lot of times, it is faster to
convert it once to a description of a finite state machine, then run a
routine simulating that machine every time you want to match the regexp.
You might be able to use the matching routines used by GNU @code{egrep}.

@item
Compilation of @code{awk} programs: @code{gawk} uses a Bison (YACC-like)
parser to convert the script given it into a syntax tree; the syntax
tree is then executed by a simple recursive evaluator.  Both of these
steps incur a lot of overhead, since parsing can be slow (especially if
you also do the previous project and convert regular expressions to
finite state machines at compile time) and the recursive evaluator
performs many procedure calls to do even the simplest things.@refill

It should be possible for @code{gawk} to convert the script's parse tree
into a C program which the user would then compile, using the normal
C compiler and a special @code{gawk} library to provide all the needed
functions (regexps, fields, associative arrays, type coercion, and so
on).@refill

An easier possibility might be for an intermediate phase of @code{awk} to
convert the parse tree into a linear byte code form like the one used
in GNU Emacs Lisp.  The recursive evaluator would then be replaced by
a straight line byte code interpreter that would be intermediate in speed
between running a compiled program and doing what @code{gawk} does
now.@refill

@item
An error message section has not been included in this version of the
manual.  Perhaps some nice beta testers will document some of the messages
for the future.
@end enumerate

@node Glossary, Index , Notes, Top
@appendix Glossary

@table @asis
@item Action
A series of @code{awk} statements attached to a rule.  If the rule's
pattern matches an input record, the @code{awk} language executes the
rule's action.  Actions are always enclosed in curly braces.
@xref{Actions}.@refill

@item Amazing @code{awk} Assembler
Henry Spencer at the University of Toronto wrote a retargetable assembler
completely as @code{awk} scripts.  It is thousands of lines long, including
machine descriptions for several 8-bit microcomputers.  It is distributed
with @code{gawk} and is a good example of a program that would have been
better written in another language.@refill

@item Assignment
An @code{awk} expression that changes the value of some @code{awk}
variable or data object.  An object that you can assign to is called an
@dfn{lvalue}.  @xref{Assignment Ops}.@refill

@item @code{awk} Language
The language in which @code{awk} programs are written.

@item @code{awk} Program
An @code{awk} program consists of a series of @dfn{patterns} and
@dfn{actions}, collectively known as @dfn{rules}.  For each input record
given to the program, the program's rules are all processed in turn.
@code{awk} programs may also contain function definitions.@refill

@item @code{awk} Script
Another name for an @code{awk} program.

@item Built-in Function
The @code{awk} language provides built-in functions that perform various
numerical and string computations.  Examples are @code{sqrt} (for the
square root of a number) and @code{substr} (for a substring of a
string).  @xref{Built-in}.@refill

@item Built-in Variable
The variables @code{ARGC}, @code{ARGV}, @code{ENVIRON},  @code{FILENAME},
@code{FNR}, @code{FS}, @code{NF}, @code{IGNORECASE}, @code{NR}, @code{OFMT},
@code{OFS}, @code{ORS}, @code{RLENGTH}, @code{RSTART}, @code{RS}, and
@code{SUBSEP}, have special meaning to @code{awk}.  Changing some of them
affects @code{awk}'s running environment.  @xref{Built-in Variables}.@refill

@item C
The system programming language that most GNU software is written in.  The
@code{awk} programming language has C-like syntax, and this manual
points out similarities between @code{awk} and C when appropriate.@refill

@item Compound Statement
A series of @code{awk} statements, enclosed in curly braces.  Compound
statements may be nested.  @xref{Statements}.@refill

@item Concatenation
Concatenating two strings means sticking them together, one after another,
giving a new string.  For example, the string @samp{foo} concatenated with
the string @samp{bar} gives the string @samp{foobar}.
@xref{Concatenation}.@refill

@item Conditional Expression
An expression using the @samp{?:} ternary operator, such as
@code{@var{expr1} ? @var{expr2} : @var{expr3}}.  The expression
@var{expr1} is evaluated; if the result is true, the value of the whole
expression is the value of @var{expr2} otherwise the value is
@var{expr3}.  In either case, only one of @var{expr2} and @var{expr3}
is evaluated.  @xref{Conditional Exp}.@refill

@item Constant Regular Expression
A constant regular expression is a regular expression written within
slashes, such as @samp{/foo/}.  This regular expression is chosen
when you write the @code{awk} program, and cannot be changed doing
its execution.  @xref{Regexp Usage}.

@item Comparison Expression
A relation that is either true or false, such as @code{(a < b)}.
Comparison expressions are used in @code{if} and @code{while} statements,
and in patterns to select which input records to process.
@xref{Comparison Ops}.@refill

@item Curly Braces
The characters @samp{@{} and @samp{@}}.  Curly braces are used in
@code{awk} for delimiting actions, compound statements, and function
bodies.@refill

@item Data Objects
These are numbers and strings of characters.  Numbers are converted into
strings and vice versa, as needed.  @xref{Conversion}.@refill

@item Dynamic Regular Expression
A dynamic regular expression is a regular expression written as an
ordinary expression.  It could be a string constant, such as
@code{"foo"}, but it may also be an expression whose value may vary.
@xref{Regexp Usage}.

@item Escape Sequences
A special sequence of characters used for describing nonprinting
characters, such as @samp{\n} for newline, or @samp{\033} for the ASCII
ESC (escape) character.  @xref{Constants}.

@item Field
When @code{awk} reads an input record, it splits the record into pieces
separated by whitespace (or by a separator regexp which you can
change by setting the built-in variable @code{FS}).  Such pieces are
called fields.  @xref{Records}.@refill

@item Format
Format strings are used to control the appearance of output in the
@code{printf} statement.  Also, data conversions from numbers to strings
are controlled by the format string contained in the built-in variable
@code{OFMT}.  @xref{Control Letters}; also @pxref{Output Separators}.@refill

@item Function
A specialized group of statements often used to encapsulate general
or program-specific tasks.  @code{awk} has a number of built-in
functions, and also allows you to define your own.  @xref{Built-in};
also @pxref{User-defined}.

@item @code{gawk}
The GNU implementation of @code{awk}.

@item Input Record
A single chunk of data read in by @code{awk}.  Usually, an @code{awk} input
record consists of one line of text.  @xref{Records}.@refill

@item Keyword
In the @code{awk} language, a keyword is a word that has special
meaning.  Keywords are reserved and may not be used as variable names.

The keywords of @code{awk} are:
@code{if},
@code{else},
@code{while},
@code{do@dots{}while},
@code{for},
@code{for@dots{}in},
@code{break},
@code{continue},
@code{delete},
@code{next},
@code{function},
@code{func},
and @code{exit}.@refill

@item Lvalue
An expression that can appear on the left side of an assignment
operator.  In most languages, lvalues can be variables or array
elements.  In @code{awk}, a field designator can also be used as an
lvalue.@refill

@item Number
A numeric valued data object.  The @code{gawk} implementation uses double
precision floating point to represent numbers.@refill

@item Pattern
Patterns tell @code{awk} which input records are interesting to which
rules.

A pattern is an arbitrary conditional expression against which input is
tested.  If the condition is satisfied, the pattern is said to @dfn{match}
the input record.  A typical pattern might compare the input record against
a regular expression.  @xref{Patterns}.@refill

@item Range (of input lines)
A sequence of consecutive lines from the input file.  A pattern
can specify ranges of input lines for @code{awk} to process, or it can
specify single lines.  @xref{Patterns}.@refill

@item Recursion
When a function calls itself, either directly or indirectly.
If this isn't clear, refer to the entry for ``recursion''.

@item Redirection
Redirection means performing input from other than the standard input
stream, or output to other than the standard output stream.

You can redirect the output of the @code{print} and @code{printf} statements
to a file or a system command, using the @samp{>}, @samp{>>}, and @samp{|}
operators.  You can redirect input to the @code{getline} statement using
the @samp{<} and @samp{|} operators.  @xref{Redirection}.@refill

@item Regular Expression
See ``regexp''.

@item Regexp
Short for @dfn{regular expression}.  A regexp is a pattern that denotes a
set of strings, possibly an infinite set.  For example, the regexp
@samp{R.*xp} matches any string starting with the letter @samp{R}
and ending with the letters @samp{xp}.  In @code{awk}, regexps are
used in patterns and in conditional expressions.  Regexps may contain
escape sequences.  @xref{Regexp}.@refill

@item Rule
A segment of an @code{awk} program, that specifies how to process single
input records.  A rule consists of a @dfn{pattern} and an @dfn{action}.
@code{awk} reads an input record; then, for each rule, if the input record
satisfies the rule's pattern, @code{awk} executes the rule's action.
Otherwise, the rule does nothing for that input record.@refill

@item Side Effect
A side effect occurs when an expression has an effect aside from merely
producing a value.  Assignment expressions, increment expressions and
function calls have side effects.  @xref{Assignment Ops}.

@item Special File
A file name interpreted internally by @code{gawk}, instead of being handed
directly to the underlying operating system.  For example, @file{/dev/stdin}.
@xref{Special Files}.

@item Stream Editor
A program that reads records from an input stream and processes them one
or more at a time.  This is in contrast with batch programs, which may
expect to read their input files in entirety before starting to do
anything, and with interactive programs, which require input from the
user.@refill

@item String
A datum consisting of a sequence of characters, such as @samp{I am a
string}.  Constant strings are written with double-quotes in the
@code{awk} language, and may contain @dfn{escape sequences}.
@xref{Constants}.

@item Whitespace
A sequence of blank or tab characters occurring inside an input record or a
string.@refill
@end table

@node Index, , Glossary, Top
@unnumbered Index
@printindex cp

@summarycontents
@contents
@bye
