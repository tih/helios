Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.



File: make-info,  Node: Directory Search,  Next: Phony Targets,  Prev: Wildcards,  Up: Rules

Searching Directories for Dependencies
======================================

For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The "directory search" features of
`make' facilitate this by searching several directories automatically
to find a dependency.  When you redistribute the files among
directories, you do not need to change the individual rules, just the
search paths.

* Menu:

* General Search::    The `VPATH' variable specifies a search path
                        that applies to every dependency.
* Selective Search::  The `vpath' directive specifies a search path
                        for a specified class of names.
* Commands/Search::   How to write shell commands that work together
                        with search paths.
* Implicit/Search::   How search paths affect implicit rules.
* Libraries/Search::  Directory search for link libraries.

 

File: make-info,  Node: General Search,  Next: Selective Search,  Prev: Directory Search,  Up: Directory Search

`VPATH': Search Path for All Dependencies
-----------------------------------------

The value of the `make' variable `VPATH' specifies a list of
directories which `make' should search (in the order specified) for
dependency files.  The directory names are separated by colons.  For
example:

     VPATH = src:../headers

specifies a path containing two directories, `src' and `../headers'.

Whenever a file listed as a dependency does not exist in the current
directory, the directories listed in `VPATH' are searched for a file
with that name.  If a file is found in one of them, that file becomes
the dependency.  Rules may then specify the names of source files as
if they all existed in the current directory.

Using the value of `VPATH' set in the previous example, a rule like
this:

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file `foo.c' does not exist in the current directory but
is found in the directory `src'.



File: make-info,  Node: Selective Search,  Next: Commands/Search,  Prev: General Search,  Up: Directory Search

The `vpath' Directive
---------------------

Similar to the `VPATH' variable but more selective is the `vpath'
directive, which allows you to specify a search path for a particular
class of filenames, those that match a particular pattern.  Thus you
can supply certain search directories for one class of filenames and
other directories (or none) for other filenames.

There are three forms of the `vpath' directive:

`vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for filenames that match
     `pattern'.  If another path was previously specified for the
     same pattern, the new path replaces it.  Note that it does *not*
     add to the old path for this pattern.

     The search path, DIRECTORIES, is a colon-separated list of
     directories to be searched, just like the search path used in
     the `VPATH' variable.

`vpath PATTERN'
     Clear out the search path associated with PATTERN.

`vpath'
     Clear all search paths previously specified with `vpath'
     directives.

A `vpath' pattern is a string containing a `%' character.  The string
must match the filename of a dependency that is being searched for,
the `%' character matching any sequence of zero or more characters
(as in pattern rules; *note Pattern Rules::.).  (If there is no `%',
the pattern must match the dependency, which is not useful very often.)

`%' characters in a `vpath' directive's pattern can be quoted with
preceding backslashes (`\').  Backslashes that would otherwise quote
`%' characters can be quoted with more backslashes.  Backslashes that
quote `%' characters or other backslashes are removed from the
pattern before it is compared to file names.  Backslashes that are
not in danger of quoting `%' characters go unmolested.

When a dependency fails to exist in the current directory, if the
PATTERN in a `vpath' directive matches the name of the dependency
file, then the DIRECTORIES in that directive are searched just like
(and before) the directories in the `VPATH' variable.  For example,

     vpath %.h ../headers

tells `make' to look for any dependency whose name ends in `.h' in
the directory `../headers' if the file is not found in the current
directory.

If several `vpath' patterns match the dependency file's name, then
`make' processes each matching `vpath' directive one by one,
searching all the directories mentioned in each directive.  The
`vpath' directives are processed in the order in which they appear in
the makefiles.



File: make-info,  Node: Commands/Search,  Next: Implicit/Search,  Prev: Selective Search,  Up: Directory Search

Writing Shell Commands with Directory Search
--------------------------------------------

When a dependency is found in another directory through directory
search, this cannot change the commands of the rule; they will
execute as written.  Therefore, you must write the commands with care
so that they will look for the dependency in the directory where
`make' finds it.

This is done with the "automatic variables" such as `$^' (*note
Automatic::.).  For instance, the value of `$^' is a list of all the
dependencies of the rule, including the names of the directories in
which they were found, and the value of `$@' is the target.  Thus:

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

The variable `CFLAGS' exists so you can specify flags for C
compilation by implicit rule; we use it here for consistency so it
will affect all C compilations uniformly (*note Implicit Variables::.).

Often the dependencies include header files as well, which you don't
want to mention in the commands.  The function `firstword' can be
used to extract just the first dependency from the entire list, as
shown here (*note Filename Functions::.):

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $(firstword $^) -o $@

Here the value of `$^' would be something like `src/foo.c
../headers/defs.h hack.h', from which `$(firstword $^)' extracts just
`src/foo.c'.



File: make-info,  Node: Implicit/Search,  Next: Libraries/Search,  Prev: Commands/Search,  Up: Directory Search

Directory Search and Implicit Rules
-----------------------------------

The search through the directories specified in `VPATH' or with
`vpath' happens also during consideration of implicit rules (*note
Implicit::.).

For example, when a file `foo.o' has no explicit rule, `make'
considers implicit rules, such as to compile `foo.c' if that file
exists.  If such a file is lacking in the current directory, the
appropriate directories are searched for it.  If `foo.c' exists (or
is mentioned in the makefile) in any of the directories, the implicit
rule for C compilation is applicable.

The commands of all the built-in implicit rules normally use
automatic variables as a matter of necessity; consequently they will
use the file names found by directory search with no extra effort.



File: make-info,  Node: Libraries/Search,  Prev: Implicit/Search,  Up: Directory Search

Directory Search for Link Libraries
-----------------------------------

Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a
dependency whose name is of the form `-lNAME'.  (You can tell
something funny is going on here because the dependency is normally
the name of a file, and the *file name* of the library looks like
`libNAME.a', not like `-lNAME'.)

When a dependency's name has the form `-lNAME', `make' handles it
specially by searching for the file `libNAME.a' in the directories
`/lib' and `/usr/lib', and then using matching `vpath' search paths
and the `VPATH' search path.

For example,

     foo : foo.c -lcurses
             cc $^ -o $@

would cause the command `cc foo.c -lcurses -o foo' to be executed
when `foo' is older than `foo.c' or than `libcurses.a' (which has
probably been found by directory search in the file
`/usr/lib/libcurses.a').

As shown by the example above, the file name found by directory
search is used only for comparing the file time with the target
file's time.  It does not replace the file's name in later usage
(such as in automatic variables like `$^'); the name remains
unchanged, still starting with `-l'.  This leads to the correct
results because the linker will repeat the appropriate search when it
processes this argument.



File: make-info,  Node: Phony Targets,  Next: Force Targets,  Prev: Directory Search,  Up: Rules

Phony Targets
=============

A phony target is one that is not really the name of a file.  It is
just a name for some commands to be executed when you make an
explicit request.

If you write a rule whose commands will not create the target file,
the commands will be executed every time the target comes up for
remaking.  Here is an example:

     clean:
             rm *.o temp

Because the `rm' command does not create a file named `clean',
probably no such file will ever exist.  Therefore, the `rm' command
will be executed every time you say `make clean'.

The phony target will cease to work if anything ever does create a
file named `clean' in this directory.  Since it has no dependencies,
the file `clean' would inevitably be considered up to date, and its
commands would not be executed.  To avoid this problem, you can
explicitly declare the target to be phony, using the special target
`.PHONY' (*note Special Targets::.) as follows:

     .PHONY : clean

Once this is done, `make clean' will run the commands regardless of
whether there is a file named `clean'.

A phony target should not be a dependency of a real target file;
strange things can result from that.  As long as you don't do that,
the phony target commands will be executed only when the phony target
is a specified goal (*note Goals::.).

Phony targets can have dependencies.  When one directory contains
multiple programs, it is most convenient to describe all of the
programs in one makefile `./Makefile'.  Since the target remade by
default will be the first one in the makefile, it is common to make
this a phony target named `all' and give it, as dependencies, all the
individual programs.  For example:

     all : prog1 prog2 prog3
     .PHONY : all
     
     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o
     
     prog2 : prog2.o
             cc -o prog2 prog2.o
     
     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o

Now you can say just `make' to remake all three programs, or specify
as arguments the ones to remake (as in `make prog1 prog3').

When one phony target is a dependency of another, it serves as a
subroutine of the other.  For example, here `make cleanall' will
delete the object files, the difference files, and the file `program':

     cleanall : cleanobj cleandiff
             rm program
     
     cleanobj :
             rm *.o
     
     cleandiff :
             rm *.diff



File: make-info,  Node: Force Targets,  Next: Empty Targets,  Prev: Phony Targets,  Up: Rules

Rules without Commands or Dependencies
======================================

If a rule has no dependencies or commands, and the target of the rule
is a nonexistent file, then `make' imagines this target to have been
updated whenever its rule is run.  This implies that all targets
depending on this one will always have their commands run.

An example will illustrate this:

     clean: FORCE
             rm $(objects)
     FORCE:

Here the target `FORCE' satisfies the special conditions, so the
target `clean' that depends on it is forced to run its commands. 
There is nothing special about the name `FORCE', but that is one name
commonly used this way.

As you can see, using `FORCE' this way has the same results as using
`.PHONY: clean'.  The latter is more explicit, but other versions of
`make' do not support it; thus `FORCE' appears in many makefiles.



File: make-info,  Node: Empty Targets,  Next: Special Targets,  Prev: Force Targets,  Up: Rules

Empty Target Files to Record Events
===================================

The "empty target" is a variant of the phony target; it is used to
hold commands for an action that you request explicitly from time to
time.  Unlike a phony target, this target file can really exist; but
the file's contents do not matter, and usually are empty.

The purpose of the empty target file is to record, with its
last-modification time, when the rule's commands were last executed. 
It does so because one of the commands is a `touch' command to update
the target file.

The empty target file must have some dependencies.  When you ask to
remake the empty target, the commands are executed if any dependency
is more recent than the target; in other words, if a dependency has
changed since the last time you remade the target.  Here is an example:

     print: foo.c bar.c
             lpr -p $?
             touch print

With this rule, `make print' will execute the `lpr' command if either
source file has changed since the last `make print'.  The automatic
variable `$?' is used to print only those files that have changed
(*note Automatic::.).



File: make-info,  Node: Special Targets,  Next: Multiple Targets,  Prev: Empty Targets,  Up: Rules

Special Built-in Target Names
=============================

Certain names have special meanings if they appear as targets.

`.PHONY'
     The dependencies of the special target `.PHONY' are considered
     to be phony targets.  When it is time to consider such a target,
     `make' will run its commands unconditionally, regardless of
     whether a file with that name exists or what its
     last-modification time is.  *Note Phony Targets::.

`.SUFFIXES'
     The dependencies of the special target `.SUFFIXES' are the list
     of suffixes to be used in checking for suffix rules.  *Note
     Suffix Rules::.

`.DEFAULT'
     The commands specified for `.DEFAULT' are used for any target
     for which no other commands are known (either explicitly or
     through an implicit rule).  If `.DEFAULT' commands are
     specified, every nonexistent file mentioned as a dependency will
     have these commands executed on its behalf.  *Note Search
     Algorithm::.

`.PRECIOUS'
     The targets which `.PRECIOUS' depends on are given this special
     treatment: if `make' is killed or interrupted during the
     execution of their commands, the target is not deleted.  *Note
     Interrupts::.

`.IGNORE'
     Simply by being mentioned as a target, `.IGNORE' says to ignore
     errors in execution of commands.  The dependencies and commands
     for `.IGNORE' are not meaningful.

     `.IGNORE' exists for historical compatibility.  Since `.IGNORE'
     affects every command in the makefile, it is not very useful; we
     recommend you use the more selective ways to ignore errors in
     specific commands.  *Note Errors::.

`.SILENT'
     Simply by being mentioned as a target, `.SILENT' says not to
     print commands before executing them.  The dependencies and
     commands for `.SILENT' are not meaningful.

     `.SILENT' exists for historical compatibility.  We recommend you
     use the more selective ways to silence specific commands.  *Note
     Echoing::.

Any defined implicit rule suffix also counts as a special target if
it appears as a target, and so does the concatenation of two
suffixes, such as `.c.o'.  These targets are suffix rules, an
obsolete way of defining implicit rules (but a way still widely
used).  In principle, any target name could be special in this way if
you break it in two and add both pieces to the suffix list.  In
practice, suffixes normally begin with `.', so these special target
names also begin with `.'.  *Note Suffix Rules::.



File: make-info,  Node: Multiple Targets,  Next: Static Pattern,  Prev: Special Targets,  Up: Rules

Multiple Targets in a Rule
==========================

A rule with multiple targets is equivalent to writing many rules,
each with one target, and all identical aside from that.  The same
commands apply to all the targets, but their effects may vary because
you can substitute the actual target name into the command using
`$@'.  The rule contributes the same dependencies to all the targets
also.

This is useful in two cases.

   * You want just dependencies, no commands.  For example:

          kbd.o commands.o files.o: command.h

     gives an additional dependency to each of the three object files
     mentioned.

   * Similar commands work for all the targets.  The commands do not
     need to be absolutely identical, since the automatic variable
     `$@' can be used to substitute the particular target to be
     remade into the commands (*note Automatic::.).  For example:

          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) > $@

     is equivalent to

          bigoutput : text.g
                  generate text.g -big > bigoutput
          littleoutput : text.g
                  generate text.g -little > littleoutput

     Here we assume the hypothetical program `generate' makes two
     types of output, one if given `-big' and one if given `-little'.

Suppose you would like to vary the dependencies according to the
target, much as the variable `$@' allows you to vary the commands. 
You cannot do this with multiple targets in an ordinary rule, but you
can do it with a "static pattern rule".  *Note Static Pattern::.



File: make-info,  Node: Static Pattern,  Next: Multiple Rules,  Prev: Multiple Targets,  Up: Rules

Static Pattern Rules
====================

"Static pattern rules" are rules which specify multiple targets and
construct the dependency names for each target based on the target
name.  They are more general than ordinary rules with multiple
targets because the targets don't have to have identical
dependencies.  Their dependencies must be *analogous*, but not
necessarily *identical*.

* Menu:

* Usage: Static Usage.  How to use static pattern rules.
* Static vs Implicit::  When are they better than implicit rules?

 

File: make-info,  Node: Static Usage,  Next: Static vs Implicit,  Prev: Static Pattern,  Up: Static Pattern

Syntax of Static Pattern Rules
------------------------------

Here is the syntax of a static pattern rule:

     TARGETS: TARGET-PATTERN: DEP-PATTERNS ...
             COMMANDS
             ...

 The TARGETS gives the list of targets that the rule applies to.  The
targets can contain wildcard characters, just like the targets of
ordinary rules (*note Wildcards::.).

The TARGET-PATTERN and DEP-PATTERNS say how to compute the
dependencies of each target.  Each target is matched against the
TARGET-PATTERN to extract a part of the target name, called the
"stem".  This stem is substituted into each of the DEP-PATTERNS to
make the dependency names (one from each DEP-PATTERN).

Each pattern normally contains the character `%' just once.  When the
TARGET-PATTERN matches a target, the `%' can match any part of the
target name; this part is called the "stem".  The rest of the pattern
must match exactly.  For example, the target `foo.o' matches the
pattern `%.o', with `foo' as the stem.  The targets `foo.c' and
`foo.out' don't match that pattern.

The dependency names for each target are made by substituting the
stem for the `%' in each dependency pattern.  For example, if one
dependency pattern is `%.c', then substitution of the stem `foo'
gives the dependency name `foo.c'.  It is legitimate to write a
dependency pattern that doesn't contain `%'; then this dependency is
the same for all targets.

`%' characters in pattern rules can be quoted with preceding
backslashes (`\').  Backslashes that would otherwise quote `%'
characters can be quoted with more backslashes.  Backslashes that
quote `%' characters or other backslashes are removed from the
pattern before it is compared file names or has a stem substituted
into it.  Backslashes that are not in danger of quoting `%'
characters go unmolested.  For example, the pattern
`the\%weird\\%pattern\\' has `the%weird\' preceding the operative `%'
character, and `pattern\\' following it.  The final two backslashes
are left alone because they can't affect any `%' character.

Here is an example, which compiles each of `foo.o' and `bar.o' from
the corresponding `.c' file:

     objects = foo.o bar.o
     
     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@

Each target specified must match the target pattern; a warning is
issued for each target that does not.  If you have a list of files,
only some of which will match the pattern, you can use the `filter'
function to remove nonmatching filenames (*note Text Functions::.):

     files = foo.elc bar.o lose.o
     
     $(filter %.o,$(files)): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $<

Here the result of `$(filter %.o,$(files))' is `bar.o lose.o', and
the first static pattern rule causes each of these object files to be
updated by compiling the corresponding C source file.  The result of
`$(filter %.elc,$(files))' is `foo.elc', so that file is made from
`foo.el'.



File: make-info,  Node: Static vs Implicit,  Prev: Static Usage,  Up: Static Pattern

Static Pattern Rules versus Implicit Rules
------------------------------------------

A static pattern rule has much in common with an implicit rule
defined as a pattern rule (*note Pattern Rules::.).  Both have a
pattern for the target and patterns for constructing the names of
dependencies.  The difference is in how `make' decides *when* the
rule applies.

An implicit rule *can* apply to any target that matches its pattern,
but it *does* apply only when the target has no commands otherwise
specified, and only when the dependencies can be found.  If more than
one implicit rule appears applicable, only one applies; the choice
depends on the order of rules.

By contrast, a static pattern rule applies to the precise list of
targets that you specify in the rule.  It cannot apply to any other
target and it invariably does apply to each of the targets specified.
If two conflicting rules apply, and both have commands, that's an
error.

The static pattern rule can be better than an implicit rule for these
reasons:

   * You may wish to override the usual implicit rule for a few files
     whose names cannot be categorized syntactically but can be given
     in an explicit list.

   * If you cannot be sure of the precise contents of the directories
     you are using, you may not be sure which other irrelevant files
     might lead `make' to use the wrong implicit rule.  The choice
     might depend on the order in which the implicit rule search is
     done.  With static pattern rules, there is no uncertainty: each
     rule applies to precisely the targets specified.



File: make-info,  Node: Multiple Rules,  Next: Double-Colon,  Prev: Static Pattern,  Up: Rules

Multiple Rules for One Target
=============================

One file can be the target of several rules if at most one rule has
commands; the other rules can only have dependencies.  All the
dependencies mentioned in all the rules are merged into one list of
dependencies for the target.  If the target is older than any
dependency from any rule, the commands are executed.

An extra rule with just dependencies can be used to give a few extra
dependencies to many files at once.  For example, one usually has a
variable named `objects' containing a list of all the compiler output
files in the system being made.  An easy way to say that all of them
must be recompiled if `config.h' changes is to write

     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h

This could be inserted or taken out without changing the rules that
really say how to make the object files, making it a convenient form
to use if you wish to add the additional dependency intermittently.

Another wrinkle is that the additional dependencies could be
specified with a variable that you could set with a command argument
to `make' (*note Overriding::.).  For example,

     extradeps=
     $(objects) : $(extradeps)

means that the command `make extradeps=foo.h' will consider `foo.h'
as a dependency of each object file, but plain `make' will not.

If none of the explicit rules for a target has commands, then `make'
searches for an applicable implicit rule to find some commands. 
*Note Implicit::.



File: make-info,  Node: Double-Colon,  Prev: Multiple Rules,  Up: Rules

Double-Colon Rules
==================

"Double-colon" rules are rules written with `::' instead of `:' after
the target names.  They are handled differently from ordinary rules
when the same target appears in more than one rule.

When a target appears in multiple rules, all the rules must be the
same type: all ordinary, or all double-colon.  If they are
double-colon, each of them is independent of the others.  Each
double-colon rule's commands are executed if the target is older than
any dependencies of that rule.  This can result in executing none,
any or all of the double-colon rules.

Double-colon rules with the same target are in fact completely
separate from one another.  Each double-colon rule is processed
individually, just as rules with different targets are processed.

The double-colon rules for a target are executed in the order they
appear in the makefile.  However, the cases where double-colon rules
really make sense are those where the order of executing the commands
would not matter.

Double-colon rules are somewhat obscure and not often very useful;
they provide a mechanism for cases in which the method used to update
a target differs depending on which dependency files caused the
update, and such cases are rare.

Each double-colon rule should specify commands; if it does not, an
implicit rule will be used if one applies.  *Note Implicit::.



File: make-info,  Node: Commands,  Next: Variables,  Prev: Rules,  Up: Top

Writing the Commands in Rules
*****************************

The commands of a rule consist of shell command lines to be executed
one by one.  Each command line must start with a tab, except that the
first command line may be attached to the target-and-dependencies
line with a semicolon in between.  Blank lines and lines of just
comments may appear among the command lines; they are ignored.

Users use many different shell programs, but commands in makefiles
are always interpreted by `/bin/sh' unless the makefile specifies
otherwise.

Whether comments can be written on command lines, and what syntax
they use, is under the control of the shell that is in use.  If it is
`/bin/sh', a `#' at the start of a word starts a comment.

* Menu:

* Echoing::       Normally commands are echoed before execution,
                    but you can control this in several ways.
* Execution::     How commands are executed.
* Parallel::      Commands of several rules can be executed in parallel,
                    to reduce total time.
* Errors::        What happens after an error in command execution.
                   How to ignore errors in certain commands.
* Interrupts::    If a command is interrupted or killed,
                   the target may be deleted.
* Recursion::     Invoking `make' from commands in makefiles.
* Sequences::     Defining canned sequences of commands.
* Empty Commands::Defining commands that do nothing (but are useful).

 

File: make-info,  Node: Echoing,  Next: Execution,  Prev: Commands,  Up: Commands

Command Echoing
===============

Normally `make' prints each command line before it is executed.  We
call this "echoing" because it gives the appearance that you are
typing the commands yourself.

When a line starts with `@', the echoing of that line is suppressed. 
The `@' is discarded before the command is passed to the shell. 
Typically you would use this for a command whose only effect is to
print something, such as an `echo' command to indicate progress
through the makefile:

     @echo About to make distribution files

When `make' is given the flag `-n', echoing is all that happens, no
execution.  *Note Options::.  In this case and only this case, even
the commands starting with `@' are printed.  This flag is useful for
finding out which commands `make' thinks are necessary without
actually doing them.

The `-s' flag to `make' prevents all echoing, as if all commands
started with `@'.  A rule in the makefile for the special target
`.SILENT' has the same effect (*note Special Targets::.).  `.SILENT'
is essentially obsolete since `@' is more flexible.



File: make-info,  Node: Execution,  Next: Parallel,  Prev: Echoing,  Up: Commands

Command Execution
=================

When it is time to execute commands to update a target, they are
executed by making a new subshell for each line.  (In practice,
`make' may take shortcuts that do not affect the results.)

This implies that shell commands such as `cd' that set variables
local to each process will not affect the following command lines. 
If you want to use `cd' to affect the next command, put the two on a
single line with a semicolon between them.  Then `make' will consider
them a single command and pass them, together, to a shell which will
execute them in sequence.  For example:

     foo : bar/lose
             cd bar; gobble lose > ../foo

If you would like to split a single shell command into multiple lines
of text, you must use a backslash at the end of all but the last
subline.  Such a sequence of lines is combined into a single line, by
deleting the backslash-newline sequences, before passing it to the
shell.  Thus, the following is equivalent to the preceding example:

     foo : bar/lose
             cd bar;  \
             gobble lose > ../foo

The program used as the shell is taken from the variable `SHELL'.  By
default, the program `/bin/sh' is used.

Unlike most variables, the variable `SHELL' will not be set from the
environment, except in a recursive `make'.  This is because the
environment variable `SHELL' is used to specify your personal choice
of shell program for interactive use.  It would be very bad for
personal choices like this to affect the functioning of makefiles. 
*Note Environment::.



File: make-info,  Node: Parallel,  Next: Errors,  Prev: Execution,  Up: Commands

Parallel Execution
==================

GNU `make' knows how to execute several commands at once.  Normally,
`make' will execute only one command at a time, waiting for it to
finish before executing the next.  However, the `-j' option tells
`make' to execute many commands simultaneously.

If the `-j' option is followed by an integer, this is the number of
commands to execute at once; this is called the number of "job slots".
If there is nothing looking like an integer after the `-j' option,
there is no limit on the number of job slots.  The default number of
job slots is one, which means serial execution (one thing at a time).

One unpleasant consequence of running several commands simultaneously
is that output from all of the commands comes when the commands send
it, so messages from different commands may be interspersed.

Another problem is that two processes cannot both take input from the
same device; so to make sure that only one command tries to take
input from the terminal at once, `make' will invalidate the standard
input streams of all but one running command.  This means that
attempting to read from standard input, for most child processes if
there are several, will usually be a fatal error (a `Broken pipe'
signal).

It is unpredictable which command will have a valid standard input
stream (which will come from the terminal, or wherever you redirect
the standard input of `make').  The first command run will always get
it first, and the first command started after that one finishes will
get it next, and so on.

We will change how this aspect of `make' works if we find a better
alternative.  In the mean time, you should not rely on any command
using standard input at all if you are using the parallel execution
feature; but if you are not using this feature, then standard input
works normally in all commands.

If a command fails (is killed by a signal or exits with a nonzero
status), and errors are not ignored for that command (*note
Errors::.), the remaining command lines to remake the same target
will not be run.  If a command fails and the `-k' option was not
given (*note Options::.), `make' aborts execution.  If make
terminates for any reason (including a signal) with child processes
running, it waits for them to finish before actually exiting.

When the system is heavily loaded, you will probably want to run
fewer jobs than when it is lightly loaded.  You can use the `-l'
option to tell `make' to limit the number of jobs to run at once,
based on the load average.  The `-l' option is followed by a
floating-point number.  For example,

     -l 2.5

will not let `make' start more than one job if the load average is
above 2.5.  The `-l' option with no following number removes the load
limit, if one was given with a previous `-l' option.

More precisely, when `make' goes to start up a job, and it already
has at least one job running, it checks the current load average; if
it is not lower than the limit given with `-l', `make' waits until
the load average goes below that limit, or until all the other jobs
finish.

By default, there is no load limit.



File: make-info,  Node: Errors,  Next: Interrupts,  Prev: Parallel,  Up: Commands

Errors in Commands
==================

After each shell command returns, `make' looks at its exit status. 
If the command completed successfully, the next command line is
executed in a new shell, or after the last command line is executed,
the rule is finished.

If there is an error (the exit status is nonzero), `make' gives up on
the current rule, and perhaps on all rules.

Sometimes the failure of a certain command does not indicate a problem.
For example, you may use the `mkdir' command to insure that a
directory exists.  If the directory already exists, `mkdir' will
report an error, but you probably want `make' to continue regardless.

To ignore errors in a command line, write a `-' at the beginning of
the line's text (after the initial tab).  The `-' is discarded before
the command is passed to the shell for execution.  For example,

     clean:
             -rm -f *.o

When `make' is run with the `-i' flag, errors are ignored in all
commands of all rules.  A rule in the makefile for the special target
`.IGNORE' has the same effect.  These ways of ignoring errors are
obsolete because `-' is more flexible.

When errors are to be ignored, because of either a `-' or the `-i'
flag, `make' treats an error return just like success, except that it
prints out a message telling you the status code the command exited
with and saying that the error has been ignored.

When an error happens that `make' has not been told to ignore, it
implies that the current target cannot be correctly remade, and
neither can any other that depends on it either directly or
indirectly.  No further commands will be executed for these targets,
since their preconditions have not been achieved.

Normally `make' gives up immediately in this circumstance, returning
a nonzero status.  However, if the `-k' flag is specified, `make'
continues to consider the other dependencies of the pending targets,
remaking them if necessary, before it gives up and returns nonzero
status.  For example, after an error in compiling one object file,
`make -k' will continue compiling other object files even though it
already knows that linking them will be impossible.  *Note Options::.

The usual behavior assumes that your purpose is to get the specified
targets up to date; once `make' learns that this is impossible, it
might as well report the failure immediately.  The `-k' option says
that the real purpose is to test as much as possible of the changes
made in the program, perhaps to find several independent problems so
that you can correct them all before the next attempt to compile. 
This is why Emacs's `compile' command passes the `-k' flag by default.



File: make-info,  Node: Interrupts,  Next: Recursion,  Prev: Errors,  Up: Commands

Interrupting or Killing `make'
==============================

If `make' gets a fatal signal while a command is executing, it may
delete the target file that the command was supposed to update.  This
is done if the target file's last-modification time has changed since
`make' first checked it.

The purpose of deleting the target is to make sure that it is remade
from scratch when `make' is next run.  Why is this?  Suppose you type
`Ctrl-c' while a compiler is running, and it has begun to write an
object file `foo.o'.  The `Ctrl-c' kills the compiler, resulting in
an incomplete file whose last-modification time is newer than the
source file `foo.c'.  But `make' also receives the `Ctrl-c' signal
and deletes this incomplete file.  If `make' did not do this, the
next invocation of `make' would think that `foo.o' did not require
updating--resulting in a strange error message from the linker when
it tries to link an object file half of which is missing.

You can prevent the deletion of a target file in this way by making
the special target `.PRECIOUS' depend on it.  Before remaking a
target, `make' checks to see whether it appears on the dependencies
of `.PRECIOUS', and thereby decides whether the target should be
deleted if a signal happens.  Some reasons why you might do this are
that the target is updated in some atomic fashion, or exists only to
record a modification-time (its contents do not matter), or must
exist at all times to prevent other sorts of trouble.



File: make-info,  Node: Recursion,  Next: Sequences,  Prev: Interrupts,  Up: Commands

Recursive Use of `make'
=======================

Recursive use of `make' means using `make' as a command in a
makefile.  This technique is useful when you want separate makefiles
for various subsystems that compose a larger system.  For example,
suppose you have a subdirectory `subdir' which has its own makefile,
and you would like the containing directory's makefile to run `make'
on the subdirectory.  You can do it by writing this:

     subsystem:
             cd subdir; $(MAKE)

or, equivalently, this (*note Options::.):

     subsystem:
             $(MAKE) -C subdir

You can write recursive `make' commands just by copying this example,
but there are many things to know about how they work and why, and
about how the sub-`make' relates to the top-level `make'.

* Menu:

* MAKE Variable::        Special effects of using `$(MAKE)'.
* Variables/Recursion::  How variables are communicated to a sub-`make'.
* Options/Recursion::    How options are communicated to a sub-`make'.
* -w Option::            The `-w' option facilitates debugging
                           makefiles with recursive `make' commands.

 

File: make-info,  Node: MAKE Variable,  Next: Variables/Recursion,  Prev: Recursion,  Up: Recursion

How the `MAKE' Variable Works
-----------------------------

Recursive `make' commands should always use the variable `MAKE', not
the explicit command name `make', as shown here:

     subsystem:
             cd subdir; $(MAKE)

The value of this variable is the file name with which `make' was
invoked.  If this file name was `/bin/make', then the command
executed is `cd subdir; /bin/make'.  If you use a special version of
`make' to run the top-level makefile, the same special version will
be executed for recursive invocations.

Also, any arguments that define variable values are added to `MAKE',
so the sub-`make' gets them too.  Thus, if you do `make CFLAGS=-O',
so that all C compilations will be optimized, the sub-`make' is run
with `cd subdir; /bin/make CFLAGS=-O'.

As a special feature, using the variable `MAKE' in the commands of a
rule alters the effects of the `-t', `-n' or `-q' option.  (*Note
Instead of Execution::.)

Consider the command `make -t' in the above example.  Following the
usual definition of `-t', this would create a file named `subsystem'
and do nothing else.  What you really want it to do is run `cd
subdir; make -t'; but that would require executing the command, and
`-t' says not to execute commands.

The special feature makes this do what you want: whenever a rule's
commands use the variable `MAKE', the flags `-t', `-n' or `-q' do not
apply to that rule.  The commands of that rule are executed normally
despite the presence of a flag that causes most commands not to be run.
The usual `MAKEFLAGS' mechanism passes the flags to the sub-`make'
(*note Options/Recursion::.), so your request to touch the files, or
print the commands, is propagated to the subsystem.



File: make-info,  Node: Variables/Recursion,  Next: Options/Recursion,  Prev: MAKE Variable,  Up: Recursion

Communicating Variables to a Sub-`make'
---------------------------------------

Most variable values of the top-level `make' are passed to the
sub-`make' through the environment.  These variables are defined in
the sub-`make' as defaults, but do not override what is specified in
the sub-`make''s makefile.

Variables are passed down if their names consist only of letters,
numbers and underscores.  Some shells cannot cope with environment
variable names consisting of characters other than letters, numbers,
and underscores.

Variable are *not* passed down if they were created by default by
`make' (*note Implicit Variables::.).  The sub-`make' will define
these for itself.

The way this works is that `make' adds each variable and its value to
the environment for running each command.  The sub-`make', in turn,
uses the environment to initialize its table of variable values. 
*Note Environment::.

As a special feature, the variable `MAKELEVEL' is changed when it is
passed down from level to level.  This variable's value is a string
which is the depth of the level as a decimal number.  The value is
`0' for the top-level `make'; `1' for a sub-`make', `2' for a
sub-sub-`make', and so on.  The incrementation happens when `make'
sets up the environment for a command.

The main use of `MAKELEVEL' is to test it in a conditional directive
(*note Conditionals::.); this way you can write a makefile that
behaves one way if run recursively and another way if run directly by
you.

You can use the variable `MAKEFILES' to cause all sub-`make' commands
to use additional makefiles.  The value of `MAKEFILES' is a
whitespace-separated list of filenames.  This variable, if defined in
the outer-level makefile, is passed down through the environment as
usual; then it serves as a list of extra makefiles for the sub-`make'
to read before the usual or specified ones.  *Note MAKEFILES
Variable::.



File: make-info,  Node: Options/Recursion,  Next: -w Option,  Prev: Variables/Recursion,  Up: Recursion

Communicating Options to a Sub-`make'
-------------------------------------

Flags such as `-s' and `-k' are passed automatically to the
sub-`make' through the variable `MAKEFLAGS'.  This variable is set up
automatically by `make' to contain the flag letters that `make'
received.  Thus, if you do `make -ks' then `MAKEFLAGS' gets the value
`ks'.

As a consequence, every sub-`make' gets a value for `MAKEFLAGS' in
its environment.  In response, it takes the flags from that value and
processes them as if they had been given as arguments.  *Note
Options::.

The options `-C', `-f', `-I', `-o', and `-W' are not put into
`MAKEFLAGS'; these options are not passed down.

If you don't want to pass the other flags down, you must change the
value of `MAKEFLAGS', like this:

     MAKEFLAGS=
     subsystem:
             cd subdir; $(MAKE)

or like this:

     subsystem:
             cd subdir; $(MAKE) MAKEFLAGS=

A similar variable `MFLAGS' exists also, for historical compatibility.
It has the same value as `MAKEFLAGS' except that a hyphen is added at
the beginning if it is not empty.  `MFLAGS' was traditionally used
explicitly in the recursive `make' command, like this:

     subsystem:
             cd subdir; $(MAKE) $(MFLAGS)

but now `MAKEFLAGS' makes this usage redundant.

The `MAKEFLAGS' and `MFLAGS' variables can also be useful if you want
to have certain options, such as `-k' (*note Options::.) set each
time you run `make'.  Just put `MAKEFLAGS=k' or `MFLAGS=-k' in your
environment.  These variables may also be set in makefiles, so a
makefile can specify additional flags that should also be in effect
for that makefile.

If you do put `MAKEFLAGS' or `MFLAGS' in your environment, you should
be sure not to include any options that will drastically affect the
actions of `make' and undermine the purpose of makefiles and of
`make' itself.  For instance, the `-t', `-n', and `-q' options, if
put in one of these variables, could have disastrous consequences and
would certainly have at least surprising and probably annoying effects.



File: make-info,  Node: -w Option,  Prev: Options/Recursion,  Up: Recursion

The `-w' Option
---------------

If you use several levels of recursive `make' invocations, the `-w'
option can make the output a lot easier to understand by showing each
directory as `make' starts processing it and as `make' finishes
processing it.  For example, if `make -w' is run in the directory
`/u/gnu/make', `make' will print a line of the form:

     make: Entering directory `/u/gnu/make'.

 before doing anything else, and a line of the form:

     make: Leaving directory `/u/gnu/make'.

 when processing is completed.



File: make-info,  Node: Sequences,  Next: Empty Commands,  Prev: Recursion,  Up: Commands

Defining Canned Command Sequences
=================================

When the same sequence of commands is useful in making various
targets, you can define it as a canned sequence with the `define'
directive, and refer to the canned sequence from the rules for those
targets.  The canned sequence is actually a variable, so the name
must not conflict with other variable names.

Here is an example of defining a canned sequence of commands:

     define run-yacc
     yacc $(firstword $^)
     mv y.tab.c $@
     endef

Here `run-yacc' is the name of the variable being defined; `endef'
marks the end of the definition; the lines in between are the
commands.  The `define' directive does not expand variable references
and function calls in the canned sequence; the `$' characters,
parentheses, variable names, and so on, all become part of the value
of the variable you are defining.  *Note Defining::, for a complete
explanation of `define'.

The first command in this example runs Yacc on the first dependency
(of whichever rule uses the canned sequence).  The output file from
Yacc is always named `y.tab.c'.  The second command moves the output
to the rule's target file name.

To use the canned sequence, substitute the variable into the commands
of a rule.  You can substitute it like any other variable (*note
Reference::.).  Because variables defined by `define' are recursively
expanded variables, all the variable references you wrote inside the
`define' are expanded now.  For example:

     foo.c : foo.y
             $(run-yacc)

`foo.y' will substituted for the variable `$^' when it occurs in
`run-yacc''s value, and `foo.c' for `$@'.

This is a realistic example, but this particular one is not needed in
practice because `make' has an implicit rule to figure out these
commands based on the file names involved.  *Note Implicit::.



File: make-info,  Node: Empty Commands,  Prev: Sequences,  Up: Commands

Defining Empty Commands
=======================

It is sometimes useful to define commands which do nothing.  This is
done simply by giving a command that consists of nothing but
whitespace.  For example:

     target:;

defines an empty command string for `target'.  You could also use a
line beginning with a tab character to define an empty command
string, but this would be confusing because such a line looks empty.

You may be wondering why you would want to define a command string
that does nothing.  The only reason this is useful is to prevent a
target from getting implicit commands (from implicit rules or the
`.DEFAULT' special target; *note Implicit::. and *note Last Resort::.).

You may be inclined to define empty command strings for targets that
are not actual files, but only exist so that their dependencies can
be remade.  However, this is not the best way to do that, because if
the target file actually does exist, its dependencies may not be
remade.  *Note Phony Targets::, for a better way to do this.


