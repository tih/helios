Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.

 

File: make-info,  Node: Makefile Arguments,  Next: Goals,  Prev: Running,  Up: Running

Arguments to Specify the Makefile
=================================

The way to specify the name of the makefile is with the `-f' option. 
For example, `-f altmake' says to use the file `altmake' as the
makefile.

If you use the `-f' flag several times (each time with a following
argument), all the specified files are used jointly as makefiles.

If you do not use the `-f' flag, the default is to try `GNUmakefile',
`makefile', or `Makefile', in that order, and use the first of these
three which exists.  *Note Makefiles::.



File: make-info,  Node: Goals,  Next: Instead of Execution,  Prev: Makefile Arguments,  Up: Running

Arguments to Specify the Goals
==============================

The "goals" are the targets that `make' should strive ultimately to
update.  Other targets are updated as well if they appear as
dependencies of goals, or dependencies of dependencies of goals, etc.

By default, the goal is the first target in the makefile (not
counting targets that start with a period or that appear in included
makefiles).  Therefore, makefiles are usually written so that the
first target is for compiling the entire program or programs they
describe.

You can specify a different goal or goals with arguments to `make'. 
Use the name of the goal as an argument.  If you specify several
goals, `make' processes each of them in turn, in the order you name
them.

Any target in the makefile may be specified as a goal (unless it
starts with `-' or contains an `=').  Even targets not in the
makefile may be specified, if `make' can find implicit rules that say
how to make them.

One use of specifying a goal is if you want to compile only a part of
the program, or only one of several programs.  Specify as a goal each
file that you wish to remake.  For example, consider a directory
containing several programs, with a makefile that starts like this:

     .PHONY: all
     all: size nm ld ar as

If you are working on the program `size', you might want to say `make
size' so that only the files of that program are recompiled.

Another use of specifying a goal is to make files that aren't
normally made.  For example, there may be a file of debugging output,
or a version of the program that is compiled specially for testing,
which has a rule in the makefile but isn't a dependency of the
default goal.

Another use of specifying a goal is to run the commands associated
with a phony target (*note Phony Targets::.) or empty target (*note
Empty Targets::.).  Many makefiles contain a phony target named
`clean' which deletes everything except source files.  Naturally,
this is done only if you request it explicitly with `make clean'. 
Here is a list of typical phony and empty target names:

`all'
     Make all the top-level targets the makefile knows about.

`clean'
     Delete all files that are normally created by running `make'.

`distclean'
`realclean'
`clobber'
     Any of these three might be defined to delete everything that
     would not be part of a standard distribution.  For example, this
     would delete configuration files or links that you would
     normally create as preparation for compilation, even if the
     makefile itself cannot create these files.

`install'
     Copy the executable file into a directory that users typically
     search for commands; copy any auxiliary files that the
     executable uses into the directories where it will look for them.

`print'
     Print listings of the source files that have changed.

`tar'
     Create a tar file of the source files.

`shar'
     Create a shell archive (shar file) of the source files.

`dist'
     Create a distribution file of the source files.  This might be a
     tar file, or a shar file, or a compressed version of one of the
     above, or even more than one of the above.



File: make-info,  Node: Instead of Execution,  Next: Avoiding Compilation,  Prev: Goals,  Up: Running

Instead of Executing the Commands
=================================

The makefile tells `make' how to tell whether a target is up to date,
and how to update each target.  But updating the targets is not
always what you want.  Certain options specify other activities for
`make'.

`-t'
     ``Touch''.  The activity is to mark the targets as up to date
     without actually changing them.  In other words, `make' pretends
     to compile the targets but does not really change their contents.

`-n'
     ``No-op''.  The activity is to print what commands would be used
     to make the targets up to date, but not actually execute them.

`-q'
     ``Question''.  The activity is to find out silently whether the
     targets are up to date already; but execute no commands in
     either case.  In other words, neither compilation nor output
     will occur.

`-W'
     ``What if''.  Each `-W' flag is followed by a file name.  The
     given files' modification times are recorded by `make' as being
     the present time, although the actual modification times remain
     the same.  When used in conjunction with the `-n' flag, the `-W'
     flag provides a way to see what would happen if you were to
     modify specific files.

With the `-n' flag, `make' prints without execution the commands that
it would normally execute.

With the `-t' flag, `make' ignores the commands in the rules and uses
(in effect) the command `touch' for each target that needs to be
remade.  The `touch' command is also printed, unless `-s' or
`.SILENT' is used.  For speed, `make' does not actually invoke the
program `touch'.  It does the work directly.

With the `-q' flag, `make' prints nothing and executes no commands,
but the exit status code it returns is zero if and only if the
targets to be considered are already up to date.

It is an error to use more than one of these three flags in the same
invocation of `make'.

The `-n', `-t', and `-q' options do not affect command lines that
begin with `+' characters or contain the strings `$(MAKE)' or
`${MAKE}'.  Note that only the line containing the `+' character or
the strings `$(MAKE)' or `${MAKE}' is run regardless of these
options.  Other lines in the same rule are not run unless they too
begin with `+' or contain `$(MAKE)' or `${MAKE}'.

The `-W' flag provides two features:

   * If you also use the `-n' or `-q' flag, you can see what `make'
     would do if you were to modify some files.

   * Without the `-n' or `-q' flag, when `make' is actually executing
     commands, the `-W' flag can direct `make' to act as if some
     files had been modified, without actually modifying the files.

Note that the options `-p' and `-v' allow you to obtain other
information about `make' or about the makefiles in use.  *Note
Options::.



File: make-info,  Node: Avoiding Compilation,  Next: Overriding,  Prev: Instead of Execution,  Up: Running

Avoiding Recompilation of Some Files
====================================

Sometimes you may have changed a source file but you don't want to
recompile all the files that depend on it.  For example, suppose you
add a macro or a declaration to a header file that many other files
depend on.  Being conservative, `make' assumes that any change in the
header file requires recompilation of all dependent files, but you
know that they don't need to be recompiled and you would rather not
waste the time waiting for them to compile.

If you anticipate the problem before changing the header file, you
can use the `-t' flag.  This flag tells `make' not to run the
commands in the rules, but rather to mark the target up to date by
changing its last-modification date.  You would follow this procedure:

  1. Use the command `make' to recompile the source files that really
     need recompilation.

  2. Make the changes in the header files.

  3. Use the command `make -t' to mark all the object files as up to
     date.  The next time you run `make', the changes in the header
     files will not cause any recompilation.

If you have already changed the header file at a time when some files
do need recompilation, it is too late to do this.  Instead, you can
use the `-o FILE' flag, which marks a specified file as ``old''
(*note Options::.).  This means that the file itself won't be remade,
and nothing else will be remade on its account.  Follow this procedure:

  1. Recompile the source files that need compilation for reasons
     independent of the particular header file, with `make -o
     HEADERFILE'.  If several header files are involved, use a
     separate `-o' option for each header file.

  2. Touch all the object files with `make -t'.



File: make-info,  Node: Overriding,  Next: Testing,  Prev: Avoiding Compilation,  Up: Running

Overriding Variables
====================

An argument that contains `=' specifies the value of a variable:
`V=X' sets the value of the variable V to X.  If you specify a value
in this way, all ordinary assignments of the same variable in the
makefile are ignored; we say they have been "overridden" by the
command line argument.

The most common way to use this facility is to pass extra flags to
compilers.  For example, in a properly written makefile, the variable
`CFLAGS' is included in each command that runs the C compiler, so a
file `foo.c' would be compiled something like this:

     cc -c $(CFLAGS) foo.c

Thus, whatever value you set for `CFLAGS' affects each compilation
that occurs.  The makefile probably specifies the usual value for
`CFLAGS', like this:

     CFLAGS=-g

Each time you run `make', you can override this value if you wish. 
For example, if you say `make CFLAGS='-g -O'', each C compilation
will be done with `cc -c -g -O'.  (This illustrates how you can
enclose spaces and other special characters in the value of a
variable when you override it.)

The variable `CFLAGS' is only one of many standard variables that
exist just so that you can change them this way.  *Note Implicit
Variables::, for a complete list.

You can also program the makefile to look at additional variables of
your own, giving the user the ability to control other aspects of how
the makefile works by changing the variables.

When you override a variable with a command argument, you can define
either a recursively-expanded variable or a simply-expanded variable.
The examples shown above make a recursively-expanded variable; to
make a simply-expanded variable, write `:=' instead of `='.  But,
unless you want to include a variable reference or function call in
the *value* that you specify, it makes no difference which kind of
variable you create.

There is one way that the makefile can change a variable that you
have overridden.  This is to use the `override' directive, which is a
line that looks like this: `override VARIABLE = VALUE'.  *Note
Override Directive::.



File: make-info,  Node: Testing,  Next: Options,  Prev: Overriding,  Up: Running

Testing the Compilation of a Program
====================================

Normally, when an error happens in executing a shell command, `make'
gives up immediately, returning a nonzero status.  No further
commands are executed for any target.  The error implies that the
goal cannot be correctly remade, and `make' reports this as soon as
it knows.

When you are compiling a program that you have just changed, this is
not what you want.  Instead, you would rather that `make' try
compiling every file that can be tried, to show you as many
compilation errors as possible.

On these occasions, you should use the `-k' flag.  This tells `make'
to continue to consider the other dependencies of the pending
targets, remaking them if necessary, before it gives up and returns
nonzero status.  For example, after an error in compiling one object
file, `make -k' will continue compiling other object files even
though it already knows that linking them will be impossible.  In
addition to continuing after failed shell commands, `make -k' will
continue as much as possible after discovering that it doesn't know
how to make a target or dependency file.  This will always cause an
error message, but without `-k', it is a fatal error.  *Note Options::.

The usual behavior of `make' assumes that your purpose is to get the
goals up to date; once `make' learns that this is impossible, it
might as well report the failure immediately.  The `-k' flag says
that the real purpose is to test as much as possible of the changes
made in the program, perhaps to find several independent problems so
that you can correct them all before the next attempt to compile. 
This is why Emacs's `M-x compile' command passes the `-k' flag by
default.



File: make-info,  Node: Options,  Prev: Testing,  Up: Running

Summary of Options
==================

Here is a table of all the options `make' understands:

`-b'
`-m'
     These options are ignored for compatibility with other versions
     of `make'.

`-C DIR'
     Change to directory DIR before reading the makefiles.  If
     multiple `-C' options are specified, each is interpreted
     relative to the previous one: `-C / -C etc' is equivalent to `-C
     /etc'.  This is typically used with recursive invocations of
     `make' (*note Recursion::.).

`-d'
     Print debugging information in addition to normal processing. 
     The debugging information says which files are being considered
     for remaking, which file-times are being compared and with what
     results, which files actually need to be remade, which implicit
     rules are considered and which are applied--everything
     interesting about how `make' decides what to do.

`-e'
     Make variables environment taken from the environment have
     precedence over variables from makefiles.  *Note Environment::.

`-f FILE'
     Use file FILE as a makefile.  *Note Makefiles::.

`-i'
     Ignore all errors in commands executed to remake files.  *Note
     Errors::.

`-I DIR'
     Specifies a directory DIR to search for included makefiles. 
     *Note Include::.  If several `-I' options are used to specify
     several directories, the directories are searched in the order
     specified.  Unlike the arguments to other flags of `make',
     directories given with `-I' flags may come directly after the
     flag: `-IDIR' is allowed, as well as `-I DIR'.  This syntax is
     allowed for compatibility with the C preprocessor's `-I' flag.

`-j JOBS'
     Specifies the number of jobs (commands) to run simultaneously. 
     If there is more than one `-j' option, the last one is effective.
     *Note Execution::, for more information on how commands are run.

`-k'
     Continue as much as possible after an error.  While the target
     that failed, and those that depend on it, cannot be remade, the
     other dependencies of these targets can be processed all the same.
     *Note Testing::.

`-l LOAD'
`-l'
     Specifies that no new jobs (commands) should be started if there
     are others jobs running and the load average is at least LOAD (a
     floating-point number).  With no argument, removes a previous
     load limit.  *Note Parallel::.

`-n'
     Print the commands that would be executed, but do not execute
     them.  *Note Instead of Execution::.

`-o FILE'
     Do not remake the file FILE even if it is older than its
     dependencies, and do not remake anything on account of changes
     in FILE.  Essentially the file is treated as very old and its
     rules are ignored.  *Note Avoiding Compilation::.

`-p'
     Print the data base (rules and variable values) that results
     from reading the makefiles; then execute as usual or as
     otherwise specified.  This also prints the version information
     given by the `-v' switch (see below).  To print the data base
     without trying to remake any files, use `make -p -f /dev/null'.

`-q'
     ``Question mode''.  Do not run any commands, or print anything;
     just return an exit status that is zero if the specified targets
     are already up to date, nonzero otherwise.  *Note Instead of
     Execution::.

`-r'
     Eliminate use of the built-in implicit rules (*note Implicit::.).
     Also clear out the default list of suffixes for suffix rules
     (*note Suffix Rules::.).

`-s'
     Silent operation; do not print the commands as they are executed.
     *Note Echoing::.

`-S'
     Cancel the effect of the `-k' option.  This is never necessary
     except in a recursive `make' where `-k' might be inherited from
     the top-level `make' via `MAKEFLAGS' (*note Recursion::.) or if
     you set `-k' in `MAKEFLAGS' in your environment.

`-t'
     Touch files (mark them up to date without really changing them)
     instead of running their commands.  This is used to pretend that
     the commands were done, in order to fool future invocations of
     `make'.  *Note Instead of Execution::.

`-v'
     Print the version of the `make' program plus a copyright, a list
     of authors and a notice that there is no warranty.  After this
     information is printed, processing continues normally.  To get
     this information without doing anything else, use `make -v -f
     /dev/null'.

`-w'
     Print a message containing the working directory both before and
     after executing the makefile.  This may be useful for tracking
     down errors from complicated nests of recursive `make' commands.
     *Note Recursion::.

`-W FILE'
     Pretend that the target FILE has just been modified.  When used
     with the `-n' flag, this shows you what would happen if you were
     to modify that file.  Without `-n', it is almost the same as
     running a `touch' command on the given file before running
     `make', except that the modification time is changed only in the
     imagination of `make'.



File: make-info,  Node: Implicit,  Next: Archives,  Prev: Running,  Up: Top

Using Implicit Rules
********************

Certain standard ways of remaking target files are used very often. 
For example, one customary way to make an object file is from a C
source file using the C compiler, `cc'.

"Implicit rules" tell `make' how to use customary techniques so that
you don't have to specify them in detail when you want to use them. 
For example, there is an implicit rule for C compilation.  Implicit
rules work based on file names.  For example, C compilation typically
takes a `.c' file and makes a `.o' file.  So `make' applies the
implicit rule for C compilation when it sees this combination of
file-name endings.

A chain of implicit rules can apply in sequence; for example, `make'
will remake a `.o' file from a `.y' file by way of a `.c' file.

The built-in implicit rules use several variables in their commands
so that, by changing the values of the variables, you can change the
way the implicit rule works.  For example, the variable `CFLAGS'
controls the flags given to the C compiler by the implicit rule for C
compilation.

You can define your own implicit rules by writing "pattern rules".

* Menu:

* Using Implicit::       How to use an existing implicit rule
                          to get the commands for updating a file.

* Catalogue of Rules::   Catalogue of built-in implicit rules.

* Implicit Variables::   By changing certain variables, you can
                          change what the predefined implicit rules do.

* Chained Rules::        Using a chain of implicit rules.

* Pattern Rules::        Defining new implicit rules.

* Last Resort::          Defining commands for rules which can't find any.

* Suffix Rules::         The old-fashioned style of implicit rule.

* Search Algorithm::     Precise algorithm for applying implicit rules.

 

File: make-info,  Node: Using Implicit,  Next: Catalogue of Rules,  Prev: Implicit,  Up: Implicit

Using Implicit Rules
====================

To allow `make' to find a customary method for updating a target
file, all you have to do is refrain from specifying commands
yourself.  Either write a rule with no command lines, or don't write
a rule at all.  Then `make' will figure out which implicit rule to
use based on which kind of source file exists.

For example, suppose the makefile looks like this:

     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)

Because you mention `foo.o' but do not give a rule for it, `make'
will automatically look for an implicit rule that tells how to update
it.  This happens whether or not the file `foo.o' currently exists.

If an implicit rule is found, it supplies both commands and one or
more dependencies (the source files).  You would want to write a rule
for `foo.o' with no command lines if you need to specify additional
dependencies, such as header files, that the implicit rule cannot
supply.

Each implicit rule has a target pattern and dependency patterns. 
There may be many implicit rules with the same target pattern.  For
example, numerous rules make `.o' files: one, from a `.c' file with
the C compiler; another, from a `.p' file with the Pascal compiler;
and so on.  The rule that actually applies is the one whose
dependencies exist or can be made.  So, if you have a file `foo.c',
`make' will run the C compiler; otherwise, if you have a file
`foo.p', `make' will run the Pascal compiler; and so on.

Of course, when you write the makefile, you know which implicit rule
you want `make' to use, and you know it will choose that one because
you know which possible dependency files are supposed to exist. 
*Note Catalogue of Rules::, for a catalogue of all the predefined
implicit rules.

Above, we said an implicit rule applies if the required dependencies
``exist or can be made''.  A file ``can be made'' if it is mentioned
explicitly in the makefile as a target or a dependency, or if an
implicit rule can be recursively found for how to make it.  When an
implicit dependency is the result of another implicit rule, we say
that "chaining" is occurring.  *Note Chained Rules::.

In general, `make' searches for an implicit rule for each target, and
for each double-colon rule, that has no commands.  A file that is
mentioned only as a dependency is considered a target whose rule
specifies nothing, so implicit rule search happens for it.  *Note
Search Algorithm::, for the details of how the search is done.

If you don't want an implicit rule to be used for a target that has
no commands, you can give that target empty commands by writing a
semicolon.  *Note Empty Commands::.



File: make-info,  Node: Catalogue of Rules,  Next: Implicit Variables,  Prev: Using Implicit,  Up: Implicit

Catalogue of Implicit Rules
===========================

Here is a catalogue of predefined implicit rules which are always
available unless the makefile explicitly overrides or cancels them. 
*Note Canceling Rules::, for information on canceling or overriding
an implicit rule.  The `-r' option cancels all predefined rules.

Not all of these rules will always be defined, even when the `-r'
option is not given.  Many of the predefined implicit rules are
implemented in `make' as suffix rules, so which ones will be defined
depends on the "suffix list" (the list of dependencies of the special
target `.SUFFIXES').  *Note Suffix Rules::.  The default suffix list
is: `.out', `.a', `.o', `.c', `.cc', `.p', `.f', `.F', `.r', `.e',
`.y', `.ye', `.yr', `.l', `.s', `.S', `.h', `.info', `.dvi', `.tex',
`.texinfo', `.cweb', `.web', `.sh', `.elc', `.el'. All of the
implicit rules described below whose dependencies have one of these
suffixes are actually suffix rules.  If you modify the suffix list,
the only predefined suffix rules in effect will be those named by one
or two of the suffixes that are on the list you specify; rules whose
suffixes fail to be on the list are disabled.

Compiling C programs
     `N.o' will be made automatically from `N.c' with a command of
     the form `$(CC) -c $(CPPFLAGS) $(CFLAGS)'.

Compiling C++ programs
     `N.o' will be made automatically from `N.cc' with a command of
     the form `$(C++) -c $(CPPFLAGS) $(C++FLAGS)'.  Although
     supported by the GNU C++ compiler, the suffix used by the AT&T
     C++ preprocessor, `.C', is not supported in `make' because we
     encourage the use of the preferred suffix for C++ files, `.cc'.

Compiling Pascal programs
     `N.o' will be made automatically from `N.p' with the command
     `$(PC) -c $(PFLAGS)'.

Compiling Fortran and Ratfor programs
     `N.o' will be made automatically from `N.r', `N.F' or `N.f' by
     running the Fortran compiler.  The precise command used is as
     follows:

    `.f'
          `$(FC) -c $(FFLAGS)'.

    `.F'
          `$(FC) -c $(FFLAGS) $(CPPFLAGS)'.

    `.r'
          `$(FC) -c $(FFLAGS) $(RFLAGS)'.

Preprocessing Fortran and Ratfor programs
     `N.f' will be made automatically from `N.r' or `N.F'.  This rule
     runs just the preprocessor to convert a Ratfor or preprocessable
     Fortran program into a strict Fortran program.  The precise
     command used is as follows:

    `.F'
          `$(FC) -F $(CPPFLAGS) $(FFLAGS)'.

    `.r'
          `$(FC) -F $(FFLAGS) $(RFLAGS)'.

Compiling Modula-2 programs
     `N.sym' will be made from `N.def' with a command of the form
     `$(M2C) $(M2FLAGS) $(DEFFLAGS)'.  `N.o' will be made from
     `N.mod' with a command of the form `$(M2C) $(M2FLAGS)
     $(MODFLAGS)'.

Assembling and preprocessing assembler programs
     `N.o' will be made automatically from `N.s' by running the
     assembler `as'.  The precise command used is `$(AS) $(ASFLAGS)'.

     `N.s' will be made automatically from `N.S' by running the C
     preprocessor `cpp'.  The precise command used is `$(CPP)
     $(CPPFLAGS)'.

Linking a single object file
     `N' will be made automatically from `N.o' by running the linker
     `ld' via the C compiler.  The precise command used is `$(CC)
     $(LDFLAGS) N.o $(LOADLIBES)'.

     This rule does the right thing for a simple program with only
     one source file.  It will also do the right thing if there are
     multiple object files (presumably coming from various other
     source files), the first of which has a name matching that of
     the executable file.  Thus,

          x: y.o z.o

     when `x.c', `y.c' and `z.c' all exist will execute:

          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o

     In more complicated cases, such as when there is no object file
     whose name derives from the executable file name, you must write
     an explicit command for linking.

     Each kind of file automatically made into `.o' object files will
     be automatically linked by using the compiler (`$(CC)', `$(FC)'
     or `$(PC)'; the C compiler `$(CC)' is used to assemble `.s'
     files) without the `-c' option.  This could be done by using the
     `.o' object files as intermediates, but it is faster to do the
     compiling and linking in one step, so that's how it's done.

Yacc for C programs
     `N.c' will be made automatically from `N.y' by running Yacc with
     the command `$(YACC) $(YFLAGS)'.

Lex for C programs
     `N.c' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

Lex for Ratfor programs
     `N.r' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

     The convention of using the same suffix `.l' for all Lex files
     regardless of whether they produce C code or Ratfor code makes
     it impossible for `make' to determine automatically which of the
     two languages you are using in any particular case.  If `make'
     is called upon to remake an object file from a `.l' file, it
     must guess which compiler to use.  It will guess the C compiler,
     because that is more common.  If you are using Ratfor, make sure
     `make' knows this by mentioning `N.r' in the makefile.  Or, if
     you are using Ratfor exclusively, with no C files, remove `.c'
     from the list of implicit rule suffixes with:

          .SUFFIXES:
          .SUFFIXES: .r .f .l ...

Making Lint Libraries from C, Yacc, or Lex programs
     `N.ln' will be made from `N.c' with a command of the form
     `$(LINT) $(LINTFLAGS) $(CPPFLAGS) -i'.  The same command will be
     used on the C code produced from `N.y' or `N.l'.

TeX and Web
     `N.dvi' will be made from `N.tex' with the command `$(TEX)'. 
     `N.tex' will be made from `N.web' with `$(WEAVE)', or from
     `N.cweb' with `$(CWEAVE)'.  `N.p' will be made from `N.web' with
     `$(TANGLE)' and `N.c' will be made from `N.cweb' with
     `$(CTANGLE)'.

Texinfo and Info
     `N.dvi' will be made from `N.texinfo' using the `$(TEX)' and
     `$(TEXINDEX)' commands.  The actual command sequence contains
     many shell conditionals to avoid unnecessarily running TeX twice
     and to create the proper sorted index files.  `N.info' will be
     made from `N.texinfo' with the command `$(MAKEINFO)'.

RCS
     Any file `N' will be extracted if necessary from an RCS file
     named either `N,v' or `RCS/N,v'.  The precise command used is
     `$(CO) $(COFLAGS)'.

SCCS
     Any file `N' will be extracted if necessary from an SCCS file
     named either `s.N' or `SCCS/s.N'.  The precise command used is
     `$(GET) $(GFLAGS)'.

     For the benefit of SCCS, a file `N' will be copied from `N.sh'
     and made executable (by everyone).  This is for shell scripts
     that are checked into SCCS.  Since RCS preserves the execution
     permission of a file, you don't need to use this feature with RCS.

     We recommend that you avoid the use of SCCS.  RCS is widely held
     to be superior, and is also free.  By choosing free software in
     place of comparable (or inferior) proprietary software, you
     support the free software movement.



File: make-info,  Node: Implicit Variables,  Next: Chained Rules,  Prev: Catalogue of Rules,  Up: Implicit

Variables Used by Implicit Rules
================================

The commands in built-in implicit rules make liberal use of certain
predefined variables.  You can alter these variables, either in the
makefile or with arguments to `make', to alter how the implicit rules
work without redefining the rules themselves.

For example, the command used to compile a C source file actually
says `$(CC) -c $(CFLAGS) $(CPPFLAGS)'.  The default values of the
variables used are `cc' and nothing, resulting in the command `cc
-c'.  By redefining `$(CC)' to `ncc', you could cause `ncc' to be
used for all C compilations performed by the implicit rule.  By
redefining `$(CFLAGS)' to be `-g', you could pass the `-g' option to
each compilation.  *All* implicit rules that do C compilation use
`$(CC)' to get the program name for the compiler and *all* include
`$(CFLAGS)' among the arguments given to the compiler.

The variables used in implicit rules fall into two classes: those
that are names of programs (like `CC') and those that contain
arguments for the programs (like `CFLAGS').  (The ``name of a
program'' may also contain some command arguments, but it must start
with an actual executable program name.)  If a variable value
contains more than one argument, separate them with spaces.

Here is a table of variables used as names of programs:

`AR'
     Archive-maintaing program; default `ar'.

`AS'
     Program for doing assembly; default `as'.

`CC'
     Program for compiling C programs; default `cc'.

`C++'
     Program for compiling C++ programs; default `g++'.

`CO'
     Program for extracting a file from RCS; default `co'.

`CPP'
     Program for running the C preprocessor, with results to standard
     output; default `$(CC) -E'.

`FC'
     Program for compiling or preprocessing Fortran, Ratfor, and EFL
     programs; default `f77'.

`GET'
     Program for extracting a file from SCCS; default `get'.

`LEX'
     Program to use to turn Lex grammars into C programs or Ratfor
     programs; default `lex'.

`PC'
     Program for compiling Pascal programs; default `pc'.

`FC'
`EC'
`RC'
     Programs for compiling Fortran, EFL, and Ratfor programs,
     respectively; these all default to `f77'.

`YACC'
     Program to use to turn Yacc grammars into C programs; default
     `yacc'.

`YACCR'
     Program to use to turn Yacc grammars into Ratfor programs;
     default `yacc -r'.

`YACCE'
     Program to use to turn Yacc grammars into EFL programs; default
     `yacc -e'.

`MAKEINFO'
     Program to make Info files from Texinfo source; default
     `makeinfo'.

`TEX'
     Program to make TeX DVI files from TeX or Texinfo source;
     default `tex'.

`TEXINDEX'
     The `texindex' program distributed with Emacs.  This is used in
     the process to make TeX DVI files from Texinfo source.

`WEAVE'
     Program to translate Web into TeX; default `weave'.

`CWEAVE'
     Program to translate C Web into TeX; default `cweave'.

`TANGLE'
     Program to translate Web into Pascal; default `tangle'.

`CTANGLE'
     Program to translate C Web into C; default `ctangle'.

`RM'
     Command to remove a file; default `rm -f'.  `make' does not use
     this variable for anything.

Here is a table of variables whose values are additional arguments
for the programs above.  The default values for all of these is the
empty string.

`ARFLAGS'
     Flags to give the archive- maintaining program; default `rv'.

`ASFLAGS'
     Extra flags to give to the assembler (when explicitly invoked on
     a `.s' file).

`CFLAGS'
     Extra flags to give to the C compiler.

`C++FLAGS'
     Extra flags to give to the C++ compiler.

`COFLAGS'
     Extra flags to give to the RCS `co' program.

`CPPFLAGS'
     Extra flags to give to the C preprocessor and programs that use
     it (the C and Fortran compilers).

`EFLAGS'
     Extra flags to give to the Fortran compiler for EFL programs.

`FFLAGS'
     Extra flags to give to the Fortran compiler.

`GFLAGS'
     Extra flags to give to the SCCS `get' program.

`LDFLAGS'
     Extra flags to give to compilers when they are supposed to
     invoke the linker, `ld'.

`LFLAGS'
     Extra flags to give to Lex.

`PFLAGS'
     Extra flags to give to the Pascal compiler.

`RFLAGS'
     Extra flags to give to the Fortran compiler for Ratfor programs.

`YFLAGS'
     Extra flags to give to Yacc.



File: make-info,  Node: Chained Rules,  Next: Pattern Rules,  Prev: Implicit Variables,  Up: Implicit

Chains of Implicit Rules
========================

Sometimes a file can be made by a sequence of implicit rules.  For
example, a file `N.o' could be made from `N.y' by running first Yacc
and then `cc'.  Such a sequence is called a "chain".

If the file `N.c' exists, or is mentioned in the makefile, no special
searching is required: `make' finds that the object file can be made
by C compilation from `N.c'; later on, when considering how to make
`N.c', the rule for running Yacc will be used.  Ultimately both `N.c'
and `N.o' are updated.

However, even if `N.c' does not exist and is not mentioned, `make'
knows how to envision it as the missing link between `N.o' and `N.y'!
In this case, `N.c' is called an "intermediate file".  Once `make'
has decided to use the intermediate file, it is entered in the data
base as if it had been mentioned in the makefile, along with the
implicit rule that says how to create it.

Intermediate files are remade using their rules just like all other
files.  The difference is that the intermediate file is deleted when
`make' is finished.  Therefore, the intermediate file which did not
exist before `make' also does not exist after `make'.  The deletion
is reported to you by printing a `rm -f' command that shows what
`make' is doing.  (You can optionally define an implicit rule so as
to preserve certain intermediate files.  You can also list the target
pattern of an implicit rule (such as `%.o') as a dependency file of
the special target `.PRECIOUS' to preserve intermediate files whose
target patterns match that file's name.)

A chain can involve more than two implicit rules.  For example, it is
possible to make a file `foo' from `RCS/foo.y,v' by running RCS, Yacc
and `cc'.  Then both `foo.y' and `foo.c' are intermediate files that
are deleted at the end.

No single implicit rule can appear more than once in a chain.  This
means that `make' will not even consider such a ridiculous thing as
making `foo' from `foo.o.o' by running the linker twice.  This
constraint has the added benefit of preventing any infinite loop in
the search for an implicit rule chain.

There are some special implicit rules to optimize certain cases that
would otherwise by handled by rule chains.  For example, making `foo'
from `foo.c' could be handled by compiling and linking with separate
chained rules, using `foo.o' as an intermediate file.  But what
actually happens is that a special rule for this case does the
compilation and linking with a single `cc' command.  The optimized
rule is used in preference to the step-by-step chain because it comes
earlier in the ordering of rules.



File: make-info,  Node: Pattern Rules,  Next: Last Resort,  Prev: Chained Rules,  Up: Implicit

Defining and Redefining Pattern Rules
=====================================

You define an implicit rule by writing a "pattern rule".  A pattern
rule looks like an ordinary rule, except that its target contains the
character `%' (exactly one of them).  The target is considered a
pattern for matching file names; the `%' can match any nonempty
substring, while other characters match only themselves.  The
dependencies likewise use `%' to show how their names relate to the
target name.

Thus, a pattern rule `%.o : %.c' says how to make any file `STEM.o'
from another file `STEM.c'.

* Menu:

* Intro: Pattern Intro.        Basics of writing pattern rules.
* Examples: Pattern Examples.  Real examples of pattern rule definitions.

* Vars: Automatic.             The automatic variables enable the commands
                                in pattern rules to act on the right files.

* Matching: Pattern Match.     Details of how patterns match.

* Match-Anything Rules::       Precautions in defining a rules that can
                                match any target file whatever.

* Canceling Rules::            Overriding or canceling built-in rules.

* Last Resort::                How to define a last-resort rule
                                that applies to any target that no other
                                rule applies to.

* Suffix Rules::               The old-fashioned way to define implicit rules.

 

File: make-info,  Node: Pattern Intro,  Next: Pattern Examples,  Prev: Pattern Rules,  Up: Pattern Rules

Introduction to Pattern Rules
-----------------------------

You define an implicit rule by writing a "pattern rule".  A pattern
rule looks like an ordinary rule, except that its target contains the
character `%' (exactly one of them).  The target is considered a
pattern for matching file names; the `%' can match any nonempty
substring, while other characters match only themselves.

For example, `%.c' as a pattern matches any file name that ends in
`.c'.  `s.%.c' as a pattern matches any file name that starts with
`s.', ends in `.c' and is at least five characters long.  (There must
be at least one character to match the `%'.)  The substring that the
`%' matches is called the "stem".

`%' in a dependency of a pattern rule stands for the same stem that
was matched by the `%' in the target.  In order for the pattern rule
to apply, its target pattern must match the file name under
consideration, and its dependency patterns must name files that exist
or can be made.  These files become dependencies of the target.

Thus, a rule of the form

     %.o : %.c

would specify how to make any file `N.o', with another file `N.c' as
its dependency, provided that the other file exists or can be made.

There may also be dependencies that do not use `%'; such a dependency
attaches to every file made by this pattern rule.  These unvarying
dependencies are useful occasionally.

It is allowed for a pattern rule to have no dependencies that contain
`%' or to have no dependencies at all.  This is effectively a general
wildcard.  It provides a way to make any file that matches the target
pattern.

Pattern rules may have more than one target.  Unlike normal rules,
this does not act as many different rules with the same dependencies
and commands.  If a pattern rule has multiple targets, `make' knows
that the rule's commands are responsible for making all of the
targets.  The commands are executed only once to make all of the
targets.  When searching for a pattern rule to match a target, the
target patterns of a rule other than the one that matches the target
in need of a rule are incidental: `make' worries only about giving
commands and dependencies to the file presently in question. 
However, when this file's commands are run, the other targets are
marked as having been updated themselves.

The order in which pattern rules appear in the makefile is important
because the rules are considered in that order.  Of equally
applicable rules, the first one found is used.  The rules you write
take precedence over those that are built in.  Note, however, that a
rule whose dependencies actually exist or are mentioned always takes
priority over a rule with dependencies that must be made by chaining
other implicit rules.



File: make-info,  Node: Pattern Examples,  Next: Automatic,  Prev: Pattern Intro,  Up: Pattern Rules

Pattern Rule Examples
---------------------

Here are some examples of pattern rules actually predefined in
`make'.  First, the rule that compiles `.c' files into `.o' files:

     %.o : %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

defines a rule that can make any file `X.o' from `X.c'.  The command
uses the automatic variables `$@' and `$<' to substitute the names of
the target file and the source file as they are in each case where
the rule applies (*note Automatic::.).

Here is a second built-in rule:

     % :: RCS/%,v
             $(CO) $(COFLAGS) $<

defines a rule that can make any file `X' whatever from a
corresponding file `X,v' in the subdirectory `RCS'.  Since the target
is `%', this rule will apply to any file whatever, provided the
appropriate dependency file exists.  The double colon makes the rule
"terminal", which means that its dependency may not be an
intermediate file (*note Match-Anything Rules::.).

This pattern rule has two targets:

     %.tab.c %.tab.h: %.y
             bison -d $<

This tells `make' that the command `bison -d X.y' will make both
`X.tab.c' and `X.tab.h'.  If the file `foo' depends on the files
`parse.tab.o' and `scan.o' and `scan.o' depends on `parse.tab.h',
when `parse.y' is changed, the command `bison -d parse.y' will be
executed only once, and the dependencies of both `parse.tab.o' and
`scan.o' will be satisfied.  (Presumably, `parse.tab.o' will be
recompiled from `parse.tab.c' and `scan.o' from `scan.c', and `foo'
will be linked from `parse.tab.o', `scan.o', and its other
dependencies, and it will execute happily ever after.)



File: make-info,  Node: Automatic,  Next: Pattern Match,  Prev: Pattern Examples,  Up: Pattern Rules

Automatic Variables
-------------------

Suppose you are writing a pattern rule to compile a `.c' file into a
`.o' file: how do you write the `cc' command so that it operates on
the right source file name?  You can't write the name in the command,
because the name is different each time the implicit rule is applied.

What you do is use a special feature of `make', the "automatic
variables".  These variables have values computed afresh for each
rule that is executed, based on the target and dependencies of the
rule.  In this example, you would use `$@' for the object file name
and `$<' for the source file name.

Here is a table of automatic variables:

`$@'
     The file name of the target of the rule.  If the target is an
     archive member, then `$@' is the name of the archive file.

`$%'
     The target member name, when the target is an archive member. 
     For example, if the target is `foo.a(bar.o)' then `$%' is
     `bar.o' and `$@' is `foo.a'.  `$%' is empty when the target is
     not an archive member.

`$<'
     The name of the first dependency.

`$?'
     The names of all the dependencies that are newer than the
     target, with spaces between them.

`$^'
     The names of all the dependencies, with spaces between them.

`$*'
     The stem with which an implicit rule matches (*note Pattern
     Match::.).  If the target is `dir/a.foo.b' and the target
     pattern is `a.%.b' then the stem is `dir/foo'.  The stem is
     useful for constructing names of related files.

     In an explicit rule, there is no stem; so `$*' cannot be
     determined in that way.  Instead, if the target name ends with a
     recognized suffix (*note Suffix Rules::.), `$*' is set to the
     target name minus the suffix.  For example, if the target name
     is `foo.c', then `$*' is set to `foo', since `.c' is a suffix.

     If the target name in an explicit rule does not end with a
     recognized suffix, `$*' is set to the empty string for that rule.

`$?' is useful even in explicit rules when you wish to operate on
only the dependencies that have changed.  For example, suppose that
an archive named `lib' is supposed to contain copies of several
object files.  This rule copies just the changed object files into
the archive:

     lib: foo.o bar.o lose.o win.o
             ar r lib $?

 Of the variables listed above, four have values that are single file
names, and two have values that are lists of file names.  These six
have variants that get just the file's directory name or just the
file name within the directory.  The variant variables' names are
formed by appending `D' or `F', respectively.  These variants are
semi-obsolete in GNU `make' since the functions `dir' and `notdir'
can be used to get an equivalent effect (*note Filename
Functions::.).  Here is a table of the variants:

`$(@D)'
     The directory part of the file name of the target.  If the value
     of `$@' is `dir/foo.o' then `$(@D)' is `dir/'.  This value is
     `./' if `$@' does not contain a slash.  `$(@D)' is equivalent to
     `$(dir $@)'.

`$(@F)'
     The file-within-directory part of the file name of the target. 
     If the value of `$@' is `dir/foo.o' then `$(@F)' is `foo.o'. 
     `$(@F)' is equivalent to `$(notdir $@)'.

`$(*D)'
`$(*F)'
     The directory part and the file-within-directory part of the
     stem; `dir/' and `foo' in this example.

`$(%D)'
`$(%F)'
     The directory part and the file-within-directory part of the
     target archive member name.  This makes sense only for archive
     member targets of the form `ARCHIVE(MEMBER)' and useful only
     when MEMBER may contain a directory name.  (*Note Archive
     Members::.)

`$(<D)'
`$(<F)'
     The directory part and the file-within-directory part of the
     first dependency.

`$(^D)'
`$(^F)'
     Lists of the directory parts and the file-within-directory parts
     of all dependencies.

`$(?D)'
`$(?F)'
     Lists of the directory parts and the file-within-directory parts
     of all dependencies that are out of date with respect to the
     target.

Note that we use a special stylistic convention when we talk about
these automatic variables; we write ``the value of `$<''', rather
than ``the variable `<''' as we would write for ordinary variables
such as `objects' and `CFLAGS'.  We think this convention looks more
natural in this special case.  Please don't assume it has a deep
significance; `$<' refers to the variable named `<' just as
`$(CFLAGS)' refers to the variable named `CFLAGS'.



File: make-info,  Node: Pattern Match,  Next: Match-Anything Rules,  Prev: Automatic,  Up: Pattern Rules

How Patterns Match
------------------

A target pattern is composed of a `%' between a prefix and a suffix,
either or both of which may be empty.  The pattern matches a file
name only if the file name starts with the prefix and ends with the
suffix, without overlap.  The text between the prefix and the suffix
is called the "stem".  Thus, when the pattern `%.o' matches the file
name `test.o', the stem is `test'.  The pattern rule dependencies are
turned into actual file names by substituting the stem for the
character `%'.  Thus, if in the same example one of the dependencies
is written as `%.c', it expands to `test.c'.

When the target pattern does not contain a slash (and usually it does
not), directory names in the file names are removed from the file
name before it is compared with the target prefix and suffix.  The
directory names, along with the slash that ends them, are added back
to the stem.  Thus, `e%t' does match the file name `src/eat', with
`src/a' as the stem.  When dependencies are turned into file names,
the directories from the stem are added at the front, while the rest
of the stem is substituted for the `%'.  The stem `src/a' with a
dependency pattern `c%r' gives the file name `src/car'.


