
This file contains context diffs between version 3.57 and 3.58 of GNU Make.
Differences in files generated by etags, ctags, TeX, and makeinfo have been
omitted.


diff -rc2 make-3.57/CHANGES make-3.58/CHANGES
*** make-3.57/CHANGES	Thu Sep 28 17:32:18 1989
--- make-3.58/CHANGES	Sun Dec 17 19:45:14 1989
***************
*** 2,5 ****
--- 2,9 ----
  ==========================================================================
  
+ Version 3.58
+ 
+ * Suffix rules may have dependencies (which are ignored).
+ 
  Version 3.57
  
***************
*** 26,32 ****
  * There is no longer a warning for using the `vpath' directive with an explicit
  pathname (instead of a `%' pattern).
- 
- * Variables defined by default are no longer put into the environment.
- This may help avoid E2BIG errors from execve.
  
  Version 3.51
--- 30,33 ----
diff -rc2 make-3.57/ChangeLog make-3.58/ChangeLog
*** make-3.57/ChangeLog	Fri Nov  3 19:31:28 1989
--- make-3.58/ChangeLog	Thu Feb  8 13:44:18 1990
***************
*** 1,2 ****
--- 1,227 ----
+ Thu Feb  8 13:43:44 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* Version 3.58.
+ 
+ Sat Feb  3 22:06:55 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* Version 3.57.7.
+ 
+ 	* make.texinfo (Implicit: Catalogue of Rules): For RCS, noted that
+ 	working files are never overwritten by the default rule.
+ 
+ Thu Feb  1 17:27:54 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* rule.c (count_implicit_rule_limits): Redid loop control to not run
+ 	twice on freed rules.
+ 
+ 	* GNUmakefile: Made `.dep' files be architecture-specific too.
+ 
+ 	* main.c (main, log_working_directory) [USG]: Block children around
+ 	calls to `getwd' (actually `getcwd' on USG), because that function
+ 	sometimes spawns a child running /bin/pwd on USG.
+ 
+ Tue Jan 30 14:02:50 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* function.c (subst_expand): Pay attention to SUFFIX_ONLY, putz.
+ 
+ Wed Jan 24 21:03:29 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* make.man: Fixed repeated word.
+ 
+ 	* make.texinfo (Missing): Reworded a buggy sentence.
+ 
+ Mon Jan 22 12:39:22 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* main.c (print_version): Added 1990 to copyright notice.
+ 
+ 	* Version 3.57.6.
+ 
+ Sat Jan 20 11:52:01 1990  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* file.c (rename_file): Don't free the storage for the old name, since
+ 	it might not have been malloc'd.
+ 
+ 	* job.c (construct_command_argv): Call
+ 	allocated_variable_expand_for_file instead of variable_expand_for_file
+ 	to expand `$(SHELL)'.
+ 
+ 	* make.texinfo (Bugs): Change address from roland@wheaties.ai.mit.edu
+ 	to roland@prep.ai.mit.edu.
+ 
+ Tue Jan 16 19:22:33 1990  Roland McGrath  (mcgrath at tully.Berkeley.EDU)
+ 
+ 	* Version 3.57.5.
+ 
+ Sun Jan 14 16:48:01 1990  Roland McGrath  (mcgrath at helen.Berkeley.EDU)
+ 
+ 	* job.c (start_job): Only call wait_to_start_job for the first command
+ 	line in each sequence.
+ 
+ Thu Jan  4 14:27:20 1990  Roland McGrath  (mcgrath at helen.Berkeley.EDU)
+ 
+ 	* load.c [LDAV_BASED] (wait_to_start_job): Loop while job_slots_used >
+ 	0, not > 1.
+ 
+ 	* job.c (search_path): Don't return a pointer to local storage.
+ 	Allocate data space for the pathname instead.
+ 
+ 	* function.c (expand_function: `shell'): Don't write garbage if the
+ 	child wrote no output.
+ 
+ Wed Jan  3 15:28:30 1990  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* Version 3.57.4.
+ 
+ 	* file.h (struct file): New member `renamed', a `struct file *' that is
+ 	the place this file has been renamed to (or nil).
+ 	(check_renamed): Macro to check for a file having been renamed.
+ 	Dereferences the renaming and sets the given variable.
+ 	* file.c (rename_file): Completely rewritten.  Renames in place if
+ 	possible, or moves FILE to a different hash bucket if there is no
+ 	existing file with the new name.  If there is an existing file with the
+ 	new name, FILE is merged into it and FILE->renamed is set to point to
+ 	it.
+ 	* variable.c (merge_variable_sets): New fn to merge two variable sets.
+ 	(merge_variable_set_lists): New fn to merge two variable set lists.
+ 	* variable.h: Declare merge_variable_set_lists.
+ 	* remake.c (update_file_1, check_dep): Run `check_renamed' after
+ 	calling file_mtime, check_dep.
+ 	(update_file): Same after update_file_1.
+ 	(update_goal_chain, update_file_1, check_dep): Same after update_file.
+ 
+ 	* read.c (uniquize_deps): New fn, broken out of record_files, to remove
+ 	duplicate deps from a chain.
+ 	(record_files): Use it.
+ 	* implicit.c (pattern_search): Use uniquize_deps.
+ 
+ 	* file.h (file_mtime_1): New macro, like file_mtime, but take second
+ 	arg, passed to f_mtime.
+ 	(file_mtime): Implement as file_mtime_1 (file, 1).
+ 	(file_mtime_no_search): New macro: file_mtime (file, 0).
+ 	* remake.c (f_mtime): Take new arg SEARCH.  Only do VPATH and `-lNAME'
+ 	searching if it is nonzero.
+ 	* main.c (main): Use file_mtime_no_search for makefiles.
+ 	* remake.c (update_goal_chain): Use file_mtime_no_search if MAKEFILES.
+ 
+ 	* main.c (printed_version): New variable, init'd to zero.
+ 	(print_version): Set it to nonzero before returning.
+ 	(die): If -v and !printed_version, call print_version before clean up
+ 	and death.
+ 
+ 	* main.c (log_working_directory): Keep track of whether or not the
+ 	"Entering" message has been printed, and return without printing the
+ 	"Leaving" message if not.
+ 
+ 	* main.c (decode_switches): Don't complain about missing args before
+ 	checking for a noarg_value elt in the command_switch structure.
+ 
+ Tue Jan  2 15:41:08 1990  Roland McGrath  (mcgrath at tully.Berkeley.EDU)
+ 
+ 	* make.texinfo (Commands: Recursion: Options/Recursion): Document
+ 	special case of -j.
+ 
+ 	* make.texinfo, main.c, job.c: Changed copyright notices to include
+ 	1990.
+ 
+ 	* make.texinfo (Top): Fixed introductory paragraph, which said that
+ 	`make' itself (instead of the manual) has various chapters.
+ 	(Variables: Advanced: Substitution Refs): When pxref'ing about
+ 	`patsubst', use node `Text Functions', not `Functions'.
+ 	Add an xref about `patsubst' after description of $(var:a%b=c%d).
+ 	(Functions: Syntax of Functions): Explain why mixing delimiters in
+ 	function/var refs is unwise.  Clarify fn arg evaluation order.
+ 	(Options): Reworded sentence about `-e'.
+ 	(Implicit: Implicit Variables): Don't say `RM' is unused.
+ 	Say the dflt values for the flag vars is empty unless otherwise noted,
+ 	since some have defaults.
+ 	(Implicit: Pattern Rules: Pattern Examples): Clarified use of $< and $@
+ 	in first example.
+ 	(Implicit: Last Resort): Don't say the .DEFAULT example creates files
+ 	"silently".  It's automatic, but not silent.
+ 	(Implicit: Search Algorithm): Fixed confusing ungrammatical sentence
+ 	for item 5.1.
+ 	(Archives: Archive Update): Added missing `next' pointer.
+ 	(Archives: Archive Symbols): Note that GNU `ar' deals with this
+ 	automatically.
+ 
+ 	* job.c (search_path): New fn, to search for an executable file in a
+ 	search path (broken out of exec_command).
+ 	(exec_command): Take fourth arg, the shell program to use (if
+ 	necessary).  Use search_path for the program, and the shell program.
+ 	Pass args "file args ..." to shell program (with no -c), where FILE is
+ 	the full pathname of the program (script) to be run.
+ 	(child_execute_job): Pass shell program to exec_command.
+ 	* main.c (main): Ditto.
+ 
+ 	* main.c (main): Don't write a message if exec_command returns, because
+ 	it will never return.
+ 
+ Fri Dec 22 16:19:58 1989  Roland McGrath  (mcgrath at hecuba.Berkeley.EDU)
+ 
+ 	* default.c (default_variables: "LINK.cc"): Use $(C++FLAGS) instead of
+ 	$(CFLAGS).
+ 
+ Wed Dec 20 09:58:48 1989  Roland McGrath  (mcgrath at hecuba.Berkeley.EDU)
+ 
+ 	* job.c (new_job): If start_job set the child's `command_state' to
+ 	`cs_finished', call notice_finished_file.
+ 
+ Sun Dec 17 19:45:41 1989  Roland McGrath  (mcgrath at hecuba.Berkeley.EDU)
+ 
+ 	* Version 3.57.3.
+ 
+ Wed Dec 13 17:57:12 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* rule.c (convert_to_pattern): Accept files with dependencies as
+ 	suffix rules.
+ 
+ Thu Nov 30 15:47:13 1989  Roland McGrath  (mcgrath at homer.Berkeley.EDU)
+ 
+ 	* Version 3.57.2.
+ 
+ 	* function.c (expand_function: `shell'): Don't clobber BUFFER and then
+ 	try to free it.
+ 
+ 	* remake.c (update_file_1): Took code to force remake of nonexistent
+ 	deps out of #if 0, and changed the test to nonexistent non-intermediate
+ 	deps.  In version 4, I think removing this test completely will
+ 	implement the new feature that if a: b and b: c and c is newer than a,
+ 	b need not be remade.
+ 
+ Sun Nov 26 16:12:41 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* compatMakefile (load.o, remote.o): Use $*.c instead of explicit file
+ 	names so that using VPATH works.
+ 
+ Tue Nov 21 14:57:18 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* Version 3.57.1.
+ 
+ Fri Nov 10 03:28:40 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* remake.c (check_dep): Set *MUST_MAKE_PTR if FILE does not exist after
+ 	being updated.  (The exact opposite test was here before; why???)
+ 	(update_file_1): Set a dep's `changed' member after updating it if it
+ 	is phony and has commands (because they will then always be executed).
+ 
+ Thu Nov  9 13:47:12 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
+ 
+ 	* load.c [UMAX]: #ifdef UMAX_43 include different headers for the
+ 	`inq_stats' call.
+ 	* compatMakefile (LOAD_AVG): Document UMAX_43.
+ 
+ 	* Version 3.57.0.
+ 
+ 	* commands.c (chop_commands): New function to chop commands into lines.
+ 	* job.c (new_job): Break that code out, and call chop_commands.
+ 	* remake.c (remake_file): Call chop_commands before looking at
+ 	FILE->cmds->any_recurse.
+ 
+ 	* make.texinfo (Running: Goals): Don't say that the default target
+ 	won't be taken from an included makefile.
+ 
+ 	* remake.c (update_file_1): #if 0 out setting MUST_MAKE if a dep
+ 	doesn't exist.
+ 
  Fri Nov  3 15:53:03 1989  Roland McGrath  (mcgrath at tully.Berkeley.EDU)
  
***************
*** 56,61 ****
  Sat Oct 14 10:43:03 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
- 	* ar.c (ar_member_date_1): Use ar_name_equal.
- 
  	* arscan.c (ar_scan): Cosmetic clean ups.
  	(ar_name_equal): New function to compare names, handling truncated
--- 281,284 ----
***************
*** 62,65 ****
--- 285,289 ----
  	member names and special `.o' truncation.
  	(ar_member_pos): Use ar_name_equal.
+ 	* ar.c (ar_member_date_1): Use ar_name_equal.
  
  	* Version 3.56.6.
***************
*** 68,72 ****
  	it before `command_state' so the bitfields can be packed better.
  
! 	* remake.c (notice_finished_file): Don't increment files_remade.
  	* job.c (new_job): Do.
  
--- 292,297 ----
  	it before `command_state' so the bitfields can be packed better.
  
! 	* remake.c (files_remade): Made global.
! 	(notice_finished_file): Don't increment files_remade.
  	* job.c (new_job): Do.
  
***************
*** 77,98 ****
  
  	* commands.c (chop_commands): Merged into job.c (new_job).
- 
  	* commands.h: Don't declare chop_commands.
  
  	* job.h: Don't declare start_job.  Do declare new_job.
- 
  	* commands.c (execute_file_commands): Call new_job.
  
- 	* job.c (free_child): New function to free a `struct child'.
- 	(child_handler, new_job): Call it.
- 
- 	* job.c (start_job): Made static.
- 	(new_job): New function to create a `struct child' and call start_job.
- 
  	* commands.c (execute_file_commands): Don't set FILE->update_status if
  	start_job fails.
  
- 	* remake.c (files_remade): Made global.
- 
  	* function.c (expand_function): Don't use `reading_filename' and
  	`reading_lineno_ptr' if they're nil.
--- 302,317 ----
  
  	* commands.c (chop_commands): Merged into job.c (new_job).
  	* commands.h: Don't declare chop_commands.
  
+ 	* job.c (start_job): Made static.
+ 	(new_job): New function to create a `struct child' and call start_job.
+ 	(free_child): New function to free a `struct child'.
+ 	(child_handler, new_job): Call it.
  	* job.h: Don't declare start_job.  Do declare new_job.
  	* commands.c (execute_file_commands): Call new_job.
  
  	* commands.c (execute_file_commands): Don't set FILE->update_status if
  	start_job fails.
  
  	* function.c (expand_function): Don't use `reading_filename' and
  	`reading_lineno_ptr' if they're nil.
***************
*** 159,163 ****
  	* job.c (child_handler): Call notice_finished_file after changing a
  	child's state to `cs_finished'.
- 
  	* remake.c (update_file_1): Don't call notice_finished_file if
  	FILE->command_state == cs_finished.
--- 378,381 ----
***************
*** 223,237 ****
  Thu Sep 21 14:28:42 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
- 	* main.c (main): Don't re-exec if a makefile was successfully updated
- 	but didn't change.
- 
  	* main.c (main): Make an array of the mtimes of the makefiles before
! 	updating them, and compare their file_mtimes against this later.
  
- 	* main.c (main): If a makefile failed to be remade and no longer
- 	exists, die.  If a makefile failed to be remade, but changed anyway,
- 	re-exec.  If a makefile failed to be remade, but is unchanged, continue
- 	on.
- 
  Wed Sep 20 18:02:07 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
--- 441,451 ----
  Thu Sep 21 14:28:42 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
  	* main.c (main): Make an array of the mtimes of the makefiles before
! 	updating them, and compare their file_mtimes against this later.  Don't
! 	re-exec if a makefile was successfully updated but didn't change.  If a
! 	makefile failed to be remade and no longer exists, die.  If a makefile
! 	failed to be remade, but changed anyway, re-exec.  If a makefile failed
! 	to be remade, but is unchanged, continue on.
  
  Wed Sep 20 18:02:07 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
***************
*** 276,304 ****
  Sun Sep 17 15:27:19 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
- 	* load.c, remake.c: Include job.h.
- 
- 	* file.c: Include variables.h.
- 
- 	* job.c: Declare dup2.
- 
- 	* job.c: Declare {block,unblock}_remote_children.
- 
- 	* file.h: Declare f_mtime.
- 
- 	* job.c: Don't declare construct_command_argv, since job.h does.
- 
- 	* function.c: Include job.h.
- 
  	* main.c (define_makeflags): Moved all the checking inside the switch.
  
- 	* main.c: Include job.h.
- 
  	* load.c [LDAV_BASED] (load_average): When we can't get the load
  	average, return zero instead of running off the end.
  
  	* load.c [LDAV_BASED] (load_average): Declare nlist.
- 
  	* variable.h: Declare print_file_variables.
- 
  	* job.c [!USG]: Don't declare sigsetmask.
  	[!USG]: Declare getdtablesize.
--- 490,505 ----
  Sun Sep 17 15:27:19 1989  Roland McGrath  (mcgrath at paris.Berkeley.EDU)
  
  	* main.c (define_makeflags): Moved all the checking inside the switch.
  
  	* load.c [LDAV_BASED] (load_average): When we can't get the load
  	average, return zero instead of running off the end.
  
+ 	* file.c: Include variables.h.
+ 	* job.c: Declare dup2 and {block,unblock}_remote_children.
+ 	* file.h: Declare f_mtime.
+ 	* job.c: Don't declare construct_command_argv, since job.h does.
+ 	* function.c, main.c, load.c, remake.c: Include job.h.
  	* load.c [LDAV_BASED] (load_average): Declare nlist.
  	* variable.h: Declare print_file_variables.
  	* job.c [!USG]: Don't declare sigsetmask.
  	[!USG]: Declare getdtablesize.
***************
*** 305,316 ****
  	Don't declare load_average.  Do declare wait_to_start_job.
  	Declare vfork, gete[gu]id, execve.
- 
  	* commands.c: Declare remote_kill, getpid.
- 
  	* make.h: Declare kill, exit, sigblock, pipe, close, ctime, open,
  	lseek, read.
- 
  	* make.h [not USG]: Declare sigsetmask.
- 
  	* job.h: Declare wait_for_children and {block,unblock}_children.
  
--- 506,513 ----
***************
*** 354,363 ****
  	* make.texinfo (Running: Options): Document -e.
  
  	* variable.c (define_variable_in_set): Under -e, if ORIGIN, or an
  	existing variable's origin, is `o_env', make it `o_env_override'.
  
- 	* main.c (main): Always give imported environment variables origin
- 	`o_env'.
- 
  	* load.c: Use the symbol KERNEL_FILE_NAME instead of KERNEL_FILE.
  	* compatMakefile: Changed the comment for `LOAD_AVG' accordinly.
--- 551,559 ----
  	* make.texinfo (Running: Options): Document -e.
  
+ 	* main.c (main): Always give imported environment variables origin
+ 	`o_env'.
  	* variable.c (define_variable_in_set): Under -e, if ORIGIN, or an
  	existing variable's origin, is `o_env', make it `o_env_override'.
  
  	* load.c: Use the symbol KERNEL_FILE_NAME instead of KERNEL_FILE.
  	* compatMakefile: Changed the comment for `LOAD_AVG' accordinly.
***************
*** 367,375 ****
  	* Version 3.55.2 (alpha).
  
- 	* compatMakefile (defines): Document NO_FLOAT.
- 
  	* variable.c (print_variable_set), rule.c (print_rule_data_base),
  	file.c (print_file_data_base): If NO_FLOAT is defined, don't use
  	floating-point for printing statistics.
  
  	* make.h (HASH): New macro to add the hashing value of one char to a
--- 563,570 ----
  	* Version 3.55.2 (alpha).
  
  	* variable.c (print_variable_set), rule.c (print_rule_data_base),
  	file.c (print_file_data_base): If NO_FLOAT is defined, don't use
  	floating-point for printing statistics.
+ 	* compatMakefile (defines): Document NO_FLOAT.
  
  	* make.h (HASH): New macro to add the hashing value of one char to a
***************
*** 385,389 ****
  	(ARCHIVES, ARCHIVES_SRC): New variables for {ar,arscan}.[oc].
  	(objs, srcs): Use $(ARCHIVES) and $(ARCHIVES_SRC).
- 
  	* commands.c (set_file_variables), dir.c (file_exists_p),
  	remake.c (touch_file, name_mtime), implicit.c (try_implicit_rule,
--- 580,583 ----
***************
*** 406,410 ****
  
  	* load.c [LDAV_BASED] (load_average): Check for == -1, rather than < 0
! 	to seek if lseek fails.  On some systems, `avenrun' is at an offset >
  	(2**31)-1, and lseek succeeds, returning a negative value.
  
--- 600,604 ----
  
  	* load.c [LDAV_BASED] (load_average): Check for == -1, rather than < 0
! 	to see if lseek fails.  On some systems, `avenrun' is at an offset >
  	(2**31)-1, and lseek succeeds, returning a negative value.
  
***************
*** 436,448 ****
  	* main.c (main): Do it here, before calling update_goal_chain.
  
- 	* remake.c (notice_finished_file): Don't return a value.
- 	(update_file_1, remake_file): Don't expect one.
- 	* commands.c (execute_file_commands): Same.
- 	* make.h: Declare notice_finished_file void rather than int.
- 
- 	* commands.c (execute_file_commands): Don't return a value.
- 	* remake.c (remake_file): Don't expect one.
- 	* commands.h: Declare execute_file_commands void rather than int.
- 
  	* remake.c (update_goal_chain): When updating fails, change STATUS even
  	if MAKEFILES is set.  Also stop remaking when updating fails if not
--- 630,633 ----
***************
*** 449,455 ****
  	under -k and MAKEFILES is not set.
  
! 	* remake.c: Declare remake_file as void instead of int.
! 	(remake_file): Don't return a value.
! 	(update_file_1): Don't expect one.
  
  	* remake.c (notice_finished_file): Don't set FILE's modtime to now if
--- 634,641 ----
  	under -k and MAKEFILES is not set.
  
! 	* remake.c (remake_file, update_file_1, notice_finished_file),
! 	commands.c (execute_file_commands), make.h, commands.h: The functions
! 	remake_file, notice_finished_file, and execute_file_commands no longer
! 	return values, and their callers no longer expect values returned.
  
  	* remake.c (notice_finished_file): Don't set FILE's modtime to now if
***************
*** 497,510 ****
  	since the <a.out.h> declaration uses the union.
  
- 	* file.c (remove_intermediates): Don't print any messages for files
- 	whose `dontcare' flag is set.
- 
  	* main.c (main): For the temporary files made for stdin makefiles, set
  	the `intermediate' and `dontcare' flags.
  
- 	* main.c (main): Use exec_command when re-execing.
- 
  	* job.c (exec_command): Made global.
  	* job.h: Declare it.
  
  	* make.h: Declare environ.
--- 683,696 ----
  	since the <a.out.h> declaration uses the union.
  
  	* main.c (main): For the temporary files made for stdin makefiles, set
  	the `intermediate' and `dontcare' flags.
+ 	* file.c (remove_intermediates): Don't print any messages for files
+ 	whose `dontcare' flag is set.  (The only files that will be
+ 	intermediate and `dontcare' will be the temporary files made for stdin
+ 	makefiles.)
  
  	* job.c (exec_command): Made global.
  	* job.h: Declare it.
+ 	* main.c (main): Use exec_command when re-execing.
  
  	* make.h: Declare environ.
***************
*** 511,521 ****
  	* make.c: Don't.
  
- 	* function.c (expand_function: `shell'): Use child_execute_job.
- 
- 	* job.h: Declare construct_command_argv and child_execute_job.
- 
  	* job.c (child_execute_job): New function to perform everything done in
  	the child side of a fork (for a job or `shell' function).
  	(start_job): Call it.
  
  Thu Aug 31 18:42:51 1989  Roland McGrath  (mcgrath at saffron.Berkeley.EDU)
--- 697,705 ----
  	* make.c: Don't.
  
  	* job.c (child_execute_job): New function to perform everything done in
  	the child side of a fork (for a job or `shell' function).
  	(start_job): Call it.
+ 	* job.h: Declare construct_command_argv and child_execute_job.
+ 	* function.c (expand_function: `shell'): Use child_execute_job.
  
  Thu Aug 31 18:42:51 1989  Roland McGrath  (mcgrath at saffron.Berkeley.EDU)
***************
*** 537,541 ****
  	* make.texinfo (Rules: Multiple Targets): Make this node's `next'
  	pointer point to `Static Pattern'.
- 
  	* make.texinfo (Makefiles: MAKEFILES Variable): Make this node's `prev'
  	pointer point to `Makefile Names'.
--- 721,724 ----
***************
*** 542,546 ****
  
  	* make.1: Renamed to make.man.
- 
  	* compatMakefile: Define `mandir' and `manext'.
  	(install): Depend on $(mandir)/make.$(manext).
--- 725,728 ----
***************
*** 560,571 ****
  Tue Aug 22 04:14:29 1989  Roland McGrath  (roland at hobbes.ai.mit.edu)
  
! 	* GNUmakefile (make-$(version).tar.Z): Put make.1 in the tar file.
  
  	* make.texinfo (Commands: Recursion: Variables/Recursion): Document
  	that default variables are not put in the environment.
  
- 	* variable.c (target_environment): Don't write variables with origin
- 	o_default (i.e., ones from default.c).
- 
  	* remake.c (update_file_1): Remake all targets with commands but no
  	deps.
--- 742,753 ----
  Tue Aug 22 04:14:29 1989  Roland McGrath  (roland at hobbes.ai.mit.edu)
  
! 	* GNUmakefile (make-$(version).tar.Z): Put make.1 (the Unix manual
! 	page) in the tar file.
  
+ 	* variable.c (target_environment): Don't write variables with origin
+ 	o_default (i.e., ones from default.c).
  	* make.texinfo (Commands: Recursion: Variables/Recursion): Document
  	that default variables are not put in the environment.
  
  	* remake.c (update_file_1): Remake all targets with commands but no
  	deps.
***************
*** 609,613 ****
  	made) and set the deps' `changed' members.  Do not set the `changed'
  	members in the loop that prints the newer/older debugging messages.
- 
  	* remake.c (update_file_1): If no deps changed and FILE has no
  	commands, decide it doesn't need remaking.
--- 791,794 ----
***************
*** 616,622 ****
  	commands from default_file.
  
- 	* make.texinfo (Makefiles: Remaking Makefiles): Document that makefiles
- 	will not be remade if they are targets but have no dependencies.
- 
  	* make.texinfo (Rules: Directory Search: Selective Search): Removed
  	note about warning for `vpath' with a constant pathname, since it isn't
--- 797,800 ----
***************
*** 625,628 ****
--- 803,808 ----
  	* remake.c (update_goal_chain): If MAKEFILES, remove makefiles which
  	are targets and have no deps.
+ 	* make.texinfo (Makefiles: Remaking Makefiles): Document that makefiles
+ 	will not be remade if they are targets but have no dependencies.
  
  Tue Aug 15 00:00:08 1989  Roland McGrath  (roland at apple-gunkies.ai.mit.edu)
***************
*** 656,678 ****
  	(construct_vpath_list): Call find_percent on the pattern and set the
  	new `percent' member.
- 
- 	* rule.c (convert_to_pattern): Pass new arg to create_pattern_rule.
- 	(create_pattern_rule): Take new arg TARGET_PERCENTS, nil or an array of
- 	pointers into the corresponding elements of TARGETS, where the %s are.
- 
  	* read.c (read_makefile): Don't run find_percent on `vpath' directive
  	patterns.
  
  	* read.c (record_files): Pass PATTERN_PERCENT to pattern_matches for
  	static pattern rules.  Save the percent pointer into implicit rule
  	targets, and pass them to create_pattern_rule.
  
- 	* function.c (expand_function: `filter', `filter-out'): Pass new arg to
- 	pattern_matches.
- 
- 	* funciton.c (pattern_matches): Take new arg PERCENT, a pointer into
- 	PATTERN where the % is.  If PERCENT is nil, copy PATTERN into local
- 	space and run find_percent on it.
- 
  Sun Aug 13 00:29:19 1989  Roland McGrath  (roland at hobbes.ai.mit.edu)
  
--- 836,854 ----
  	(construct_vpath_list): Call find_percent on the pattern and set the
  	new `percent' member.
  	* read.c (read_makefile): Don't run find_percent on `vpath' directive
  	patterns.
  
+ 	* function.c (pattern_matches): Take new arg PERCENT, a pointer into
+ 	PATTERN where the % is.  If PERCENT is nil, copy PATTERN into local
+ 	space and run find_percent on it.
+ 	(expand_function: `filter', `filter-out'): Pass new arg to
+ 	pattern_matches.
  	* read.c (record_files): Pass PATTERN_PERCENT to pattern_matches for
  	static pattern rules.  Save the percent pointer into implicit rule
  	targets, and pass them to create_pattern_rule.
+ 	* rule.c (convert_to_pattern): Pass new arg to create_pattern_rule.
+ 	(create_pattern_rule): Take new arg TARGET_PERCENTS, nil or an array of
+ 	pointers into the corresponding elements of TARGETS, where the %s are.
  
  Sun Aug 13 00:29:19 1989  Roland McGrath  (roland at hobbes.ai.mit.edu)
  
***************
*** 3430,3435 ****
  
  	* rule.c (pattern_search): Made it reject nonterminal match-anything
! 	rules in as intermediate targets when searching for both real and
! 	intermediate dependencies, rather than only for intermediate ones.
  
  Sun Jul 31 00:33:56 1988  Roland McGrath  (mcgrath at tully.Berkeley.EDU)
--- 3606,3612 ----
  
  	* rule.c (pattern_search): Made it reject nonterminal match-anything
! 	rules as intermediate targets when searching for both real and
! 	intermediate dependencies, rather than only when searching for
! 	intermediate ones.
  
  Sun Jul 31 00:33:56 1988  Roland McGrath  (mcgrath at tully.Berkeley.EDU)
diff -rc2 make-3.57/Makefile make-3.58/Makefile
*** make-3.57/Makefile	Fri Nov  3 19:32:53 1989
--- make-3.58/Makefile	Sat Feb  3 22:18:43 1990
***************
*** 35,41 ****
  defines =
  
! # Define UMAX here to use Encore's inq_stats call.  If the load average is in a
! # symbol in /dev/kmem, define KERNEL_FILE_NAME if not "/vmunix", LDAV_SYMBOL if
! # not "_avenrun", LDAV_TYPE if not `long int', and LDAV_CVT to convert the
  # LDAV_TYPE value from LDAV_SYMBOL (in `load') to a double if this is not
  # "(double) load".  If a `struct nlist' (as defined in <nlist.h>) has a `n_un'
--- 35,42 ----
  defines =
  
! # Define UMAX here to use Encore's inq_stats call.  Define UMAX_43 (and UMAX)
! # if you have UMAX 4.3 instead of UMAX 4.2.  If the load average is in a symbol
! # in /dev/kmem, define KERNEL_FILE_NAME if not "/vmunix", LDAV_SYMBOL if not
! # "_avenrun", LDAV_TYPE if not `long int', and LDAV_CVT to convert the
  # LDAV_TYPE value from LDAV_SYMBOL (in `load') to a double if this is not
  # "(double) load".  If a `struct nlist' (as defined in <nlist.h>) has a `n_un'
***************
*** 110,116 ****
  
  load.o: load.c
! 	$(CC) $(CFLAGS) $(LOAD_AVG) -c load.c
  remote.o: remote.c
! 	$(CC) $(CFLAGS) $(REMOTE) -c remote.c
  
  TAGS: $(srcs)
--- 111,117 ----
  
  load.o: load.c
! 	$(CC) $(CFLAGS) $(LOAD_AVG) -c $*.c
  remote.o: remote.c
! 	$(CC) $(CFLAGS) $(REMOTE) -c $*.c
  
  TAGS: $(srcs)
diff -rc2 make-3.57/README make-3.58/README
*** make-3.57/README	Fri Nov  3 19:32:29 1989
--- make-3.58/README	Thu Feb  8 13:45:19 1990
***************
*** 1,3 ****
! This directory contains the 3.57 test release of GNU Make.
  All bugs reported for previous test releases have been fixed.
  Some bugs probably remain.
--- 1,3 ----
! This directory contains the 3.58 test release of GNU Make.
  All bugs reported for previous test releases have been fixed.
  Some bugs probably remain.
diff -rc2 make-3.57/commands.c make-3.58/commands.c
*** make-3.57/commands.c	Fri Nov  3 16:34:18 1989
--- make-3.58/commands.c	Thu Nov  9 15:08:20 1989
***************
*** 218,223 ****
--- 218,300 ----
  #undef	DEFINE_VARIABLE
  }
+ 
+ /* Chop CMDS up into individual command lines if necessary.  */
  
+ void
+ chop_commands (cmds)
+      register struct commands *cmds;
+ {
+   if (cmds != 0 && cmds->command_lines == 0)
+     {
+       /* Chop CMDS->commands up into lines in CMDS->command_lines.
+ 	 Also set the corresponding CMDS->lines_recurse elements,
+ 	 and the CMDS->any_recurse flag.  */
+       register char *p;
+       unsigned int nlines, idx;
+       char **lines;
  
+       nlines = 5;
+       lines = (char **) xmalloc (5 * sizeof (char *));
+       idx = 0;
+       p = cmds->commands;
+       while (*p != '\0')
+ 	{
+ 	  char *end = p;
+ 	find_end:;
+ 	  end = index (end, '\n');
+ 	  if (end == 0)
+ 	    end = p + strlen (p);
+ 	  else if (end > p && end[-1] == '\\')
+ 	    {
+ 	      int backslash = 1;
+ 	      register char *b;
+ 	      for (b = end - 2; b >= p && *b == '\\'; --b)
+ 		backslash = !backslash;
+ 	      if (backslash)
+ 		{
+ 		  ++end;
+ 		  goto find_end;
+ 		}
+ 	    }
+ 
+ 	  if (idx == nlines - 1)
+ 	    {
+ 	      nlines += 2;
+ 	      lines = (char **) xrealloc ((char *) lines,
+ 					  nlines * sizeof (char *));
+ 	    }
+ 	  lines[idx++] = savestring (p, end - p);
+ 	  p = end;
+ 	  if (*p != '\0')
+ 	    ++p;
+ 	}
+       lines[idx++] = 0;
+ 
+       if (idx != nlines)
+ 	{
+ 	  nlines = idx;
+ 	  lines = (char **) xrealloc ((char *) lines,
+ 				      nlines * sizeof (char *));
+ 	}
+ 
+       cmds->command_lines = lines;
+ 
+       cmds->any_recurse = 0;
+       --nlines;
+       cmds->lines_recurse = (char *) xmalloc (nlines);
+       for (idx = 0; idx < nlines; ++idx)
+ 	{
+ 	  unsigned int len;
+ 	  int recursive;
+ 	  p = lines[idx];
+ 	  len = strlen (p);
+ 	  recursive = (sindex (p, len, "$(MAKE)", 7) != 0
+ 		       || sindex (p, len, "${MAKE}", 7) != 0);
+ 	  cmds->lines_recurse[idx] = recursive;
+ 	  cmds->any_recurse |= recursive;
+ 	}
+     }
+ }
+ 
  /* Execute the commands to remake FILE.  If they are currently executing,
     return or have already finished executing, just return.  Otherwise,
diff -rc2 make-3.57/default.c make-3.58/default.c
*** make-3.57/default.c	Wed Sep  6 16:09:31 1989
--- make-3.58/default.c	Fri Dec 22 16:42:47 1989
***************
*** 213,217 ****
      "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
      "COMPILE.cc", "$(C++) $(C++FLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
!     "LINK.cc", "$(C++) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
      "YACC.y", "$(YACC) $(YFLAGS)",
      "LEX.l", "$(LEX) $(LFLAGS) -t",
--- 213,217 ----
      "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
      "COMPILE.cc", "$(C++) $(C++FLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
!     "LINK.cc", "$(C++) $(C++FLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
      "YACC.y", "$(YACC) $(YFLAGS)",
      "LEX.l", "$(LEX) $(LFLAGS) -t",
diff -rc2 make-3.57/file.c make-3.58/file.c
*** make-3.57/file.c	Mon Sep 18 17:16:20 1989
--- make-3.58/file.c	Sat Jan 20 15:26:36 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 114,119 ****
  }
  
! /* Rename FILE to NAME.  This is not as simple as resetting the `name'
!    member, since it must be put in a new hash bucket.  */
  
  void
--- 114,120 ----
  }
  
! /* Rename FILE to NAME.  This is not as simple as resetting
!    the `name' member, since it must be put in a new hash bucket,
!    and possibly merged with an existing file called NAME.  */
  
  void
***************
*** 122,190 ****
       char *name;
  {
!   register unsigned int hashval;
    register char *n;
!   register struct file *lastf, *f;
    struct file *oldfile;
  
!   /* Remove FILE from its hash bucket.  */
  
!   hashval = 0;
!   for (n = file->name; *n != '\0'; ++n)
!     HASH (hashval, *n);
!   hashval %= FILE_BUCKETS;
  
!   lastf = 0;
!   f = files[hashval];
!   while (f != file)
      {
!       lastf = f;
!       f = f->next;
!     }
  
!   if (lastf == 0)
!     files[hashval] = f->next;
!   else
!     lastf->next = f->next;
  
  
!   /* Rename FILE and put it in its new hash bucket.  */
  
!   hashval = 0;
!   for (n = name; *n != '\0'; ++n)
!     HASH (hashval, *n);
!   hashval %= FILE_BUCKETS;
  
!   lastf = 0;
!   oldfile = files[hashval];
!   while (oldfile != 0)
      {
!       if (streq (oldfile->name, name))
! 	break;
!       lastf = oldfile;
!       oldfile = oldfile->next;
      }
  
!   if (oldfile != 0)
!     /* There was already a file with that name.  */
!     if ((oldfile->deps != 0 && file->deps != 0)
! 	|| (oldfile->cmds != 0 && file->cmds != 0))
!       {
! 	error ("rename_file loses %s.  Goodbye, cruel world.", name);
! 	abort ();
!       }
!     else
!       {
! 	if (lastf == 0)
! 	  files[hashval] = oldfile->next;
! 	else
! 	  lastf->next = oldfile->next;
! 	free (oldfile->name);
! 	free ((char *) oldfile);
!       }
  
!   free (file->name);
!   file->name = name;
!   file->next = files[hashval];
!   files[hashval] = file;
  }
  
--- 123,244 ----
       char *name;
  {
!   char *oldname = file->name;
!   register unsigned int oldhash, newhash;
    register char *n;
!   register struct file *f;
    struct file *oldfile;
  
!   /* Find the hash values of the old and new names.  */
  
!   oldhash = 0;
!   for (n = oldname; *n != '\0'; ++n)
!     HASH (oldhash, *n);
!   oldhash %= FILE_BUCKETS;
  
!   newhash = 0;
!   for (n = name; *n != '\0'; ++n)
!     HASH (newhash, *n);
!   newhash %= FILE_BUCKETS;
! 
!   /* Look for an existing file under the new name.  */
! 
!   for (oldfile = files[newhash]; oldfile != 0; oldfile = oldfile->next)
!     if (streq (oldfile->name, name))
!       break;
! 
!   if (newhash != oldhash || oldfile != 0)
      {
!       /* Remove FILE from its hash bucket.  */
  
!       struct file *lastf = 0;
  
+       for (f = files[oldhash]; f != file; f = f->next)
+ 	lastf = f;
  
!       if (lastf == 0)
! 	files[oldhash] = f->next;
!       else
! 	lastf->next = f->next;
!     }
  
!   /* Give FILE its new name.  */
  
!   for (f = file; f != 0; f = f->prev)
!     f->name = name;
! 
!   if (oldfile == 0)
      {
!       /* There is no existing file with the new name.  */
! 
!       if (newhash != oldhash)
! 	{
! 	  /* Put FILE in its new hash bucket.  */
! 	  file->next = files[newhash];
! 	  files[newhash] = file;
! 	}
      }
+   else
+     {
+       /* There is an existing file with the new name.
+ 	 We must merge FILE into the existing file.  */
  
!       register struct dep *d;
  
!       if (file->cmds != 0)
! 	{
! 	  if (oldfile->cmds == 0)
! 	    oldfile->cmds = file->cmds;
! 	  else
! 	    {
! 	      /* We have two sets of commands.  We will go with the
! 		 one given in the rule explicitly mentioning this name,
! 		 but give a message to let the user know what's going on.  */
! 	      error ("%s:%u: commands were specified for file `%s' at %s:%u",
! 		     file->cmds->filename, file->cmds->lineno,
! 		     oldname, oldfile->cmds->filename, oldfile->cmds->lineno);
! 	      error ("%s:%u: but `%s' is now considered the same file as `%s'",
! 		     file->cmds->filename, file->cmds->lineno,
! 		     oldname, name);
! 	      error ("%s:%u: commands for `%s' will be ignored \
! in favor of those for `%s",
! 		     file->cmds->filename, file->cmds->lineno,
! 		     name, oldname);
! 	    }
! 	}
! 
!       /* Merge the dependencies of the two files.  */
! 
!       d = oldfile->deps;
!       if (d == 0)
! 	oldfile->deps = file->deps;
!       else
! 	{
! 	  while (d->next != 0)
! 	    d = d->next;
! 	  d->next = file->deps;
! 	  uniquize_deps (oldfile->deps);
! 	}
! 
!       merge_variable_set_lists (&oldfile->variables, file->variables);
! 
!       if (oldfile->double_colon && !file->double_colon)
! 	fatal ("can't rename single-colon `%s' to double-colon `%s'",
! 	       oldname, name);
!       if (!oldfile->double_colon && file->double_colon)
! 	fatal ("can't rename double-colon `%s' to single-colon `%s'",
! 	       oldname, name);
! 
! #define MERGE(field) oldfile->field |= file->field
!       MERGE (precious);
!       MERGE (tried_implicit);
!       MERGE (updating);
!       MERGE (updated);
!       MERGE (is_target);
!       MERGE (cmd_target);
!       MERGE (phony);
! #undef MERGE
! 
!       file->renamed = oldfile;
!     }
  }
  
diff -rc2 make-3.57/file.h make-3.58/file.h
*** make-3.57/file.h	Sat Oct 14 12:21:12 1989
--- make-3.58/file.h	Wed Jan  3 20:51:08 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 35,38 ****
--- 35,42 ----
  				   entries for the same file.  */
  
+     /* File that this file was renamed to.  After any time that a
+        file could be renamed, call `check_renamed' (below).  */
+     struct file *renamed;
+ 
      /* List of variable sets used for this file.  */
      struct variable_set_list *variables;
***************
*** 83,86 ****
  
  extern time_t f_mtime ();
! #define file_mtime(f) \
!   ((f)->last_mtime != (time_t) 0 ? (f)->last_mtime : f_mtime (f))
--- 87,96 ----
  
  extern time_t f_mtime ();
! #define file_mtime_1(f, v) \
!   ((f)->last_mtime != (time_t) 0 ? (f)->last_mtime : f_mtime ((f), v))
! #define file_mtime(f) file_mtime_1 ((f), 1)
! #define file_mtime_no_search(f) file_mtime_1 ((f), 0)
! 
! 
! #define check_renamed(file) \
!   while ((file)->renamed != 0) (file) = (file)->renamed /* No ; here.  */
diff -rc2 make-3.57/function.c make-3.58/function.c
*** make-3.57/function.c	Sat Oct 14 10:44:41 1989
--- make-3.58/function.c	Tue Jan 30 14:04:07 1990
***************
*** 62,69 ****
  
        /* If we're substituting only by fully matched words,
! 	 check if this is one.  */
!       if (by_word
! 	  && ((p > t && p[-1] != ' ' && p[-1] != '\t')
! 	      || (p[slen] != '\0' && p[slen] != ' ' && p[slen] != '\t')))
  	/* Struck out.  Output the rest of the string that is
  	   no longer to be replaced.  */
--- 62,71 ----
  
        /* If we're substituting only by fully matched words,
! 	 or only at the ends of words, check that this case qualifies.  */
!       if ((by_word
! 	   && ((p > t && p[-1] != ' ' && p[-1] != '\t')
! 	       || (p[slen] != '\0' && p[slen] != ' ' && p[slen] != '\t'))
! 	   || (suffix_only
! 	       && (p[slen] != '\0' && p[slen] != ' ' && p[slen] != '\t'))))
  	/* Struck out.  Output the rest of the string that is
  	   no longer to be replaced.  */
***************
*** 415,423 ****
  		   newlines in its output with spaces, and put
  		   that in the variable output buffer.  */
! 		if (i > 0 && buffer[i - 1] == '\n')
! 		  buffer[--i] = '\0';
! 		for (p = buffer; (p = index (buffer, '\n')) != 0; buffer = ++p)
! 		  *p = ' ';
! 		o = variable_buffer_output (o, buffer, i);
  	      }
  
--- 417,429 ----
  		   newlines in its output with spaces, and put
  		   that in the variable output buffer.  */
! 		if (i > 0)
! 		  {
! 		    if (buffer[i - 1] == '\n')
! 		      buffer[--i] = '\0';
! 		    p = buffer;
! 		    while ((p = index (p, '\n')) != 0)
! 		      *p++ = ' ';
! 		    o = variable_buffer_output (o, buffer, i);
! 		  }
  	      }
  
diff -rc2 make-3.57/implicit.c make-3.58/implicit.c
*** make-3.57/implicit.c	Wed Sep 20 18:06:03 1989
--- make-3.58/implicit.c	Wed Jan  3 20:53:26 1990
***************
*** 1,4 ****
  /* Implicit rule searching for GNU Make.
! Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,4 ----
  /* Implicit rule searching for GNU Make.
! Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 525,539 ****
        dep->next = file->deps;
        file->deps = dep;
- 
-       /* If the new dependency duplicates an old one, delete the old one.  */
-       while (dep != 0)
- 	{
- 	  if (dep->next != 0 && streq (dep_name (dep->next), s))
- 	    dep->next = dep->next->next;
- 	  else
- 	    dep = dep->next;
- 	}
      }
   
    if (!checked_lastslash[foundrule])
      file->stem = stem[stemlen] == '\0' ? stem : savestring (stem, stemlen);
--- 525,532 ----
        dep->next = file->deps;
        file->deps = dep;
      }
   
+   uniquize_deps (file->deps);
+ 
    if (!checked_lastslash[foundrule])
      file->stem = stem[stemlen] == '\0' ? stem : savestring (stem, stemlen);
diff -rc2 make-3.57/job.c make-3.58/job.c
*** make-3.57/job.c	Tue Oct 24 19:38:09 1989
--- make-3.58/job.c	Sat Jan 20 12:21:05 1990
***************
*** 1,4 ****
  /* Job execution and handling for GNU Make.
! Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,4 ----
  /* Job execution and handling for GNU Make.
! Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 584,593 ****
    else
      {
!       /* Wait for the load to be low enough.  */
  
-       wait_to_start_job ();
- 
        /* Fork the child process.  */
!       
        child->remote = 0;
        child->pid = vfork ();
--- 584,594 ----
    else
      {
!       if (child->command_line - 1 == 0)
! 	/* Wait for the load to be low enough if this
! 	   is the first command in the sequence.  */
! 	wait_to_start_job ();
  
        /* Fork the child process.  */
! 
        child->remote = 0;
        child->pid = vfork ();
***************
*** 626,700 ****
    register struct child *c;
  
!   if (cmds->command_lines == 0)
!     {
!       /* Chop CMDS->commands up into lines in CMDS->command_lines.
! 	 Also set the corresponding CMDS->lines_recurse elements,
! 	 and the CMDS->any_recurse flag.  */
!       register char *p;
!       unsigned int nlines, idx;
!       char **lines;
  
-       nlines = 5;
-       lines = (char **) xmalloc (5 * sizeof (char *));
-       idx = 0;
-       p = cmds->commands;
-       while (*p != '\0')
- 	{
- 	  char *end = p;
- 	find_end:;
- 	  end = index (end, '\n');
- 	  if (end == 0)
- 	    end = p + strlen (p);
- 	  else if (end > p && end[-1] == '\\')
- 	    {
- 	      int backslash = 1;
- 	      register char *b;
- 	      for (b = end - 2; b >= p && *b == '\\'; --b)
- 		backslash = !backslash;
- 	      if (backslash)
- 		{
- 		  ++end;
- 		  goto find_end;
- 		}
- 	    }
- 
- 	  if (idx == nlines - 1)
- 	    {
- 	      nlines += 2;
- 	      lines = (char **) xrealloc ((char *) lines,
- 					  nlines * sizeof (char *));
- 	    }
- 	  lines[idx++] = savestring (p, end - p);
- 	  p = end;
- 	  if (*p != '\0')
- 	    ++p;
- 	}
-       lines[idx++] = 0;
- 
-       if (idx != nlines)
- 	{
- 	  nlines = idx;
- 	  lines = (char **) xrealloc ((char *) lines,
- 				      nlines * sizeof (char *));
- 	}
- 
-       cmds->command_lines = lines;
- 
-       cmds->any_recurse = 0;
-       --nlines;
-       cmds->lines_recurse = (char *) xmalloc (nlines);
-       for (idx = 0; idx < nlines; ++idx)
- 	{
- 	  unsigned int len;
- 	  int recursive;
- 	  p = lines[idx];
- 	  len = strlen (p);
- 	  recursive = (sindex (p, len, "$(MAKE)", 7) != 0
- 		       || sindex (p, len, "${MAKE}", 7) != 0);
- 	  cmds->lines_recurse[idx] = recursive;
- 	  cmds->any_recurse |= recursive;
- 	}
-     }
- 
    if (job_slots > 0)
      /* Wait for a job slot to be freed up.  */
--- 627,633 ----
    register struct child *c;
  
!   /* Chop the commands up into lines if they aren't already.  */
!   chop_commands (cmds);
  
    if (job_slots > 0)
      /* Wait for a job slot to be freed up.  */
***************
*** 724,727 ****
--- 657,661 ----
      case cs_finished:
        free_child (c);
+       notice_finished_file (file);
        break;
  
***************
*** 757,762 ****
       char **argv, **envp;
  {
-   char *path;
- 
    if (stdin_fd != 0)
      (void) dup2 (stdin_fd, 0);
--- 691,694 ----
***************
*** 775,819 ****
    unblock_children ();
  
-   path = allocated_variable_expand_for_file ("$(PATH)", file);
- 
    /* Run the command.  */
!   exec_command (argv, envp, path);
! 
!   /* If exec_command returned, then we should use the shell.  */
!   {
!     int argc;
!     char **shell_argv;
! 
!     argc = 0;
!     while (argv[argc] != 0)
!       ++argc;
!     shell_argv = (char **) alloca ((2 + argc + 1) * sizeof (char *));
!     shell_argv[0] = variable_expand_for_file ("$(SHELL)", file);
!     shell_argv[1] = "-c";
!     do
!       shell_argv[2 + argc] = argv[argc];
!     while (argc-- > 0);
!     exec_command (shell_argv, envp, path);
! 
!     /* If that returned, die.  */
!     _exit (127);
!   }
  }
  
! /* Replace the current process with one running the command
!    in ARGV, with environment ENVP.  The program named in ARGV[0]
!    is searched for in PATH.  This function does not return.  */
! 
! void
! exec_command (argv, envp, path)
!      char **argv, **envp;
!      char *path;
  {
!   char *program;
! 
!   if (*path == '\0' || index (argv[0], '/') != 0)
!     program = argv[0];
    else
      {
        unsigned int len;
  
--- 707,728 ----
    unblock_children ();
  
    /* Run the command.  */
!   exec_command (argv, envp,
! 		allocated_variable_expand_for_file ("$(PATH)", file),
! 		allocated_variable_expand_for_file ("$(SHELL)", file));
  }
+ 
+ /* Search PATH for FILE, returning a full pathname or nil.
+    The returned pathname is allocated via `malloc'.  */
  
! static char *
! search_path (file, path)
!      char *file, *path;
  {
!   if (*path == '\0' || index (file, '/') != 0)
!     return file;
    else
      {
+       char *program;
        unsigned int len;
  
***************
*** 826,831 ****
  #endif	/* Not USG.  */
  
!       len = strlen (argv[0]) + 1;
!       program = (char *) alloca (strlen (path) + 1 + len);
        do
  	{
--- 735,740 ----
  #endif	/* Not USG.  */
  
!       len = strlen (file) + 1;
!       program = (char *) xmalloc (strlen (path) + 1 + len);
        do
  	{
***************
*** 839,843 ****
  
  	  if (p == path)
! 	    bcopy (argv[0], program, len);
  	  else
  	    {
--- 748,752 ----
  
  	  if (p == path)
! 	    bcopy (file, program, len);
  	  else
  	    {
***************
*** 844,848 ****
  	      bcopy (path, program, p - path);
  	      program[p - path] = '/';
! 	      bcopy (argv[0], program + (p - path) + 1, len);
  	    }
  
--- 753,757 ----
  	      bcopy (path, program, p - path);
  	      program[p - path] = '/';
! 	      bcopy (file, program + (p - path) + 1, len);
  	    }
  
***************
*** 869,873 ****
  
  	      if (perm != 0)
! 		goto run;
  	    }
  
--- 778,782 ----
  
  	      if (perm != 0)
! 		return program;
  	    }
  
***************
*** 874,894 ****
  	  path = p + 1;
  	} while (*path != '\0');
- 
-       error ("%s: Command not found", argv[0]);
-       _exit (127);
      }
  
!  run:;
!   /* Make might be installed set-gid kmem so that the load average
!      code works, so we want to make sure we use the real gid.  */
!   (void) setgid (getgid ());
  
!   execve (program, argv, envp);
  
!   if (errno != ENOEXEC)
      {
!       perror_with_name ("execve: ", program);
!       _exit (127);
      }
  }
  
--- 783,843 ----
  	  path = p + 1;
  	} while (*path != '\0');
      }
  
!   return 0;
! }
  
! /* Replace the current process with one running the command in ARGV,
!    with environment ENVP.  The program named in ARGV[0] is searched
!    for in PATH.  SHELL is the shell program to run for shell scripts.
!    This function does not return.  */
  
! void
! exec_command (argv, envp, path, shell)
!      char **argv, **envp;
!      char *path, *shell;
! {
!   char *program;
! 
!   program = search_path (argv[0], path);
!   if (program == 0)
!     error ("%s: Command not found", argv[0]);
!   else
      {
!       /* Run the program.  */
!       execve (program, argv, envp);
! 
!       if (errno == ENOEXEC)
! 	{
! 	  char *shell_path = search_path (shell, path);
! 	  if (shell_path == 0)
! 	    error ("%s: Shell program not found", shell);
! 	  else
! 	    {
! 	      char **new_argv;
! 	      int argc;
! 
! 	      argc = 1;
! 	      while (argv[argc] != 0)
! 		++argc;
! 
! 	      new_argv = (char **) alloca ((1 + argc + 1) * sizeof (char *));
! 	      new_argv[0] = shell_path;
! 	      new_argv[1] = program;
! 	      while (argc > 0)
! 		{
! 		  new_argv[1 + argc] = argv[argc];
! 		  --argc;
! 		}
! 
! 	      execve (shell_path, new_argv, envp);
! 	      perror_with_name ("execve: ", shell_path);
! 	    }
! 	}
!       else
! 	perror_with_name ("execve: ", program);
      }
+ 
+   _exit (127);
  }
  
***************
*** 1018,1022 ****
      free (new_argv);
    new_argv = (char **) xmalloc (4 * sizeof (char *));
!   new_argv[0] = variable_expand_for_file ("$(SHELL)", file);
    new_argv[1] = "-c";
    new_argv[2] = line;
--- 967,971 ----
      free (new_argv);
    new_argv = (char **) xmalloc (4 * sizeof (char *));
!   new_argv[0] = allocated_variable_expand_for_file ("$(SHELL)", file);
    new_argv[1] = "-c";
    new_argv[2] = line;
diff -rc2 make-3.57/load.c make-3.58/load.c
*** make-3.57/load.c	Sun Sep 17 16:42:33 1989
--- make-3.58/load.c	Sat Jan 20 11:54:09 1990
***************
*** 24,32 ****
  #define LDAV_BASED
  
! /*
!  *  UMAX 4.2, which runs on the Encore Multimax multiprocessor, does not
!  *  have a /dev/kmem.  Information about the workings of the running kernel
!  *  can be gathered with inq_stats system calls.
!  */
  #include <stdio.h>
  #include <signal.h>
--- 24,30 ----
  #define LDAV_BASED
  
! /* UMAX 4.2, which runs on the Encore Multimax multiprocessor, does not
!    have a /dev/kmem.  Information about the workings of the running kernel
!    can be gathered with inq_stats system calls.  */
  #include <stdio.h>
  #include <signal.h>
***************
*** 37,40 ****
--- 35,46 ----
  #include <sys/sysdefs.h>
  #include <sys/syscall.h>
+ 
+ #ifdef	UMAX_43
+ #include <machine/cpu.h>
+ #include <inq_stats/statistics.h>
+ #include <inq_stats/sysstats.h>
+ #include <inq_stats/cpustats.h>
+ #include <inq_stats/procstats.h>
+ #else	/* Not UMAX_43.  */
  #include <sys/statistics.h>
  #include <sys/sysstats.h>
***************
*** 42,47 ****
  #include <sys/cpustats.h>
  #include <sys/procstats.h>
  
- 
  static double
  load_average ()
--- 48,53 ----
  #include <sys/cpustats.h>
  #include <sys/procstats.h>
+ #endif
  
  static double
  load_average ()
***************
*** 235,239 ****
      return;
  
!   while (job_slots_used > 1)
      {
        double load = load_average ();
--- 241,245 ----
      return;
  
!   while (job_slots_used > 0)
      {
        double load = load_average ();
diff -rc2 make-3.57/main.c make-3.58/main.c
*** make-3.57/main.c	Fri Nov  3 16:34:16 1989
--- make-3.58/main.c	Thu Feb  1 17:29:23 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 361,364 ****
--- 361,368 ----
    /* Figure out where we are.  */
  
+ #ifdef	USG
+   /* In some System V's, `getcwd' spawns a child running /bin/pwd.  */
+   block_children ();
+ #endif
    if (getwd (current_directory) == 0)
      {
***************
*** 366,369 ****
--- 370,376 ----
        current_directory[0] = '\0';
      }
+ #ifdef	USG
+   unblock_children ();
+ #endif
  
    /* Read in variables from the environment.  It is important that this be
***************
*** 687,691 ****
  		    xrealloc ((char *) makefile_mtimes,
  			      (mm_idx + 1) * sizeof (time_t));
! 		makefile_mtimes[mm_idx++] = file_mtime (d->file);
  		last = d;
  		d = d->next;
--- 694,698 ----
  		    xrealloc ((char *) makefile_mtimes,
  			      (mm_idx + 1) * sizeof (time_t));
! 		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
  		last = d;
  		d = d->next;
***************
*** 723,728 ****
  		      {
  			/* It was successfully updated.  */
! 			any_remade
! 			  |= file_mtime (d->file) != makefile_mtimes[i];
  		      }
  		    else if (d->changed != 1)
--- 730,735 ----
  		      {
  			/* It was successfully updated.  */
! 			any_remade |= (file_mtime_no_search (d->file)
! 				       != makefile_mtimes[i]);
  		      }
  		    else if (d->changed != 1)
***************
*** 733,737 ****
  			error ("Failed to remake makefile `%s'.",
  			       d->file->name);
! 			mtime = file_mtime (d->file);
  			any_remade |= (mtime != (time_t) -1
  				       && mtime != makefile_mtimes[i]);
--- 740,744 ----
  			error ("Failed to remake makefile `%s'.",
  			       d->file->name);
! 			mtime = file_mtime_no_search (d->file);
  			any_remade |= (mtime != (time_t) -1
  				       && mtime != makefile_mtimes[i]);
***************
*** 818,823 ****
  		break;
  	      }
! 	  exec_command (argv, environ, allocated_variable_expand ("$(PATH)"));
! 	  pfatal_with_name ("exec_command");
  	  /* NOTREACHED */
  	}
--- 825,831 ----
  		break;
  	      }
! 	  exec_command (argv, environ,
! 			allocated_variable_expand ("$(PATH)"),
! 			allocated_variable_expand ("$(SHELL)"));
  	  /* NOTREACHED */
  	}
***************
*** 926,934 ****
  			  if (arg == 0)
  			    {
! 			    missing_arg:;
! 			      error ("argument required for `-%c' option",
! 				     cs->c);
! 			      bad = 1;
! 			      break;
  			    }
  			}
--- 934,946 ----
  			  if (arg == 0)
  			    {
! 			      arg = cs->noarg_value;
! 			      if (arg == 0)
! 				{
! 				missing_arg:;
! 				  error ("argument required for `-%c' option",
! 					 cs->c);
! 				  bad = 1;
! 				  break;
! 				}
  			    }
  			}
***************
*** 960,968 ****
  		    case positive_int:
  		      if (*sw == '\0')
! 			{
! 			  arg = argv[++i];
! 			  if (arg == 0)
! 			    goto missing_arg;
! 			}
  		      else
  			arg = sw;
--- 972,976 ----
  		    case positive_int:
  		      if (*sw == '\0')
! 			arg = argv[++i];
  		      else
  			arg = sw;
***************
*** 1000,1008 ****
  		    case floating:
  		      if (*sw == '\0')
! 			{
! 			  arg = argv[++i];
! 			  if (arg == 0)
! 			    goto missing_arg;
! 			}
  		      else
  			arg = sw;
--- 1008,1012 ----
  		    case floating:
  		      if (*sw == '\0')
! 			arg = argv[++i];
  		      else
  			arg = sw;
***************
*** 1212,1215 ****
--- 1216,1221 ----
  }
  
+ static int printed_version = 0;
+ 
  /* Print version information.  */
  
***************
*** 1225,1229 ****
  
    printf (", by Richard Stallman and Roland McGrath.\n\
! %sCopyright (C) 1988, 1989 Free Software Foundation, Inc.\n\
  %sThis is free software; see the source for copying conditions.\n\
  %sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
--- 1231,1235 ----
  
    printf (", by Richard Stallman and Roland McGrath.\n\
! %sCopyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.\n\
  %sThis is free software; see the source for copying conditions.\n\
  %sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
***************
*** 1230,1233 ****
--- 1236,1241 ----
  %sPARTICULAR PURPOSE.\n\n", precede, precede, precede, precede);
  
+   printed_version = 1;
+ 
    /* Flush stdout so the user doesn't have to wait to see the
       version information while things are thought about.  */
***************
*** 1268,1271 ****
--- 1276,1282 ----
        dying = 1;
  
+       if (print_version_flag && !printed_version)
+ 	print_version ();
+ 
        /* Wait for children to die.  */
        wait_for_children (0, status != 0);
***************
*** 1289,1295 ****
--- 1300,1314 ----
       int entering;
  {
+   static int entered = 0;
    char pwdbuf[MAXPATHLEN];
    char *message = entering ? "Entering" : "Leaving";
  
+   if (entered && entering)
+     /* Don't print the leaving message if we
+        haven't printed the entering message.  */
+     return;
+   else
+     entered = 1;
+ 
    if (print_data_base_flag)
      fputs ("# ", stdout);
***************
*** 1300,1303 ****
--- 1319,1326 ----
      printf ("%s[%u]: %s ", program, makelevel, message);
  
+ #ifdef	USG
+   /* In some System V's, `getcwd' spawns a child running /bin/pwd.  */
+   block_children ();
+ #endif
    if (getwd (pwdbuf) == 0)
      printf ("an unknown directory (getwd: %s)\n", pwdbuf);
***************
*** 1304,1306 ****
--- 1327,1332 ----
    else
      printf ("directory `%s'\n", pwdbuf);
+ #ifdef	USG
+   unblock_children ();
+ #endif
  }
diff -rc2 make-3.57/make.man make-3.58/make.man
*** make-3.57/make.man	Tue Aug 22 16:00:25 1989
--- make-3.58/make.man	Wed Jan 24 21:31:33 1990
***************
*** 139,143 ****
  .TP 0.5i
  .BI "\-f " file
! Use file
  .I file as a makefile.
  .TP 0.5i
--- 139,143 ----
  .TP 0.5i
  .BI "\-f " file
! Use
  .I file as a makefile.
  .TP 0.5i
diff -rc2 make-3.57/make.texinfo make-3.58/make.texinfo
*** make-3.57/make.texinfo	Tue Oct 24 19:24:42 1989
--- make-3.58/make.texinfo	Sat Feb  3 22:08:46 1990
***************
*** 16,20 ****
  This file documents the GNU Make utility.
  
! Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 16,20 ----
  This file documents the GNU Make utility.
  
! Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 51,67 ****
  @center by Richard M. Stallman and Roland McGrath
  @sp 3
! @center Edition 0.25 Beta,
  @sp 1
! @center last updated 24 October 1989,
  @sp 1
! @center for @code{make}, Version 3.57 Beta.
  @page
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988, 1989 Free Software Foundation, Inc.
  @sp 2
  
! This is Edition 0.25 Beta of the @cite{GNU Make Manual}, @*
! last updated 24 October 1989, @*
! for @code{make} Version 3.57 Beta.
  
  @sp 2
--- 51,67 ----
  @center by Richard M. Stallman and Roland McGrath
  @sp 3
! @center Edition 0.26 Beta,
  @sp 1
! @center last updated 20 January 1990,
  @sp 1
! @center for @code{make}, Version 3.58 Beta.
  @page
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988, 1989, 1990 Free Software Foundation, Inc.
  @sp 2
  
! This is Edition 0.26 Beta of the @cite{GNU Make Manual}, @*
! last updated 20 January 1990, @*
! for @code{make} Version 3.58 Beta.
  
  @sp 2
***************
*** 96,100 ****
  The GNU @code{make} utility determines automatically which pieces of a
  large program need to be recompiled, and issues the commands to
! recompile them; it contains the following chapters:
  @end ifinfo
  
--- 96,101 ----
  The GNU @code{make} utility determines automatically which pieces of a
  large program need to be recompiled, and issues the commands to
! recompile them.  This manual describes it and contains the following
! chapters:
  @end ifinfo
  
***************
*** 494,499 ****
  or are just obscure features, ask Roland McGrath; he'll be happy to help
  you out (but no promises).  You can send him electronic mail at Internet
! address @samp{roland@@wheaties.ai.mit.edu} or UUCP path
! @samp{mit-eddie!wheaties.ai.mit.edu!roland}.
  
  @node Simple, Makefiles, Bugs, Top
--- 495,500 ----
  or are just obscure features, ask Roland McGrath; he'll be happy to help
  you out (but no promises).  You can send him electronic mail at Internet
! address @samp{roland@@prep.ai.mit.edu} or UUCP path
! @samp{mit-eddie!prep.ai.mit.edu!roland}.@refill
  
  @node Simple, Makefiles, Bugs, Top
***************
*** 721,728 ****
  @noindent
  This rule would be added at the end of the makefile, because we don't
! want it to run by default!  We want the rule for @code{all}, which
  recompiles the editor, to remain the default goal.
  
! Since @code{clean} is not a dependency of @code{all}, this rule won't
  run at all if we give the command @samp{make} with no arguments.  In
  order to make the rule run, we have to type @samp{make clean}.
--- 722,729 ----
  @noindent
  This rule would be added at the end of the makefile, because we don't
! want it to run by default!  We want the rule for @code{edit}, which
  recompiles the editor, to remain the default goal.
  
! Since @code{clean} is not a dependency of @code{edit}, this rule won't
  run at all if we give the command @samp{make} with no arguments.  In
  order to make the rule run, we have to type @samp{make clean}.
***************
*** 2389,2392 ****
--- 2390,2402 ----
  are not put into @code{MAKEFLAGS}; these options are not passed down.@refill
  
+ The @samp{-j} (@pxref{Parallel}) option is a special case.  If you set
+ it to some numeric value, @samp{-j 1} is always put into
+ @code{MAKEFLAGS} instead of the value you specified.  This is because if
+ the @samp{-j} option were passed down to sub-@code{make}s, you would get
+ many more jobs running in parallel than you asked for.  If you give
+ @samp{-j} with no numeric argument, meaning to run as many jobs as
+ possible in parallel, this is passed down, since multiple infinities are
+ no more than one.@refill
+ 
  If you don't want to pass the other flags down, you must change the
  value of @code{MAKEFLAGS}, like this:
***************
*** 2771,2775 ****
  
  A substitution reference is actually an abbreviation for use of the
! @code{patsubst} expansion function (@pxref{Functions}).  We provide
  substitution references as well as @code{patsubst} for compatibility with
  other implementations of @code{make}.
--- 2781,2785 ----
  
  A substitution reference is actually an abbreviation for use of the
! @code{patsubst} expansion function (@pxref{Text Functions}).  We provide
  substitution references as well as @code{patsubst} for compatibility with
  other implementations of @code{make}.
***************
*** 2779,2783 ****
  @samp{$(@var{var}:@var{a}=@var{b})} described above, except that now
  @var{a} must contain a single @samp{%} character.  This case is equivalent
! to @samp{$(patsubst @var{a},@var{b},$(@var{var}))}.  For example:@refill
  
  @example
--- 2789,2795 ----
  @samp{$(@var{var}:@var{a}=@var{b})} described above, except that now
  @var{a} must contain a single @samp{%} character.  This case is equivalent
! to @samp{$(patsubst @var{a},@var{b},$(@var{var}))}.
! @xref{Text Functions}, for a description of the @code{patsubst} function.
! For example:@refill
  
  @example
***************
*** 3420,3428 ****
  variable references, it is wisest to use the same kind of delimiters for
  all the references; in other words, write @w{@samp{$(subst a,b,$(x))}}, not
! @w{@samp{$(subst a,b,$@{x@})}}.
  
  The text written for each argument is processed by substitution of
! variables and function calls in order to produce the argument value, which
! is the text on which the function acts.
  
  Commas and unmatched parentheses or braces cannot appear in the text of an
--- 3432,3445 ----
  variable references, it is wisest to use the same kind of delimiters for
  all the references; in other words, write @w{@samp{$(subst a,b,$(x))}}, not
! @w{@samp{$(subst a,b,$@{x@})}}.  This is both because it is clearer, and
! because only one type of delimiters is matched to find the end of the
! reference.  Thus in @w{@samp{$(subst a,b,$@{subst c,d,$@{x@}@})}}
! doesn't work because the second @code{subst} function invocation ends at
! the first @samp{@}}, not the second.
  
  The text written for each argument is processed by substitution of
! variables and function calls to produce the argument value, which
! is the text on which the function acts.  The substitution is done in the
! order in which the arguments appear.
  
  Commas and unmatched parentheses or braces cannot appear in the text of an
***************
*** 4062,4068 ****
  
  By default, the goal is the first target in the makefile (not counting
! targets that start with a period or that appear in included makefiles).
! Therefore, makefiles are usually written so that the first target is for
! compiling the entire program or programs they describe.
  
  You can specify a different goal or goals with arguments to @code{make}.
--- 4079,4085 ----
  
  By default, the goal is the first target in the makefile (not counting
! targets that start with a period).  Therefore, makefiles are usually
! written so that the first target is for compiling the entire program or
! programs they describe.
  
  You can specify a different goal or goals with arguments to @code{make}.
***************
*** 4379,4383 ****
  
  @item -e
! Make variables environment taken from the environment have precedence
  over variables from makefiles.  @xref{Environment}.
  
--- 4396,4400 ----
  
  @item -e
! Give variables taken from the environment precedence
  over variables from makefiles.  @xref{Environment}.
  
***************
*** 4768,4774 ****
  
  @item RCS
! Any file @file{@var{n}} will be extracted if necessary from an RCS
! file named either @file{@var{n},v} or @file{RCS/@var{n},v}.  The
! precise command used is @samp{$(CO) $(COFLAGS)}.@refill
  
  @item SCCS
--- 4785,4793 ----
  
  @item RCS
! Any file @file{@var{n}} will be extracted if necessary from an RCS file
! named either @file{@var{n},v} or @file{RCS/@var{n},v}.  The precise
! command used is @samp{$(CO) $(COFLAGS)}.  @file{@var{n}} will not be
! extracted from RCS if it already exists, even if the RCS file is
! newer.@refill
  
  @item SCCS
***************
*** 4917,4925 ****
  @vindex RM
  Command to remove a file; default @samp{rm -f}.
- @code{make} does not use this variable for anything.
  @end table
  
  Here is a table of variables whose values are additional arguments for the
! programs above.  The default values for all of these is the empty string.
  
  @table @code
--- 4936,4944 ----
  @vindex RM
  Command to remove a file; default @samp{rm -f}.
  @end table
  
  Here is a table of variables whose values are additional arguments for the
! programs above.  The default values for all of these is the empty
! string, unless otherwise noted.
  
  @table @code
***************
*** 5149,5153 ****
  @file{@var{x}.c}.  The command uses the automatic variables @samp{$@@} and
  @samp{$<} to substitute the names of the target file and the source file
! as they are in each case where the rule applies (@pxref{Automatic}).@refill
  
  Here is a second built-in rule:
--- 5168,5172 ----
  @file{@var{x}.c}.  The command uses the automatic variables @samp{$@@} and
  @samp{$<} to substitute the names of the target file and the source file
! in each case where the rule applies (@pxref{Automatic}).@refill
  
  Here is a second built-in rule:
***************
*** 5450,5454 ****
  @noindent
  to cause all the source files needed (as dependencies) to be created
! silently.
  
  If you give @code{.DEFAULT} with no commands or dependencies:
--- 5469,5473 ----
  @noindent
  to cause all the source files needed (as dependencies) to be created
! automatically.
  
  If you give @code{.DEFAULT} with no commands or dependencies:
***************
*** 5605,5610 ****
  @enumerate
  @item
! Find the stem @var{s}: the nonempty part of @var{t} or @var{n}
! matched by the @samp{%} in the target pattern matches.@refill
  
  @item
--- 5624,5629 ----
  @enumerate
  @item
! Find the stem @var{s}, which is the nonempty part of @var{t} or @var{n}
! matched by the @samp{%} in the target pattern.@refill
  
  @item
***************
*** 5710,5714 ****
  and there is an implicit rule to do it for you.
  
! @node Archive Update,  , Archive Members, Archives
  @section Implicit Rule for Archive Member Targets
  
--- 5729,5733 ----
  and there is an implicit rule to do it for you.
  
! @node Archive Update, Archive Symbols, Archive Members, Archives
  @section Implicit Rule for Archive Member Targets
  
***************
*** 5787,5790 ****
--- 5806,5812 ----
  files into the archive, as described in the preceding section.
  
+ This is not necessary when using the GNU @code{ar} program, which
+ updates the @file{__.SYMDEF} member automatically.
+ 
  @node Features, Missing, Archives, Top
  @chapter Features of GNU @code{make}
***************
*** 6027,6033 ****
  @item
  In System V and 4.3 BSD @code{make}, files found by @code{VPATH} search
! (@pxref{Directory Search}) have their names changed inside command strings.
! We feel it is much cleaner to always use automatic variables and thus
! obviate the need for this feature.  We are still debating whether to
  implement this for the sake of compatibility or to leave it out to avoid
  such terrible ugliness.@refill
--- 6049,6055 ----
  @item
  In System V and 4.3 BSD @code{make}, files found by @code{VPATH} search
! (@pxref{Directory Search}) have their names changed inside command
! strings.  We feel it is much cleaner to always use automatic variables
! and thus make this feature obsolete.  We are still debating whether to
  implement this for the sake of compatibility or to leave it out to avoid
  such terrible ugliness.@refill
diff -rc2 make-3.57/read.c make-3.58/read.c
*** make-3.57/read.c	Fri Oct 13 20:44:27 1989
--- make-3.58/read.c	Wed Jan  3 20:59:35 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 815,818 ****
--- 815,855 ----
  }
  
+ /* Remove duplicate dependencies in CHAIN.  */
+ 
+ void
+ uniquize_deps (chain)
+      struct dep *chain;
+ {
+   register struct dep *d;
+ 
+   /* Make sure that no dependencies are repeated.  This does not
+      really matter for the purpose of updating targets, but it
+      might make some names be listed twice for $^ and $?.  */
+ 
+   for (d = chain; d != 0; d = d->next)
+     {
+       struct dep *last, *next;
+ 
+       last = d;
+       next = d->next;
+       while (next != 0)
+ 	if (streq (dep_name (d), dep_name (next)))
+ 	  {
+ 	    struct dep *n = next->next;
+ 	    last->next = n;
+ 	    if (next->name != 0 && next->name != d->name)
+ 	      free (next->name);
+ 	    if (next != d)
+ 	      free ((char *) next);
+ 	    next = n;
+ 	  }
+ 	else
+ 	  {
+ 	    last = next;
+ 	    next = next->next;
+ 	  }
+     }
+ }
+ 
  /* Record a description line for files FILENAMES,
     with dependencies DEPS, commands to execute described
***************
*** 980,1008 ****
  	    f->deps = this;
  
! 	  /* Make sure that no dependencies are repeated.  This does not
! 	     really matter for the purpose of updating the target, but it
! 	     might list some names twice for $^ and $?.  */
! 	  for (d = f->deps; d != 0; d = d->next)
! 	    {
! 	      struct dep *last, *next;
! 	      last = d;
! 	      next = d->next;
! 	      while (next != 0)
! 		if (streq (dep_name (d), dep_name (next)))
! 		  {
! 		    struct dep *n = next->next;
! 		    last->next = n;
! 		    if (next->name != 0 && next->name != d->name)
! 		      free (next->name);
! 		    if (next != d)
! 		      free ((char *) next);
! 		    next = n;
! 		  }
! 		else
! 		  {
! 		    last = next;
! 		    next = next->next;
! 		  }
! 	    }
  
  	  /* If this is a static pattern rule, set the file's stem to
--- 1017,1021 ----
  	    f->deps = this;
  
! 	  uniquize_deps (f->deps);
  
  	  /* If this is a static pattern rule, set the file's stem to
diff -rc2 make-3.57/remake.c make-3.58/remake.c
*** make-3.57/remake.c	Sat Oct 28 23:07:17 1989
--- make-3.58/remake.c	Wed Jan  3 20:56:12 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 60,63 ****
--- 60,66 ----
    int status = -1;
  
+ #define	MTIME(file) (makefiles ? file_mtime_no_search (file) \
+ 		     : file_mtime (file))
+ 
    /* Duplicate the chain so we can remove things from it.  */
  
***************
*** 82,86 ****
        while (g != 0)
  	{
! 	  time_t mtime = file_mtime (g->file);
  
  	  if (makefiles)
--- 85,90 ----
        while (g != 0)
  	{
! 	  int x;
! 	  time_t mtime = MTIME (g->file);
  
  	  if (makefiles)
***************
*** 96,101 ****
  	    }
  
! 	  if (update_file (g->file, makefiles ? 1 : 0) != 0
! 	      || g->file->updated)
  	    {
  	      int stop = 0;
--- 100,106 ----
  	    }
  
! 	  x = update_file (g->file, makefiles ? 1 : 0);
! 	  check_renamed (g->file);
! 	  if (x != 0 || g->file->updated)
  	    {
  	      int stop = 0;
***************
*** 111,115 ****
  		      stop = !keep_going_flag && !makefiles;
  		    }
! 		  else if (file_mtime (g->file) != mtime)
  		    {
  		      /* Updating was done.
--- 116,120 ----
  		      stop = !keep_going_flag && !makefiles;
  		    }
! 		  else if (MTIME (g->file) != mtime)
  		    {
  		      /* Updating was done.
***************
*** 186,189 ****
--- 191,195 ----
        char not_started = f->command_state == cs_not_started;
        status |= update_file_1 (f, depth);
+       check_renamed (f);
        if (status != 0 && !keep_going_flag)
  	return status;
***************
*** 259,262 ****
--- 265,269 ----
  
    this_mtime = file_mtime (file);
+   check_renamed (file);
    noexist = this_mtime == (time_t) -1;
    if (noexist)
***************
*** 314,319 ****
--- 321,328 ----
  
        mtime = file_mtime (d->file);
+       check_renamed (d->file);
        d->file->parent = file;
        dep_status |= check_dep (d->file, depth, this_mtime, &must_make);
+       check_renamed (d->file);
  
        running |= (d->file->command_state == cs_running
***************
*** 339,344 ****
--- 348,355 ----
  	  {
  	    time_t mtime = file_mtime (d->file);
+ 	    check_renamed (d->file);
  	    d->file->parent = file;
  	    dep_status |= update_file (d->file, depth);
+ 	    check_renamed (d->file);
  
  	    running |= (d->file->command_state == cs_running
***************
*** 349,353 ****
  
  	    if (!running)
! 	      d->changed = file_mtime (d->file) != mtime;
  	  }
      }
--- 360,365 ----
  
  	    if (!running)
! 	      d->changed = ((file->phony && file->cmds != 0)
! 			    || file_mtime (d->file) != mtime);
  	  }
      }
***************
*** 393,400 ****
      {
        time_t d_mtime = file_mtime (d->file);
  
!       if (d_mtime == (time_t) -1)
! 	/* We must remake if this dep does not exist.  */
  	must_make = 1;
  
        /* Set DEPS_CHANGED if this dep actually changed.  */
--- 405,418 ----
      {
        time_t d_mtime = file_mtime (d->file);
+       check_renamed (d->file);
  
! #if 1	/* %%% In version 4, remove this code completely to
! 	   implement not remaking deps if their deps are newer
! 	   than their parents.  */
!       if (d_mtime == (time_t) -1 && !d->file->intermediate)
! 	/* We must remake if this dep does not
! 	   exist and is not intermediate.  */
  	must_make = 1;
+ #endif
  
        /* Set DEPS_CHANGED if this dep actually changed.  */
***************
*** 533,537 ****
        dep_status = update_file (file, depth);
        mtime = file_mtime (file);
!       if (mtime != (time_t) -1 && mtime > this_mtime)
  	*must_make_ptr = 1;
      }
--- 551,556 ----
        dep_status = update_file (file, depth);
        mtime = file_mtime (file);
!       check_renamed (file);
!       if (mtime == (time_t) -1 || mtime > this_mtime)
  	*must_make_ptr = 1;
      }
***************
*** 568,571 ****
--- 587,591 ----
  	  d->file->parent = file;
  	  dep_status |= check_dep (d->file, depth, this_mtime, must_make_ptr);
+ 	  check_renamed (d->file);
  	  if (dep_status != 0 && !keep_going_flag)
  	    break;
***************
*** 667,670 ****
--- 687,692 ----
    else
      {
+       chop_commands (file->cmds);
+ 
        if (touch_flag && file->cmds != 0 && !file->cmds->any_recurse)
  	{
***************
*** 686,699 ****
  }
  
! /* Return the mtime of a file, given a struct file.
!    Caches the time in the struct file to avoid excess stat calls.
!    If the file is not found, VPATH searching and replacement
!    is done.  If that fails, a library (-lLIBNAME) is tried but
!    the library's actual name (/lib/libLIBNAME.a, etc.) is not
!    substituted into FILE.  */
  
  time_t
! f_mtime (file)
       register struct file *file;
  {
    register time_t mtime;
--- 708,721 ----
  }
  
! /* Return the mtime of a file, given a `struct file'.
!    Caches the time in the struct file to avoid excess stat calls.  If the file
!    is not found, and SEARCH is nonzero, VPATH searching and replacement is
!    done.  If that fails, a library (-lLIBNAME) is tried but the library's
!    actual name (/lib/libLIBNAME.a, etc.) is not substituted into FILE.  */
  
  time_t
! f_mtime (file, search)
       register struct file *file;
+      int search;
  {
    register time_t mtime;
***************
*** 703,707 ****
    mtime = name_mtime (file->name);
  
!   if (mtime == (time_t) -1)
      {
        /* If name_mtime failed, search VPATH.  */
--- 725,729 ----
    mtime = name_mtime (file->name);
  
!   if (mtime == (time_t) -1 && search)
      {
        /* If name_mtime failed, search VPATH.  */
***************
*** 710,713 ****
--- 732,736 ----
  	{
  	  rename_file (file, name);
+ 	  file = file->renamed;
  	  mtime = name_mtime (name);
  	}
diff -rc2 make-3.57/rule.c make-3.58/rule.c
*** make-3.57/rule.c	Thu Sep 28 17:55:32 1989
--- make-3.58/rule.c	Thu Feb  1 18:29:58 1990
***************
*** 1,4 ****
  /* Pattern and suffix rule internals for GNU Make.
! Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,4 ----
  /* Pattern and suffix rule internals for GNU Make.
! Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 72,77 ****
    name = 0;
    namelen = 0;
!   lastrule = pattern_rules;
!   for (rule = lastrule; rule != 0; lastrule = rule, rule = rule->next)
      {
        unsigned int ndeps = 0;
--- 72,77 ----
    name = 0;
    namelen = 0;
!   rule = lastrule = pattern_rules;
!   while (rule != 0)
      {
        unsigned int ndeps = 0;
***************
*** 108,112 ****
  		{
  		  if (*name == '/')
! 		    freerule (rule, lastrule);
  		  else
  		    rule->subdir = 1;
--- 108,116 ----
  		{
  		  if (*name == '/')
! 		    {
! 		      freerule (rule, lastrule);
! 		      rule = lastrule;
! 		      goto end_main_loop;
! 		    }
  		  else
  		    rule->subdir = 1;
***************
*** 117,120 ****
--- 121,128 ----
        if (ndeps > max_pattern_deps)
  	max_pattern_deps = ndeps;
+ 
+     end_main_loop:;
+       lastrule = rule;
+       rule = rule->next;
      }
    
***************
*** 163,167 ****
  
        f = d->file;
!       if (f->cmds != 0 && f->deps == 0)
  	{
  	  /* Record a pattern for this suffix's null-suffix rule.  */
--- 171,175 ----
  
        f = d->file;
!       if (f->cmds != 0)
  	{
  	  /* Record a pattern for this suffix's null-suffix rule.  */
diff -rc2 make-3.57/variable.c make-3.58/variable.c
*** make-3.57/variable.c	Fri Nov  3 16:34:14 1989
--- make-3.58/variable.c	Wed Jan  3 20:56:10 1990
***************
*** 1,4 ****
  /* Internals of variables for GNU Make.
! Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,4 ----
  /* Internals of variables for GNU Make.
! Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 267,270 ****
--- 267,352 ----
    setlist->next = current_variable_set_list;
    current_variable_set_list = setlist;
+ }
+ 
+ /* Merge SET1 into SET0, freeing unused storage in SET1.  */
+ 
+ static void
+ merge_variable_sets (set0, set1)
+      struct variable_set *set0, *set1;
+ {
+   register unsigned int bucket1;
+ 
+   for (bucket1 = 0; bucket1 < set1->buckets; ++bucket1)
+     {
+       register struct variable *v1 = set1->table[bucket1];
+       while (v1 != 0)
+ 	{
+ 	  struct variable *next = v1->next;
+ 	  unsigned int bucket0;
+ 	  register struct variable *v0;
+ 
+ 	  if (set1->buckets >= set0->buckets)
+ 	    bucket0 = bucket1;
+ 	  else
+ 	    {
+ 	      register char *n;
+ 	      bucket0 = 0;
+ 	      for (n = v1->name; *n != '\0'; ++n)
+ 		HASH (bucket0, *n);
+ 	    }
+ 	  bucket0 %= set0->buckets;
+ 
+ 	  for (v0 = set0->table[bucket0]; v0 != 0; v0 = v0->next)
+ 	    if (streq (v0->name, v1->name))
+ 	      break;
+ 
+ 	  if (v0 == 0)
+ 	    {
+ 	      /* There is no variable in SET0 with the same name.  */
+ 	      v1->next = set0->table[bucket0];
+ 	      set0->table[bucket0] = v1;
+ 	    }
+ 	  else
+ 	    {
+ 	      /* The same variable exists in both sets.
+ 		 SET0 takes precedence.  */
+ 	      free (v1->value);
+ 	      free ((char *) v1);
+ 	    }
+ 
+ 	  v1 = next;
+ 	}
+     }
+ }
+ 
+ /* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
+ 
+ void
+ merge_variable_set_lists (setlist0, setlist1)
+      struct variable_set_list **setlist0, *setlist1;
+ {
+   register struct variable_set_list *list0 = *setlist0;
+   struct variable_set_list *last0 = 0;
+ 
+   while (setlist1 != 0 && list0 != 0)
+     {
+       struct variable_set_list *next = setlist1;
+       setlist1 = setlist1->next;
+ 
+       merge_variable_sets (list0->set, next->set);
+ 
+       free ((char *) next);
+ 
+       last0 = list0;
+       list0 = list0->next;
+     }
+ 
+   if (setlist1 != 0)
+     {
+       if (last0 == 0)
+ 	*setlist0 = setlist1;
+       else
+ 	last0->next = setlist1;
+     }
  }
  
diff -rc2 make-3.57/variable.h make-3.58/variable.h
*** make-3.57/variable.h	Sun Sep 17 16:36:14 1989
--- make-3.58/variable.h	Wed Jan  3 20:51:06 1990
***************
*** 1,3 ****
! /* Copyright (C) 1988, 1989 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
--- 1,3 ----
! /* Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.
  This file is part of GNU Make.
  
***************
*** 81,84 ****
--- 81,86 ----
  extern void initialize_file_variables ();
  extern void print_file_variables ();
+ 
+ extern void merge_variable_set_lists ();
  
  extern int try_variable_definition ();
diff -rc2 make-3.57/version.c make-3.58/version.c
*** make-3.57/version.c	Fri Nov  3 19:31:30 1989
--- make-3.58/version.c	Thu Feb  8 13:44:08 1990
***************
*** 1,3 ****
! char *version_string = "3.57";
  
  /*
--- 1,3 ----
! char *version_string = "3.58";
  
  /*
